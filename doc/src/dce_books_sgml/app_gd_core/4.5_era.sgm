<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: 4.5_era.sgm,v $
# Revision 1.1.2.8  1996/12/14  20:23:57  wardr
# 	{edit,R1.2.2}
# 	penultimate format fixes
# 	[1996/12/14  20:21:45  wardr]
#
# Revision 1.1.2.7  1996/12/13  22:10:29  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/13  22:08:19  wardr]
# 
# Revision 1.1.2.6  1996/12/12  21:30:09  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/12  21:28:17  wardr]
# 
# Revision 1.1.2.5  1996/12/12  16:49:09  carrig
# 	{enh,R1.2.2}
# 	Minor edits
# 	[1996/12/12  16:46:54  carrig]
# 
# Revision 1.1.2.4  1996/12/06  21:09:48  carrig
# 	{enh,R1.2.2}
# 	Second pass for editor
# 	[1996/12/06  21:07:38  carrig]
# 
# Revision 1.1.2.3  1996/12/05  21:38:39  carrig
# 	{enh,R1.2.2}
# 	First pass to prepare for editing
# 	[1996/12/05  21:36:42  carrig]
# 
# Revision 1.1.2.2  1996/12/02  15:40:45  weir
# 	Removed thinsp entities, corrected other minor errors
# 	[1996/12/02  15:38:59  weir]
# 
# Revision 1.1.2.1  1996/12/01  20:43:11  weir
# 	Initial submission
# 	[1996/12/01  20:41:22  weir]
# 
# 	Initial submission
# 	[1996/11/29  20:35:32  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
<!ENTITY  DCEADG.SECERA.ent.1  SYSTEM "eps/4.5_era_10.ps" NDATA eps>
<!ENTITY  DCEADG.SECERA.ent.2  SYSTEM "eps/4.5_era_20.ps" NDATA eps>
<!ENTITY  DCEADG.SECERA.ent.3  SYSTEM "eps/4.5_era_40.ps" NDATA eps>
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.6.1  1996/08/16  17:18:58  sherman-->
<!-- 	{edt, R1.2.2}-->
<!-- 	Fixed typo-->
<!-- 	[1996/08/16  17:18:31  sherman]-->
<!---->
<!-- Revision 1.1.4.1  1996/03/27  14:03:56  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	More Release Edits-->
<!-- 	[1996/03/27  14:03:28  wardr]-->
<!-- -->
<!-- Revision 1.1.2.16  1995/06/07  14:46:54  rcb-->
<!-- 	edited 1.1 version, PRENTICE HALL reformat-->
<!-- 	[1995/06/07  14:46:06  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/05/11  15:00:25  rcb]-->
<!-- -->
<!-- 	incorporated 1.1 edits-->
<!-- 	[1995/05/10  17:01:47  rcb]-->
<!-- -->
<!-- Revision 1.1.2.15  1994/11/03  23:35:19  neilson-->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- 	[1994/11/03  01:39:10  neilson]-->
<!-- -->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- -->
<!-- Revision 1.1.2.14  1994/10/21  15:43:49  jshirley-->
<!-- 	Figures don't print in double-side mode.-->
<!-- 	OK in single-side mode so did not try to fix.-->
<!-- 	[1994/10/21  15:43:04  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.13  1994/10/19  20:10:40  jshirley-->
<!-- 	Removed \*L - \*O pair from inside a heading.-->
<!-- 	[1994/10/19  20:10:23  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.12  1994/10/14  19:35:45  millette-->
<!-- 	(enh, 10056, R1.1)-->
<!-- 	.pI fixes-->
<!-- 	[1994/10/14  19:34:01  millette]-->
<!-- -->
<!-- 	(enh, 10056, R1.1)-->
<!-- 	HP review edits-->
<!-- 	[1994/10/14  18:50:59  millette]-->
<!-- -->
<!-- Revision 1.1.2.10  1994/08/26  16:53:34  millette-->
<!-- 	(enh,11628,R1.1)-->
<!-- 	Add info on DCE attr interface-->
<!-- 	(enh, 10056, R1.1)-->
<!-- 	Added section on macros to use with calls-->
<!-- 	[1994/08/26  16:52:44  millette]-->
<!-- -->
<!-- Revision 1.1.2.9  1994/06/13  18:20:40  devobj-->
<!-- 	cr10872- fix copyright-->
<!-- 	[1994/06/13  18:18:19  devobj]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/05/17  18:21:32  millette-->
<!-- 	(enh, 10056, R1.1)-->
<!-- 	head numbering fix-->
<!-- 	[1994/05/17  18:20:58  millette]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/05/17  17:30:13  jshirley-->
<!-- 	SGML conversion edits.-->
<!-- 	[1994/05/17  17:29:58  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/05/13  15:14:20  millette-->
<!-- 	(enh, 10056, R1.1)-->
<!-- 	index fix-->
<!-- 	[1994/05/13  15:13:50  millette]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/05/11  15:58:21  millette-->
<!-- 	(enh, 10056, R1.1)-->
<!-- 	Code changes to confidential bytes encoding type-->
<!-- 	[1994/05/11  15:57:22  millette]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/04/04  16:33:28  millette-->
<!-- 	(enh, 10056, R1.1)-->
<!-- 	Fixed PS embeds-->
<!-- 	[1994/04/04  16:33:04  millette]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/03/15  19:54:49  millette-->
<!-- 	(enh, 10056, R1.1)-->
<!-- 	HP internal review changes.-->
<!-- 	[1994/03/15  19:54:21  millette]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/03/14  22:00:54  rom-->
<!-- 	{enh, 10129, R1.1}-->
<!-- 	Fix pathnames of included files for new three-book organization.-->
<!-- 	[1994/03/14  21:20:31  rom]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/03/11  22:13:07  millette-->
<!-- 	(enh, 10056, R1.1)-->
<!-- 	Created for new ERA chapter.-->
<!-- 	[1994/03/11  22:12:32  millette]-->
<!-- -->
<Chapter Id="DCEADG.SECERA.div.1">
<Title>The Extended Attribute API</Title>
<Para><IndexTerm Id="DCEADG.SECERA.indx.1">
<Primary>API</Primary>
<Secondary>extended attribute</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.SECERA.indx.2">
<Primary>extended attribute</Primary>
<Secondary>API</Secondary>
</IndexTerm>This chapter describes the extended attribute APIs.  There are two extended
attribute APIs: the extended registry attribute (ERA) interface to 
create attributes in the registry database and the DCE attribute interface 
to create attributes in a database of your choice.
</Para>
<Para>The ERA interface (consisting of <Literal>sec_attr_</Literal><Symbol Role="Variable">*</Symbol><Literal>()</Literal> calls) 
provides facilities for extending 
the registry database by
creating, maintaining, and viewing attribute types and instances, 
and providing information to and receiving it from outside attribute servers 
known as <FirstTerm>attribute triggers</FirstTerm>.  It is the preferred API for security 
schema and attribute manipulations. 
Application servers that manage legacy security attributes or 
provide third-party processing of attributes stored in the registry 
database can export and implement the <Function>sec_attr()</Function> interface.  
Trigger servers are accessed through the <Function>sec_attr_trig()</Function> 
interface by the security client agent during certain <Literal>sec_rgy_attr_</Literal><Symbol Role="Variable">*</Symbol><Literal>()</Literal> 
calls.  The ERA interface uses the same binding mechanism as the registry API, 
described in Chapter 28.
</Para>
<Para>The DCE attribute interface (consisting of <Literal>dce_attr_sch_</Literal><Symbol Role="Variable">*</Symbol><Literal>()</Literal> calls) is provided for 
schema and attribute manipulation of data repositories other than the registry.  
Although similar to the ERA interface, the functionality of the DCE 
attribute interface is limited to creating schema entries (attribute types).  
The interface does not provide calls to create and manipulate attribute instances or to 
access trigger servers.
</Para>
<Para>The chapter first describes the ERA interface and 
then the DCE attribute interface.  Finally is describes macros and 
utilities provided for developers who use either attribute API.
</Para>
<Sect1 Id="DCEADG.SECERA.div.2">
<Title>The ERA API</Title>
<IndexTerm Id="DCEADG.SECERA.indx.3">
<Primary>Schema</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.SECERA.indx.4">
<Primary>attribute</Primary>
<Secondary>schema</Secondary>
<Tertiary>defined</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.SECERA.indx.5">
<Primary>registry</Primary>
<Secondary>extending</Secondary>
</IndexTerm>
<Para>The registry is a repository for principal, group, organization, and
account data.  It stores the network privilege attributes used
by DCE and account data used by local operating systems.  This local 
account data, however, is appropriate only for UNIX operating systems.  
The ERA facility provides a mechanism for extending 
the registry schema to include data (attributes) required by or useful to 
operating systems other than UNIX operating systems.
</Para>
<Para>The ERA API provides the ability to define attribute types and 
to attach attribute instances to registry objects.  
Registry objects are nodes in the registry database, to which 
access is controlled by an ACL manager type.  The registry objects are
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>principal</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>group</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>organization</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>policy</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>directory</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>replist</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>attr_schema</Literal>
</Para>
</ListItem>
</ItemizedList>
<Para>All registry objects and their accompanying ACL manager type are 
described in the &DCEAc;.  
</Para>
<Para>The ERA API also provides a trigger interface that application servers 
use to integrate their attribute services with ERA services.
</Para>
<Sect2 Id="DCEADG.SECERA.div.3">
<Title>Attribute Schema</Title>
<Para>The schema extensions are implemented in a single attribute schema that 
is essentially a 
catalog of schema entries, each of which defines the format and 
function of an attribute type.  The schema can be dynamically updated to 
create, modify, or delete schema entries.
</Para>
<Para>The attribute schema is identified by 
the name <Command>xattrschema</Command> under the security junction point 
(usually <Filename>/.:/sec</Filename>) in the CDS namespace.  Access to the attribute 
schema (hereinafter called simply <FirstTerm>schema</FirstTerm>) is controlled by an  
ACL on the schema object. 
<IndexTerm Id="DCEADG.SECERA.indx.6">
<Primary><Command>xattrschema object</Command></Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.SECERA.indx.7">
<Primary>attribute</Primary>
<Secondary>type</Secondary>
<Tertiary>access control</Tertiary>
</IndexTerm>The schema is propagated from the master security
server to replicas, like other registry data.  Since the attribute schema 
is local to a cell, it defines the types that can be used within the cell, but 
not outside the cell (unless the type is also defined in another cell).
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.4">
<Title>Attribute Types and Instances</Title>
<Para>Each attribute type definition in the schema consists of attribute type identifiers 
(UUID and name) and semantics that control the instances of attributes of this type.
In this manual, <FirstTerm>schema entry</FirstTerm> refers to the registry entry that defines 
an attribute type. 
</Para>
<Para>An attribute instance is an attribute that is attached to an 
object and has a value (as opposed to 
an attribute type, which has no values but simply defines the semantics 
to which attribute instances of that attribute type must 
adhere).  Attribute instances contain the UUID of their attribute type.
<IndexTerm Id="DCEADG.SECERA.indx.8">
<Primary>Schema</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.SECERA.indx.9">
<Primary>attribute</Primary>
<Secondary>instance</Secondary>
<Tertiary>defined</Tertiary>
</IndexTerm>
<IndexTerm Id="DCEADG.SECERA.indx.10">
<Primary>attribute</Primary>
<Secondary>type</Secondary>
<Tertiary>defined</Tertiary>
</IndexTerm></Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.5">
<Title>Attribute Type Components</Title>
<Para>The <StructName Role="typedef">sec_attr_schema_entry_t</StructName> data type defines an attribute type.  
This data type contains attribute type identifiers and 
characteristics.  
</Para>
<Para>The identifiers of attribute types are a name and a UUID.  
Generally, the name is used for interactive access and the UUID 
for programmatic access. 
</Para>
<Para>Attribute type characteristics describe the format and function 
of the attribute type and thus control the format and function of 
instances of that type.  
These characteristics, all specified in the 
<StructName Role="typedef">sec_attr_schema_entry_t</StructName> data type, 
are described in the following sections.
</Para>
<Sect3 Id="DCEADG.SECERA.div.6">
<Title>Attribute Encoding</Title>
<Para>Attribute encoding defines the legal encoding for 
instances of the attribute type.  
The encoding controls the format of the 
attribute instance values, such as whether the attribute value is 
an integer, string, a UUID, or a vector of UUIDs that define an 
attribute set. 
</Para>
<Para>Attribute encodings are specified in 
the <StructName Role="typedef">sec_attr_encoding_t</StructName> data type (fully described in the &DCEDr;). 
</Para>
<Para>The possible encodings for attribute types are
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>any</Literal>
</Para>
<Para>The attribute instance value can be of any legal encoding type. 
</Para>
</ListItem>
<ListItem>
<Para><Literal>void</Literal>
</Para>
<Para>The attribute instance has no value. 
It is simply a marker that is either present or absent.
</Para>
</ListItem>
<ListItem>
<Para><Literal>printstring</Literal>
</Para>
<Para>The attribute value is a printable IDL character 
string from the DCE Portable Character Set (PCS).
<!-- DCE 1.2 WRITER: above sentence correct?-->
</Para>
</ListItem>
<ListItem>
<Para><Literal>printstring_array</Literal>
</Para>
<Para>The attribute value is an array of print strings.
</Para>
</ListItem>
<ListItem>
<Para><Literal>integer</Literal>
</Para>
<Para>The attribute value is a signed 32-bit integer.
</Para>
</ListItem>
<ListItem>
<Para><Literal>bytes</Literal>
</Para>
<Para>The attribute value is a string of bytes. 
The byte string is assumed to be a 
pickle or is otherwise a self-describing type.
</Para>
</ListItem>
<ListItem>
<Para><Literal>confidential_bytes</Literal>
</Para>
<Para>The attribute value is a string of encrypted 
bytes.  This encrypted data can be passed over the network and is available to user-developed 
applications.
</Para>
</ListItem>
<ListItem>
<Para><Literal>internationalization_data</Literal>
</Para>
<Para>An internationalized string of bytes with a tag identifying 
the OSF registered codeset used to encode the data.
</Para>
</ListItem>
<ListItem>
<Para><Literal>uuid</Literal>
</Para>
<Para>A DCE UUID.
</Para>
</ListItem>
<ListItem>
<Para><Literal>attr_set</Literal>
</Para>
<Para>The value is an attribute set, 
a vector of attribute type UUIDs 
used to associate multiple related attribute instances (members of the set).  
The vector contains the UUIDs of each member of the set.   
Attribute sets provide a flexible way to 
group related attributes on an object for 
easier search and retrieval. 
</Para>
<Para>The attribute type UUIDs referenced in an attribute 
set instance must correspond 
to existing attribute schema entries.  Although the members specified in a 
set are generally expected to be attached to the object to which the set 
instance is attached, no checking is done to confirm that they are.
Thus, it is possible to create an attribute set instance 
on an object before creating member attribute instances on that object.  
A query on such an attribute set returns all instances of member 
attributes that exist on 
the object along with a warning that some attribute types were missing.
</Para>
<Para>Note that attribute sets cannot be nested; a member UUID of an attribute 
set cannot itself identify an attribute set. 
</Para>
<Para>A query on an attribute set expands to a query per the set's members. In other words, 
an attribute lookup operation on an attribute 
set returns all attribute instances that are members of the set, not the 
set instance itself.  (Certain operations, such as
<Function>sec_rgy_attr_set_lookup_by_id()</Function> and 
<Function>sec_rgy_attr_lookup_by_name()</Function>, can retrieve attribute set instances.)
</Para>
<Para>Updates to an attribute set (<Function>sec_rgy_attr_update()</Function>) 
do not expand the update to its members but 
apply only to the attribute set.  Since the value carried by 
a set instance is a vector containing the UUIDs of the member 
attribute types, an update makes changes only to the 
set's members, not the values carried by those member attributes.   
Deletions of attribute sets delete only the set instance, not the member 
instances.
</Para>
<Para>Since the attributes that are set members exist independently of the attribute 
set, they can be manipulated directly like any other attribute.
</Para>
</ListItem>
<ListItem>
<Para><Literal>binding</Literal>
</Para>
<Para>The attribute value is a <StructName Role="typedef">sec_attr_binding_info_t</StructName> type containing 
authentication, authorization, and binding information suitable for 
communicating with a DCE server.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.7">
<Title>ACL Manager Set</Title>
<Para>An attribute type's ACL manager set specifies the 
ACL manager type or types (by UUID) that 
control access to the object types to which attribute instances of this type can 
be attached.  
Attribute instances 
can be attached only to objects protected by the ACL manager types in the schema 
entry.  For example, suppose an ACL manager set for 
an attribute type named <Literal>MVSname</Literal> lists only the ACL manager type for principals.  
Then, instances 
of the attribute type named <Literal>MVSname</Literal> can be attached only to 
principals and not any other registry 
objects.  
<IndexTerm Id="DCEADG.SECERA.indx.11">
<Primary>attribute</Primary>
<Secondary>instance</Secondary>
<Tertiary>access control</Tertiary>
</IndexTerm></Para>
<Para>Access to an attribute instance is controlled by the ACL on the 
object to which the attribute instance is attached and access control 
is implemented by the 
object's ACL manager type.  
For example, access to an attribute named <Literal>MVSname</Literal> on the principal 
object named <Literal>delores</Literal> is controlled by the ACL on 
the <Literal>delores</Literal> object. 
</Para>
<Para>Do not confuse access to an attribute type definition (a schema entry) with 
access to an attribute instance.  As described previously, access 
to a schema entry is 
controlled by the ACL on the <Command>xattrschema</Command> object.  Access to 
an attribute instance is controlled by the ACL on the object to which the 
attribute instance is attached.
</Para>
<Para>In addition to the ACL manager types, the ACL manager set 
defines the permission bits needed
to query, update, test, and delete instances 
of the attribute type.  These bits are used by the object's ACL manager 
to determine rights to the object's attributes.
</Para>
<Para>The ACL manager types and permissions 
defined for the attribute type apply to all instances of the attribute type. 
</Para>
<Para>Note that the ACL manager facility supports additional generic 
attribute type permissions (<Literal>O</Literal> through <Literal>Z</Literal> inclusive).  
Administrators can assign these permissions to attribute types 
of their choice.  
All uses of these additional permission bits are controlled by the cell's 
administrator.  See the &DCEAc; for more information. 
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.8">
<Title>Attribute Flags</Title>
<Para>The attribute type flags set in a schema entry are described in the following 
paragraphs.
</Para>
<Sect4 Id="DCEADG.SECERA.div.9">
<Title>The Unique Flag</Title>
<Para>The unique flag specifies whether
the value of each instance of an attribute type must be 
unique within the cell.  For example, assume that an instance of attribute 
type A is attached to 25 principals in the cell.  If the unique flag is set on, 
the value of the A attribute for each of those 25 principals must be 
different.  If it is set off, all 25 principals can share the same value 
for attribute A. 
</Para>
</Sect4>
<Sect4 Id="DCEADG.SECERA.div.10">
<Title>The Multivalued Flag</Title>
<Para>The multivalued flag specifies whether instances of the 
attribute can be multivalued.  If an attribute is multivalued, multiple 
instances of the same attribute type can be attached to a single registry 
object.  For example, if the multivalued flag is set on, a single principal 
can have multiple instances of attribute type A.  If the flag is set off, a single 
principal can have only one instance of attribute type A.
</Para>
<Para>All instances' multivalued attributes share the UUID  
(the UUID of their attribute type), but the values carried by the 
instances differ.  Generally, to access all instances of a multivalued 
attribute, you supply the attribute UUID.  To access a specific instance 
of a multivalued attribute, you supply the UUID and the value carried 
by that instance. 
</Para>
</Sect4>
<Sect4 Id="DCEADG.SECERA.div.11">
<Title>The Reserved Flag</Title>
<Para>The reserved flag indicates whether the 
attribute type can be deleted from the schema.  
Note that, when an attribute type is deleted, all instances of the 
attribute type are deleted.  If the reserved flag is set on, the 
entry cannot be deleted.    
If the reserved flag is set off, authorized principals can 
delete the schema entry.
</Para>
</Sect4>
<Sect4 Id="DCEADG.SECERA.div.12">
<Title>The Apply-Defaults Flag</Title>
<Para>The apply-defaults flag indicates 
whether or not default attributes 
should be returned when objects are queried by 
a client with the <Function>sec_rgy_attr_get_effective()</Function> call. 
If the apply-defaults flag is set on, defaults are 
applied.  If it is set off, defaults are not supplied. 
</Para>
<Para>Defaults are determined in the 
following manner:
</Para>
<OrderedList>
<ListItem>
<Para>If the requested attribute exists on the principal, that 
attribute is returned.  If it does not, the search continues.  
</Para>
</ListItem>
<ListItem>
<Para>The next step in the search depends on the type of object:
</Para>
<Para>For principals with accounts:
</Para>
<OrderedList>
<ListItem>
<Para>The organization named in the principal's 
account is examined to 
see if an attribute of the requested type exists.  If it does, it 
is returned and the search ends.  If it does not, the search continues 
to the <Literal>policy</Literal> object as described in Step 2b.
</Para>
</ListItem>
<ListItem>
<Para>The registry <Literal>policy</Literal> object is examined to 
see if an attribute of the requested type exists.  
If it does, it is returned.  If it does not, a message indicating that 
no attribute of the type exists for the object is returned.
</Para>
</ListItem>
</OrderedList>
<Para>For principals without accounts, for groups, and for organizations: 
</Para>
<Para>The registry <Literal>policy</Literal> object is examined to 
see if an attribute of the requested type exists.  
If it does, it is returned.  If it does not, a message indicating that 
no attribute of the type exists for the object is returned.
</Para>
</ListItem>
</OrderedList>
</Sect4>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.13">
<Title>The Intercell Action Field</Title>
<Para>The intercell action field of the schema entry specifies the action that should be taken 
by the privilege server when reading attributes from a foreign cell.   This 
field can contain one of three values:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>sec_attr_intercell_act_accept</Literal>
</Para>
<Para>To accept the foreign attribute instance
</Para>
</ListItem>
<ListItem>
<Para><Literal>sec_attr_intercell_act_reject</Literal>
</Para>
<Para>To reject the foreign attribute instance
</Para>
</ListItem>
<ListItem>
<Para><Literal>sec_attr_intercell_act_evaluate</Literal>
</Para>
<Para>To call a remote trigger 
server to determine how the attribute instance should be handled
</Para>
</ListItem>
</ItemizedList>
<Para>When the privilege server generates a PTGT for a foreign principal, it 
retrieves the list of attributes from the foreign principal's EPAC.
</Para>
<Para>These attributes instances may be 
attached to the <Literal>principal</Literal> object itself or attached to the group or 
<Literal>organization</Literal> object associated with the <Literal>principal</Literal> object.
</Para>
<Para>The privilege server then checks the local attribute schema for 
attribute types with UUIDs that match the UUIDs of the 
the attribute instances from the foreign cell that are contained in the 
EPAC.  At this point, the privilege server 
takes one of the following two actions:
</Para>
<OrderedList>
<ListItem>
<Para>If the privilege server cannot find a matching attribute type in the 
local attribute schema, it checks the <Literal>unknown_intercell_action</Literal> 
attribute on the <Literal>policy</Literal> object.  If the <Literal>unknown_intercell_action</Literal> 
attribute is set to
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>sec_attr_intercell_act_accept</Literal>, the foreign 
attribute instance is retained and included in the EPAC generated 
for the object by the privilege server.
</Para>
</ListItem>
<ListItem>
<Para><Literal>sec_attr_intercell_act_reject</Literal>, the 
foreign attribute is discarded.
</Para>
</ListItem>
</ItemizedList>
<Note>
<Para>The <Literal>unknown_intercell_action</Literal> attribute must be created 
by the system administrator and attached to the <Literal>policy</Literal> object.  The 
attribute type, which takes the same values as the 
intercell_action field, 
has the following characteristics:
</Para>
<Para>
Name:&ensp;&ensp;<Literal>unknown_intercell_action</Literal>
</Para>
<Para>
<?sml-space .5>Attribute&ensp;UUID:
<?Pub _newline>
<Literal>171e0ef2c-d12e-11cc-bb7b-080009353559</Literal>
</Para>
<Para>
<?sml-space .5>Encoding:&ensp;&ensp;<Literal>sec_attr_encoding_integer</Literal>
</Para>
<Para>
<?sml-space .5>ACL manager set:&ensp;&ensp;<Literal>policy_acl_mgr</Literal>
</Para>
<Para>
<?sml-space .5>Unique:&ensp;&ensp;false
</Para>
<Para>
<?sml-space .5>Multivalued:&ensp;&ensp;false
</Para>
<Para>
<?sml-space .5>Reserved:&ensp;&ensp;true
</Para>
<Para>
<?sml-space .5>Comment&ensp;text:&ensp;&ensp;Flag indicating whether to accept or reject foreign 
attributes for which no schema entry exists 
</Para>
</Note>
</ListItem>
<ListItem>
<Para>If the privilege server finds a matching attribute type in the 
local attribute schema, it retrieves the attribute.  The action it 
now takes depends on  
the setting of the attribute type's intercell action field 
and unique flag as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>If the intercell action field is set to <Literal>sec_attr_intercell_act_accept</Literal> and
</Para>
<ItemizedList>
<ListItem>
<Para>The
unique flag is not set on, the privilege server includes the foreign attribute 
instance in the principal's EPAC.
</Para>
</ListItem>
<ListItem>
<Para>The
unique flag is set on, the privilege server includes the foreign attribute 
instance in the principal's EPAC only if 
the attribute instance value is unique among all instances of the attribute 
type within the local cell.
</Para>
</ListItem>
</ItemizedList>
<Note>
<Para>If the unique attribute type flag is set on and a query trigger exists for a 
given attribute type, the intercell action field cannot be set to 
<Literal>sec_attr_intercell_act_accept</Literal> because, in this case, only the 
query trigger server can reasonably perform a uniqueness check.
</Para>
</Note>
</ListItem>
<ListItem>
<Para>If the intercell action field is set to <Literal>sec_attr_intercell_act_reject</Literal>, 
the privilege server unconditionally discards the foreign attribute instance.
</Para>
</ListItem>
<ListItem>
<Para>If the intercell action field is set to 
<Literal>sec_attr_intercell_act_evaluate</Literal>,
the privilege server makes a remote <Function>sec_attr_trig_intercell_avail()</Function> 
call to an attribute trigger by
using the binding information in the local attribute type schema entry.  
The remote attribute trigger decides whether to retain, discard, or map 
the attribute instance to another value(s). 
The privilege server includes the values returned by the 
attribute trigger in the <Function>sec_attr_trig_query()</Function> call output array 
in the principal's EPAC.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</OrderedList>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.14">
<Title>Attribute Scope</Title>
<Para>The scope field controls the objects to which the attribute can be 
be attached.  If scope is defined, the attribute can be attached only to 
objects defined by the scope.  For example, if the scope for a given attribute 
type is defined as the directory name <Filename>/principal/krbgt</Filename>, instances of that 
attribute type can be attached only to objects in the <Filename>/principal/krbgt</Filename> 
directory (a directory that by convention contains only cell principals).  
If the scope is narrowed by fully specifying an object in the 
<Filename>/principal/krbgt</Filename> directory (for example, 
<Filename>/principal/krbgt/dresden.com</Filename>) then the attribute can be 
attached only to the <Filename>dresden.com</Filename> principal.
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.15">
<Title>Trigger Type Flag</Title>
<Para>The schema entry trigger type flag specifies whether the trigger 
server associated with the attribute type is invoked for update or query operations. 
See Section 29.4 for more information 
on attribute triggers. 
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.16">
<Title>Trigger Binding</Title>
<Para>The schema entry trigger binding field contains a binding handle to a 
remote trigger that will perform processing for the attribute instances.
See Section 29.4 for more information 
on attribute triggers. 
</Para>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.SECERA.div.17">
<Title>Calls to Manipulate Schema Entries</Title>
<Para>This section first introduces the <StructName Role="typedef">sec_attr_schema_entry_t</StructName> data type 
used by the calls that create and update schema entries that define 
attribute types.  It 
then describes the calls that create, modify, delete, and read schema entries.
</Para>
<Sect2 Id="DCEADG.SECERA.div.18">
<Title>The sec_attr_schema_entry_t Data Type</Title>
<Para>The <StructName Role="typedef">sec_attr_schema_entry_t</StructName> data type is used in 
the calls that create and update 
schema entries.  The data type consists of 
four values and six other data types.  
The values used by the <StructName Role="typedef">sec_attr_schema_entry_t</StructName> are 
the attribute type name, UUID, scope, and a text field for comments.  
</Para>
<Para>The data types used by the <StructName Role="typedef">sec_attr_schema_entry_t</StructName> are
</Para>
<ItemizedList>
<ListItem>
<Para><StructName Role="typedef">sec_attr_sch_entry_flags_t</StructName>
</Para>
<Para>Specifies the unique, multivalued, reserved, and apply defaults attribute flags.
</Para>
</ListItem>
<ListItem>
<Para><StructName Role="typedef">sec_attr_acl_mgr_info_set_t</StructName>
</Para>
<Para>Specifies the attribute type's 
ACL manager(s).  This data type defines the attribute type ACL manager 
set.  This data type contains an array of pointers of 
type <StructName Role="typedef">sec_attr_mgr_info_p_t</StructName>, which reference 
<StructName Role="typedef">sec_attr_acl_mgr_info_t</StructName> data types.  There is one 
<StructName Role="typedef">sec_attr_acl_mgr_info_t</StructName> data type for each 
ACL manager associated with the attribute type.  
Each <StructName Role="typedef">sec_attr_acl_mgr_info_t</StructName> defines the
ACL manager UUID and the permission bits.
</Para>
</ListItem>
<ListItem>
<Para><StructName Role="typedef">sec_attr_encoding_t</StructName>
</Para>
<Para>Specifies the schema entry encoding.
</Para>
</ListItem>
<ListItem>
<Para><StructName Role="typedef">sec_attr_trig_type_t</StructName>
</Para>
<Para>Specifies the type of attribute trigger associated with the 
attribute type (if an attribute trigger is to be associated with the attribute 
type).  See Section 29.4 for more information on attribute triggers.
</Para>
</ListItem>
<ListItem>
<Para><StructName Role="typedef">sec_attr_intercell_action_t</StructName>
</Para>
<Para>Specifies the action to be taken 
attribute instances of this type that come from a foreign cell.
</Para>
</ListItem>
<ListItem>
<Para><StructName Role="typedef">sec_attr_bind_info_t</StructName>
</Para>
<Para>Specifies binding information for the trigger 
server associated with the attribute type (if an attribute trigger is associated 
with the attribute type). 
</Para>
<Para>The <StructName Role="typedef">sec_attr_bind_info_t</StructName> data type uses two other data types:  
<StructName Role="typedef">sec_attr_bind_auth_info_t</StructName> and <StructName Role="typedef">sec_attr_binding_t</StructName>.   
The <StructName Role="typedef">sec_attr_bind_info_t</StructName> structure for trigger binding 
is described fully in Section 29.4.
</Para>
</ListItem>
</ItemizedList>
<Para>Figure 29-1 illustrates the structure of 
a <StructName Role="typedef">sec_attr_schema_entry_t</StructName> data type.
</Para>
<Figure>
<Title>The sec_attr_schema_entry_t Data Type</Title>
<Graphic Entityref="DCEADG.SECERA.ent.1" role="page-wide" Scalefit="1" Reprowid="425" Reprodep="425"></Graphic>
</Figure>
<!-- .pI security/figures/4.5_era_10.ps 0 0 1-->
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.19">
<Title>Creating and Managing Schema Entries</Title>
<Para>This section describes the calls to create, modify, and delete the 
schema entries that define attribute types. 
</Para>
<Sect3 Id="DCEADG.SECERA.div.20">
<Title>The <Function>sec_rgy_attr_sch_create_entry()</Function> Call</Title>
<Para>The <Function>sec_rgy_attr_sch_create_entry()</Function> call creates a schema entry 
that defines an attribute type in the attribute schema.
</Para>
<Para>This call uses the <StructName Role="typedef">sec_attr_schema_entry_t</StructName> data type 
that completely defines the schema entry, including the following:
</Para>
<ItemizedList>
<ListItem>
<Para>The attribute type name (generally used for interactive access) and UUID 
(generally used for programmatic access).  Note that attribute instances share 
the name and UUID of their attribute type.
</Para>
</ListItem>
<ListItem>
<Para>The attribute's encoding (described in Section 29.1.3).  The encoding is 
specified as an enumerator of type <StructName Role="typedef">sec_attr_encoding_t</StructName>.  For some  
kinds of encodings, additional data types are used to further specify the 
encoding information.  These additional data types, the kinds of encodings 
that require them, and the purpose of the data types are listed in 
Table 29-1.
</Para>
</ListItem>
</ItemizedList>
<Table Frame="all" Remap="center" Orient="Port" role="page-wide">
<Title>Encodings and Required Data Types</Title>
<TGroup Rowsep="1" Colsep="1" Cols="3">
<ColSpec Colsep="1" Align="Left" Colwidth="1.2*" Colname="col1" Colnum="1">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Align="Left" Colwidth="1*" Colname="col3" Colnum="3">
<thead>

<Row>
<Entry Rowsep="1"><Literal>Encoding</Literal></Entry>
<Entry Rowsep="1"><Literal>Required Data Type</Literal></Entry>
<Entry Rowsep="1"><Literal>Purpose of Data Type</Literal></Entry>
</Row>
</thead>
<tbody>
<Row>
<Entry Rowsep="1"><Literal>sec_attr_enc_bytes</Literal></Entry>
<Entry Rowsep="1"><StructName Role="typedef">sec_attr_enc_bytes_t</StructName></Entry>
<Entry Rowsep="1">Defines the length of attribute values
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>sec_attr_enc_confidential_bytes</Literal></Entry>
<Entry Rowsep="1"><StructName Role="typedef">sec_attr_enc_bytes_t</StructName></Entry>
<Entry Rowsep="1">Defines the length of attribute values
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>sec_attr_enc_i18n_data</Literal></Entry>
<Entry Rowsep="1"><StructName Role="typedef">sec_attr_i18n_data_t</StructName></Entry>
<Entry Rowsep="1">Defines the internationalization codeset
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>sec_attr_enc_attr_set</Literal></Entry>
<Entry Rowsep="1"><StructName Role="typedef">sec_attr_enc_attr_set_t</StructName></Entry>
<Entry Rowsep="1">Defines the total number of members in the attribute set and 
the UUID of each member
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>sec_attr_enc_printstring</Literal></Entry>
<Entry Rowsep="1"><StructName Role="typedef">sec_attr_enc_printstring_t</StructName></Entry>
<Entry Rowsep="1">Defines a single print string
</Entry>
</Row>
<Row>
<Entry><Literal>sec_attr_enc_printstring_array</Literal></Entry>
<Entry><StructName Role="typedef">sec_attr_enc_str_array_t</StructName></Entry>
<Entry>Defines an array of print strings
</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-point-size 10>
<!--no-op:  12-->
<?sml-point-size 12>
<!--no-op:  14-->
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.21">
<Title>The <Function>sec_rgy_attr_sch_update_entry()</Function> Call</Title>
<Para>The <Function>sec_rgy_attr_sch_update_entry()</Function> call updates a schema entry that defines 
an attribute type.
</Para>
<Para>The schema entry components that can be modified are controlled by the 
ERA API and the <Symbol Role="Variable">modify_parts</Symbol> parameter of 
the <Function>sec_rgy_attr_sch_update_entry()</Function> call.
</Para>
<Para>To ensure that registry and access control data 
remains consistent, the ERA API 
allows only the following schema entry components to 
be modified:
</Para>
<ItemizedList>
<ListItem>
<Para>Attribute name
</Para>
</ListItem>
<ListItem>
<Para>Reserved flag 
</Para>
</ListItem>
<ListItem>
<Para>Apply defaults flag
</Para>
</ListItem>
<ListItem>
<Para>Intercell action flag
</Para>
</ListItem>
<ListItem>
<Para>Trigger binding
</Para>
</ListItem>
<ListItem>
<Para>Comment
</Para>
</ListItem>
</ItemizedList>
<Para>Note that ACL managers can be added to a schema entry's ACL manager 
set, but they cannot be modified or deleted.
</Para>
<Para>To modify any other schema entry fields implies a drastic change to the 
attribute type.  If this change must be made, the schema entry 
must be deleted 
(which deletes all attribute instances of that type) 
and then recreated. 
</Para>
<Para>The <Symbol Role="Variable">modify_parts</Symbol> parameter of the <Function>sec_rgy_attr_sch_update_entry()</Function> call can 
also be used to prohibit modification of additional schema entry fields.  This parameter, which 
is actually a <StructName Role="typedef">sec_attr_schema_entry_parts_t</StructName> data type, lists the fields that 
can be modified by the call.  Only those fields listed in 
<StructName Role="typedef">sec_attr_schema_entry_parts_t</StructName> can be modified.
</Para>
<Para>The new values used to update the attribute type 
are supplied in a <StructName Role="typedef">sec_attr_schema_entry_t</StructName> data type.
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.22">
<Title>The <Function>sec_rgy_attr_sch_delete_entry()</Function> Call</Title>
<Para>The <Function>sec_rgy_attr_sch_delete_entry()</Function> call deletes 
attributes types from the attribute schema.  
The attribute type to be deleted is specified by UUID.  
When an attribute type is deleted, 
all instances of that attribute type are invalidated.
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.23">
<Title>Reading Schema Entries</Title>
<Para>This section describes the calls that read schema entries and the cursor used by 
the <Function>sec_rgy_attr_sch_scan()</Function> call.
</Para>
<Sect3 Id="DCEADG.SECERA.div.24">
<Title>Using <StructName Role="typedef">sec_attr_cursor_t</StructName> with <Function>sec_rgy_attr_sch_scan()</Function></Title>
<Para>The <Function>sec_rgy_attr_sch_scan()</Function> call, which reads a specified number of 
attribute type entries from the attribute schema, uses a cursor of type 
<StructName Role="typedef">sec_attr_cursor_t</StructName>.  
This cursor must be allocated before it can be used as input to 
the <Function>sec_rgy_attr_sch_scan()</Function> call.  In addition, it can also 
be initialized to the first attribute type entry in the schema, although this 
is not required.  After use, the resources allocated to the <StructName Role="typedef">sec_attr_cursor_t</StructName> 
must be released.
</Para>
<Para>The following calls allocate, initialize, and release a <StructName Role="typedef">sec_attr_cursor_t</StructName> for 
use with the <Function>sec_rgy_attr_sch_scan()</Function> call:
</Para>
<ItemizedList>
<ListItem>
<Para><Function>sec_rgy_attr_sch_cursor_init()</Function>
</Para>
<Para>The <Function>sec_rgy_attr_sch_cursor_init()</Function> call allocates resources to the cursor and 
initializes the cursor to the first attribute type entry in the attribute schema.  
This call also supplies 
the total number of entries in the attribute schema as part of its output.  
The cursor 
allocation is a local operation.  The cursor initialization is a remote operation 
and makes a remote call to the registry.
</Para>
</ListItem>
<ListItem>
<?sml-need 10>
<Para><Function>sec_rgy_attr_sch_cursor_alloc()</Function>
</Para>
<Para>The <Function>sec_rgy_attr_sch_cursor_alloc()</Function> call allocates 
resources to the cursor but does not initialize the cursor.  
However, since the <Function>sec_rgy_attr_sch_scan()</Function> call will initialize the 
cursor if it is passed in uninitialized, you may prefer this call to 
limit the number of remote calls performed by an application.  
Be aware that the <Function>sec_rgy_attr_sch_cursor_init()</Function> call 
provides the total 
number of entries in the named schema, a piece of information not 
provided by the <Function>sec_rgy_attr_sch_cursor_alloc()</Function> call.
</Para>
</ListItem>
<ListItem>
<Para><Function>sec_rgy_attr_sch_cursor_release()</Function> 
</Para>
<Para>The <Function>sec_rgy_attr_sch_cursor_release()</Function> call releases all resources 
allocated to a <StructName Role="typedef">sec_attr_cursor_t</StructName> cursor used with the 
<Function>sec_rgy_attr_sch_scan()</Function> call.
</Para>
</ListItem>
<ListItem>
<Para><Function>sec_rgy_attr_sch_cursor_reset()</Function> 
</Para>
<Para>The <Function>sec_rgy_attr_sch_cursor_reset()</Function> call initializes a  
<StructName Role="typedef">sec_attr_cursor_t</StructName> cursor used with the 
<Function>sec_rgy_attr_sch_scan()</Function> call.  The reset cursor can then 
be used without releasing and reallocating.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.25">
<Title>The <Function>sec_rgy_attr_sch_scan()</Function> Call</Title>
<Para>The <Function>sec_rgy_attr_sch_scan()</Function> call reads a specified number of schema 
entries from the attribute schema.  
</Para>
<Para>The number of entries to read is specified as an unsigned 32-bit integer. 
The read begins at the entry at which the <StructName Role="typedef">sec_attr_cursor_t</StructName> 
cursor is positioned and continues through the number of entries specified.  
The cursor must be allocated but can be initialized or uninitialized since 
<Function>sec_rgy_attr_sch_scan()</Function> initializes any uninitialized 
cursor it receives as input.  
</Para>
<Para>The call output includes an array of <StructName Role="typedef">sec_attr_schema_entry_t</StructName> values 
and a 
32-bit integer that specifies the number of schema entries returned.    
</Para>
<Para>To read through all entries in a schema, continue making 
<Function>sec_rgy_attr_sch_scan()</Function> calls, 
until the <Literal>no_more_entries</Literal> message is received.  
When all calls are complete, 
release the resources allocated to the 
<StructName Role="typedef">sec_attr_cursor_t</StructName> cursor by using the 
<Function>sec_rgy_attr_sch_cursor_release()</Function> call.
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.26">
<Title>The <Function>sec_rgy_attr_sch_lookup_by_id()</Function> and <Function>sec_rgy_attr_sch_lookup_by_name()</Function> Calls</Title>
<Para>The <Function>sec_rgy_attr_sch_lookup_by_id()</Function> call reads the attribute 
schema entry identified by UUID.  The output of the call is a 
<StructName Role="typedef">sec_attr_schema_entry_t</StructName> type that contains the specified attribute 
type's name, UUID, and characteristics.  Generally, this call is used for 
programmatic access.  
</Para>
<Para>For interactive access, use the <Function>sec_rgy_attr_sch_lookup_by_name()</Function> call. 
This call returns the same information as the 
<Function>sec_rgy_attr_sch_lookup_by_id()</Function> 
call but specifies the schema entry to read by name instead of by UUID.
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.27">
<Title>Reading the ACL Manager Types</Title>
<Para>Two calls retrieve the ACL manager types that 
protect objects dominated by a named schema:
</Para>
<ItemizedList>
<ListItem>
<Para><Function>sec_rgy_attr_sch_get_acl_mgrs()</Function>
</Para>
<Para>Retrieves the UUIDs of the ACL manager types protecting all 
objects in a named schema.
</Para>
</ListItem>
<ListItem>
<Para><Function>sec_rgy_attr_sch_aclmgr_strings()</Function>
</Para>
<Para>Retrieves printable strings for each ACL manager type protecting objects 
in a named schema.  The strings contain the ACL manager type's name, associated 
help information, and supported permission bits.
</Para>
</ListItem>
</ItemizedList>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.SECERA.div.28">
<Title>Calls to Manipulate Attribute Instances</Title>
<Para>This section introduces the <StructName Role="typedef">sec_attr_schema_t</StructName> data type 
used by the calls that create and update attribute instances and
then describes the calls that create, modify, delete, 
and read attribute instances.  
For all calls, the object whose 
attributes should be accessed is identified by name and 
by the domain in which the object exists.  
(The domain parameter is ignored 
for the <Literal>Policy</Literal> and the <Literal>Replist</Literal> objects.)   
Registry domains are described in Chapter 28.
</Para>
<Sect2 Id="DCEADG.SECERA.div.29">
<Title>The sec_attr_t Data Type</Title>
<Para>The <StructName Role="typedef">sec_attr_t</StructName> data type is used in the calls that create and update 
attribute instances.  The data type consists of a value of type <StructName Role="typedef">uuid_t</StructName> 
that identifies the attribute to be accessed by UUID and data type of 
<StructName Role="typedef">sec_attr_value_t</StructName>.  The <StructName Role="typedef">sec_attr_value_t</StructName> data type 
is a tagged union of the actual value 
assigned (or to be assigned to the attribute instance) and a data type of 
<StructName Role="typedef">sec_attr_encoding_t</StructName> that specifies the encoding tags that define the 
attribute type characteristics.  
Figure 29-2 illustrates the structure of 
a <StructName Role="typedef">sec_attr_t</StructName> data type.
</Para>
<Figure>
<Title>The sec_attr_t Data Type</Title>
<Graphic Entityref="DCEADG.SECERA.ent.2" Scalefit="1" Reprowid="300" Reprodep="300"></Graphic>
</Figure>
<!-- .pI security/figures/4.5_era_20.ps 0 0 1-->
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.30">
<Title>Creating and Managing Attribute Instances</Title>
<Para>This section describes the calls to create, modify, and delete the 
attribute instances. 
</Para>
<Sect3 Id="DCEADG.SECERA.div.31">
<Title>The <Function>sec_rgy_attr_update()</Function> Call</Title>
<Para>The <Function>sec_rgy_attr_update()</Function> call creates new attribute 
instances and updates existing attribute instances attached to an
object specified by name and registry domain.  
The instances to be created or updated are 
passed as an array of <StructName Role="typedef">sec_attr_t</StructName> data types.
</Para>
<Para>Because the new values are passed in as an array, if the update of any 
attribute instance in the array fails, all fail.  However, to help pinpoint the 
cause of the failure, the call identifies the first attribute whose update failed 
in a failure index by array element number. 
</Para>
<Para>For existing attribute instances attached to the object, the values 
passed in the array overwrite the existing values.  In other 
words, if the UUID passed in the input array matches 
the UUID of an existing instance, the values passed in overwrite 
the existing values.  
</Para>
<Para>If the attribute instance does not exist, it is created.  
In other 
words, if the UUID passed in in the array does not match 
any other attribute type UUID attached to the object, a new 
attribute instance is created. 
</Para>
<Para>For multivalued attributes, 
because every instance of the multivalued attribute is identified by the same 
UUID, every instance is overwritten with the supplied 
value.  For example, suppose object <Literal>delores</Literal> 
has three attributes of the multivalued type <Literal>security_role</Literal>.  
If you pass in 
one value for <Literal>security_role</Literal>, the values of all 
three are changed to the one you enter.  
</Para>
<Para>To change only one of the <Literal>security_role</Literal> values, you must supply the values 
that should be unchanged as well as the new value.  For example, 
suppose object <Literal>delores</Literal> 
has three <Literal>security_role</Literal> attributes with values of <Literal>level1</Literal>, 
<Literal>level2</Literal>, and <Literal>level3</Literal>.  
To change <Literal>level1</Literal> to <Literal>level1O. and retain </Literal><Literal>level2</Literal> 
and <Literal>level3</Literal>, the input array must contain 
<Literal>level1.5</Literal>, <Literal>level2</Literal>, and <Literal>level3</Literal>.
</Para>
<Para>To create instances of multivalued attributes, 
you must create individual <StructName Role="typedef">sec_attr_t</StructName> 
data types to define each multivalued attribute 
instance and then pass all of them in the 
<Function>sec_rgy_attr_update()</Function> input array.
</Para>
<Para>If an input attribute is associated with an update attribute trigger, 
the attribute trigger is invoked (by the <Function>sec_attr_trig_update()</Function> call),
and the values in the <Function>sec_rgy_attr_update()</Function> input 
array are used as input to the update attribute trigger.
The output values from the update attribute trigger are stored 
in the registry database and returned in the <Function>sec_rgy_attr_update()</Function> 
output array.
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.32">
<Title>The <Function>sec_rgy_attr_test_and_update()</Function> Call</Title>
<Para>The <Function>sec_rgy_attr_test_and_update()</Function> call, like the <Function>sec_rgy_attr_update()</Function> 
call,  creates new attribute instances and updates 
existing attribute instances attached to an
object specified by name and registry domain.   
However, it performs the update only 
if a set of specified attribute instances match the attribute instances that 
already exist for the object.  This call is useful to ensure that updates 
are made only if certain conditions exist.
</Para>
<Para>The attribute instances to be matched are passed in an input array of <StructName Role="typedef">sec_attr_t</StructName> 
values.  Other than this conditional test, this call functions exactly the same as 
the <Function>sec_rgy_attr_update()</Function> call.
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.33">
<Title>The <Function>sec_rgy_attr_delete()</Function> Call</Title>
<Para>The <Function>sec_rgy_attr_delete()</Function> call deletes the specified attribute instances 
from an object identified by name and registry domain.  The attribute instances to 
be deleted are passed in  as an array of values of <StructName Role="typedef">sec_attr_t</StructName>.  
</Para>
<Para>To delete attribute instances that are not multivalued and to 
delete all instances of a multivalued attribute, an attribute UUID 
is all that is required.  For these attribute instances, supply the attribute 
UUID in the input array and 
set the attribute encoding (in <StructName Role="typedef">sec_attr_encoding_t</StructName>)  
to <Literal>sec_attr_enc_void</Literal>.     
</Para>
<Para>To delete a specific instance of a multivalued attribute, you 
must supply the UUID and value that uniquely identify the multivalued 
attribute instance in the input array.
</Para>
<Para>Note that, if the deletion of any 
attribute instance in the array fails, all fail.  However, to help pinpoint the 
cause of the failure, the call identifies the first attribute whose deletion failed 
in a failure index by array element number. 
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.34">
<Title>Reading Attribute Instances</Title>
<Para>This section describes the calls that read attribute instances, 
and it describes the cursor used by the  
<Function>sec_rgy_attr_lookup_by_id()</Function> call.
</Para>
<Sect3 Id="DCEADG.SECERA.div.35">
<Title>Using <StructName Role="typedef">sec_rgy_attr_cursor_t</StructName> with <Function>sec_rgy_attr_lookup_by_id()</Function></Title>
<Para>The <Function>sec_rgy_attr_lookup_by_id()</Function> call, which reads attributes for 
a specified object, uses a cursor of type 
<StructName Role="typedef">sec_attr_cursor_t</StructName>.  
This cursor must be allocated before it can be used as input to 
the <Function>sec_rgy_attr_lookup_by_id()</Function> call.  
In addition, it can also be 
initialized to the first attribute in the specified object's list 
of attributes, although this 
is not required.  After use, the resources allocated to the <StructName Role="typedef">sec_attr_cursor_t</StructName> 
must be released.
</Para>
<Para>The following calls allocate, initialize, and release a <StructName Role="typedef">sec_attr_cursor_t</StructName> for 
use with the <Function>sec_rgy_attr_lookup_by_id()</Function> call:
</Para>
<ItemizedList>
<ListItem>
<Para><Function>sec_rgy_attr_cursor_init()</Function>
</Para>
<Para>The <Function>sec_rgy_attr_sch_cursor_init()</Function> call allocates resources to and 
initializes the cursor to the first attribute in the specified object's list of 
attributes.   
This call also supplies 
the total number of attributes attached to the object as part of its output.  
The cursor 
allocation is a local operation.  The cursor initialization is a remote operation 
and makes a remote call to the registry.
</Para>
</ListItem>
<ListItem>
<Para><Function>sec_rgy_attr_cursor_alloc()</Function>
</Para>
<Para>The <Function>sec_rgy_attr_cursor_alloc()</Function> call allocates resources to 
the cursor but does not initialize the cursor.  However, 
since the <Function>sec_rgy_attr_lookup_by_id()</Function> call will initialize the 
cursor if it is passed in uninitialized, you may prefer this call to 
limit the number of remote calls performed by the application.  
Be aware that the <Function>sec_rgy_attr_cursor_init()</Function> call provides the total 
number of attributes attached to the specified object, a piece of information not 
provided by this call.
</Para>
</ListItem>
<ListItem>
<?sml-need 5>
<Para><Function>sec_rgy_attr_cursor_release()</Function> 
</Para>
<Para>The <Function>sec_rgy_attr_cursor_release()</Function> call releases all resources 
allocated to a <StructName Role="typedef">sec_attr_cursor_t</StructName> cursor used with the 
<Function>sec_rgy_attr_lookup_by_id()</Function> call. 
</Para>
</ListItem>
<ListItem>
<Para><Function>sec_rgy_attr_cursor_reset()</Function> 
</Para>
<Para>The <Function>sec_rgy_attr_cursor_reset()</Function> call reinitializes a  
<StructName Role="typedef">sec_attr_cursor_t</StructName> cursor used with the 
<Function>sec_rgy_attr_lookup_by_id()</Function> call.  The reset cursor can then be used without releasing and reallocating.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.36">
<Title>The <Function>sec_rgy_attr_lookup_by_id()</Function> Call</Title>
<Para>The <Function>sec_rgy_attr_lookup_by_id()</Function> call reads attributes specified by UUID for 
an object specified by name and domain.  Specifically the call returns
the following:
</Para>
<ItemizedList>
<ListItem>
<Para>An array of <StructName Role="typedef">sec_attr_t</StructName> values.
</Para>
</ListItem>
<ListItem>
<Para>A count of the total number of attribute instances returned.
</Para>
</ListItem>
<ListItem>
<Para>A count of the total number of attribute instances 
that could not be returned because of size constraints of 
the <StructName Role="typedef">sec_attr_t</StructName> array.  (Note that the call allows the size of the 
array to be specified.)
</Para>
</ListItem>
</ItemizedList>
<Para>For multivalued attributes, the call returns 
a <StructName Role="typedef">sec_attr_t</StructName> for each value as an individual attribute instance.  
For attribute sets, the call returns a <StructName Role="typedef">sec_attr_t</StructName>  for each member 
of the set, but not the set instance.  This routine is useful for programmatic access.
</Para>
<Para>If the attribute instance to be read is not 
associated with a query trigger or no additional information is
required by the query trigger, an attribute UUID is all that is required.  
For these attribute instances, supply the attribute 
UUID in the input array and 
set the attribute encoding (in <StructName Role="typedef">sec_attr_encoding_t</StructName>)  
to <Literal>sec_attr_enc_void</Literal>.   
</Para>
<Para>If the attribute instance to be read is associated with a 
query attribute trigger that 
requires additional information before it can process the query request, 
use a <StructName Role="typedef">sec_attr_value_t</StructName> to supply the requested information  
by doing the following:
</Para>
<ItemizedList>
<ListItem>
<?sml-need 4>
<Para>Set the <StructName Role="typedef">sec_attr_encoding_t</StructName> to an encoding type that is 
compatible with the information required by the query attribute trigger.  
</Para>
</ListItem>
<ListItem>
<Para>Set the <StructName Role="typedef">sec_attr_value_t</StructName> to hold the 
required information.
</Para>
</ListItem>
</ItemizedList>
<Para>You can define the number of elements in the input array of <StructName Role="typedef">sec_attr_t</StructName> values (in 
the <Symbol Role="Variable">num_attr_keys</Symbol> parameter).  If you define the number of elements as 
0 (zero), the call returns all of the object's 
attribute instances that the caller 
is authorized to see.  You should be aware, however, that if you 
define the number of elements as zero and the attribute is associated with 
a query attribute trigger, you will be unable to pass any information to the 
query attribute trigger. 
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.37">
<Title>The <Function>sec_rgy_attr_set_lookup_by_id()</Function> Call</Title>
<Para>The <Function>sec_rgy_attr_set_lookup_by_id()</Function> call reads attribute sets specified by 
set instance UUID for 
an object specified by name and domain.  Specifically the call returns
the following:
</Para>
<ItemizedList>
<ListItem>
<Para>A <StructName Role="typedef">sec_attr_t</StructName> for each attribute instance in the 
attribute set.  
</Para>
</ListItem>
<ListItem>
<Para>A count of the total number of attribute set instances returned.
</Para>
</ListItem>
<ListItem>
<Para>A count of the total number that could not be returned because of size constraints of 
the <StructName Role="typedef">sec_attr_t</StructName> array.  (Note that the call allows the size and length of the 
array to be specified.)
</Para>
</ListItem>
</ItemizedList>
<Note>
<Para>Since attribute triggers cannot be associated with an attribute set instance, 
this call 
provides no way to supply input data to a query attribute trigger.  
</Para>
</Note>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.38">
<Title>The <Function>sec_rgy_attr_lookup_by_name()</Function> Call</Title>
<Para>The <Literal>sec_rgy_attr_lookup_by_name</Literal>() call reads a single attribute 
instance specified by name 
for an object specified by name and domain.  The call returns a 
<StructName Role="typedef">sec_attr_t</StructName>  for the specified attribute instance.
</Para>
<Para><?sml-need 3>For multivalued attributes, 
the call returns the first instance of the 
multivalued attribute. (To retrieve every instance of a multivalued attribute, 
use the <Function>sec_rgy_attr_lookup_by_id()</Function> call.)
</Para>
<Para><?sml-need 3>For attribute sets, the call returns the attribute set 
instance, not the member instances.  
To retrieve all members of the set, use the 
<Function>sec_rgy_attr_lookup_by_id()</Function> call.
</Para>
<Note>
<Para>This call provides no way to supply input data to a query attribute trigger.  
If the attribute to be read is 
associated with a query trigger that requires input data, 
use the <Function>sec_rgy_attr_lookup_by_id()</Function> call.  
</Para>
</Note>
<!-- .cS-->
<!-- ******NOT AVAILABLE FOR BETA************************-->
<!-- .H 3 "Searching for Attribute Instances"-->
<!-- .P-->
<!-- This section describes calls that search for objects that possess -->
<!-- specified attribute instances.-->
<!-- .H 4 "Using sec_attr_srch_cursor_t with sec_rgy_attr_srch Calls"-->
<!-- .P-->
<!-- The \*Lsec_rgy_attr_srch_names(\|)(\.)\*O  and \*Lsec_rgy_attr_srch_names_attrs(\|)\*O calls -->
<!-- use a cursor of type \*Lsec_attr_srch_cursor_t\*O initialized to a list of objects that -->
<!-- meet a specified criteria.    -->
<!-- This cursor must be initialized before it can be used as input to -->
<!-- the calls.  After use, the resources allocated to the \*Lsec_attr_srch_cursor_t\*O -->
<!-- must be released.  The following calls allocate, initialize, and release a -->
<!-- \*Lsec_attr_srch_cursor_t\*O.-->
<!-- .ML-->
<!-- .LI-->
<!-- \*Lsec_rgy_attr_srch_cursor_init(\|)\*O-->
<!-- .P-->
<!-- The \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call allocates resources to a -->
<!-- \*Lsec_attr_srch_cursor_t\*O and initializes the cursor to a search set -->
<!-- of objects that possess specified attribute types or instances.  -->
<!-- The attribute types and attribute instance values searched for are -->
<!-- identified in an array of -->
<!-- \*Lsec_attr_t\*O values.   -->
<!-- .P-->
<!-- .P-->
<!-- To find all attributes of a specified type, an attribute UUID is all -->
<!-- that is required.  For these attributes, supply the UUID of the -->
<!-- desired attribute type in the input array and set -->
<!-- attribute encoding (in \*Lsec_attr_encoding_t\*O) to -->
<!-- \*Lsec_attr_enc_void\*O.-->
<!-- .P -->
<!-- To find a specific attribute instance, supply that attribute instance's-->
<!-- UUID and value in the \*Lsec_attr_t\*O.  This method is -->
<!-- useful for finding a single instance of a multivalued attribute.-->
<!-- .P-->
<!-- If you specify an attribute set in the input array, -->
<!-- only the set instance is found, not the members of the set.  -->
<!-- .P-->
<!-- Query triggers are not supported during evaluation -->
<!-- of the input \*O array.  -->
<!-- Although an attribute type associated with a query trigger -->
<!-- can be used in the array, -->
<!-- if the attribute type also carries a value, a match -->
<!-- will not be found.  The match will fail because the query -->
<!-- trigger is not executed; therefore, a value will not -->
<!-- be retrieved for comparison against the search value.-->
<!-- .P-->
<!-- You can define the number of elements in the input array (in -->
<!-- the \*Vnum_search_attrs\*O parameter).  If you define the number as -->
<!-- zero, the search set -->
<!-- is a list of all attributes in the named domain that -->
<!-- are managed by the server to which the call is bound.  -->
<!-- The cursor is positioned at the beginning of the -->
<!-- list.-->
<!-- .LI-->
<!-- \*Lsec_rgy_attr_srch_cursor_release(\|)\*O-->
<!-- .P-->
<!-- The \*Lsec_rgy_attr_srch_cursor_release(\|)\*O call releases all resources -->
<!-- allocated to a \*Lsec_rgy_attr_srch_cursor\*O cursor.-->
<!-- .LE-->
<!-- .H 4 "sec_rgy_attr_srch_names(\|)"-->
<!-- .P-->
<!-- The \*Lsec_rgy_attr_srch_names(\|)\*O call returns the names of the objects that possess the -->
<!-- attributes selected in the search set selected by the -->
<!-- \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call.  Specifically this call returns:-->
<!-- .ML-->
<!-- .LI-->
<!-- An array of names (\*Lsec_rgy_name_t\*O) of the objects that possess the attributes -->
<!-- specified as input to the \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call.-->
<!-- .LI-->
<!-- A count of the total object names returned.-->
<!-- .LI-->
<!-- An array of values that specify the total number of attributes attached to each object -->
<!-- whose name is returned in the names array.-->
<!-- .LE-->
<!-- .P-->
<!-- The position of the element in the array of names and the number of -->
<!-- attributes array connects the object name to the object's total number of attributes.  -->
<!-- As illustrated in the Figure titled "Array Correspondence", the -->
<!-- object named in position 1 of the array of names has the total number of -->
<!-- attributes listed in position 1 total number of attributes array. -->
<!-- .P-->
<!-- .nP-->
<!-- ...\" .ne 2.5-->
<!-- .FG "Array Correspondence"-->
<!-- .pI ../security/figures/4.5_era_30.ps 0 0 1-->
<!-- ...\" .pI security/figures/4.5_era_30.ps 0 0 1-->
<!-- .P-->
<!-- Before this call is executed, must execute the \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call -->
<!-- to select the search set, initialize a \*Lsec_rgy_attr_srch_cursor_t\*O cursor to the -->
<!-- beginning of the search set, and allocate resources to the cursor.  -->
<!-- After a \*Lsec_rgy_attr_srch_names(\|)\*O call is -->
<!-- executed, you must execute a \*Lsec_rgy_attr_srch_cursor_release(\|)\*O call to release -->
<!-- resources allocated to the cursor.-->
<!-- .H 4 "sec_rgy_attr_srch_names_attrs(\|)"-->
<!-- .P-->
<!-- The \*Lsec_rgy_attr_srch_names_attrs(\|)\*O call returns:-->
<!-- .ML-->
<!-- .LI-->
<!-- The names of the objects that possess the -->
<!-- attributes in the search set selected by the -->
<!-- \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call. -->
<!-- .LI-->
<!-- For those objects, the attributes specified in an array of attribute UUIDs -->
<!-- supplied as a parameter to this call.-->
<!-- .LE-->
<!-- .P-->
<!-- Except for the fact that you can return attributes in addition to  -->
<!-- object names, the call is similar to the \*Lsec_rgy_attr_srch_names_attrs(\|)\*O call.  -->
<!-- Like the \*Lsec_rgy_attr_srch_names(\|)\*O call, this call returns an -->
<!-- array of object names (\*Lsec_rgy_name_t\*O), a count of the total object names returned, and -->
<!-- array of values that specify the total number of attributes attached to each object -->
<!-- whose name is returned in the names array.  In addition, this call returns the -->
<!-- following information that is not returned by the \*Lsec_rgy_attr_srch_names(\|)\*O call:-->
<!-- .ML-->
<!-- .LI-->
<!-- A array of specified attribute UUIDs and values (\*Lsec_attr_t\*O).-->
<!-- .LI-->
<!-- A count of the total number of attributes that are attached to the -->
<!-- object.-->
<!-- .LI-->
<!-- A count of the total number of attributes returned.-->
<!-- .LE-->
<!-- .P-->
<!-- The attributes to be returned are specified in an array type \*Luuid_t\*O values.  -->
<!-- ******NOT AVAILABLE FOR 1.1************************-->
<!-- .cE-->
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.SECERA.div.39">
<Title>The Attribute Trigger Facility</Title>
<Para>Some attribute types require the support of an outside server either 
to verify input attribute values or to supply output attribute values 
when those values are stored in an external database. 
Such a server could, for example, 
connect a legacy registry system to the DCE registry.  
The attribute trigger facility provides for automatic calls  
to outside DCE servers, known as <FirstTerm>attribute triggers</FirstTerm>.
</Para>
<Para>Trigger servers, which are written by application developers, 
export the <Literal>sec_attr_trig</Literal> interface.  They 
are invoked automatically when an attribute that has been associated with an 
attribute trigger (during schema entry creation) is queried or updated.  
The attribute trigger facility consists of three components:
</Para>
<ItemizedList>
<ListItem>
<Para>The attribute schema trigger fields (<Literal>trig_types</Literal> and 
<Literal>trig_binding</Literal>) that associate an 
attribute trigger and its binding information with an attribute type.  These 
fields are part of the standard creation of a schema entry that 
defines an attribute type.  See Section 29.1.1.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>sec_attr_trig</Literal> APIs 
that define the query and update trigger operations.  
The APIs are provided in the <Literal>sec_attr_trig_</Literal><Symbol Role="Variable">*</Symbol><Literal>()</Literal> calls.
</Para>
</ListItem>
<ListItem>
<Para>The user-written attribute trigger servers are independent from DCE servers.  
The trigger servers implement the trigger operations for the attribute types 
that require attribute trigger 
processing.  These servers are not provided as part of DCE, 
but must be written by application developers.
</Para>
</ListItem>
</ItemizedList>
<Sect2 Id="DCEADG.SECERA.div.40">
<Title>Defining an Attribute Trigger/Attribute Association</Title>
<Para>When an attribute is created with the <Function>sec_rgy_attr_update()</Function> call,
you define the association between the attribute type and an attribute trigger 
by specifying the following:
</Para>
<ItemizedList>
<ListItem>
<Para>Trigger Type
</Para>
<Para>Defines the trigger as a query server (invoked for 
query operations) or an update server (invoked for updates operations).  
The trigger type is defined in a <StructName Role="typedef">sec_attr_trig_type_t</StructName> data type, 
which is used by a <StructName Role="typedef">sec_attr_schema_entry_t</StructName> data type.
</Para>
</ListItem>
<ListItem>
<Para>Trigger Binding
</Para>
<Para>Defines the server binding handle for the attribute trigger.  
The details of the trigger binding are defined in a number of data types, 
which are also used by the <StructName Role="typedef">sec_attr_schema_entry_t</StructName> data type.  Trigger 
binding is described in detail in Section 29.1.3.7.
</Para>
</ListItem>
</ItemizedList>
<Para>Only if both of pieces of information are provided will the association between the 
attribute type and the attribute trigger be created.  You can 
associate an attribute trigger to any attribute type of any encoding except for 
attribute sets.
</Para>
<Sect3 Id="DCEADG.SECERA.div.41">
<Title>Query Triggers</Title>
<Para>When you execute a call that 
accesses an attribute associated 
with a query trigger, the client-side 
attribute lookup code performs the following 
tasks:
</Para>
<ItemizedList>
<ListItem>
<Para>Binds to the attribute trigger (using a binding from the attribute type's schema entry)
</Para>
</ListItem>
<ListItem>
<Para>Makes the remote <Function>sec_attr_trig_query()</Function> call to the attribute trigger server, 
passing in the attribute keys and 
optional information provided by the caller
</Para>
</ListItem>
<ListItem>
<Para>If the <Function>sec_attr_trig_query()</Function> call is successful, returns the output attribute(s) 
to the caller
</Para>
</ListItem>
</ItemizedList>
<Para><?sml-need 5>If you execute a <Function>sec_rgy_attr()</Function> update call with an attribute type 
that is associated with a query trigger, not an update trigger, 
the input attribute values are ignored and a ``stub'' attribute instance 
is created on the 
named object simply to mark the existence of this attribute on the object.  
Modifications 
to the real attribute value must occur at the attribute trigger.
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.42">
<Title>Update Triggers</Title>
<Para>When you execute a call that 
accesses an attribute associated 
with an update trigger, the client-side attribute update code 
performs the following tasks:
</Para>
<ItemizedList>
<ListItem>
<Para>Binds to the attribute trigger (using a binding from the attribute type's schema entry)
</Para>
</ListItem>
<ListItem>
<Para>Makes the remote <Function>sec_attr_trig_update()</Function> call to the attribute trigger server, 
passing in the 
attributes provided by the 
caller 
</Para>
</ListItem>
<ListItem>
<Para>If the <Function>sec_attr_trig_update()</Function> call is successful, stores the output attribute(s) 
in the registry database and returns the output attribute(s) to the caller
</Para>
</ListItem>
</ItemizedList>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.43">
<Title>Trigger Binding</Title>
<Para>Two data types are used to defined an attribute trigger.  The 
<StructName Role="typedef">sec_attr_trig_type_t</StructName> type
defines the type of attribute trigger.  The <StructName Role="typedef">sec_attr_bind_info_t</StructName> 
data type, illustrated in Figure 29-3 and described 
in this section, specifies the attribute trigger's binding.
</Para>
<?sml-need 4.5i>
<Figure>
<Title>The sec_attr_bind_info_t Data Type</Title>
<Graphic Entityref="DCEADG.SECERA.ent.3" Scalefit="1" Reprowid="300" Reprodep="300"></Graphic>
</Figure>
<!-- .pI security/figures/4.5_era_40.ps 0 0 1-->
<?sml-space .5>
<Para>The <StructName Role="typedef">sec_attr_bind_info_t</StructName> data type uses two data types:  
<StructName Role="typedef">sec_attr_binding_t</StructName>, 
which defines the information used to generate binding handle 
and <StructName Role="typedef">sec_attr_bind_auth_info_t</StructName>, which defines the 
binding authentication and 
authorization information.
</Para>
<Sect3 Id="DCEADG.SECERA.div.44">
<Title>The <StructName Role="typedef">sec_attr_binding_t</StructName> Data Type</Title>
<Para>To describe the binding handle, the <StructName Role="typedef">sec_attr_binding_t</StructName> type uses a 
<StructName Role="typedef">sec_attr_bind_type_t</StructName> data type that specifies the format to the 
data used to generate the binding handle and a tagged union that 
contains the binding handle.  The binding handle can 
be generated from any of the following:
</Para>
<ItemizedList>
<?sml-need 9>
<ListItem>
<Para><Literal>A server directory entry name</Literal> (used 
with <Literal>rpc_ns_binding_import_</Literal><Symbol Role="Variable">*</Symbol><Literal>()</Literal> calls)
</Para>
<Para>If the binding information is a server name, 
call <Function>rpc_ns_binding_import_begin()</Function> 
to establish a context for importing RPC 
binding handles from the name service database.  
For the <Function>rpc_ns_binding_import_begin()</Function> call, 
specify the CDS server directory entry name, an entry name syntax value of  
<Literal>rpc_c_ns_syntax_dce</Literal>, and <Literal>sec_attr_trig</Literal> as the interface handle 
of the interface to import. 
</Para>
</ListItem>
<ListItem>
<Para><Literal>A string binding</Literal> (used with <Function>rpc_binding_from_string_binding()</Function> calls)
</Para>
<Para>If the binding information is a string binding, call 
<Function>rpc_binding_from_string_binding()</Function> to 
generate an RPC binding handle.
</Para>
</ListItem>
<ListItem>
<Para><Literal>An RPC protocol tower set</Literal> (used with <Function>rpc_tower_to_binding()</Function> calls)
</Para>
<Para>If the binding information is a protocol tower, two additional data types are used to pass in an 
unallocated array of towers, which the server must then allocate.  These 
data types are <StructName Role="typedef">sec_attr_twr_ref_t</StructName> to point to the tower and 
<StructName Role="typedef">sec_attr_twr_set_t</StructName> to define the array of towers.  
</Para>
<Para>Architectural components of DCE can take advantage 
of the internal <Literal>rpc_tower_to_binding</Literal> 
operation in <Filename>rpcpvt.idl</Filename> to generate a binding handle from the 
canonical representation of 
a protocol tower.
</Para>
</ListItem>
</ItemizedList>
<Para>Although the server directory entry name, with the actual server 
address stored in CDS, is the recommended 
way to specify an 
attribute trigger binding handle, prototype applications may want to specify a 
string binding or protocol tower for convenience.  
</Para>
</Sect3>
<Sect3 Id="DCEADG.SECERA.div.45">
<Title>The <StructName Role="typedef">sec_attr_bind_auth_info_t</StructName> Data Type</Title>
<Para>To describe whether or not RPC calls to the server will be authenticated and,
for authenticated calls, to provide authentication and 
authorization information,  
the <StructName Role="typedef">sec_attr_bind_auth_info_t</StructName> type uses the 
<StructName Role="typedef">sec_attr_bind_auth_info_type_t</StructName> data type, 
and a tagged union.  The 
<StructName Role="typedef">sec_attr_bind_auth_info_type_t</StructName> type defines whether or not the call is 
authenticated.  The tagged union contains the authentication and authorization 
parameters.    
</Para>
<Para><?sml-need 3>Once a binding handle is obtained, 
call <Function>rpc_binding_set_auth_info()</Function> and supply it with the 
binding handle and authorization and authentication 
information.
</Para>
</Sect3>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.46">
<Title>Access Control on Attributes with Triggers</Title>
<Para>When a query or update call accesses an attribute associated with an
attribute trigger, the call checks the ACL of the 
object with which the attribute is associated to see if the 
client has the permissions required for the operation.  
If access is granted, the operation returns a
binding handle authenticated with the client's login context.  
This handle is then used to 
perform the <Literal>sec_attr_trig_query</Literal> 
or <Literal>sec_attr_trig_update</Literal> operation.   
</Para>
<Para>Access to information maintained by an attribute trigger is controlled entirely by that 
attribute trigger.  The attribute trigger can choose to implement any authorization mechanism, 
including none.   For example, the attribute trigger can
obtain the client's identity from the RPC runtime to  
perform name-based authentication and perform ACL 
checks (or any other type of access control mechanism), 
and it can query the registry 
attribute schema for the attribute type's 
permission set  to use for an ACL check. 
Access control
on attribute information stored outside of the registry database 
is left to the application designer.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.SECERA.div.47">
<Title>Calls that Access Attribute Triggers</Title>
<Para>This section describes the calls that send information to 
and receive it from attribute triggers.
</Para>
<Sect2 Id="DCEADG.SECERA.div.48">
<Title>Using sec_attr_trig_cursor_t with sec_attr_trig_query()</Title>
<Para>The <Function>sec_attr_trig_query()</Function> call, which reads attributes associated with 
a query attribute trigger, uses a cursor of type 
<StructName Role="typedef">sec_attr_trig_cursor_t</StructName>.  
This cursor must be allocated and initialized before it can be used as input to 
the <Function>sec_attr_trig_query()</Function> call.  
After use, the resources allocated to <StructName Role="typedef">sec_attr_trig_cursor_t</StructName> 
must be released.
</Para>
<Para>The following calls allocate, initialize, and 
release a <StructName Role="typedef">sec_attr_trig_cursor_t</StructName> type for 
use with the <Function>sec_attr_trig_query()</Function> call:
</Para>
<ItemizedList>
<ListItem>
<Para><Function>sec_attr_trig_cursor_init()</Function>
</Para>
<Para>The <Function>sec_attr_trig_cursor_init()</Function> 
call allocates resources to the cursor and 
initializes the cursor to the first attribute in the list of attributes 
for the object whose binding handle is specified.  
This call makes a remote call.
</Para>
</ListItem>
<ListItem>
<Para><Function>sec_attr_trig_cursor_release()</Function> 
</Para>
<Para>The <Function>sec_rgy_attr_cursor_release()</Function> call releases 
all resources 
allocated to a <StructName Role="typedef">sec_attr_trig_cursor_t</StructName> type
by <Function>sec_attr_trig_cursor_init()</Function>. 
</Para>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.49">
<Title>The sec_rgy_attr_trig_query() and sec_rgy_attr_trig_update() Calls</Title>
<Para>The <Function>sec_attr_trig_query()</Function> call 
reads instances of attributes coded with a trigger type of query for a specified object.  
It passes an array of <StructName Role="typedef">sec_attr_t</StructName> values to a  
query attribute trigger and receives the output parameters 
back from the server.  
The <Function>sec_attr_trig_update()</Function> routine 
passes attributes coded with a trigger type of update 
to an update attribute trigger for evaluation 
before the updates are made to the registry. 
</Para>
<Para>Both calls are called automatically by 
the DCE attribute lookup or update code for all schema entries that 
specify a trigger.  
Although you should not call these
calls directly, if you are implementing a trigger 
server, it will receive input from these calls and the 
attribute trigger's output should be passed back to them.  The data received must be 
in a form accessible to the call and, if it is the result of an update, a 
form that can be stored in the registry database.
</Para>
<Para>The object whose attribute instances are to be read or updated is identified by
</Para>
<ItemizedList>
<ListItem>
<Para>The name of the cell in which the object exists
</Para>
</ListItem>
<ListItem>
<Para>The name of the object or a UUID in string format 
that identifies the object
</Para>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.50">
<Title>The priv_attr_triq_query() Call</Title>
<Para>The <Function>priv_attr_trig_query()</Function> call is used by the privilege service to retrieve 
trigger attributes and add them to a 
princpal's EPAC.  The privilege service executes this call when it 
receives a request to add a principal and its extended attribute instances to an EPAC and the 
attributes are associated with a trigger server.  
The call passes an array of
<StructName Role="typedef">sec_attr_t</StructName> values to the   
attribute trigger and receives the attribute values back from the trigger server 
in another array of <StructName Role="typedef">sec_attr_t</StructName> values.  
If the principal is being added to a delegation chain, the call also passes the 
UUIDs of all of the current members of the delegation chain to the trigger server.  
The trigger server can then evaluate all identities to determine access rights to the 
requested attributes.
</Para>
<Para>Like the
<Function>sec_rgy_attr_trig_update()</Function> calls, you will not call <Function>priv_attr_trig_query()</Function> 
directly.  However, if you are implementing a trigger 
server, it will receive input from these calls and the 
attribute trigger's output should be passed back to the call.  The data received must be 
in a form accessible to the call.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.SECERA.div.51">
<Title>The DCE Attribute API</Title>
<Para>The DCE attribute calls are not described in detail.  This is 
because, with the exception of the calls that bind to a selected 
database (<Function>dce_attr_sch_bind()(</Function> and 
<Function>dce_attr_sch_bind_free()</Function>), 
the <Literal>dce_sec_attr_</Literal><Symbol Role="Variable">*</Symbol><Literal>()</Literal> calls 
are the same as the <Literal>sec_rgy_attr_sch_</Literal><Symbol Role="Variable">*</Symbol><Literal>()</Literal> 
calls.  Refer to Section 29.1 for information on 
using each call.  Note also that the DCE attribute calls are suffixed with 
<Literal>3dce</Literal>, not <Literal>3sec</Literal> (for example, <Filename MoreInfo="RefEntry">dce_attr_sch_bind.3dce</Filename>).
</Para>
<Para>The DCE attribute API consists of the following calls:
</Para>
<ItemizedList>
<ListItem>
<Para><Function>dce_attr_sch_bind()</Function>
</Para>
<Para>Returns an opaque handle of 
type <StructName Role="typedef">dce_attr_sch_handle_t</StructName> to a 
schema object specified by name and sets authentication and 
authorization parameters for the handle.  This is the call used 
to bind to the schema of your choice.
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_bind_free()</Function>
</Para>
<Para>Releases an opaque handle of 
type <StructName Role="typedef">dce_attr_sch_handle_t</StructName>.
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_create_entry()</Function>
</Para>
<Para>Creates a schema entry in a schema 
bound to with <Literal>dce_attr_sch_bind</Literal>.  This call is based on 
<Function>sec_rgy_attr_sch_create_entry()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_update_entry()</Function>
</Para>
<Para>Updates a schema entry in a schema bound to with <Function>dce_attr_sch_bind()</Function>.  
This call is based on 
<Function>sec_rgy_attr_sch_update_entry()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_delete_entry()</Function>
</Para>
<Para>Deletes a schema entry in a schema bound to with <Function>dce_attr_sch_bind()</Function>.  
This call is based on 
<Function>sec_rgy_attr_sch_delete_entry()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_scan()</Function>
</Para>
<Para>Reads a specified number of schema entries.  This call is based on 
<Function>sec_rgy_attr_sch_scan()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_cursor_init()</Function>
</Para>
<Para>Allocates resources 
to and initializes a cursor used with <Function>dce_attr_sch_scan()</Function>. 
The <Function>dce_attr_sch_cursor_init()</Function> routine makes a
remote call that also returns the current number of 
schema entries in the schema.
The <Function>dce_attr_sch_cursor_init()</Function> call is based on 
<Function>sec_rgy_attr_sch_cursor_init()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<?sml-need 6>
<Para><Function>dce_attr_sch_cursor_alloc()</Function>
</Para>
<Para>Allocates resources to a cursor 
used with <Function>dce_attr_sch_scan()</Function>.  The <Function>dce_attr_sch_cursor_alloc()</Function> 
routine is a local operation.
The <Function>dce_attr_sch_cursor_alloc()</Function> 
call is based on 
<Function>sec_rgy_attr_sch_cursor_alloc()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_cursor_release()</Function>
</Para>
<Para>Releases states associated with a 
cursor created by <Function>dce_attr_sch_cursor_alloc()</Function> or 
<Function>dce_attr_sch_cursor_init()</Function>.
The <Function>dce_attr_sch_cursor_release()</Function> call is based on 
<Function>sec_rgy_attr_sch_cursor_release()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_cursor_reset()</Function>
</Para>
<Para>Reinitializes a cursor used with 
<Function>dce_attr_sch_scan()</Function>.  The reset cursor can then be reused without 
releasing and reallocating.
This call is based on the 
<Function>sec_rgy_attr_sch_cursor_reset()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_lookup_by_id()</Function>
</Para>
<Para>Reads a schema entry identified by UUID.  This call is based on 
<Function>sec_rgy_attr_lookup_by_id()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_lookup_by_name()</Function>
</Para>
<Para>Reads a schema entry identified by name.  
This call is based on 
<Function>sec_rgy_attr_sch_lookup_by_name()</Function> and is used in the same way. 
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_get_acl_mgrs()</Function>
</Para>
<Para>Retrieves the UUIDs of ACL manager types 
protecting objects dominated by a named schema.  This call is based on 
<Function>sec_rgy_attr_sch_get_acl_mgrs()</Function> and is used in the same way.  
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_attr_sch_aclmgr_strings()</Function>
</Para>
<Para>Retrieves the print strings containing information about ACL manager types 
protecting objects dominated by a named schema.  The print 
strings contain the manager's 
name, help information, and supported permission bits.  This call is based 
on <Function>sec_rgy_attr_sch_aclmgr_strings()</Function> and is used in the same way.  
</Para>
</ListItem>
</ItemizedList>
</Sect1>
<Sect1 Id="DCEADG.SECERA.div.52">
<Title>Macros to Aid Extended Attribute Programming</Title>
<Para>The extended attribute APIs includes macros to help programmers using the 
extended 
attribute interfaces.  The 
macros perform a variety of functions including
</Para>
<ItemizedList>
<ListItem>
<Para>Accessing fields in data structures
</Para>
</ListItem>
<ListItem>
<Para>Calculating the size of data structures
</Para>
</ListItem>
<ListItem>
<Para>Performing semantic and flag checks 
</Para>
</ListItem>
<ListItem>
<Para>Setting flags
</Para>
</ListItem>
</ItemizedList>
<Para>The macros are in <Filename>dce/rpcbase.h</Filename>, which is derived 
from <Filename>dce/rpcbase.idl</Filename>.
</Para>
<Para>The following subsections list the definitions of each macro.
</Para>
<Sect2 Id="DCEADG.SECERA.div.53">
<Title>Macros to Access Binding Fields</Title>
<Para>In the following macro definitions, which are used by a 
<StructName Role="typedef">sec_attr_schema_entry_t</StructName> and its equivalent <Literal>dce_attr_sch</Literal> 
data type, B is a pointer to <StructName Role="typedef">sec_attr_bind_info_t</StructName>.
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
<?sml-need 50>
#define SA_BND_AUTH_INFO(B)		(B)->auth_info
#define SA_BND_AUTH_INFO_TYPE(B)	(SA_BND_AUTH_INFO(B)).info_type

#define SA_BND_AUTH_SVR_PNAME_P(B) \
 
	(SA_BND_AUTH_DCE_INFO(B)).svr_princ_name

#define SA_BND_AUTH_PROT_LEVEL(B) \
 
        (SA_BND_AUTH_DCE_INFO(B)).protect_level

#define SA_BND_AUTH_AUTHN_SVC(B) \
 
        	(SA_BND_AUTH_DCE_INFO(B)).authn_svc

#define SA_BND_AUTH_AUTHZ_SVC(B) \
 
	(SA_BND_AUTH_DCE_INFO(B)).authz_svc

#define SA_BND_NUM(B)			(B)->num_bindings
#define SA_BND_ARRAY(B,I)		(B)->bindings[I]
#define SA_BND_TYPE(B,I)		(SA_BND_ARRAY(B,I)).bind_type

#define SA_BND_STRING_P(B,I) \
 
	(SA_BND_ARRAY(B,I)).tagged_union.string_binding

#define SA_BND_SVRNAME_P(B,I) \
 
	(SA_BND_ARRAY(B,I)).tagged_union.svrname

#define SA_BND_SVRNAME_SYNTAX(B,I) \
 
	(SA_BND_SVRNAME_P(B,I))->name_syntax

#define SA_BND_SVRNAME_NAME_P(B,I) \
 
	(SA_BND_SVRNAME_P(B,I))->name

#define SA_BND_TWRSET_P(B,I) \
 
	(SA_BND_ARRAY(B,I)).tagged_union.twr_set

#define SA_BND_TWRSET_COUNT(B,I)	(SA_BND_TWRSET_P(B,I))->count
#define SA_BND_TWR_P(B,I,J)		(SA_BND_TWRSET_P(B,I))->towers[J]
#define SA_BND_TWR_LEN(B,I,J)		(SA_BND_TWR_P(B,I,J))->tower_length

#define SA_BND_TWR_OCTETS(B,I,J) \
 
	(SA_BND_TWR_P(B,I,J))->tower_octet_string
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.54">
<Title>Macros to Access Schema Entry Fields</Title>
<Para>In the following macro definitions, 
S is a pointer to <StructName Role="typedef">sec_attr_schema_entry_t</StructName> 
(and its equivalent <Literal>dce_attr_sch</Literal> data type) and 
I and J are nonnegative integers for array element selection.
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">
<?Pub _font TypeSize="8pt">
#define SA_ACL_MGR_SET_P(S)             (S)->acl_mgr_set
#define SA_ACL_MGR_NUM(S)               (SA_ACL_MGR_SET_P(S))->num_acl_mgrs
#define SA_ACL_MGR_INFO_P(S,I)          (SA_ACL_MGR_SET_P(S))->mgr_info[I]
#define SA_ACL_MGR_TYPE(S,I)            (SA_ACL_MGR_INFO_P(S,I))->acl_mgr_type
#define SA_ACL_MGR_PERMS_QUERY(S,I)     (SA_ACL_MGR_INFO_P(S,I))->query_permset
#define SA_ACL_MGR_PERMS_UPDATE(S,I)    (SA_ACL_MGR_INFO_P(S,I))->update_permset
#define SA_ACL_MGR_PERMS_TEST(S,I)      (SA_ACL_MGR_INFO_P(S,I))->test_permset
#define SA_ACL_MGR_PERMS_DELETE(S,I)    (SA_ACL_MGR_INFO_P(S,I))->delete_permset
#define SA_TRG_BND_INFO_P(S)            (S)->trig_binding

#define SA_TRG_BND_AUTH_INFO(S) \
 
	(SA_BND_AUTH_INFO(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_INFO_TYPE(S) \
 
	(SA_BND_AUTH_INFO_TYPE(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_DCE_INFO(S) \
 
	(SA_BND_AUTH_DCE_INFO(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_SVR_PNAME_P(S) \
 
	(SA_BND_AUTH_SVR_PNAME_P(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_PROT_LEVEL(S) \
 
	(SA_BND_AUTH_PROT_LEVEL(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_AUTHN_SVC(S) \
 
	(SA_BND_AUTH_AUTHN_SVC(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_AUTHZ_SVC(S) \
 
	(SA_BND_AUTH_AUTHZ_SVC(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_NUM(S) \
 
	(SA_BND_NUM(SA_TRG_BND_INFO_P(S)))

<?sml-need 3>#define SA_TRG_BND_ARRAY(S,I) \
 
	(SA_BND_ARRAY((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_TYPE(S,I) \
 
	(SA_BND_TYPE((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_STRING_P(S,I) \
 
	(SA_BND_STRING_P((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_SVRNAME_P(S,I) \
 
	(SA_BND_SVRNAME_P((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_SVRNAME_SYNTAX(S,I) \
 
        (SA_BND_SVRNAME_SYNTAX((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_SVRNAME_NAME_P(S,I) \
 
        (SA_BND_SVRNAME_NAME_P((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_TWRSET_P(S,I) \
 
	(SA_BND_TWRSET_P((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_TWRSET_COUNT(S,I) \
 
	(SA_BND_TWRSET_COUNT((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_TWR_P(S,I,J) \
 
	(SA_BND_TWR_P((SA_TRG_BND_INFO_P(S)),I,J))

#define SA_TRG_BND_TWR_LEN(S,I,J) \
 
	(SA_BND_TWR_LEN((SA_TRG_BND_INFO_P(S)),I,J))

#define SA_TRG_BND_TWR_OCTETS(S,I,J) \
 
	(SA_BND_TWR_OCTETS((SA_TRG_BND_INFO_P(S)),I,J))
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.55">
<Title>Macros to Access Attribute Instance Fields</Title>
<Para>In the following macro descriptions, 
S is a pointer to <StructName Role="typedef">sec_attr_t</StructName>, and 
I and J are nonnegative integers for array element selection.
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
#define SA_ATTR_ID(S)			(S)->attr_id
#define SA_ATTR_VALUE(S)		(S)->attr_value
#define SA_ATTR_ENCODING(S)		(SA_ATTR_VALUE(S)).attr_encoding

#define SA_ATTR_INTEGER(S) \
 
	(SA_ATTR_VALUE(S)).tagged_union.signed_int

#define SA_ATTR_PRINTSTRING_P(S) \

	(SA_ATTR_VALUE(S)).tagged_union.printstring
 

#define SA_ATTR_STR_ARRAY_P(S) \
 
	(SA_ATTR_VALUE(S)).tagged_union.string_array

#define SA_ATTR_STR_ARRAY_NUM(S)	(SA_ATTR_STR_ARRAY_P(S))->num_strings
#define SA_ATTR_STR_ARRAY_ELT_P(S,I)	(SA_ATTR_STR_ARRAY_P(S))->strings[I]

#define SA_ATTR_BYTES_P(S) \
 
	(SA_ATTR_VALUE(S)).tagged_union.bytes

#define SA_ATTR_BYTES_LEN(S)		(SA_ATTR_BYTES_P(S))->length
#define SA_ATTR_BYTES_DATA(S,I)		(SA_ATTR_BYTES_P(S))->data[I]

#define SA_ATTR_IDATA_P(S) \
 
	(SA_ATTR_VALUE(S)).tagged_union.idata

#define SA_ATTR_IDATA_CODESET(S)	(SA_ATTR_IDATA_P(S))->codeset
#define SA_ATTR_IDATA_LEN(S)		(SA_ATTR_IDATA_P(S))->length
#define SA_ATTR_IDATA_DATA(S,I)		(SA_ATTR_IDATA_P(S))->data[I]

#define SA_ATTR_UUID(S) \
 
	(SA_ATTR_VALUE(S)).tagged_union.uuid

#define SA_ATTR_SET_P(S) \
 
	(SA_ATTR_VALUE(S)).tagged_union.attr_set

<?sml-need 3>#define SA_ATTR_SET_NUM(S)		(SA_ATTR_SET_P(S))->num_members
#define SA_ATTR_SET_MEMBERS(S,I)	(SA_ATTR_SET_P(S))->members[I]

#define SA_ATTR_BND_INFO_P(S) \
 
	(SA_ATTR_VALUE(S)).tagged_union.binding

#define SA_ATTR_BND_AUTH_INFO(S) \
 
	(SA_BND_AUTH_INFO(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_INFO_TYPE(S) \
 
	(SA_BND_AUTH_INFO_TYPE(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_DCE_INFO(S) \
 
	(SA_BND_AUTH_DCE_INFO(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_SVR_PNAME_P(S) \

	(SA_BND_AUTH_SVR_PNAME_P(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_PROT_LEVEL(S) \
 
	(SA_BND_AUTH_PROT_LEVEL(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_AUTHN_SVC(S) \
 
	(SA_BND_AUTH_AUTHN_SVC(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_AUTHZ_SVC(S) \
 
	(SA_BND_AUTH_AUTHZ_SVC(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_NUM(S) \
 
	(SA_BND_NUM(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_ARRAY(S,I) \
 
	(SA_BND_ARRAY((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_TYPE(S,I) \
 
	(SA_BND_TYPE((SA_ATTR_BND_INFO_P(S)),I))

<?sml-need 3>#define SA_ATTR_BND_STRING_P(S,I) \
 
	(SA_BND_STRING_P((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_SVRNAME_P(S,I) \
 
	(SA_BND_SVRNAME_P((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_SVRNAME_SYNTAX(S,I) \
 
        (SA_BND_SVRNAME_SYNTAX((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_SVRNAME_NAME_P(S,I) \
 
        (SA_BND_SVRNAME_NAME_P((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_TWRSET_P(S,I) \
 
	(SA_BND_TWRSET_P((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_TWRSET_COUNT(S,I) \
 
	(SA_BND_TWRSET_COUNT((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_TWR_P(S,I,J) \
 
	(SA_BND_TWR_P((SA_ATTR_BND_INFO_P(S)),I,J))

#define SA_ATTR_BND_TWR_LEN(S,I,J) \
 
	(SA_BND_TWR_LEN((SA_ATTR_BND_INFO_P(S)),I,J))

#define SA_ATTR_BND_TWR_OCTETS(S,I,J) \
 
	(SA_BND_TWR_OCTETS((SA_ATTR_BND_INFO_P(S)),I,J))
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.56">
<Title>Binding Data Structure Size Calculation Macros</Title>
<Para>The following macros are supplied to calculate the size 
of data types that hold binding information.  The macros 
work with the ERA API data types 
and their equivalent <Literal>dce_attr_sch</Literal> 
data types.
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>/*
 * SA_BND_INFO_SIZE(N) - calculate the size required
 * for a sec_attr_bind_info_t with N bindings.
 */
#define SA_BND_INFO_SIZE(N) ( sizeof(sec_attr_bind_info_t) + \
 
        (((N) - 1) * sizeof(sec_attr_binding_t)) )

<?sml-need 7>/*
 * SA_TWR_SET_SIZE(N) - calculate the size required
 * for a sec_attr_twr_set_t with N towers.
 */
#define SA_TWR_SET_SIZE(N) ( sizeof(sec_attr_twr_set_t) + \
 
        (((N) - 1) * sizeof(sec_attr_twr_ref_t)) )

/*
 * SA_TWR_SIZE(N) - calculate the size required
 * for a twr_t with a tower_octet_string of length N.
 */
#define SA_TWR_SIZE(N) ( sizeof(twr_t) + (N) - 1 )
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.57">
<Title>Schema Entry Data Structure Size Calculation Macros</Title>
<Para>The following macro is supplied to calculate the size 
of a <StructName Role="typedef">sec_attr_alc_mgr_info_set_t</StructName> data type.
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
/*
 * SA_ACL_MGR_SET_SIZE(N) - calculate the size required
 * for a sec_attr_acl_mgr_info_set_t with N acl_mgrs.
 */
#define SA_ACL_MGR_SET_SIZE(N) ( sizeof(sec_attr_acl_mgr_info_set_t) + \
 
        (((N) - 1) * sizeof(sec_attr_acl_mgr_info_p_t)) )
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.58">
<Title>Attribute Instance Data Structure Size Calculation Macros</Title>
<Para>The following macros are supplied to calculate the size 
of data types that hold attribute information.
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
/*
 * SA_ATTR_STR_ARRAY_SIZE(N) - calculate the size required
 * for a sec_attr_enc_str_array_t with N sec_attr_enc_printstring_p_t-s.
 */
#define SA_ATTR_STR_ARRAY_SIZE(N) ( sizeof(sec_attr_enc_str_array_t) + \
 
        (((N) - 1) * sizeof(sec_attr_enc_printstring_p_t)) )

<?sml-need 5>/*
 * SA_ATTR_BYTES_SIZE(N) - calculate the size required
 * for a sec_attr_enc_bytes_t with byte string length of N.
 */
#define SA_ATTR_BYTES_SIZE(N) ( sizeof(sec_attr_enc_bytes_t) + (N) - 1 )

/*
 * SA_ATTR_IDATA_SIZE(N) - calculate the size required
 * for a sec_attr_i18n_data_t with byte string length of N.
 */
#define SA_ATTR_IDATA_SIZE(N) ( sizeof(sec_attr_i18n_data_t) + (N) - 1 )

/*
 * SA_ATTR_SET_SIZE(N) - calculate the size required
 * for a sec_attr_enc_attr_set_t with N members (uuids).
 */
#define SA_ATTR_SET_SIZE(N) ( sizeof(sec_attr_enc_attr_set_t) + \
 
        (((N) - 1) * sizeof(uuid_t)) )
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.59">
<Title>Binding Semantic Check Macros</Title>
<Para>The following macros are supplied to check the semantics of 
entries in the binding fields.  The macros 
work with the ERA API data types 
and their equivalent <Literal>dce_attr_sch</Literal> 
data types.
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>
<?Pub _font TypeSize="8pt">
/*
 * SA_BND_AUTH_INFO_TYPE_VALID(B) - evaluates to TRUE (1)
 * if the binding auth_info type is valid; FALSE (0) otherwise.
 * B is a pointer to a sec_attr_bind_info_t.
 */
#define SA_BND_AUTH_INFO_TYPE_VALID(B)	( \
 
    (SA_BND_AUTH_INFO_TYPE(B)) == sec_attr_bind_auth_none	|| \
 
    (SA_BND_AUTH_INFO_TYPE(B)) == sec_attr_bind_auth_dce ? true : false )

/*
 * SA_BND_AUTH_PROT_LEV_VALID(B) - evaluates to TRUE (1)
 * if the binding auth_info protect_level is valid; FALSE (0) otherwise.
 * B is a pointer to a sec_attr_bind_info_t.
 */
#define SA_BND_AUTH_PROT_LEV_VALID(B)	( \
 
<?sml-need 6>    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_default		|| \
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_none		|| \
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_connect		|| \
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_call		|| \
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_pkt		|| \
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_pkt_integ	|| \
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_pkt_privacy ? \
 
    true : false )

/*
 * SA_BND_AUTH_AUTHN_SVC_VALID(B) - evaluates to TRUE (1)
 * if the binding auth_info authentication service is valid; 
 * FALSE (0) otherwise.
 * B is a pointer to a sec_attr_bind_info_t.
 */
#define SA_BND_AUTH_AUTHN_SVC_VALID(B)	( \
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_none		|| \
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_dce_secret	|| \
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_dce_public	|| \
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_dce_dummy		|| \
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_dssa_public	|| \
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_default ? \
    true : false )

/*
 * SA_BND_AUTH_AUTHZ_SVC_VALID(B) - evaluates to TRUE (1)
 * if the binding auth_info authorization service is valid; 
 * FALSE (0) otherwise.
 * B is a pointer to a sec_attr_bind_info_t.
 */
#define SA_BND_AUTH_AUTHZ_SVC_VALID(B)	( \
 
<?sml-need 8>    (SA_BND_AUTH_AUTHZ_SVC(B)) == rpc_c_authz_none	|| \
 
    (SA_BND_AUTH_AUTHZ_SVC(B)) == rpc_c_authz_name	|| \
 
    (SA_BND_AUTH_AUTHZ_SVC(B)) == rpc_c_authz_dce ? \
 
    true : false )
<?Pub /_font><?Pub Caret>
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.60">
<Title>Schema Entry Semantic Check Macros</Title>
<Para>The following macros are supplied to check the semantics of 
schema entry fields.  In the macros, S is a pointer to 
<StructName Role="typedef">sec_attr_schema_entry_t</StructName> and its equivalent <Literal>dce_attr_sch</Literal> 
data type.
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing>#define SA_TRG_BND_AUTH_INFO_TYPE_VALID(S) \
 
	(SA_BND_AUTH_INFO_TYPE_VALID(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_PROT_LEV_VALID(S) \
 
	(SA_BND_AUTH_PROT_LEV_VALID(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_AUTHN_SVC_VALID(S) \
 
	(SA_BND_AUTH_AUTHN_SVC_VALID(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_AUTHZ_SVC_VALID(S) \
 
	(SA_BND_AUTH_AUTHZ_SVC_VALID(SA_TRG_BND_INFO_P(S))
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.61">
<Title>Attribute Instance Semantic Check Macros</Title>
<Para>The following macros are supplied to check the semantics of 
entries in the attribute instance fields.  In the following macros, 
S is a pointer to <StructName Role="typedef">sec_attr_t</StructName>.  F is a 
<StructName Role="typedef">sec_attr_trigs_types_flags_t</StructName>. 
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 35>#define SA_ATTR_BND_AUTH_INFO_TYPE_VALID(S) \
 
	(SA_BND_AUTH_INFO_TYPE_VALID(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_PROT_LEV_VALID(S) \
 
	(SA_BND_AUTH_PROT_LEV_VALID(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_AUTHN_SVC_VALID(S) \
 
	(SA_BND_AUTH_AUTHN_SVC_VALID(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_AUTHZ_SVC_VALID(S) \
 
	(SA_BND_AUTH_AUTHZ_SVC_VALID(SA_ATTR_BND_INFO_P(S))

#define SA_SCH_FLAG_IS_SET(S,F) \
 
	(((S)->schema_entry_flags &amp; (F)) == (F))

#define SA_SCH_FLAG_IS_SET_UNIQUE(S) \
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_sch_entry_unique))

#define SA_SCH_FLAG_IS_SET_MULTI_INST(S) \
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_sch_entry_multi_inst))

#define SA_SCH_FLAG_IS_SET_RESERVED(S) \
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_sch_entry_reserved))

#define SA_SCH_FLAG_IS_SET_USE_DEFAULTS(S) \
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_sch_entry_use_defaults))
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.62">
<Title>Schema Entry Flag Set and Unset Macros</Title>
<Para>The following macros set and unset flag(s) in 
the schema entry <Literal>schema_entry_flags</Literal> field.    
In the following macros, S is a pointer to <StructName Role="typedef">sec_attr_schema_entry_t</StructName>.  
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 41>/*
 * Macros to set the flags. 
 */
#define SA_SCH_FLAG_SET(S, FLAG) ((S)->schema_entry_flags |= (FLAG))

#define SA_SCH_FLAG_SET_UNIQUE(S) \
 
        (SA_SCH_FLAG_SET((S),sec_attr_sch_entry_unique))

#define SA_SCH_FLAG_SET_MULTI_INST(S) \
 
        (SA_SCH_FLAG_SET((S),sec_attr_sch_entry_multi_inst))

#define SA_SCH_FLAG_SET_RESERVED(S) \
 
        (SA_SCH_FLAG_SET((S),sec_attr_sch_entry_reserved))

#define SA_SCH_FLAG_SET_USE_DEFAULTS(S) \
 
        (SA_SCH_FLAG_SET((S),sec_attr_sch_entry_use_defaults))

/*
 * Macros to unset the flags. 
 */
#define SA_SCH_FLAG_UNSET(S, FLAG) ((S)->schema_entry_flags \
        &amp;= ~(FLAG))

#define SA_SCH_FLAG_UNSET_UNIQUE(S) \
 
        (SA_SCH_FLAG_UNSET((S),sec_attr_sch_entry_unique))

#define SA_SCH_FLAG_UNSET_MULTI_INST(S) \
 
        (SA_SCH_FLAG_UNSET((S),sec_attr_sch_entry_multi_inst))

#define SA_SCH_FLAG_UNSET_RESERVED(S) \
 
        (SA_SCH_FLAG_UNSET((S),sec_attr_sch_entry_reserved))

#define SA_SCH_FLAG_UNSET_USE_DEFAULTS(S) \
 
        (SA_SCH_FLAG_UNSET((S),sec_attr_sch_entry_use_defaults))
</ProgramListing></Para>
</InformalExample>
<Para><?sml-point-size 12>
<!--no-op:  14-->
</Para>
</Sect2>
<Sect2 Id="DCEADG.SECERA.div.63">
<Title>Schema Trigger Entry Flag Check Macros</Title>
<Para>The following macros evaluate to TRUE if the requested flag(s) is 
set in the schema entry <Literal>trig_types</Literal> field.    
In the following macros, S is a pointer to <StructName Role="typedef">sec_attr_schema_entry_t</StructName> and 
F is a <StructName Role="typedef">sec_attr_trigs_types_flags_t</StructName> type.  
<?sml-break><?sml-point-size 10>
<!--no-op:  12-->
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 15>#define SA_SCH_TRIG_FLAG_IS_SET(S,F) \

	(((S)->trig_types &amp; (F)) == (F))

#define SA_SCH_TRIG_FLAG_IS_NONE(S) \
 
	(SA_SCH_TRIG_FLAG_IS_SET((S),sec_attr_trig_type_none))

#define SA_SCH_TRIG_FLAG_IS_QUERY(S) \
 
	(SA_SCH_TRIG_FLAG_IS_SET((S),sec_attr_trig_type_query))

#define SA_SCH_TRIG_FLAG_IS_UPDATE(S) \
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_trig_type_update))
</ProgramListing></Para>
</InformalExample>
<?sml-break>
<?sml-point-size 12>
<!--no-op:  14-->
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.SECERA.div.64">
<Title>Utilities to Use with Extended Attribute Calls</Title>
<Para>The extended attribute APIs includes utilities to help programmers using 
the extended attribute interfaces.  These utilities are
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>sec_attr_util_alloc_copy</Literal>&mdash;Copies data from one <StructName Role="typedef">sec_attr_t</StructName> 
data type to another.
</Para>
</ListItem>
<ListItem>
<Para><Literal>sec_attr_util_free</Literal>&mdash;Frees memory allocated to <StructName Role="typedef">sec_attr_t</StructName> 
by the <Function>sec_attr_util_alloc_copy()</Function> function.
</Para>
</ListItem>
<ListItem>
<Para><Literal>sec_attr_util_inst_free_ptrs</Literal>&mdash;Frees nonnull pointers in a 
<StructName Role="typedef">sec_attr_t</StructName><Literal> type.
</Literal></Para>
</ListItem>
<ListItem>
<Para><Literal>sec_attr_util_inst_free</Literal>&mdash;Frees nonnull pointers in a 
<StructName Role="typedef">sec_attr_t</StructName> type and the pointer to the <StructName Role="typedef">sec_attr_t</StructName> 
itself.
</Para>
</ListItem>
<ListItem>
<Para><Literal>sec_attr_util_sch_ent_free_ptrs</Literal>&mdash;Frees nonnull pointers in a 
<StructName Role="typedef">sec_attr_schema_entry_t</StructName><Literal> type.
</Literal></Para>
</ListItem>
<ListItem>
<?sml-need 4>
<Para><Literal>sec_attr_util_sch_ent_free</Literal>&mdash;Frees nonnull pointers in a 
<StructName Role="typedef">sec_attr_schema_entry_t</StructName> type and the 
pointer to the <StructName Role="typedef">sec_attr_schema_entry_t</StructName> 
itself.  The utility also works with the equivalent <Literal>dce_attr_sch</Literal> 
data type.
</Para>
</ListItem>
</ItemizedList>
</Sect1>
</Chapter>
<!--+ 11/27/96 19:53:47
    | tagMorph:  $Id: 4.5_era.sgm,v 1.1.2.8 1996/12/14 20:23:57 wardr Exp $
    | tagMorph library:  $Id: 4.5_era.sgm,v 1.1.2.8 1996/12/14 20:23:57 wardr Exp $
    | sml-to-docbook:  1.25
    +-->
