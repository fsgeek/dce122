<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: 4_exceptions.sgm,v $
# Revision 1.1.2.8  1996/12/14  20:23:59  wardr
# 	{edit,R1.2.2}
# 	penultimate format fixes
# 	[1996/12/14  20:21:47  wardr]
#
# Revision 1.1.2.7  1996/12/13  22:10:32  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/13  22:08:22  wardr]
# 
# Revision 1.1.2.6  1996/12/12  21:30:12  wardr
# 	{edit,R1.2.2}
# 	Fixed formatting problems
# 	[1996/12/12  21:28:20  wardr]
# 
# Revision 1.1.2.5  1996/12/12  16:49:12  carrig
# 	{enh,R1.2.2}
# 	Minor edits
# 	[1996/12/12  16:46:57  carrig]
# 
# Revision 1.1.2.4  1996/12/06  21:09:50  carrig
# 	{enh,R1.2.2}
# 	Second pass for editor
# 	[1996/12/06  21:07:41  carrig]
# 
# Revision 1.1.2.3  1996/12/05  21:38:41  carrig
# 	{enh,R1.2.2}
# 	First pass to prepare for editing
# 	[1996/12/05  21:36:44  carrig]
# 
# Revision 1.1.2.2  1996/12/02  15:40:47  weir
# 	Removed thinsp entities, corrected other minor errors
# 	[1996/12/02  15:39:02  weir]
# 
# Revision 1.1.2.1  1996/12/01  20:43:15  weir
# 	Initial submission
# 	[1996/12/01  20:41:24  weir]
# 
# 	Initial submission
# 	[1996/11/29  20:35:34  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<!---->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the-->
<!-- src directory for the full copyright text.-->
<!---->
<!---->
<!-- OLD HISTORY-->
<!-- Revision 1.1.8.6  1995/06/07  14:43:18  rcb-->
<!-- 	PRENTICE HALL reformat; final edits and changes-->
<!-- 	[1995/06/05  19:57:55  rcb]-->
<!---->
<!-- 	no change-->
<!-- 	[1995/04/13  17:57:35  rcb]-->
<!---->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/04/13  17:56:45  rcb]-->
<!---->
<!-- 	incorporated 1.1 edits-->
<!-- 	[1995/04/13  17:31:06  rcb]-->
<!---->
<!-- Revision 1.1.8.5  1994/11/03  23:35:54  neilson-->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- 	[1994/11/03  01:39:17  neilson]-->
<!-- -->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- -->
<!-- Revision 1.1.8.4  1994/10/20  22:14:41  jshirley-->
<!-- 	Fixed table reference.-->
<!-- 	[1994/10/20  22:14:30  jshirley]-->
<!-- -->
<!-- Revision 1.1.8.3  1994/09/30  18:51:45  weir-->
<!-- 	Fixing internal cross-references-->
<!-- 	[1994/09/30  18:51:12  weir]-->
<!-- -->
<!-- Revision 1.1.8.2  1993/06/01  18:18:33  buckler-->
<!-- 	{defect, 7625, R1.0.3}-->
<!-- 	Rewrote paragraph describing unhandled exceptions to state that-->
<!-- 	the entire application process, not just the faulting thread,-->
<!-- 	is terminated.-->
<!-- 	[1993/05/27  21:25:06  buckler]-->
<!-- -->
<!-- Revision 1.1.6.6  1993/01/28  18:46:55  cjd-->
<!-- 	Embedded copyright notice-->
<!-- 	[1993/01/28  18:08:01  cjd]-->
<!-- -->
<!-- Revision 1.1.6.5  1993/01/14  19:49:57  buckler-->
<!-- 	Remerged old revisions with K. Johnson's latest fixes for bug #2723.-->
<!-- 	Somehow, all preceding revisions of the file were destroyed when-->
<!-- 	the #2723 fixes were submitted.-->
<!-- 	[1993/01/14  19:49:01  buckler]-->
<!-- -->
<!-- Revision 1.1.6.4  1993/01/08  19:40:14  johnson-->
<!-- 	CR#:     2723-->
<!-- 	File:    /src/app_gd/threads/4_exceptions.gpsml-->
<!-- 	Change:  Added exceptions that are in code but were not in doc-->
<!-- 	[1993/01/08  19:39:23  johnson]-->
<!-- -->
<!-- Revision 1.1.6.3  1993/01/06  17:12:02  mcdonald-->
<!-- 	Changes made:           Add index entries pointing to text added to-->
<!-- 	                        file src/app_gd/rpc/3_build_app.gpsml for-->
<!-- 	                        Change Request #3474; this text responds to-->
<!-- 	                        Change Request #2138.-->
<!-- 	File name:              src/app_gd/threads/4_exceptions.gpsml-->
<!-- 	Change Request Number:  2138-->
<!-- 	[1993/01/06  17:10:26  mcdonald]-->
<!-- -->
<!-- Revision 1.1.6.2  1992/11/20  21:00:48  weir-->
<!-- 	Moved into 1.0.2doc tree-->
<!-- 	[1992/11/20  20:58:01  weir]-->
<!-- -->
<!-- Revision 1.1.4.5  1992/11/11  23:54:41  buckler-->
<!-- 	Corrected index entries-->
<!-- 	[1992/11/11  23:00:04  buckler]-->
<!-- -->
<!-- Revision 1.1.4.4  1992/10/12  22:19:53  casey-->
<!-- 	Index corrections for PH-->
<!-- 	[1992/10/12  22:16:42  casey]-->
<!-- -->
<!-- Revision 1.1.4.3  1992/10/08  17:45:46  lmk-->
<!-- 	Prentice-Hall edits only-->
<!-- 	[1992/10/08  17:44:11  lmk]-->
<!-- -->
<!-- Revision 1.1.4.2  1992/09/10  20:43:19  buckler-->
<!-- 	Second editorial review-->
<!-- 	[1992/09/10  20:39:30  buckler]-->
<!-- -->
<!-- Revision 1.1.2.3  1992/06/17  20:17:15  buckler-->
<!-- 	Incorporated editorial review-->
<!-- 	[1992/06/17  20:16:23  buckler]-->
<!-- -->
<!-- Revision 1.1.2.2  1992/05/08  21:57:14  johnson-->
<!-- 	File: src/app_gd/threads/4_exceptions.gpsml-->
<!-- -->
<!-- 	Defect:  3192-->
<!-- 	Short description:  Changed value to -1.-->
<!-- -->
<!-- 	Defect:  2721-->
<!-- 	Short description:  Added two exceptions to table.-->
<!-- 	[1992/05/08  21:56:16  johnson]-->
<!-- -->
<!-- Revision 1.1  1992/01/29  16:07:10  damon-->
<!-- 	Initial revision-->
<!-- -->
<!---->
<!-- Copyright 1991, Open Software Foundation, Inc.  ALL RIGHTS RESERVED.-->
<!-- ********************************************************************-->
<!--                                                                    *-->
<!-- COPYRIGHT (c) 1991 BY DIGITAL EQUIPMENT CORPORATION,               *-->
<!-- Maynard, Massachusetts                                             *-->
<!-- All Rights Reserved.                                               *-->
<!--                                                                    *-->
<!-- This document is furnished under a license and may be used and     *-->
<!-- copied only in accordance with the terms of such license and with  *-->
<!-- the inclusion of the above copyright notice.  No title to or        *-->
<!-- ownership of the document is hereby transferred.                   *-->
<!--                                                                    *-->
<!-- The information in this document is subject to change without      *-->
<!-- notice and should not be construed as a commitment by Digital      *-->
<!-- Equipment Corporation.                                             *-->
<!--                                                                    *-->
<!-- ********************************************************************-->
<Chapter Id="DCEADG.THREXP.div.1">
<Title>Using the DCE Threads Exception-Returning Interface</Title>
<Para>DCE Threads provides the following two ways to obtain information about the
status of a threads routine:
<IndexTerm Id="DCEADG.THREXP.indx.1">
<Primary>exception-returning interface</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.2">
<Primary>thread</Primary>
<Secondary>exception-returning interface</Secondary>
</IndexTerm></Para>
<ItemizedList>
<ListItem>
<Para>The routine returns a status value to the thread.
</Para>
</ListItem>
<ListItem>
<Para>The routine raises an exception.
</Para>
</ListItem>
</ItemizedList>
<Para>Before you write a multithreaded program, you must choose only one of the
preceding two methods of receiving status.  These two methods cannot be used
together in the same code module.
</Para>
<Para>The POSIX P1003.4a (pthreads) draft standard specifies that errors be
reported to the thread by setting the external variable <Literal>errno</Literal> to 
an error code and returning a function value of &minus;1. The threads reference 
pages document this status-value-returning interface (see the
&DCEDr;). 
However, an alternative to status values
is provided by DCE Threads in the exception-returning interface.
</Para>
<Para>This chapter introduces and provides conventions for the modular use of the
exception-returning interface to DCE Threads.
</Para>
<Sect1 Id="DCEADG.THREXP.div.2">
<Title>Syntax for C</Title>
<IndexTerm Id="DCEADG.THREXP.indx.3">
<Primary>exception-returning interface</Primary>
<Secondary>syntax for C</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.4">
<Primary>interface</Primary>
<Secondary>exception-returning</Secondary>
<See>exception-returning interface</See>
</IndexTerm>
<Para>Access to exceptions from the C language is defined by the macros in the
<Filename>exc_handling.h</Filename> file.  The <Filename>exc_handling.h</Filename> header file is 
included automatically when you include <Filename>pthread_exc.h</Filename> (see 
Section 9.2).
</Para>
<Para>The following example shows the syntax for handling exceptions:
<IndexTerm Id="DCEADG.THREXP.indx.5">
<Primary><Literal>TRY</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.6">
<Primary><Literal>CATCH</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.7">
<Primary><Literal>CATCH_ALL</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.8">
<Primary><Literal>ENDTRY</Literal> statement</Primary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>TRY 
    try_block
[CATCH (exception_name) 
    handler_block]...
[CATCH_ALL 
    handler_block]
ENDTRY
</ProgramListing></Para>
</InformalExample>
<Para>A <Literal>try_block</Literal> or a <Literal>handler_block</Literal> is a sequence of
statements, the first of which may be declarations, as in a normal
block.  If an exception is raised in the <Literal>try_block</Literal>, the catch
clauses are evaluated in order to see if any one matches the current
exception.
</Para>
<Para>The <Literal>CATCH</Literal> or <Literal>CATCH_ALL</Literal> clauses absorb an exception;
that is, they catch an exception propagating out of the <Literal>try_block</Literal>,
and direct execution into the associated <Literal>handler_block</Literal>.
Propagation of the exception, by default, then ends.  Within the
lexical scope of a handler, it is possible to explicitly cause
propagation of the same exception to resume (this is called
<Symbol Role="Variable">reraising</Symbol> the exception), or it is possible to raise some new exception.
</Para>
<Para><IndexTerm Id="DCEADG.THREXP.indx.9">
<Primary><Literal>RERAISE</Literal> statement</Primary>
</IndexTerm>The <Literal>RERAISE</Literal> statement is allowed in any handler statements and causes the
current exception to be reraised.  Propagation of the caught exception
resumes.
</Para>
<Para><IndexTerm Id="DCEADG.THREXP.indx.10">
<Primary><Literal>RAISE</Literal> statement</Primary>
</IndexTerm>The <Literal>RAISE</Literal> (<Replaceable>exception_name</Replaceable>) statement is allowed anywhere
and causes a particular exception to start propagating.  For example:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 16>TRY
    sort(); /* Call a function that may raise an exception.
             * An exception is accomplished by longjumping
             * out of some nested routine back to the TRY
             * clause.  Any output parameters or return 
             * values of the called routine are therefore
             * indeterminate.
             */

CATCH (pthread_cancel_e) 
    printf("Alerted while sorting\n"); RERAISE;

CATCH_ALL 
    printf("Some other exception while sorting\n"); RERAISE;

ENDTRY
</ProgramListing></Para>
</InformalExample>
<Para>In the preceding example, if the <Literal>pthread_cancel_e</Literal> 
exception propagates out 
of the function call, the first <Literal>printf</Literal> is executed. 
If any other exception propagates out of sort, the second <Literal>printf</Literal> is 
executed.  In either situation, propagation of the exception 
resumes because of the <Literal>RERAISE</Literal> statement. (If the 
code is unable to fully recover from the error, or does not understand the 
error, it needs to do what it did in the previous example and 
further propagate the error to its callers.)
</Para>
<Para>The following shows the syntax for an epilogue:
</Para>
<InformalExample>
<Para><ProgramListing>TRY       try_block
[FINALLY  final_block]
ENDTRY
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>final_block</Literal> is executed whether the <Literal>try_block</Literal> executes
to completion without raising an exception, or if an exception is
raised in the <Literal>try_block</Literal>.  If an exception is raised in the
<Literal>try_block</Literal>, propagation of the exception is resumed after
executing the <Literal>final_block</Literal>.
</Para>
<Para>Note that a <Literal>CATCH_ALL</Literal> handler and <Literal>RERAISE</Literal> could be used to do 
this, but the epilogue code would then have to be duplicated in two 
places, as follows:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 7>TRY
     try_block
CATCH_ALL
     final_block
     RERAISE;
ENDTRY
{ final_block }
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DCEADG.THREXP.indx.11">
<Primary><Literal>FINALLY</Literal> statement</Primary>
</IndexTerm>A <Literal>FINALLY</Literal> statement has exactly this meaning, but avoids code duplication.
</Para>
<Note>
<Para>The behavior of <Literal>FINALLY</Literal> along with the
<Literal>CATCH</Literal> or <Literal>CATCH_ALL</Literal> 
clauses is undefined.  Do <Symbol Role="Variable">not</Symbol> combine them for the same <Literal>try_block</Literal>.
</Para>
</Note>
<Para>Another example of the <Literal>FINALLY</Literal> statement is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>pthread__mutex_lock (some_object.mutex);
some_object.num_waiters = some_object.num_waiters + 1;
TRY
    while (! some_object.data_available)
        pthread_cond_wait (some_object.condition);
    /* The code to act on the data_available goes here */
FINALLY
    some_object.num_waiters = some_object.num_waiters - 1;
    pthread_mutex_unlock (some_object.mutex);
ENDTRY
</ProgramListing></Para>
</InformalExample>
<Para>In the preceding example, the call to <Function>pthread_cond_wait()</Function> could
raise the <Literal>pthread_cancel_e</Literal> exception. 
The <Literal>final_block</Literal> ensures that the 
shared data associated with the lock is correct for the next thread that 
acquires the mutex.
</Para>
</Sect1>
<Sect1 Id="DCEADG.THREXP.div.3">
<Title>Invoking the Exception-Returning Interface</Title>
<Para><IndexTerm Id="DCEADG.THREXP.indx.12">
<Primary>exceptions</Primary>
<Secondary>invoking the exception-returning interface</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.13">
<Primary>exception-returning interface</Primary>
<Secondary>invoking</Secondary>
</IndexTerm>To use the exception-returning interface, replace the first statement
that follows with the second:
</Para>
<InformalExample>
<Para><ProgramListing>#include &lt;pthread.h>

#include &lt;pthread_exc.h>
</ProgramListing></Para>
</InformalExample>
</Sect1>
<Sect1 Id="DCEADG.THREXP.div.4">
<Title>Operations on Exceptions</Title>
<Para><IndexTerm Id="DCEADG.THREXP.indx.14">
<Primary>exceptions</Primary>
<Secondary>definition</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.15">
<Primary>exceptions</Primary>
<Secondary>operations on</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.16">
<Primary>operations</Primary>
<Secondary>on exceptions</Secondary>
</IndexTerm>An exception is an object that describes an error condition.  Operations on
exception objects allow errors to be reported and handled.  If an exception
is handled properly, the program can recover from errors.  For example, if an
exception is raised from a parity error while reading a tape, the recovery
action may be to retry 100 times before giving up.
</Para>
<Para>The DCE Threads exception-returning interface allows you to perform
the following operations on exceptions:
</Para>
<ItemizedList>
<ListItem>
<Para>Declare and initialize an exception object
</Para>
</ListItem>
<ListItem>
<Para>Raise an exception
</Para>
</ListItem>
<ListItem>
<Para>Define a region of code over which exceptions are caught
</Para>
</ListItem>
<ListItem>
<Para>Catch a particular exception or all exceptions
</Para>
</ListItem>
<ListItem>
<Para>Define epilogue actions for a block
</Para>
</ListItem>
<ListItem>
<Para>Import a system-defined error status into the program as an exception
</Para>
</ListItem>
</ItemizedList>
<Para>These operations are discussed in the following subsections.
</Para>
<Sect2 Id="DCEADG.THREXP.div.5">
<Title>Declaring and Initializing an Exception Object</Title>
<Para><IndexTerm Id="DCEADG.THREXP.indx.17">
<Primary>exceptions</Primary>
<Secondary>declaring and initializing</Secondary>
</IndexTerm>Declaring and initializing an exception object documents that a program 
reports or handles a particular error.  Having the error expressed as an
exception object provides future extensibility as well as portability.
Following is an example of declaring and initializing an exception object:
</Para>
<InformalExample>
<Para><ProgramListing>EXCEPTION parity_error;         /* Declare it */
EXCEPTION_INIT (parity_error);  /* Initialize it */
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.THREXP.div.6">
<Title>Raising an Exception</Title>
<IndexTerm Id="DCEADG.THREXP.indx.18">
<Primary>exceptions</Primary>
<Secondary>raising</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.19">
<Primary>raising exceptions</Primary>
</IndexTerm>
<Para>Raising an exception reports an error, not by returning a value, but by
propagating an exception.  Propagation involves searching all active scopes
for code written to handle the error or code written to perform
scope-completion actions in case of any error, and then causing that code to
execute.  If a scope does not define a handler or epilogue block, then
the scope is simply torn down as the exception propagates through the stack.
This is sometimes referred to as <Symbol Role="Variable">unwinding the stack</Symbol>.  DCE Threads 
exceptions are terminating; there is no option to make execution resume at
the point of the error. (Execution resumes at the point where the exception
was caught.)
</Para>
<Para>If an exception is unhandled, the entire application process is
terminated.  Aborting the process, rather than just the faulting
thread, provides clean termination at the point of error. 
This prevents the disappearance of the faulting thread 
from causing problems at some later point.
</Para>
<Para>An example of raising an exception is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>RAISE (parity_error);
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.THREXP.div.7">
<Title>Defining a Region of Code over Which Exceptions Are Caught</Title>
<IndexTerm Id="DCEADG.THREXP.indx.20">
<Primary>exceptions</Primary>
<Secondary>defining a region of code to catch</Secondary>
</IndexTerm>
<Para>Defining a region of code over which exceptions are
caught allows you to call functions that can raise an exception and specify
the recovery action.
</Para>
<Para>Following is an example of defining an exception-handling region (without
indicating any recovery actions):
</Para>
<InformalExample>
<Para><ProgramListing>TRY {
   read_tape ();
    }
ENDTRY;
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.THREXP.div.8">
<Title>Catching a Particular Exception or All Exceptions</Title>
<Para><IndexTerm Id="DCEADG.THREXP.indx.21">
<Primary>exceptions</Primary>
<Secondary>catching</Secondary>
</IndexTerm>It is possible to discriminate among errors and perform different actions
for each error.
</Para>
<Para>Following is an example of catching a particular exception and specifying
the recovery action (in this case, a message).  The exception is reraised 
(passed to its callers) after catching the exception and executing the 
recovery action:
</Para>
<InformalExample>
<Para><ProgramListing>TRY {
   read_tape ();
    }
CATCH (parity_error) {
   printf ("Oops, parity error, program terminating\n");
   printf ("Try cleaning the heads!\n");
   RERAISE;
   }
ENDTRY
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.THREXP.div.9">
<Title>Defining Epilogue Actions for a Block</Title>
<Para><IndexTerm Id="DCEADG.THREXP.indx.22">
<Primary>epilogue actions</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.23">
<Primary>defining</Primary>
<Secondary>epilogue actions</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.24">
<Primary>exceptions</Primary>
<Secondary>defining epilogue actions</Secondary>
</IndexTerm>A <Literal>FINALLY</Literal> 
mechanism is provided so that multithreaded programs
can restore invariants as certain scopes are unwound; for example, restoring
shared data to a correct state and releasing locks.  This is often the ideal
way to define, in one place, the cleanup activities for normal or abnormal
exit from a block that has changed some invariant.
</Para>
<Para>Following is an example of specifying an invariant action whether or not
there is an error:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 15>lock_tape_drive (t);
TRY 
    TRY
       read_tape ();
    CATCH (parity_error)
       printf ("Oops, parity error, program terminating\n");
       printf ("Try cleaning the heads!\n");
       RERAISE;
    ENDTRY
    /* Control gets here only if no exception is raised */
    /* ... Now we can use the data off the tape */
FINALLY
    /* Control gets here normally, or if any exception is */
    raised unlock_tape_drive (t);
ENDTRY
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="DCEADG.THREXP.div.10">
<Title>Importing a System-Defined Error Status into the Program as an Exception</Title>
<IndexTerm Id="DCEADG.THREXP.indx.25">
<Primary>exceptions</Primary>
<Secondary>importing error status</Secondary>
</IndexTerm>
<Para>Most systems define error messages by integer-sized status values.  Each
status value corresponds to some error message text that should be expressed
in the user's own language.  The capability to import a status value as 
an exception permits the DCE Threads exception-returning interface to raise 
or handle system-defined errors as well as programmer-defined exceptions.
</Para>
<Para><?sml-need 3>An example of importing an error status into an exception is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>exc_set_status (&amp;parity_error, EPARITY);
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>parity_error</Literal> exception can then be raised and handled like 
any other exception.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="DCEADG.THREXP.div.11">
<Title>Rules and Conventions for Modular Use of Exceptions</Title>
<IndexTerm Id="DCEADG.THREXP.indx.26">
<Primary>exceptions</Primary>
<Secondary>rules for modular use of</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.27">
<Primary>modular use of exceptions</Primary>
</IndexTerm>
<Para>The following rules ensure that exceptions are used in a modular way so
that independent software components can be written without requiring
knowledge of each other:
</Para>
<ItemizedList>
<ListItem>
<Para>Use unique names for exceptions.
<IndexTerm Id="DCEADG.THREXP.indx.28">
<Primary>exceptions</Primary>
<Secondary>naming convention for</Secondary>
</IndexTerm></Para>
<Para>A naming convention makes sure that the names for exceptions that are
declared <Literal>EXTERN</Literal> from different modules do not clash.  The following
convention is recommended:
</Para>
<InformalExample>
<Para><ProgramListing>&lt;facility-prefix>_&lt;error_name>_e
</ProgramListing></Para>
</InformalExample>
<Para>For example, <Literal>pthread_cancel_e</Literal>.
</Para>
</ListItem>
<ListItem>
<Para>Avoid putting code in a <Literal>TRY</Literal> routine that belongs before it.
</Para>
<Para><IndexTerm Id="DCEADG.THREXP.indx.29">
<Primary><Literal>TRY</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.30">
<Primary><Literal>FINALLY</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.31">
<Primary><Literal>CATCH</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.32">
<Primary><Literal>CATCH_ALL</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.33">
<Primary><Literal>ENDTRY</Literal> statement</Primary>
</IndexTerm>The <Literal>TRY</Literal> only guards statements for which the statements in the 
<Literal>FINALLY</Literal>, <Literal>CATCH</Literal>, or <Literal>CATCH_ALL</Literal> clauses are always valid.
</Para>
<Para>A common misuse of <Literal>TRY</Literal> is to put code in the <Literal>try_block</Literal> that 
needs to be placed before <Literal>TRY</Literal>.  An example of this misuse is as follows:
</Para>
<InformalExample>
<Para><ProgramListing>TRY
    handle = open_file (file_name);
    /* Statements that may raise an exception here */
FINALLY
    close (handle);
ENDTRY  
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 13>The preceding <Literal>FINALLY</Literal> code assumes that no exception is raised by 
<Literal>open_file</Literal>.  This is because the code accesses an invalid identifier in 
the <Literal>FINALLY</Literal> part if <Literal>open_file</Literal> is modified to raise an exception. 
The preceding example needs to be rewritten as follows:
</Para>
<InformalExample>
<Para><ProgramListing>handle = open_file (file_name);
TRY
    {
    /* Statements that may raise an exception here */
    }
FINALLY
    close (handle);
ENDTRY  
</ProgramListing></Para>
</InformalExample>
<Para>The code that opens the file belongs prior to <Literal>TRY</Literal>, and
the code that closes the file belongs in the
<Literal>FINALLY</Literal> statement. (If <Literal>open_file</Literal> raises exceptions, it may 
need a separate <Literal>try_block</Literal>.)
</Para>
</ListItem>
<ListItem>
<Para>Raise exceptions to their proper scope.
</Para>
<Para>Write functions that propagate exceptions to their callers so that the
function does not modify any persistent process state before raising the
exception.  A call to the matching <Literal>close</Literal> 
call is required only if the <Literal>open_file</Literal>
operation is successful in the current scope.
</Para>
<Para>If <Literal>open_file</Literal> raises an exception, the identifier will not be written,
so <Literal>open_file</Literal> must not require that <Literal>close</Literal> 
be called when <Literal>open_file</Literal> raises an exception;
that is, <Literal>open_file</Literal> should not be part of the 
<Literal>TRY</Literal> clause because that 
means <Literal>close</Literal> is called if <Literal>open_file</Literal> fails, and you cannot close an 
unopened file.
</Para>
</ListItem>
<ListItem>
<Para>Do not place a <Literal>RETURN</Literal> or nonlocal <Literal>GOTO</Literal> 
between <Literal>TRY</Literal> and <Literal>ENDTRY</Literal>.
</Para>
<Para><IndexTerm Id="DCEADG.THREXP.indx.34">
<Primary><Literal>TRY</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.35">
<Primary><Literal>FINALLY</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.36">
<Primary><Literal>CATCH</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.37">
<Primary><Literal>CATCH_ALL</Literal> statement</Primary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.38">
<Primary><Literal>ENDTRY</Literal> statement</Primary>
</IndexTerm>It is invalid to use <Literal>RETURN</Literal> or <Literal>GOTO</Literal>, 
or to leave by any other means, a <Literal>TRY</Literal>, 
<Literal>CATCH</Literal>, <Literal>CATCH_ALL</Literal>, or <Literal>FINALLY</Literal> block.  Special code is 
generated by the <Literal>ENDTRY</Literal> macro, and it must be executed.
</Para>
</ListItem>
<ListItem>
<Para>Use the ANSI C volatile attribute.
</Para>
<Para>Variables that are read or written by exception-handling code must be
declared with the ANSI C volatile attribute.  Run your tests with the
optimize compiler option to ensure that the compiler thoroughly tests your
exception-handling code.
</Para>
</ListItem>
<ListItem>
<?sml-need 7>
<Para>Reraise exceptions that are not fully handled.
</Para>
<Para>You need to reraise any exception that you catch, unless 
your handler performs the complete recovery action for the
error.  This rule permits an unhandled exception to propagate to some
final default handler that prints an error message to terminate
the offending thread. (An unhandled exception is an exception for
which recovery is incomplete.)
</Para>
<Para>A corollary of this rule is that <Literal>CATCH_ALL</Literal> handlers must reraise 
the exception because they may catch any exception, and usually cannot do 
recovery actions that are proper for every exception.
</Para>
<Para>Following this convention is important so that you also do not absorb a
cancel or thread-exit request.  These are mapped into exceptions so that
exception handling has the full power to handle all exceptional conditions
from access violations to thread exit. (In some applications, it is important
to be able to catch these to work around an erroneously written library
package, for example, or to provide a fully fault-tolerant thread.)
</Para>
</ListItem>
<ListItem>
<Para>Declare only static exceptions.
</Para>
<Para>For compatibility with C++, you need to only declare static exceptions.
</Para>
</ListItem>
</ItemizedList>
</Sect1>
<Sect1 Id="DCEADG.THREXP.div.12">
<Title>DCE Threads Exceptions and Definitions</Title>
<Para><IndexTerm Id="DCEADG.THREXP.indx.39">
<Primary>thread</Primary>
<Secondary>exceptions and definitions, table of</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADG.THREXP.indx.40">
<Primary>exceptions</Primary>
<Secondary>and definitions, table of</Secondary>
</IndexTerm>Table 9-1 lists the DCE Threads exceptions and briefly
explains the meaning of each exception.  Exception names beginning with 
<Literal>pthread_</Literal> are raised as the result of something happening 
internal to the DCE Threads facility and are not meant to be raised 
by your code.  Exceptions beginning with <Literal>exc_</Literal> are generic and belong to 
the exception facility, the underlying system, or both.  The 
pthread-specific extensions are listed followed by the generic 
extensions, each in alphabetical order.
<IndexTerm Id="DCEADG.THREXP.indx.41">
<Primary>DCE</Primary>
<Secondary>Threads Exceptions</Secondary>
<Tertiary>table of</Tertiary>
</IndexTerm></Para>
<?sml-need 5i>
<Table Frame="all" Remap="center" Orient="Port">
<Title>DCE Threads Exceptions</Title>
<TGroup Rowsep="1" Colsep="1" Cols="2">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="207*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Align="Left" Colwidth="248*" Colname="col2" Colnum="2">
<THead>
<Row>
<Entry Rowsep="1"><Literal>Exception</Literal></Entry>
<Entry Rowsep="1"><Literal>Definition</Literal></Entry>
</Row>
</THead>
<TBody>
<Row>
<Entry><Literal>pthread_badparam_e</Literal></Entry>
<Entry>An improper parameter was used.</Entry>
</Row>
<Row>
<Entry><Literal>pthread_cancel_e</Literal></Entry>
<Entry>A thread cancellation is in progress.</Entry>
</Row>
<Row>
<Entry><Literal>pthread_defer_q_full_e</Literal></Entry>
<Entry>No space is currently available to process an interrupt request.
</Entry>
</Row>
<Row>
<Entry><Literal>pthread_existence_e</Literal></Entry>
<Entry>The object referenced does not exist.</Entry>
</Row>
<Row>
<Entry><Literal>pthread_in_use_e</Literal></Entry>
<Entry>The object referenced is already in use.</Entry>
</Row>
<Row>
<Entry><Literal>pthread_nostackmem_e</Literal></Entry>
<Entry>No space is currently available to create a new stack.
</Entry>
</Row>
<Row>
<Entry><Literal>pthread_notstack_e</Literal></Entry>
<Entry>The current stack was not created by DCE Threads.
</Entry>
</Row>
<Row>
<Entry><Literal>pthread_signal_q_full_e</Literal></Entry>
<Entry>Unable to process condition signal from interrupt level.
</Entry>
</Row>
<Row>
<Entry><Literal>pthread_stackovf_e</Literal></Entry>
<Entry>An attempted stack overflow was detected.</Entry>
</Row>
<Row>
<Entry><Literal>pthread_unimp_e</Literal></Entry>
<Entry>This is an unimplemented feature.</Entry>
</Row>
<Row>
<Entry><Literal>pthread_use_error_e</Literal></Entry>
<Entry>The requested operation is improperly invoked.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_decovf_e</Literal></Entry>
<Entry>An unhandled decimal overflow trap exception occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_exquota_e</Literal></Entry>
<Entry>The operation failed due to an insufficient quota.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_fltdiv_e</Literal></Entry>
<Entry>An unhandled floating-point division by zero trap exception occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_fltovf_e</Literal></Entry>
<Entry>An unhandled floating-point overflow trap exception occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_fltund_e</Literal></Entry>
<Entry>An unhandled floating-point underflow trap exception occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_illaddr_e</Literal></Entry>
<Entry>The data or object could not be referenced.</Entry>
</Row>
<Row>
<Entry><Literal>exc_insfmem_e</Literal></Entry>
<Entry>There is insufficient virtual memory for the requested operation.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_intdiv_e</Literal></Entry>
<Entry>An unhandled integer divide by zero trap exception occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_intovf_e</Literal></Entry>
<Entry>An unhandled integer overflow trap exception occurred.
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>exc_nopriv_e</Literal></Entry>
<Entry Rowsep="1">There is insufficient privilege for the requested operation.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_privinst_e</Literal></Entry>
<Entry>An unhandled privileged instruction fault exception occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_resaddr_e</Literal></Entry>
<Entry>An unhandled reserved addressing fault exception occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_resoper_e</Literal></Entry>
<Entry>An unhandled reserved operand fault exception occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_SIGBUS_e</Literal></Entry>
<Entry>An unhandled bus error signal occurred.</Entry>
</Row>
<Row>
<Entry><Literal>exc_SIGEMT_e</Literal></Entry>
<Entry>An unhandled EMT trap signal occurred.</Entry>
</Row>
<!-- DCE 1.2 WRITER: define EMT trap signal?-->
<Row>
<Entry><Literal>exc_SIGFPE_e</Literal></Entry>
<Entry>An unhandled floating-point exception signal occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_SIGILL_e</Literal></Entry>
<Entry>An unhandled illegal instruction signal occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_SIGIOT_e</Literal></Entry>
<Entry>An unhandled IOT trap signal occurred.</Entry>
</Row>
<!-- DCE 1.2 WRITER: define IOT trap signal?-->
<Row>
<Entry><Literal>exc_SIGPIPE_e</Literal></Entry>
<Entry>An unhandled broken pipe signal occurred.</Entry>
</Row>
<Row>
<Entry><Literal>exc_SIGSEGV_e</Literal></Entry>
<Entry>An unhandled segmentation violation signal occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_SIGSYS_e</Literal></Entry>
<Entry>An unhandled bad system call signal occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_SIGTRAP_e</Literal></Entry>
<Entry>An unhandled trace or breakpoint trap signal occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_SIGXCPU_e</Literal></Entry>
<Entry>An unhandled CPU time limit exceeded signal occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_SIGXFSZ_e</Literal></Entry>
<Entry>An unhandled file-size limit exceeded signal occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_subrng_e</Literal></Entry>
<Entry>An unhandled subscript out-of-range trap exception occurred.
</Entry>
</Row>
<Row>
<Entry><Literal>exc_uninitexc_e</Literal></Entry>
<Entry>An uninitialized exception was raised.</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<Para><?sml-point-size 11>
<!--no-op:  13-->
</Para>
<?sml-point-size 12>
<!--no-op:  14-->
<IndexTerm Id="DCEADG.THREXP.indx.42">
<Primary>exception-returning interface</Primary>
</IndexTerm>
</Sect1>
</Chapter>
<!--+ 11/27/96 19:53:47
    | tagMorph:  $Id: 4_exceptions.sgm,v 1.1.2.8 1996/12/14 20:23:59 wardr Exp $
    | tagMorph library:  $Id: 4_exceptions.sgm,v 1.1.2.8 1996/12/14 20:23:59 wardr Exp $
    | sml-to-docbook:  1.25
    +-->
