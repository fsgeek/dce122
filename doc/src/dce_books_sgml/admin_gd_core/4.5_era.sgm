<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: 4.5_era.sgm,v $
# Revision 1.1.2.11  1996/12/04  22:49:04  carrig
# 	{enh,R1.2.2}
# 	JC's edits
# 	[1996/12/04  22:46:50  carrig]
#
# Revision 1.1.2.10  1996/11/29  20:20:42  carrig
# 	{enh,R1.2.2}
# 	Finished edit changes; must scale graphics
# 	[1996/11/29  20:17:09  carrig]
# 
# Revision 1.1.2.9  1996/11/27  21:43:26  carrig
# 	{enh,R1.2.2}
# 	More editor's comments
# 	[1996/11/27  21:41:29  carrig]
# 
# 	{enh,R1.2.2}
# 	More editor's comments
# 	[1996/11/27  21:28:15  carrig]
# 
# Revision 1.1.2.8  1996/11/26  21:45:00  carrig
# 	{enh,R1.2.2}
# 	Putting in editor's comments
# 	[1996/11/26  21:40:40  carrig]
# 
# Revision 1.1.2.7  1996/11/25  21:51:09  carrig
# 	{enh,R1.2.2}
# 	Started to put in editor's comments
# 	[1996/11/25  21:49:08  carrig]
# 
# Revision 1.1.2.6  1996/11/07  20:43:19  weir
# 	Cleaned up history
# 	[1996/11/07  20:41:27  weir]
# 
# Revision 1.1.2.5  1996/11/07  16:15:39  weir
# 	Removed empty paragraph with revflag setting
# 	[1996/11/07  16:15:19  weir]
# 
# Revision 1.1.2.4  1996/11/06  20:40:28  carrig
# 	{enh,R1.2.2}
# 	OK for editing
# 	[1996/11/06  20:37:54  carrig]
# 
# Revision 1.1.2.3  1996/11/05  18:58:40  carrig
# 	{enh,R1.2.2}
# 	Second pass
# 	[1996/11/05  18:55:23  carrig]
# 
# Revision 1.1.2.2  1996/11/04  22:03:34  carrig
# 	{enh,R1.2.2}
# 	First pass at corrections
# 	[1996/11/04  22:00:04  carrig]
# 
# Revision 1.1.2.1  1996/11/01  18:20:14  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 	[1996/11/01  18:17:48  wardr]
# 
# Revision 1.1.1.2  1996/11/01  18:17:48  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 
# $EndLog$
-->
<!---->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- HISTORY-->
<!-- Revision 1.1.6.1  1996/09/19  17:08:45  sherman-->
<!-- 	{def,13330,R1.2.2}-->
<!-- 	Fixed xattrschema create example-->
<!-- 	{def,13339,R1.2.2}-->
<!-- 	Fixed xattrschema rename example-->
<!-- 	{def,13575,R1.2.2}-->
<!-- 	Fixed various dcecp problems-->
<!-- 	[1996/09/19  17:08:05  sherman]-->
<!---->
<!-- Revision 1.1.4.1  1996/03/12  19:52:26  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	Release Edits-->
<!-- 	[1996/03/12  19:52:05  wardr]-->
<!-- -->
<!-- Revision 1.1.2.8  1995/05/25  19:07:52  rcb-->
<!-- 	PRENTICE HALL reformat: final changes-->
<!-- 	[1995/05/25  13:24:40  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat - index entries, odds and ends-->
<!-- 	[1995/03/27  19:51:00  rcb]-->
<!-- -->
<!-- 	minor edit fix-->
<!-- 	[1995/03/16  17:30:21  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/03/09  19:59:43  rcb]-->
<!-- -->
<!-- 	incorporated 1.1 edits-->
<!-- 	[1995/03/09  19:15:54  rcb]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/10/21  17:26:26  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	Final GA release edits-->
<!-- 	[1994/10/21  17:26:11  wardr]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/10/20  20:40:33  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	Final GA release edits-->
<!-- 	[1994/10/20  20:40:00  wardr]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/10/20  16:08:25  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	Final GA release edits-->
<!-- 	[1994/10/20  16:08:05  wardr]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/10/18  21:12:34  millette-->
<!-- 	(enh,10056,R1.1)-->
<!-- 	HP dcecp edits-->
<!-- 	[1994/10/18  21:12:10  millette]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/10/18  19:18:26  millette-->
<!-- 	(enh,10056,R1.1)-->
<!-- 	HP dcecp edits-->
<!-- 	[1994/10/18  19:17:49  millette]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/10/06  20:40:25  rrizzo-->
<!-- 	expand copyright-->
<!-- 	[1994/10/06  20:07:32  rrizzo]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/09/16  21:13:35  millette-->
<!-- 	(enh,10056,R1.1)-->
<!-- 	Created for ERA-->
<!-- 	[1994/09/16  21:12:34  millette]-->
<!-- -->
<Chapter Id="AGCC.SECERA.div.1">
<Title>Creating and Using Extended Registry Attributes</Title>
<Para><IndexTerm Id="AGCC.SECERA.indx.1">
<Primary>ERA</Primary>
</IndexTerm>
<IndexTerm Id="AGCC.SECERA.indx.2">
<Primary>extended registry attribute</Primary>
<See>ERA</See>
</IndexTerm>
<IndexTerm Id="AGCC.SECERA.indx.3">
<Primary>schema</Primary>
</IndexTerm>
<IndexTerm Id="AGCC.SECERA.indx.4">
<Primary>attribute schema</Primary>
<Secondary>defined</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.SECERA.indx.5">
<Primary>registry</Primary>
<Secondary>extending</Secondary>
</IndexTerm></Para>
<Para>The registry stores specific information about principals, groups, 
organizations, and
accounts.  This is the information that you create when you use 
<Command>dcecp</Command> commands to create principals, groups, organizations, and
accounts.
The kind of information that can be stored in the registry database 
is defined in the registry 
schema, which is essentially a catalog of the kinds of data stored in the 
database.  There is a schema entry definition for each type of attribute that can be 
associated or attached to a 
registry object.   
For example, a schema entry 
defines principal names as a printable character string in 
DCE PCS
format.   When you create a principal, you enter 
a text string that is stored in PCS format.
</Para>
<Para>Using the extended registry attribute (ERA)
facility, you can add schema entries that define 
attribute types of your choosing.  These attributes are called 
<Symbol Role="Variable">extended attributes</Symbol> because they extend the registry schema. 
Once the extended attribute types are defined, you can 
attach them to a security object with the <Command>dcecp create</Command> or <Literal>modify</Literal> 
operations.  
The extended attribute types you create are used by custom 
applications that run in conjunction 
with DCE and are passed to those applications for processing.  
For example, if you work with an MVS application  
that requires a user's MVS name, you could establish an MVS name 
extended attribute that is stored in the registry.  The MVS name can then 
be passed to the MVS application for appropriate processing.
</Para>
<Para>If a principal has extended attributes, these attributes are carried with the 
extended privilege attribute certificate (EPAC) obtained when the
principal is authenticated.  
</Para>
<Para>In this manual, attribute type refers to the schema entry that defines 
an extended attribute type.  Attribute instance refers to an attribute that 
is attached to a registry object and has a value.    
</Para>
<Para>This chapter describes how to create and maintain attribute 
types and attribute 
instances.  
It begins first with a discussion of the <Command>xattrschema</Command> object; then 
it describes how to define attribute types and attach attributes to objects.
</Para>
<Sect1 Id="AGCC.SECERA.div.2">
<Title>The xattrschema Object</Title>
<Para>Extended attribute types are stored in the object named <Command>xattrschema</Command> 
under the security junction point 
(usually <Filename>/.:/sec</Filename>) in the CDS namespace.  Access to <Command>xattrschema</Command> and 
the attribute type definitions it contains is controlled by an  
ACL on the <Command>xattrschema</Command> object. 
<IndexTerm Id="AGCC.SECERA.indx.6">
<Primary><Command>xattrschema object</Command></Primary>
</IndexTerm>
<IndexTerm Id="AGCC.SECERA.indx.7">
<Primary>attribute types</Primary>
<Secondary>access control</Secondary>
</IndexTerm>The <Command>xattrschema</Command> object is propagated from the master security
server to replicas, like other registry data.  
</Para>
</Sect1>
<Sect1 Id="AGCC.SECERA.div.3">
<Title>Creating and Maintaining Attribute Types</Title>
<Para>Use the <Command>dcecp xattrschema</Command> command to create and 
maintain attribute types.  As part of the command, you must 
supply the attribute type's fully qualified name (for example, 
<Filename>/.:/sec/xattrschema/</Filename><Symbol Role="Variable">name</Symbol>) as an argument. 
<!---->
</Para>
<Sect2 Id="AGCC.SECERA.div.4">
<Title>Creating Attribute Types</Title>
<!---->
<Para>Use the <Command>dcecp xattrschema create</Command> command to create 
attribute types.    
Attribute options you can supply with this command are
summarized in Table 32-1.
Note that the options described 
in this table can also be supplied without the dashes in attribute lists.
</Para>
<?sml-need 5i>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Options to Create Extended Attributes</Title>
<TGroup Rowsep="0" Colsep="0" Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1.5*" Colname="col2" Colnum="2">
<THead>
<Row>
<Entry Rowsep="1"><Literal>Option</Literal></Entry>
<Entry Rowsep="1"><Literal>Meaning</Literal></Entry>
<Entry Rowsep="1"></Entry>
</Row>
</THead>
<TBody>
<Row>
<Entry Rowsep="1"><Option>aclmgr</Option> <Symbol Role="Variable">description</Symbol></Entry>
<Entry Rowsep="1">A required list of the ACL manager types that support the objects 
to which this attribute type can be attached and the permissions supported by those managers.  
No default.  Attribute type ACL managers are described fully in 
Section 32.2.5.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>-annotation </Literal><Symbol Role="Variable">string</Symbol></Entry>
<Entry Rowsep="1">A PCS text string that annotates the attribute type.  If the 
string contains spaces, enclose it in braces or quotes.
The default is blank.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Option>applydefs</Option></Entry>
<Entry Rowsep="1">This option is not currently implemented.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Option>encoding</Option> <Symbol Role="Variable">type</Symbol></Entry>
<Entry Rowsep="1">The format of the attribute type instance value.  Attribute 
encoding is described more fully in Section 32.2.6.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Option>intercell</Option></Entry>
<Entry Rowsep="1">This option is not currently implemented.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>-multivalued {yes | no}</Literal></Entry>
<Entry Rowsep="1">An indication of whether or not the attribute is multivalued
(<Literal>yes</Literal>=multivalued; <Literal>no</Literal>=not multivalued).  If an attribute is 
multivalued, multiple 
instances of the same attribute type can be attached to a single registry 
object.  For example, if attribute A is coded as 
multivalued, a single principal 
can have multiple instances of attribute A.  If it is not coded as 
multivalued, a single 
principal can have only one instance of attribute A.
The default is <Literal>no</Literal>.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>-reserved {yes | no}</Literal></Entry>
<Entry Rowsep="1">An indication of whether or not the attribute is reserved 
(<Literal>yes</Literal>=reserved; <Literal>no</Literal>=not reserved).  Reserved attribute types cannot be deleted 
unless the reserved restriction is removed.  
The default is <Literal>no</Literal>.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Option>scope</Option> <Symbol Role="Variable">name</Symbol></Entry>
<Entry Rowsep="1">Not implemented in the current release.
<!-- .nL-->
<!-- Controls the objects to which the attribute can be -->
<!-- attached.  If a scope is defined, the attribute can be attached only to -->
<!-- objects defined by the scope.  \*Vname\*O can be a directory name or an -->
<!-- object name.  For example, if \*L-scope\*O is the directory name -->
<!-- \*L/principal/krbgt\*O, instances of the -->
<!-- attribute can be attached only to objects in the \*L/principal/krbgt\*O -->
<!-- directory (a directory that by convention contains only cell principals).  -->
<!-- If \*L-scope\*O is the object named \*L/principal/krbgt/dresden.com\*O, -->
<!-- instances of the attribute can be -->
<!-- attached only to the \*Ldresden.com\*O principal.  The default is blank.-->
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<?sml-need 10>
<Row>
<Entry Rowsep="1"><Option>trigtype</Option> <Symbol Role="Variable">type</Symbol></Entry>
<Entry Rowsep="1">Identifies whether or not a trigger server is associated 
with the attribute type and,
if a trigger server is associated, the type of trigger.
Possible values are the following:
<?sml-space .3>
<?Pub _newline>
<Literal>none</Literal>&mdash;A trigger server is not associated with the attribute type.
<?sml-space .3>
<?Pub _newline>
<Literal>query</Literal>&mdash;A query trigger server is associated with the attribute type.  
<?sml-space .3>
<?Pub _newline>
<Literal>update</Literal>&mdash;An update trigger server is associated with the attribute type. 
<?sml-space .3>
<?Pub _newline>
If the <Option>trigtype</Option> option is set to <Literal>query</Literal> or <Literal>update</Literal>, you must 
supply the <Option>trigbind</Option> option to specify the trigger server's binding.
See Section 32.3 for more 
information.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Option>trigbind</Option> <Symbol Role="Variable">binding</Symbol></Entry>
<Entry Rowsep="1">If a trigger server is associated with the  attribute type, 
this option specifies the trigger serving binding.  
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>-unique {yes | no}</Literal></Entry>
<Entry Rowsep="1">An indication of whether or not each instance of the attribute type
must be unique within the cell (<Literal>yes</Literal>=unique; <Literal>no</Literal>=not unique).  
For example, assume that an instance of attribute 
type A is attached to 25 principals in the 
cell.  If attribute type A is coded as unique, the value of 
the A attribute for each 
of those 25 principals must be different.  If it is not coded as 
unique, all 25 principals can 
be assigned the same value for attribute A.  
The default is <Literal>no</Literal>.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry><Option>uuid</Option> <Symbol Role="Variable">uuid</Symbol></Entry>
<Entry>A UUID that identifies the attribute type internally.  Note that the name 
supplied as an argument to the <Command>dcecp xattrschema create</Command> command is 
used to access the attribute type.  If you do not supply a UUID, the 
system will generate one.
</Entry>
<Entry></Entry>
</Row>
</TBody>
</TGroup>
</Table>
<Para><?sml-need 3>The syntax of the <Command>dcecp xattrschema create</Command> command is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>xattrschema create</Literal> <Replaceable>attr_name</Replaceable><Literal> {</Literal><Replaceable>attr_options</Replaceable><Literal>}
</Literal></ProgramListing></Para>
</InformalExample>
<Para>where:
</Para>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">attr_name</Symbol></Term>
<ListItem>
<Para>Is the fully qualified name of the attribute type to create.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">attr_option</Symbol></Term>
<ListItem>
<Para>Is one or more of the options described in Table 32-1.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para RevisionFlag="Changed">The following sample command creates the extended attribute 
type named <Literal>employee_num</Literal> and assigns it an ACL manager 
of <Command>principal</Command> and an encoding type of <Literal>integer</Literal>:
<?og-ChangeStart def, 13330,R1.2.2,Fixed xattrschema create example"></Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed">dcecp> <Literal>xattrschema create /.:/sec/xattrschema/employee_num \</Literal> 
> <Literal>-aclmgr {principal r r r r} -encoding integer
</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<!-- -->
<?og-ChangeEnd def, 13330,R1.2.2,Fixed xattrschema create example">
<Para>Although this sample uses options to supply information, you can use 
standard <Command>dcecp</Command> attribute lists.
</Para>
<Para>Note that you can supply a list of names to create multiple 
schema entries with one operation.  However, you should be aware that,
if the command
argument contains more than one schema name, you cannot specify a UUID
attribute and the attributes you specify are applied to all entries created.
<!-- -->
</Para>
</Sect2>
<Sect2 Id="AGCC.SECERA.div.5">
<Title>Modifying Attribute Types</Title>
<!-- -->
<Para>Use the <Command>dcecp modify</Command> command with the <Option>change</Option> option 
to modify attribute types.  Only the 
<Literal>aclmgr</Literal>, <Literal>applydefs</Literal>, <Literal>intercell</Literal>, <Literal>trigbind</Literal>, 
<Literal>annotation</Literal>, and <Literal>reserved</Literal> schema type attributes can be modified.  
</Para>
<Para>The syntax of the <Command>xattrschema modify</Command> command is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>xattrschema modify</Literal> <Replaceable>attr_name</Replaceable> <Literal>change</Literal> <Replaceable>new_option</Replaceable>
</ProgramListing></Para>
</InformalExample>
<Para>where:
</Para>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">attr_name</Symbol></Term>
<ListItem>
<Para>Is the fully qualified name of the attribute type to change.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">new_option</Symbol></Term>
<ListItem>
<Para>Is the option that specifies the changes.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para><?sml-need 6>The following 
sample command modifies the <Literal>MVSname</Literal> attribute to change its annotation. 
Note that the fully qualified attribute type name must be supplied 
to the command.
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>xattrschema modify /.:/sec/xattrschema/MVSname -change \</Literal>
> <Literal>{annotation {Use with version 2.3}}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<!-- -->
</Sect2>
<Sect2 Id="AGCC.SECERA.div.6">
<Title>Renaming Attribute Types</Title>
<!-- -->
<Para>Use the <Command>dcecp xattrschema rename</Command> command 
to change the name of an extended attribute. 
Enter the command in the 
following form:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>xattrschema rename</Literal> <Replaceable>old_name</Replaceable> <Literal>to</Literal> <Replaceable>new_name</Replaceable>
</ProgramListing></Para>
</InformalExample>
<Para>where:
</Para>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">old_name</Symbol></Term>
<ListItem>
<Para RevisionFlag="Changed">Is the fully qualified extended attribute name to be changed.
<?og-ChangeStart def, 13339,R1.2.2,Fixed xattrschema rename example"></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable" RevisionFlag="Changed">new_name</Symbol></Term>
<ListItem>
<Para RevisionFlag="Changed">Is the new simple extended attribute name.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para RevisionFlag="Changed">The following example shows the <Command>xattrschema rename</Command> command 
used to change an attribute name from <Literal>log_name</Literal> to <Literal>MVSname</Literal>. 
</Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed">dcecp> <Literal>xattrschema rename  /.:/sec/xattrschema/log_name -to MVSname</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<!--  -->
<!--  -->
<!-- <Para RevisionFlag="Changed"> -->
<!-- <?og-ChangeEnd def, 13339,R1.2.2,Fixed xattrschema rename example"></Para> -->
<!--  -->
<!--  -->
</Sect2>
<Sect2 Id="AGCC.SECERA.div.7">
<Title>Deleting Attribute Types</Title>
<!-- -->
<Para>Use the <Command>dcecp xattrschema delete</Command> command 
to delete an extended attribute.  
Be aware that 
when you delete an attribute type you also delete all instances of that 
attribute type.  For example, assume that an instance of the 
<Literal>MVSname</Literal> attribute is 
attached to a principal named <Literal>delores</Literal>.  If you 
delete the <Literal>MVSname</Literal> attribute, you also delete the instance of 
that attribute attached to <Literal>delores</Literal>.
</Para>
<Para>To delete attribute types enter the command in the 
following form:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>xattrschema delete </Literal><Replaceable>attribute_name</Replaceable>
</ProgramListing></Para>
</InformalExample>
<Para>where <Symbol Role="Variable">attribute_name</Symbol> is the fully qualified 
name of the attribute to be deleted.
</Para>
<Para>For example, to delete the extended attribute named <Literal>MVSname</Literal>, 
the command would be as follows:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>xattrschema delete /.:/xattrschema/MVSname
</Literal>
dcecp> 
</ProgramListing></Para>
</InformalExample>
<!---->
</Sect2>
<Sect2 Id="AGCC.SECERA.div.8">
<Title>Defining the ACL Managers for Attributes</Title>
<!---->
<Para>When you define an extended attribute type, you must define 
the objects to which the attribute can be attached and the permissions 
to access the attribute.  To do this, you associate an attribute 
type with one or more ACL managers, 
and you supply the permission sets that control access to 
attribute instances of that type.  
The attribute can be attached 
only to the 
objects that are supported by the ACL manager types named 
in its ACL manager set.  
And, only the permissions named in the ACL manager set are valid for accessing the 
attribute instance.  (Note that these permissions are in addition to the 
permissions already established by the ACL manager for the object it controls.)
For example, suppose an ACL manager set for 
an attribute type named <Literal>MVSname</Literal> lists only the ACL manager type for principals.  
Then, instances 
of the attribute type named <Literal>MVSname</Literal> can be attached only to 
principals and not any other registry 
objects.   The ACL manager set for the <Literal>MVSname</Literal> 
attribute also contains the 
permissions that control access to the <Literal>MVSname</Literal> attribute.
</Para>
<Para>Use the <Literal>dcecp xattrschema -aclmgr</Literal> option to specify an attribute's 
ACL manager set.  This option has the following form:
</Para>
<InformalExample>
<Para><ProgramListing>{<Replaceable>mgr_uuid queryset updateset testset deleteset }</Replaceable>
</ProgramListing></Para>
</InformalExample>
<Para>where:
</Para>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">mgr_uuid</Symbol></Term>
<ListItem>
<Para>Is the UUID that identifies the ACL manager to be associated with the attribute type.  
You can supply either the UUID or one of the following shorthand names (which are
converted internally to a UUID) to access the ACL manager types provided by DCE:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>policy</Literal></Term>
<ListItem>
<Para>To access the ACL manager for the policy object.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Command>principal</Command></Term>
<ListItem>
<Para>To access the ACL manager for principals.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Command>group</Command></Term>
<ListItem>
<Para>To access the ACL manager for groups.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Command>organization</Command></Term>
<ListItem>
<Para>To access the ACL manager for organizations.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>secdirectory</Literal></Term>
<ListItem>
<Para>To access the ACL manager for directories in the registry 
database.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>replist</Literal></Term>
<ListItem>
<Para>To access the ACL manager for the replica list.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Command>xattrschema</Command></Term>
<ListItem>
<Para>To access the ACL manager for the registry schema.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>srvrconf</Literal></Term>
<ListItem>
<Para>To access the ACL manager for the <Filename>dced</Filename> object.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">queryset</Symbol></Term>
<ListItem>
<Para>Is the permission set to query instances of the attribute.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">updateset</Symbol></Term>
<ListItem>
<Para>Is the permission set to modify instances of the attribute.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">testset</Symbol></Term>
<ListItem>
<Para>Is the permission set to test instances of the attribute.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">deleteset</Symbol></Term>
<ListItem>
<Para>Is the permission to delete instances of the attribute.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>To enter a permission set with more than one permission,  
concatenate the permissions; for example, to enter the permissions 
<Literal>t</Literal>, <Literal>M</Literal>, and <Literal>d</Literal>, enter <Literal>tMd</Literal>.
</Para>
<Para>Enclose each ACL manger type's information in braces and leave a space 
between each item (except, of course, between items in the concatenated 
permission sets).  
</Para>
<Para>For example, consider the following command to define an addition ACL 
Manager for the <Literal>MVS_name</Literal> attribute: 
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>xattrschema modify /.:/sec/xattrschema/MVS_name \</Literal> 
> <Literal>-aclmgr {18dbdad2-23df-11cd-82d4-080009251352 r w t mD}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>The command adds an ACL manager identified by the UUID 
<Literal>18dbdad2-23df-11cd-82d4-08000925135</Literal> 
to the <Literal>MVS_name</Literal> attribute.  The permissions sets for the ACL manager are 
as follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>r</Literal> is the query permission set
</Para>
</ListItem>
<ListItem>
<Para><Literal>w</Literal> is the update permission set
</Para>
</ListItem>
<ListItem>
<Para><Literal>t</Literal> is the test permission set
</Para>
</ListItem>
<ListItem>
<Para><Literal>mD</Literal> is the delete permission set
</Para>
</ListItem>
</ItemizedList>
<Para>Note that you cannot modify or delete an attribute type's ACL manager set.  However, you 
can add additional manager types to it. 
<!---->
</Para>
</Sect2>
<Sect2 Id="AGCC.SECERA.div.9" RevisionFlag="Changed">
<Title>Defining Attribute Type Encoding</Title>
<!---->
<Para>You must define the format of values that can be supplied for an attribute type in the 
attribute type's encoding.  An attribute can be assigned only those values that 
are in the format defined in the encoding.  For example, the encoding 
can specify that instances of this attribute type contain 
values only in the form of UUIDs.  
</Para>
<Para>Each 
attribute type can have only one encoding and that encoding cannot be modified.
In addition, a special encoding type lets you create attribute sets.  
</Para>
<Para>Use the <Literal>dcecp xattrschema -encoding</Literal> option to specify an attribute's 
encoding.  This option has the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Option>encoding</Option> <Symbol Role="Variable">type</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Symbol Role="Variable">type</Symbol> parameter is one of the encoding types described in Table
32-2.
</Para>
<?sml-need 5i>
<?og-ChangeStart def, 13575,R1.2.2,Fixed encoding type any">
<Table Frame="all" Remap="center" Orient="Port">
<Title>Encoding Types</Title>
<TGroup Rowsep="0" Colsep="0" Cols="2">
<ColSpec Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Align="Left" Colwidth="1.5*" Colname="col2" Colnum="2">

<THead>
<Row>
<Entry Rowsep="1"><Literal>Encoding Type</Literal></Entry>
<Entry Rowsep="1"><Literal>Meaning</Literal></Entry>
<Entry Rowsep="1"></Entry>
</Row>
</THead>
<TBody>
<Row>
<Entry Rowsep="1"><Literal>any</Literal></Entry>
<Entry Rowsep="1">The attribute value can take on any encoding.  This encoding type is only 
legal for the definition of an ERA in a schema entry.  All instances 
of an ERA must have an encoding of some other value. 
<!--  The attribute instance value can be of any encoding type.  Type is defined -->
<!-- when attribute instance is created.-->
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>attrset</Literal></Entry>
<Entry Rowsep="1">The attribute value must be a list of attribute type 
UUIDs enclosed in braces.   This encoding type defines an attribute set.  
Attribute sets allow for easier attribute search and retrieval.  
For instance, a query on an attribute set returns all instances of 
attributes that are 
members of the set.  
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>binding</Literal></Entry>
<Entry Rowsep="1">The attribute value must consist of authentication, authorization, and
binding information suitable for communicating with a DCE server.  
Use this encoding if 
you want to store a name or server binding as an object's attribute.  
See Section 32.3.2.2 for more information. 
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>byte</Literal></Entry>
<Entry Rowsep="1">The attribute value must be a string of bytes. 
The byte string is assumed to be a 
pickle or is otherwise a self-describing type.  Note that this 
encoding type allows entry of binary data.  See the <Command>xattrschema(8dce)</Command> 
reference page for more information on entering binary data.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>confidential</Literal></Entry>
<Entry Rowsep="1">Not implemented in this release of DCE.
<!-- The attribute value is a string of encrypted -->
<!-- bytes.  Although this encrypted data is not stored in the registry database, -->
<!-- it can be passed over the network and is available to user-developed -->
<!-- applications.-->
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>i18ndata</Literal></Entry>
<Entry Rowsep="1">The attribute value must be an internationalized string of 
bytes with a tag identifying 
the OSF registered codeset used to encode the data.  Note that this 
encoding type allows entry of binary data.  See the <Command>xattrschema(8dce)</Command> 
reference page for more information on how to enter binary data.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>integer</Literal></Entry>
<Entry Rowsep="1">The attribute value must be a signed 32-bit integer.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>printstring</Literal></Entry>
<Entry Rowsep="1">The attribute instance value must be a character 
string printable by the PCS.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>stringarray</Literal></Entry>
<Entry Rowsep="1">The attribute value must be an array of one of more printstrings.  Note that 
the printstring can be a null.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>uuid</Literal></Entry>
<Entry Rowsep="1">The attribute value must be a DCE UUID.
</Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry><Literal>void</Literal></Entry>
<Entry>The attribute has no value.  It is simply a marker that is either present or absent.
</Entry>
<Entry></Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?og-ChangeEnd def, 13575,R1.2.2,Fixed encoding type any">
<!-- NOT FOR 1.1-->
<!-- .H 3 "Defining Defaults for Attribute Types"-->
<!-- -->
<!-- The \%\*L-applydefs\*O option lets you specify whether or not default -->
<!-- no be applied, only those attributes explicitly attached to an object will -->
<!-- attributes should be supplied for objects.  If you specify that defaults should -->
<!-- no be applied, only those attributes explicitly attached to an object will -->
<!-- be evaluated during attribute processing.  If you specify that defaults should -->
<!-- be applied, the attributes instances will be associated with objects by default.  -->
<!-- The default attribute applied depends on the type of object.  If the object is -->
<!-- a principal with an account, first the organization associated with the account is -->
<!-- examined to see if the requeseted attribute is attached.  If it is not, then the registry polic-->
<!-- .P-->
<!-- IF I PUT AN ATTR ON POLICY OBJECT, IT IS LIKE SETTING POLICY-->
<!-- .P-->
<!-- The apply_defaults flag indicates -->
<!-- whether or not default attributes -->
<!-- should be returned when objects are queried by -->
<!-- a client with the \*Lsec_rgy_attr_get_effective\*O call. -->
<!-- If apply-defaults flag is set on, defaults are -->
<!-- applied.  If it is set off, defaults are not -->
<!-- supplied. -->
<!-- .P-->
<!-- Defaults are determined in the -->
<!-- following manner:-->
<!-- .AL-->
<!-- .LI-->
<!-- If the requested attribute exists on the principal, that attribute is returned.  -->
<!-- If it does not, the search continues.  -->
<!-- .LI-->
<!-- The next step in the search depends on the type of object:-->
<!-- .P-->
<!-- \*LFor principals with accounts:\*O-->
<!-- .AL-->
<!-- .LI-->
<!-- The organization named in the principal's -->
<!-- account is examined to -->
<!-- see if an attribute of the requested type exists.  If it does, it -->
<!-- is returned and the search ends.  If it does not, the search continues -->
<!-- to the \*Lpolicy\*O object as described in b, below. -->
<!-- .LI-->
<!-- The registry \*Lpolicy\*O object is examined to -->
<!-- see if an attribute of the requested type exits.  -->
<!-- If it does, it is returned.  If it does not, a message indicating the -->
<!-- no attribute of the type exists for the object is returned.-->
<!-- .LE-->
<!-- .P-->
<!-- \*LFor principals without accounts, for groups, and for organizations:\*O -->
<!-- the registry \*Lpolicy\*O object is examined to -->
<!-- see if an attribute of the requested type exits.  -->
<!-- If it does, it is returned.  If it does not, a message indicating the -->
<!-- no attribute of the type exists for the object is returned.-->
<!---->
<!--.H 3 "Defining Intercell Actions for Attribute Types" NOT FOR 1.1-->
<!---->
<!-- -->
<!-- -->
<!-- -->
</Sect2>
</Sect1>
<Sect1 Id="AGCC.SECERA.div.10">
<Title>Defining Attribute Trigger Servers</Title>
<!---->
<Para>Some attribute types require the support of an outside server either 
to verify input attribute values or to supply output attribute values 
when those values are stored in an external database. 
Such a server could, for example, 
connect a legacy registry system to the DCE registry.  
The attribute trigger facility provides for automatic calls  
to outside DCE servers, known as <Symbol Role="Variable">attribute triggers</Symbol>.
</Para>
<Para>Trigger servers are invoked automatically when an attribute 
associated with a trigger server is queried or updated.  
Note that access to information maintained by a trigger server is controlled 
entirely by that server.  
</Para>
<Note>
<Para>Update trigger servers are not supported in this release.
</Para>
</Note>
<Para>To associate an attribute type with a trigger server, use the 
<Option>trigtype</Option> and <Literal>-trigbind dcecp xattrschema</Literal> options.  
</Para>
<Sect2 Id="AGCC.SECERA.div.11">
<Title>The -trigtype Option</Title>
<Para>The <Option>trigtype</Option> options defines whether the attribute type is 
associated with a trigger server and, if it is, which kind of server.  This 
option has the following form:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>-trigtype [none | query | update]</Literal>
</ProgramListing></Para>
</InformalExample>
<Para>where:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>none</Literal></Term>
<ListItem>
<Para>Indicates the attribute is not associated with a trigger server. (This is the 
default.)
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>query</Literal></Term>
<ListItem>
<Para>Indicates that the attribute is associated with a query trigger.  Query 
trigger servers can perform only queries.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>update</Literal></Term>
<ListItem>
<Para>Indicates the attribute is associated with an update trigger.  Update
trigger servers can perform queries and updates.
</Para>
<Note>
<Para>Update trigger servers are not supported in this release.
</Para>
</Note>
<Para>Once set the <Option>trigtype</Option> option cannot be modified.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Sect2>
<Sect2 Id="AGCC.SECERA.div.12">
<Title>The -trigbind Option</Title>
<Para>The <Option>trigbind</Option>&ensp;option defines authentication information 
for the trigger server and the trigger binding itself. 
</Para>
<Para>The <Option>trigbind</Option> option has the following format.
</Para>
<InformalExample>
<Para><ProgramListing><Literal>-trigbind {{</Literal><Replaceable>auth_info</Replaceable><Literal>} {</Literal><Replaceable>binding_info</Replaceable><Literal>}}
</Literal></ProgramListing></Para>
</InformalExample>
<Para>The following sections describe how to specify the authentication type and the 
binding.
</Para>
<Sect3 Id="AGCC.SECERA.div.13">
<Title>Specifying the Authentication Type</Title>
<Para>The <Symbol Role="Variable">auth_info</Symbol> parameter has the following syntax:
</Para>
<InformalExample>
<Para><ProgramListing>{<Replaceable>auth_serv_type</Replaceable> <Replaceable>name prot_level authentication_service authorization_service</Replaceable>}
</ProgramListing></Para>
</InformalExample>
<Para>where: 
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">auth_serv_type</Symbol></Term>
<ListItem>
<Para>Specifies the authentication type, which can be
</Para>
<ItemizedList>
<ListItem>
<?sml-need 3>
<Para><Literal>none</Literal>&mdash;No authentication is performed.  
</Para>
</ListItem>
<ListItem>
<Para><Literal>dce</Literal>&mdash;Standard DCE authentication is performed. 
</Para>
</ListItem>
</ItemizedList>
<Para>If you are using no authentication, no other information except the 
binding itself is required.  If you are using the standard DCE authentication type, you 
must specify all the remaining parameters.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">name</Symbol></Term>
<ListItem>
<Para>Specifies the principal name of the trigger server.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">prot_level</Symbol></Term>
<ListItem>
<Para>Specifies the protection level that
determines the degree to which authenticated communications
between the client and the server are protected
by the authentication service.  The possible protection levels 
are 
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>default</Literal>&mdash;Uses the default protection 
level of <Literal>pkt</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>none</Literal>&mdash;Performs no authentication:
tickets
are not exchanged, session keys are not established, client
EPACs or names are not certified,
and transmissions are in the clear.
Note that although uncertified EPACs should not be trusted,
they may be useful for
debugging, tracing, and measurement purposes.
</Para>
</ListItem>
<ListItem>
<Para><Literal>connect</Literal>&mdash;Authenticates 
only when the client establishes a
relationship with the server.
</Para>
</ListItem>
<ListItem>
<Para><Literal>call</Literal>&mdash;Authenticates 
only at the beginning of each remote procedure
call when the server receives the request.
</Para>
<Para>This level does not apply to remote procedure calls made over a
connection-based protocol sequence (that is,
<Literal>ncacn_ip_tcp</Literal>).  If this level is specified and the binding
handle uses a connection-based protocol sequence,
the routine uses
the <Literal>pkt</Literal> protection level instead.
</Para>
</ListItem>
<ListItem>
<Para><Literal>pkt</Literal>&mdash;Ensures that all data received 
is from the expected client.
</Para>
</ListItem>
<ListItem>
<Para><Literal>pktinteg</Literal>&mdash;Ensures and verifies that none 
of the data transferred between
client and server has been modified.
This is the highest protection level that is guaranteed to be
present in the RPC runtime.
</Para>
</ListItem>
<ListItem>
<Para><Literal>pktprivacy</Literal>&mdash;Authenticates as specified 
by all of the previous levels and
also encrypts each RPC argument value.
This is the highest protection level, but it is not guaranteed to be
present in the RPC runtime.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">authentication_service</Symbol></Term>
<ListItem>
<Para>Specifies the authentication service.  
The exact level of protection provided by the
authentication service is specified by the protection 
level.
The supported
authentication services are as follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>default</Literal>&mdash;DCE shared-secret key.
</Para>
</ListItem>
<ListItem>
<Para><Literal>none</Literal>&mdash;No authentication:  no tickets
are exchanged, no session keys established, client EPACs or names
are not transmitted, and transmissions are in the clear.
Specify <Literal>none</Literal> to turn authentication off for
remote procedure calls made using this binding.
</Para>
</ListItem>
<ListItem>
<Para><Literal>secret</Literal>&mdash;DCE shared-secret key authentication.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">authorization_service</Symbol></Term>
<ListItem>
<Para>Specifies the authorization service.  The validity and trustworthiness of
authorization data, like any application data, is dependent on the
authentication service and protection level specified.  The
supported authorization services are as follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>none</Literal>&mdash;Server performs no authorization.  
This is valid only if the authorization service 
is set to <Literal>none</Literal>, specifying that
no authentication is being performed.
</Para>
</ListItem>
<ListItem>
<Para><Literal>name</Literal>&mdash;Server performs authorization based 
on the client principal name.
This value cannot be used if the authorization service is
<Literal>none</Literal>.
</Para>
</ListItem>
<ListItem>
<?sml-need 5>
<Para><Literal>dce</Literal>&mdash;Server performs authorization by using the client's DCE 
EPAC sent to the server with each
remote procedure call made with this binding.  Generally,
access is checked against DCE ACLs.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
</VarListEntry>
</VariableList>
<!---->
</Sect3>
<Sect3 Id="AGCC.SECERA.div.14">
<Title>Specifying the Binding Information</Title>
<!---->
<Para>The <Symbol Role="Variable">binding_info</Symbol> parameter specifies the binding, which can be a 
string binding, a server entry name, or a list containing one 
or more string bindings or server entry names.  The following example shows a server 
entry name binding:
</Para>
<Para><Literal>./.:/hosts/host_name/dce_entity_name</Literal>
</Para>
<Para>The following example shows a string binding in standard syntax:
</Para>
<Para><Literal>ncadg_udp_ip:130.105.96.3[1234]</Literal>
</Para>
<Para>The following example shows a string binding in TCL syntax:
</Para>
<Para><Literal>ncarn_ip_tcp 10-29.58.00 2001</Literal>
</Para>
</Sect3>
<Sect3 Id="AGCC.SECERA.div.15">
<Title>Sample Value for the <Option>trigbind</Option> Option</Title>
<Para>The following sample shows the value for a <Option>trigbind</Option> option.  
In the sample, the binding has the principal name <Literal>MVS_server</Literal>, 
is authenticated with  packet-privacy protection level, uses a
shared secret key and an authorization service of DCE.  The 
binding is supplied as a server entry 
name.
<!-- MIDDLE SENTENCE ABOVE SHOULD BE CHECKED FOR ACCURACY-->
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>-trigbind {{dce MVS_server pktprivacy secret dce} \
    {/.:/hosts/host_name/dce_entity_name}}
</UserInput></ProgramListing></Para>
</InformalExample>
<!-- -->
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="AGCC.SECERA.div.16">
<Title>Creating and Maintaining Attribute Instances</Title>
<!---->
<Para>Using <Command>dcecp</Command>, you can attach extended registry attributes 
to objects, modify the values assigned to those attributes, and delete the attachement just as you 
would any attribute attached to an object.
</Para>
<Para>You can attach extended registry attributes to any of 
the following registry objects using the 
<Command>dcecp create</Command> and <Literal>modify</Literal> operations:
</Para>
<ItemizedList>
<ListItem>
<Para><Command>principal</Command>
</Para>
</ListItem>
<ListItem>
<Para><Command>group</Command>
</Para>
</ListItem>
<ListItem>
<Para><Command>organization</Command>
</Para>
</ListItem>
<ListItem>
<Para><Literal>policy</Literal> 
</Para>
<Note>
<Para>In DCE Version 1.2.1, you cannot attach attributes to the 
policy object.
</Para>
</Note>
</ListItem>
<ListItem>
<Para><Command>directory</Command>
</Para>
</ListItem>
<ListItem>
<Para><Literal>replist</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Command>xattrschema</Command>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  . -->
<Sect2 Id="AGCC.SECERA.div.17">
<Title>Attaching Attribute Instances to Objects</Title>
<!---->
<Para>You can attach  attributes to object when you create the objects with the 
<Literal>dcecp principal -attribute</Literal> operation, or you can attach attributes to 
existing objects with the <Literal>dcecp modify -add</Literal> operation.  
</Para>
<Para>For example, to create the principal <Literal>delores</Literal> and at the 
same time attach the <Literal>MVSname</Literal> attribute with a value of <Literal>admin</Literal>,  
use the following <Command>principal create</Command> command:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal create delores -attribute {MVSname admin}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>To attach the <Literal>MVSname</Literal> attribute with a value of <Literal>admin</Literal> 
to the principal named <Literal>delores</Literal>, use the following <Command>principal modify</Command> command:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal modify delores -add {MVSname admin}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>To add instances of a multivalued extended attribute, include each 
value, separated by a space after the attribute name.  For example, to 
attach the <Literal>multi_name</Literal> attribute with values of <Literal>value1</Literal>, 
<Literal>value2</Literal>, <Literal>value3</Literal>, and <Literal>value4</Literal> 
to the principal named <Literal>delores</Literal>, use the following command: 
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal modify delores -add {multi_name value1 value2 value3 value4}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<!--no-op:  . -->
</Sect2>
<Sect2 Id="AGCC.SECERA.div.18">
<Title>Modifying Attribute Instances</Title>
<!---->
<Para>Use the <Literal>dcecp modify -change</Literal> operation to change the values of 
attribute instances.  Whether an attribute is modifiable is determined 
by the application that uses the attribute.  For example, the following 
command changes the value assigned to the <Literal>MVSname</Literal> 
from <Literal>admin</Literal> to <Literal>cell_admin</Literal>  for the principal named <Literal>delores</Literal>.
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal modify delores -change {MVSname cell_admin}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>If you use the <Literal>dcecp modify -change</Literal> command as shown in the previous paragraphs 
to change the value of a multivalued attribute, all instances of the 
multivalued 
attribute are deleted and replaced by the new values specified in the command.  
For example, to change only a specific value, you must enter all the values.  
For example, assume that the <Literal>multi_name</Literal> attribute has the following 
four values: <Literal>value1</Literal>, <Literal>value2</Literal>, <Literal>value3</Literal>, and <Literal>value4</Literal>.  
To change <Literal>value4</Literal> to <Literal>value5</Literal> you must enter the following command:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal modify delores -change {multi_name {value1 value2 value3 value5}}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>However, you can add and remove individual values from a multivalued attribute.    
Use the <Option>add</Option> option to add values.  
For example, assume that  the <Literal>multi_name</Literal> attribute has values 
of <Literal>value1</Literal>, <Literal>value2</Literal>, v<Literal>alue3</Literal>, and <Literal>value5</Literal>.  
The following sample command adds <Literal>value6</Literal> to the <Literal>multi_name</Literal> attribute.
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal modify delores -add {multi_name value6}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>(Use the <Command>remove</Command> option described in the following subsection to delete 
specific values in a multivalued attribute.)
</Para>
<Para><?sml-need 3>Note that 
the following command 
replaces all instances of the attribute named <Literal>multi_name</Literal>  attached to the 
principal named <Literal>delores</Literal> with a single instance with a 
value of <Literal>value1</Literal>:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal modify delores -change {multi_name value1}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>For example, if the <Literal>multi_name</Literal> attribute had the following values:
</Para>
<InformalExample>
<Para><ProgramListing>{multi_name value1 value2 value3}
</ProgramListing></Para>
</InformalExample>
<Para>then the previous command would change the values as follows:
</Para>
<InformalExample>
<Para><ProgramListing>{multi_name value1}
</ProgramListing></Para>
</InformalExample>
<!--no-op:  . -->
</Sect2>
<Sect2 Id="AGCC.SECERA.div.19">
<Title>Deleting Attribute Instances</Title>
<!---->
<Para>Use the <Command>dcecp modify</Command> command with the <Option>remove</Option> 
option to delete attribute instances attached 
to an object.  To delete all instances of an attribute from an object, 
supply the attribute name to the <Option>remove</Option> option.  
For example, the following command deletes all instances of the <Literal>MVSname</Literal> 
attribute from the 
principal named <Literal>delores</Literal>:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal modify delores -remove MVSname</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>To remove a single instance of a multivalued attribute, 
supply the attribute name 
and the attribute value.  For example, the following command deletes 
only the instance <Literal>value5</Literal> from the multivalued attribute named 
<Literal>multi-value</Literal>. 
All other values and the attribute itself remain intact.
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal modify delores -remove {multi-value value5}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>However, if you delete the last instance of a  multivalued attribute, 
<Command>dcecp</Command> will 
also delete the attribute from the object because an attribute without a value 
cannot be attached to an object.  Note that
you cannot combine deleting multivalued attributes and 
values from multivalued attributes with the same command. 
</Para>
<Para><?sml-need 5>To delete more than one attribute from an object, you must use the 
<Option>types</Option> option.  This option tells <Command>dcecp</Command> that all the 
values supplied are the names of attribute types, not attribute values.
For example, the following sample command uses the <Option>types</Option> option 
to delete the attributes named <Literal>MVSname</Literal> and <Literal>MVSinteger</Literal> from 
the principal <Literal>delores</Literal>:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>principal modify delores -remove {MVSname MVSinteger} -types</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>Without the <Option>types</Option> option,
<Command>dcecp</Command> will assume that <Literal>MVSinteger</Literal> is the 
value for the <Literal>MVSname</Literal> attribute and, because no such value 
exists, the command will 
fail.  
<!-- -->
<!-- .H 4 "Deleting Multi-Valued Attribute Instances"-->
<!---->
<!-- For multivalued attributes, you can delete all the values and the attribute itself by -->
<!-- supplying the attribute name.  For example, the following command deletes -->
<!-- all values of the multivalued attribute named \*Lmulti-value\*O and -->
<!-- the attribute itself.-->
<!-- .oS-->
<!-- \*Cdcecp> \*Lprincipal modify delores -remove multi-value\*O-->
<!-- .oE -->
<!-- To remove more than one multivalued attribute you must use the \%\*L-types\*O option -->
<!-- as shown in the previous section.  Note you cannot combine deleting a mutli-valued attributes -->
<!-- and -->
<!-- .P-->
<!-- To remove a single value of a multivalued attribute, supply the attribute name -->
<!-- and the attribute value.  For example, the following command deletes -->
<!-- only the value \*Lvalue5\*O from the multivalued attribute named \*Lmulti-value\*O. -->
<!-- All other values and the attribute itself remain intact.-->
<!-- .oS-->
<!-- \*Cdcecp> \*Lprincipal modify delores -remove {multi-value value5}\*O-->
<!-- .oE-->
<!-- However, if you delete the last value in a multivalued attribute, \*Ldcecp\*O will -->
<!-- also delete the attribute from the object because an attribute without a value -->
<!-- cannot be attached to an object.  -->
<!-- Note you cannot combine deleting a mutli-valued attributes and values from multivalued -->
<!-- attributes with the same command.  -->
<!---->
</Para>
</Sect2>
<Sect2 Id="AGCC.SECERA.div.20">
<Title>Using Attribute Sets</Title>
<!---->
<Para>An attribute set is a collection of attribute UUIDs that identify 
the attribute instances that are members of the set.  
Attribute sets let you group related attributes instances on an object for 
easier access.   For example, if you use 
the <Command>dcecp show</Command> operation to display an attribute set, the 
display expands the attribute set and includes all members of the set 
in the display output.  This attribute expansion works only for 
<Command>dcecp</Command> commands that display information.  The commands 
to create and modify attribute instances work only on the specific 
attribute named in the command.  Since the attributes that are set members 
exist independently of the attribute 
set, they can be manipulated directly like any other attribute.
</Para>
<Para>Each attribute set is attached to an object and, although 
the system does not enforce it, each attribute that is a member 
of a set should also be attached to the same object.  
Attribute sets cannot be nested;  a member of an attribute set cannot 
itself be an  attribute set. 
</Para>
<Para>To create, modify, and delete members in an attribute set, follow the instructions 
to create, modify, and delete mutli-valued attributes.  The attribute instances that 
are members of the set are identified by UUIDs.  
<!-- For example, the following command creates an attribute set -->
<!-- named MVS, with 2 members:-->
<!-- .oS-->
<!-- \*Cdcecp> \*Lprincipal modify delores -add {MVS {18dbdad2-23df-11cd-82d4-080009251352 23dkakal2-18ab-50ef-78a4-093459231352}}\*O-->
<!-- .oE-->
</Para>
</Sect2>
</Sect1>
</Chapter>
<!--+ 10/31/96 16:05:54
    | tagMorph:  $Id: 4.5_era.sgm,v 1.1.2.11 1996/12/04 22:49:04 carrig Exp $
    | tagMorph library:  $Id: 4.5_era.sgm,v 1.1.2.11 1996/12/04 22:49:04 carrig Exp $
    | sml-to-docbook:  1.24
    +-->
