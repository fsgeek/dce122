<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: host_admin.sgm,v $
# Revision 1.1.2.10  1996/12/04  22:49:40  carrig
# 	{enh,R1.2.2}
# 	JC's edits
# 	[1996/12/04  22:47:36  carrig]
#
# Revision 1.1.2.9  1996/11/29  20:21:13  carrig
# 	{enh,R1.2.2}
# 	Finished edit changes; must scale graphics
# 	[1996/11/29  20:18:00  carrig]
# 
# Revision 1.1.2.8  1996/11/27  21:43:57  carrig
# 	{enh,R1.2.2}
# 	More editor's comments
# 	[1996/11/27  21:42:09  carrig]
# 
# 	{enh,R1.2.2}
# 	More editor's comments
# 	[1996/11/27  21:28:58  carrig]
# 
# Revision 1.1.2.7  1996/11/26  21:45:34  carrig
# 	{enh,R1.2.2}
# 	Putting in editor's comments
# 	[1996/11/26  21:41:28  carrig]
# 
# Revision 1.1.2.6  1996/11/25  21:51:37  carrig
# 	{enh,R1.2.2}
# 	Started to put in editor's comments
# 	[1996/11/25  21:49:53  carrig]
# 
# Revision 1.1.2.5  1996/11/07  20:43:50  weir
# 	Cleaned up history
# 	[1996/11/07  20:42:01  weir]
# 
# Revision 1.1.2.4  1996/11/06  20:41:05  carrig
# 	{enh,R1.2.2}
# 	OK for editing
# 	[1996/11/06  20:38:35  carrig]
# 
# Revision 1.1.2.3  1996/11/05  18:59:11  carrig
# 	{enh,R1.2.2}
# 	Second pass
# 	[1996/11/05  18:56:06  carrig]
# 
# Revision 1.1.2.2  1996/11/04  22:04:05  carrig
# 	{enh,R1.2.2}
# 	First pass at corrections
# 	[1996/11/04  22:00:48  carrig]
# 
# Revision 1.1.2.1  1996/11/01  18:21:01  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 	[1996/11/01  18:18:19  wardr]
# 
# Revision 1.1.1.2  1996/11/01  18:18:19  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 
# $EndLog$
-->
<!---->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- HISTORY-->
<!-- Revision 1.1.6.2  1996/10/21  15:26:16  wardr-->
<!-- 	{edit,R1.2.2}-->
<!-- 	Update for sgml conversion-->
<!-- 	[1996/10/21  15:25:55  wardr]-->
<!---->
<!-- Revision 1.1.6.1  1996/09/19  14:15:22  sherman-->
<!-- 	{def,13575,R1.2.2}-->
<!-- 	Miscellaneous dcecp fixes-->
<!-- 	[1996/09/19  14:14:53  sherman]-->
<!-- -->
<!-- Revision 1.1.4.1  1996/03/12  15:49:14  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	Release Edits-->
<!-- 	[1996/03/12  15:48:41  wardr]-->
<!-- -->
<!-- Revision 1.1.2.11  1995/05/25  19:06:00  rcb-->
<!-- 	PRENTICE HALL reformat: final changes-->
<!-- 	[1995/05/25  13:21:41  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat; minor changes-->
<!-- 	[1995/05/08  17:01:07  rcb]-->
<!-- -->
<!-- 	1.1 edits: minor addition-->
<!-- 	[1995/05/01  20:01:04  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat - index entries, odds and ends-->
<!-- 	[1995/03/27  19:49:03  rcb]-->
<!-- -->
<!-- 	prevented hyphenation of option names-->
<!-- 	[1995/03/09  15:00:01  rcb]-->
<!-- -->
<!-- 	minor editorial fix: init cap on "For" in headers-->
<!-- 	[1995/03/06  17:04:59  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/03/02  18:45:17  rcb]-->
<!-- -->
<!-- 	incorporated 1.1 edits-->
<!-- 	[1995/03/02  18:08:46  rcb]-->
<!-- -->
<!-- Revision 1.1.2.10  1994/11/03  23:27:17  neilson-->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- 	[1994/11/03  01:38:04  neilson]-->
<!-- -->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- -->
<!-- Revision 1.1.2.9  1994/10/28  14:57:05  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	added index hits-->
<!-- 	[1994/10/28  14:56:23  wardr]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/10/18  20:39:56  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	Final fixes for the GA release-->
<!-- 	[1994/10/18  20:39:33  wardr]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/09/21  19:30:49  wardr-->
<!-- 	{enh, CR10014, R1.1}-->
<!-- 	prep for final draft review-->
<!-- 	[1994/09/21  19:30:10  wardr]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/09/08  13:51:16  wardr-->
<!-- 	{enh, CR10014, R1.1}-->
<!-- 	dcecp access to dced functions-->
<!-- 	[1994/09/08  13:50:12  wardr]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/07/12  22:55:19  jshirley-->
<!-- 	No change.-->
<!-- 	[1994/07/12  22:55:02  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/06/13  18:13:41  devobj-->
<!-- 	cr10872 - fix copyright-->
<!-- 	[1994/06/13  18:13:30  devobj]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/05/12  12:36:28  wardr-->
<!-- 	{enh,CR10014,R1.1}-->
<!-- 	minor edits-->
<!-- 	[1994/05/12  12:36:09  wardr]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/05/05  18:33:16  wardr-->
<!-- 	{enh, CR10014, R1.1}-->
<!-- 	initial dced admin documentation-->
<!-- 	[1994/05/05  18:32:28  wardr]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/05/03  12:29:46  wardr-->
<!-- 	{enh, CR10014, R1.1}-->
<!-- 	creating host and app admin files-->
<!-- 	[1994/05/03  12:27:55  wardr]-->
<!-- -->
<Chapter Id="AGCC.HSTADM.div.1">
<Title>Managing DCE Host Services and Host Data</Title>
<Para>Some services like DTS, CDS, and the DCE Security Service registry, which
produce or maintain cell-wide information, are centralized.  Although
the services they provide are available throughout a cell, the
servers themselves typically reside on just a few selected hosts in a
cell. 
</Para>
<Para>Other DCE services are pervasive; that is, they reside on every host
in a DCE cell.  The DCE software that runs on every DCE host provides
essential services that enable local client and server programs to
interact with remote client and server programs in a reliable and
secure way.  Consequently, each host in a DCE cell has administrative
aspects which are discussed in the first part of this chapter.  
</Para>
<Para>Each DCE host maintains local data that is essential to host
operation in a DCE environment.  Occasionally, you may find it
necessary to modify parts of this data as your cell configuration
changes, or as you add DCE capabilities or DCE applications.  The
second part of this chapter discusses how to use the DCE control
program to gain remote, authenticated access to this data. 
</Para>
<Para>When DCE operations do not succeed for some reason, you want to inform
the right people about what happened.  DCE's serviceability messaging
facility lets you route error messages based on the severity level of
the message.  The last part of this chapter explains how to manage this
facility. 
</Para>
<Sect1 Id="AGCC.HSTADM.div.2">
<Title>DCE Host Services</Title>
<IndexTerm Id="AGCC.HSTADM.indx.1">
<Primary>DCE daemon</Primary>
</IndexTerm>
<IndexTerm Id="AGCC.HSTADM.indx.2">
<Primary>host services</Primary>
</IndexTerm>
<Para>Some DCE host services such as the runtime libraries are inert and
require no administration once DCE has been configured on a host.  But
other services are active programs.  One such active service is the
<Symbol Role="Variable">endpoint mapper</Symbol> which acts as a lookup service on a host.  The
endpoint mapper lists server communication ports (called
<Symbol Role="Variable">endpoints</Symbol>) in the host's <Symbol Role="Variable">endpoint map</Symbol>.  Remote clients
looking for particular servers query the endpoint mapper which returns
information contained in the endpoint map.  The endpoint mapper, along
with other active services, are contained in a single program called
the <Symbol Role="Variable">DCE host daemon</Symbol> or <Filename>dced</Filename>.  Typically, once a host has
been configured with DCE software, the host booting
process starts the <Filename>dced</Filename> process along with other daemons
or processes.  Occasionally however, you may need to manually start or
restart this daemon.
</Para>
<Para>The <Filename>dced</Filename> program comprises a set of DCE host services that
satisfies many needs of DCE client and server applications on a host
system:
</Para>
<ItemizedList>
<ListItem>
<Para>The endpoint mapper service acts as a directory of servers running on
a host.  Clients can acquire a registered server's communication
endpoint by looking in the host endpoint map.
</Para>
</ListItem>
<ListItem>
<Para>A security validation service manages DCE security on the local host.
</Para>
</ListItem>
<ListItem>
<Para>A server configuration and execution service lets administrators
remotely set servers' starting and stopping conditions, explicitly
start and stop individual servers, and monitor running servers'
states.
</Para>
</ListItem>
<ListItem>
<Para>A key management service lets administrators manage server passwords
remotely. 
</Para>
</ListItem>
<ListItem>
<Para>A hostdata service lets administrators remotely manage data stored in
files on a host.  Administrators will find this most useful for
remotely managing a host's cell name and cell alias information.
</Para>
</ListItem>
<ListItem>
<Para>An attribute schema capability lets administrators add new attributes
to server configuration information.
</Para>
</ListItem>
</ItemizedList>
<Para>Normally, any system that hosts a DCE server (such as a DCE cell
directory server) or that runs a DCE-based application server or
client that uses authentication, must also run the <Filename>dced</Filename>
process.
</Para>
<Para><?sml-need 7>It is clear that if the <Filename>dced</Filename> process failed for some reason, it
would take all of its component services down along with it, leaving
the host unable to respond to client requests.  Similarly, a failure
of one of the component services (for example the key management
service) might be caused by the <Filename>dced</Filename> process unexpectedly
exiting for some reason.  This relationship between <Filename>dced</Filename> and its
component services is worth remembering if problems occur. 
</Para>
</Sect1>
<Sect1 Id="AGCC.HSTADM.div.3">
<Title>Starting and Stopping DCE Host Services</Title>
<IndexTerm Id="AGCC.HSTADM.indx.3">
<Primary>DCE daemon</Primary>
<Secondary>starting and stopping</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.HSTADM.indx.4">
<Primary>host services</Primary>
<Secondary>starting and stopping</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.HSTADM.indx.5">
<Primary>starting</Primary>
<Secondary>host services</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.HSTADM.indx.6">
<Primary>stopping</Primary>
<Secondary>host services</Secondary>
</IndexTerm>
<!-- THEME: DCE's built-in services help streamline applications.-->
<Para>Although the <Filename>dced</Filename> process generally starts as part of the host
booting process, sometimes you may need to start the process manually.
</Para>
<Para>Before starting <Filename>dced</Filename>, any underlying network services on which
client/server communication depends must be available; on most UNIX
systems, for example, network interfaces and routing services must be
enabled.  Once these transport-layer services are established, you can
start <Filename>dced</Filename>.  After <Filename>dced</Filename> starts, RPC-based servers can start.
</Para>
<Para>The endpoint mapper listens on privileged or reserved communication ports
(well-known endpoints) for client requests for
service.  Consequently, <Filename>dced</Filename> must be started as a privileged user.
</Para>
<Para>Part of <Filename>dced</Filename> (the endpoint map) contains information that
clients use to locate servers on a host system.  The <Filename>dced</Filename> process
maintains a copy of this information in a database file named
<Symbol Role="Variable">dcelocal</Symbol><Filename>/var/dced/Ep.db</Filename> so it will not be lost if you stop and
then restart <Filename>dced</Filename> for some reason.  Another database file called
<Symbol Role="Variable">dcelocal</Symbol><Filename>/var/dced/Srvrexec.db</Filename> maintains information about
servers (such as each server's process ID) that are currently running
on the host.  The information in both of these databases becomes
obsolete when a system reboots because most servers get different
endpoints and different process IDs each time they start.
</Para>
<Para>You can configure <Filename>dced</Filename> to start each time a host boots.  In some
cases, the <Symbol Role="Variable">dcelocal</Symbol><Filename>/etc/rc.dce</Filename> file is linked to or copied to
<Filename>/etc/rc.dce</Filename>.  This way, <Filename>dced</Filename> is invoked when other daemons
are started.  The <Symbol Role="Variable">dcelocal</Symbol><Filename>/etc/rc.dce</Filename> file is also
responsible for deleting the <Literal>Srvrexec.db</Literal> and <Filename>Ep.db</Filename>
database files before starting <Filename>dced</Filename>.  If your system does not
automatically delete these files, you will have to manually delete them
before starting <Filename>dced</Filename>.
</Para>
<Para><?sml-need 4>While you normally do not need to start <Filename>dced</Filename> in a shell, if you
ever need to do so, log in as <Literal>root</Literal> and enter the
following command:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput># <Symbol Role="Variable">dcelocal</Symbol><Filename>/bin/dced</Filename>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>By default, <Filename>dced</Filename> listens on one endpoint for each transport that
is supported by the host on which it is running.  That is, if a host
supports both TCP/IP and UDP/IP transports, <Filename>dced</Filename> will listen
on one TCP and one UDP socket for client requests.  An
optional <Symbol Role="Variable">protseq</Symbol> argument lets you limit the transports that
<Filename>dced</Filename> uses to the ones you specify.  Intended as a debugging
capability, this feature should be used with care; if you limit
transports, clients will not be able to locate servers over the
excluded transports, and servers will not be able to register
themselves in the endpoint map by using the excluded transports.
For information about the optional <Symbol Role="Variable">protseq</Symbol> argument, see the
<Command>dced(8dce)</Command> reference page.
</Para>
<Para>If the DCE daemon stops or exits unexpectedly, you can restart it.  The
restarted <Filename>dced</Filename> process does <Symbol Role="Variable">not</Symbol> lose any previously registered
server bindings.  It simply loads the information from the
<Filename>Ep.db</Filename> and <Literal>Srvrexec.db</Literal> files.  As a rule, stopping and
restarting <Filename>dced</Filename> is not recommended because it also stops the
security validation service.
</Para>
<Para>Although you should run the host services on all hosts where DCE client
or server applications run, there are some situations where you can
avoid running them:
</Para>
<ItemizedList>
<ListItem>
<Para>DCE clients that do not perform authentication
</Para>
</ListItem>
<ListItem>
<Para>DCE servers that do not perform authentication and that do not use the
endpoint mapper or other active DCE host services
</Para>
</ListItem>
</ItemizedList>
<Para>Once you've started the DCE host services, you can perform all DCE host
and server administration tasks by using the DCE control program, 
<Command>dcecp</Command>.  The control program offers secure, remote access to 
host and server administrative functions, which means you can manage all
of your DCE hosts without having to log into each 
host.  Part 1 of this book explained how to use <Command>dcecp</Command> in interactive
mode as well as how to write <Command>dcecp</Command> scripts to manage DCE
activities.  You should be acquainted with those basics before performing
administrative tasks explained in this chapter or elsewhere in this document.
<!-- DCE Administration Guide-->
</Para>
</Sect1>
<Sect1 Id="AGCC.HSTADM.div.4">
<Title>Managing Host Data</Title>
<Para>Each host in a DCE cell maintains local data that is essential for
operating in a DCE environment.  For instance, each host's DCE
identity relies on certain data items that specify the host's
host name, cell name, and any cell aliases.  Currently, these data
items are stored in a local file called <Symbol Role="Variable">dcelocal</Symbol><Filename>/dce_cf.db</Filename>.
These and other data items can be modified remotely using the DCE
control program's <Command>hostdata</Command> object.
</Para>
<Para>The <Command>hostdata</Command> object has a much broader application, too;
administrators will find it extremely useful for accessing general
data and files on remote hosts using secure and platform-independent
methods.  The last part of this chapter examines this powerful access
method.
</Para>
<Sect2 Id="AGCC.HSTADM.div.5">
<Title>Permissions for Accessing Host Data</Title>
<Para>Access control lists (ACLs) prevent unauthorized principals from
creating, changing, or deleting hostdata information.  Two types of
ACLs protect hostdata information.  One type of ACL protects the
container in which the hostdata items reside.  A second type 
protects each individual hostdata item.
</Para>
<Para>This section shows how to manage ACLs that protect hostdata
information.  For detailed information about setting and using ACL
protections, see Chapter 28.
</Para>
<Sect3 Id="AGCC.HSTADM.div.6">
<Title>Permissions for the Hostdata Container</Title>
<Para>In DCE, the hostdata items reside in a <Symbol Role="Variable">container</Symbol>
which is really a backing storage mechanism maintained by <Filename>dced</Filename>.
On UNIX systems this is usually a file called
<Symbol Role="Variable">dcelocal</Symbol><Filename>/var/dced/Hostdata.db</Filename>.  The file is owned by root and
its access via <Filename>dced</Filename> is protected by an ACL.  These ACL
permissions control who can access the data in the container.  Each DCE
host has one hostdata Container ACL with the following name:
</Para>
<InformalExample>
<Para><ProgramListing><Literal>/.../</Literal><Replaceable>cellname</Replaceable><Literal>/hosts/</Literal><Replaceable>hostname</Replaceable><Literal>/config/hostdata</Literal>
</ProgramListing></Para>
</InformalExample>
<Para>The hostdata Container ACL has the following permissions:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>c</Literal> (control)</Term>
<ListItem>
<Para>Modify the Container ACL. 
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>r</Literal> (read)</Term>
<ListItem>
<Para>Read the list of hostdata items in the container.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>i</Literal> (insert)</Term>
<ListItem>
<Para>Create new hostdata items.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>I</Literal> (Insert)</Term>
<ListItem>
<Para>Although the <Literal>I</Literal> permission is present, it does not apply to
hostdata items.  The permission applies to server control facilities,
which are explained in Chapter 10.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>Use the <Command>dcecp</Command> <Command>acl</Command> object to view or modify ACLs.  For
example, use the following operation to view the ACL for the hostdata
container object on host <Literal>silver</Literal>:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>acl show /.:/hosts/silver/config/hostdata</Literal>
{user hosts/silver/self criI}
{unauthenticated r}
{any_other r}
dcecp>
</ProgramListing></Para>
</InformalExample>
</Sect3>
<Sect3 Id="AGCC.HSTADM.div.7">
<Title>Permissions for the Hostdata Items</Title>
<Para>Each of the following host identity data items is protected by an ACL:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>/.../<Symbol Role="Variable">cellname</Symbol><Filename>/hosts/</Filename><Symbol Role="Variable">hostname</Symbol><Literal>/config/hostdata/host_name

/.../</Literal><Symbol Role="Variable">cellname</Symbol><Filename>/hosts/</Filename><Symbol Role="Variable">hostname</Symbol><Literal>/config/hostdata/cell_name

/.../</Literal><Symbol Role="Variable">cellname</Symbol><Filename>/hosts/</Filename><Symbol Role="Variable">hostname</Symbol><Literal>/config/hostdata/cell_aliases

/.../</Literal><Symbol Role="Variable">cellname</Symbol><Filename>/hosts/</Filename><Symbol Role="Variable">hostname</Symbol><Literal>/config/hostdata/post_processors
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para RevisionFlag="Changed"><?og-ChangeStart def,13575,R1.2.2,Changed sentence from has to can have">Each ACL can have the following permissions:
<?og-ChangeEnd def,13575,R1.2.2,Changed sentence from has to can have"></Para>
<VariableList>
<VarListEntry>
<Term><Literal>c</Literal> (control)</Term>
<ListItem>
<Para>Modify the ACL
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>d</Literal> (delete)</Term>
<ListItem>
<Para>Delete the item
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>p</Literal> (purge)</Term>
<ListItem>
<Para>Delete the backing storage for an item
<?sml-break><?sml-need 3></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>r</Literal> (read)</Term>
<ListItem>
<Para>Read an item's data
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>w</Literal> (write)</Term>
<ListItem>
<Para>Modify an item's data
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para RevisionFlag="Changed">Use the <Command>acl</Command> object to view or modify ACLs.  For example, use the
following operation to view the ACL for the <Literal>cell_aliases</Literal> hostdata
item on host <Literal>silver</Literal>:
<?og-ChangeStart def,13575,R1.2.2,Changed example"></Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed">dcecp> <Literal>acl show /.:/hosts/silver/config/hostdata/cell_aliases</Literal>
{unauthenticated ---r-}
{user hosts/silver/self cdprw}
{any_other ---r-}
dcecp>
</ProgramListing></Para>
</InformalExample>
<?og-ChangeEnd def,13575,R1.2.2,Changed example">
</Sect3>
</Sect2>
<Sect2 Id="AGCC.HSTADM.div.8">
<Title>Modifying Host Cell Name Information</Title>
<Para>Using the <Command>hostdata</Command> object, you can add, change, and remove data
items on DCE hosts.  While administrators will find this useful for
modifying a host's cell name or cell alias information, they can also
operate on other data that is accessible on a host.
</Para>
<Para>Each DCE host maintains a protected local copy of the cell name and
cell aliases of the cell in which the host is registered.  Hosts keep
this information in a local file called <Symbol Role="Variable">dcelocal</Symbol><Filename>/dce_cf.db</Filename>
which is owned by <Literal>root</Literal>.  A host uses this information for
authentication purposes&mdash;as part of its host identity information.
</Para>
<Para>Although host cell name information tends to be fairly stable, there
are circumstances where it is necessary to change this information:
</Para>
<ItemizedList>
<ListItem>
<Para>When a host moves to a different cell
</Para>
</ListItem>
<ListItem>
<Para>When a host's cell name changes or the cell name acquires an alias
</Para>
</ListItem>
</ItemizedList>
<Para>When either of these situations occurs, however, it is usually not
enough to just update the cell name information on the host.  Cell name
information must also be updated in CDS and in the DCE Security
Service registry as well.  For these purposes, <Command>dcecp</Command>
provides the <Command>host</Command> and <Command>cellalias</Command> task objects which update
cell name information wherever it needs to be changed.
</Para>
<Para>When a host moves to a different cell, you should usually perform a
<Command>host unconfigure</Command> operation to remove the host from one cell.
Then run a <Command>host configure</Command> operation to establish the host in the
new cell.  For details on using the <Command>host</Command> task object, refer to
Chapter 7.
</Para>
<Para>When a host's cell name changes or the cell name acquires an alias,
you should perform a <Command>cellalias</Command> operation which updates
cell information in CDS, in the DCE Security Service registry, and in
the <Literal>dce_cf.db</Literal> file of every affected host in the cell.  For
details on using the <Command>cellalias</Command> task object, refer to Chapter 6.
</Para>
<Para>Sometimes however, the higher-level <Command>dcecp</Command> task objects do not
offer enough control such as you might need when fixing a corrupted
file somewhere or when configuring a host by hand for some reason.  In
these cases, you can use the <Command>hostdata</Command> object to change cell name
information on individual hosts.
</Para>
<Para>Note though, that this use of the <Command>hostdata</Command> object is intended
mostly to be a troubleshooting operation to be relied on when a host's
cell information is out of synchronization with other cell information
stored in the DCE registry or stored in CDS.  This situation might
be a common occurrence in cells with many hosts. 
</Para>
<Para>To update the cell name or cell alias name information on a host, use
the <Command>hostdata</Command> object.  The following example catalogs the
<Command>hostdata</Command> objects in the cell named
<Filename>/.../my_cell.goodco.com</Filename>.  Then it shows the contents of the
<Replaceable>cell_name</Replaceable> object on host <Literal>silver</Literal>.  Finally, it modifies the
cell name to be <Filename>/.../my_cell.goodco.com</Filename> on host <Literal>silver</Literal>.
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>hostdata cat </Literal>
/.../my_cell.goodco.com/bronze/config/hostdata/dce_cf.db
/.../my_cell.goodco.com/bronze/config/hostdata/cell_name
/.../my_cell.goodco.com/bronze/config/hostdata/host_name
/.../my_cell.goodco.com/bronze/config/hostdata/cell_aliases
/.../my_cell.goodco.com/bronze/config/hostdata/post_processors

dcecp> <Literal>hostdata show cell_name </Literal>
{uuid 00174f6c-6eca-1d6a-bf90-0000c09ce054}
{annotation  {Name of cell}}
{storage cell_name}
{data {/.../old_cell.goodco.com}}

dcecp> <Literal>hostdata modify \ </Literal>
> <Literal>/.../my_cell.goodco.com/hosts/bronze/config/hostdata/cell_name \ </Literal>
> <Literal>-data {/.../my_cell.goodco.com}}</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="AGCC.HSTADM.div.9">
<Title>Manipulating Data in Other Host Files</Title>
<Para>While the <Command>hostdata</Command> object is useful for changing cell name and
cell alias information, it has a broader use too; you can use it to
add, change, and remove data from any file that is accessible on a DCE
host.
</Para>
<Para>One useful example is adding a new CDS attribute.  Every DCE host has
its own CDS attributes file (<Literal>cds_attributes</Literal>) where it stores
object IDs for each CDS attribute.  You could use the local host's
editor to add the attribute and then copy the new file to each host.
But this method requires you to log into each host.  A simpler method
would be to use the <Command>hostdata</Command> object to add the new attribute to the
CDS attributes file.  Place the operation within a <Command>foreach</Command> loop
that reexecutes it for each host in the cell.
</Para>
<OrderedList>
<ListItem RevisionFlag="Changed">
<?og-ChangeStart def,13575,R1.2.2,Added phrase to end of paragraph">
<Para>Make the CDS attributes file accessible as an object of the
<Command>hostdata</Command> object.  First, use the <Command>hostdata</Command> object to create
a CDS entry representing the CDS attributes file.  Set the storage
attribute to be the host filename of the CDS attributes file.  The
following example assumes the CDS attributes file is in the default
location, and that the file exists:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>hostdata create /.:/hosts/silver/config/hostdata/cds_attr \ </Literal>
> <Literal>-storage /opt/dcelocal/etc/cds_attributes -entry</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<?og-ChangeEnd def,13575,R1.2.2,Added phrase to end of paragraph">
</ListItem>
<ListItem>
<Para RevisionFlag="Changed">The <Command>hostdata</Command> object modifies data in files by replacing all the
data in the file with new data that you specify.  The following
example shows one way to do this.  First, retrieve and store all the
lines as <Command>dcecp</Command> list elements in a variable.  Then create a new
variable by using the <Command>attrlist</Command> command to add the new line as a
list element to the variable.  Finally, copy the new variable back to
the file.
<?og-ChangeStart def,13575,R1.2.2,Corrected example"></Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed">dcecp> <Literal>set val [attrlist getvalues [hostdata show \</Literal>
> <Literal>/.:/hosts/silver/config/hostdata/cds_attr] -type hostdata/data] </Literal>
dcecp> <Literal>set newval [attrlist add $val -member {NEW_ATTR 1.2.3.4}] </Literal>
dcecp> <Literal>hostdata modify /.:/hosts/silver/config/hostdata/cds_attr -data $newval</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<?og-ChangeEnd def,13575,R1.2.2,Corrected example">
</ListItem>
</OrderedList>
</Sect2>
</Sect1>
<Sect1 Id="AGCC.HSTADM.div.10">
<Title>Routing Serviceability Messages</Title>
<Para>The DCE serviceability mechanism is designed to be used 
mainly for server informational and error messaging&mdash;that 
is, for messages that are of interest to those who are 
concerned with server maintenance and administration (in 
the broadest sense of these terms). The essential idea 
of the mechanism is that all server events that are significant 
for maintaining or restoring normal operation should be reported 
in messages that are made to be self-documenting.  As a result 
(assuming that all events have been correctly identified 
and reported), users and administrators will always be able 
to learn what action they should take in a given situation.
</Para>
<Note>
<Para>User-prompted, 
interactive, client-generated messaging is handled through 
the standard DCE messaging interface.
</Para>
</Note>
<Para>The serviceability component is used by the DCE components (RPC, 
DTS, Security, and so on) for their own server messaging, and it 
is made available as an API for use by DCE application programmers 
who wish to standardize their applications' server messaging. 
(The serviceability API is described in the &DCEDk;.)
</Para>
<Para>Messaging uses XPG4 (<Symbol Role="Variable">X/Open Portability Guide</Symbol>) message 
catalogs to hold message texts, but it adds an additional layer to 
the XPG4 functionality.  The message catalogs and other required 
data (and documentation) files are generated by a utility called 
<Command>sams</Command> (symbols and message strings).  Its input is a text 
file that establishes some organizational information about the 
program that is to use the messages, followed by a series of 
specifications of the messages themselves.  The serviceability 
mechanism allows system administrators to control the routing 
of these messages.  Specifically, you can define message routings 
based on the severity levels (<Literal>FATAL</Literal>, <Literal>ERROR</Literal>, and so on) defined 
for the messages.
</Para>
<Para>The following sections describe how to control the routing of 
serviceability messages.  First, you are provided with an overview 
of serviceability messaging in the DCE.  Then the text describes
how you can use message severity levels to control routing. 
Finally, it describes the different ways in which you can specify routing 
for serviceability messages.
</Para>
<Sect2 Id="AGCC.HSTADM.div.11">
<Title>Serviceability Message Severity Levels</Title>
<Para>Serviceability messages are categorized by their 
<Symbol Role="Variable">severity level</Symbol>, which provides important information 
about the situation that causes the program to issue the message. 
Every message's severity is defined in the text of the message 
itself (for example, <Literal>NOTICE</Literal> indicates that a message is an 
informational notice), and system administrators can route messages 
differently on the basis of their severity levels.
</Para>
<Para>The following table lists the possible severity levels and provides an 
explanation for each.
</Para>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Serviceability Message Severity Levels</Title>
<TGroup Rowsep="1" Colsep="1" Cols="2">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1.25*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Align="Left" Colwidth="2.5*" Colname="col2" Colnum="2">
<THead>
<Row>
<Entry Rowsep="1"><Literal>Name</Literal></Entry>
<Entry Rowsep="1"><Literal>Meaning</Literal></Entry>
</Row>
</THead>
<TBody>
<Row>
<Entry><Literal>FATAL</Literal></Entry>
<Entry>Fatal error exit: An unrecoverable error (such 
as database corruption) has occurred and will 
probably require manual intervention to be 
corrected.  The program usually terminates 
immediately after such an error.
</Entry>
</Row>
<Row>
<Entry><Literal>ERROR</Literal></Entry>
<Entry>Error detected: An unexpected event that is 
nonterminal (such as a timeout), or is correctable 
by human intervention, has occurred.  The program 
will continue operation, although some functions 
or services may no longer be available.  This 
severity level may also be used to indicate that a 
particular request or action could not be completed.
</Entry>
</Row>
<Row>
<Entry><Literal>WARNING</Literal></Entry>
<Entry>Correctable error: An error occurred that was 
automatically corrected (for example, a configuration 
file was not found, and default values were used 
instead). This severity level may also be used to 
indicate a condition that <Symbol Role="Variable">may</Symbol> be an error 
if the effects are undesirable (for example, removing 
all files as a side effect of removing a nonempty 
directory). This severity level may also be used to 
indicate a condition that, if not corrected, will 
eventually result in an error (for example, a 
printer is running low on paper).
</Entry>
</Row>
<Row>
<Entry><Literal>NOTICE</Literal></Entry>
<Entry>Informational notice: A significant routine major 
event has occurred; for example, a server has started.
</Entry>
</Row>
<Row>
<Entry><Literal>NOTICE_VERBOSE</Literal></Entry>
<Entry>Verbose information notice: A significant routine 
event has occurred; for example, a directory 
entry was removed.
</Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-space .5>
</Sect2>
<Sect2 Id="AGCC.HSTADM.div.12">
<Title>How to Route Serviceability Messages</Title>
<Para>Serviceability messages can be written to any of the normal 
output destinations.  You can specify routing for serviceability 
messages in any of the following four ways:
</Para>
<ItemizedList>
<ListItem>
<Para>Through the <Command>dcecp log</Command> object, if the server supports the 
remote serviceability interface
</Para>
</ListItem>
<ListItem>
<Para>By the contents of a routing file
</Para>
</ListItem>
<ListItem>
<Para>By the contents of an environment variable
</Para>
</ListItem>
<ListItem>
<Para>By command-line flags (usually <Option>w</Option>), if supported by the server
</Para>
</ListItem>
</ItemizedList>
<Note>
<Para>Each of the methods accepts the string syntax form for serviceability 
routing specifications.  In addition, <Command>dcecp</Command> allows you to use 
Tcl (Tool Command Language) syntax, which is easier to use 
when writing scripts.
</Para>
</Note>
<Para><Symbol Role="Variable">Routing</Symbol> a message actually consists of specifying two things:
</Para>
<ItemizedList>
<ListItem>
<Para>How the message should be processed (that is, the form in which it 
should be put)
</Para>
</ListItem>
<ListItem>
<Para>Where the message should be sent (its destination)
</Para>
</ListItem>
</ItemizedList>
<Para>The two specifications are sometimes closely interrelated, and 
sometimes specifying a certain destination implies that the 
message must be put into a certain form.  This fact allows certain 
combinations to be abbreviated.
</Para>
<Para>The ways to route serviceability messages are described 
separately in the following sections.
</Para>
<Sect3 Id="AGCC.HSTADM.div.13">
<Title>Using the <Command>dcecp log</Command> Object</Title>
<Para>The <Command>dcecp log</Command> object represents the current state of routing 
for DCE serviceability messages for a given server.  The <Command>log</Command> 
object supports both serviceability routing and debug routing. 
</Para>
<Para>The <Command>log</Command> object exports a number of operations. 
The following operations are useful for serviceability 
message routing:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Command>log list</Command> operation returns a list of the components registered by the 
server.  The <Option>comp</Option> option allows you to also return a list of the 
subcomponents for one or more named components.
</Para>
</ListItem>
<ListItem>
<Para>The <Command>log show</Command> operation returns a list describing the current 
serviceability routing specifications for a server.
</Para>
</ListItem>
<ListItem>
<Para>The <Command>log modify</Command> operation sets message routing specifications for one 
or more specified servers.
</Para>
</ListItem>
</ItemizedList>
<Para>For a complete description of the <Command>dcecp log</Command> object and the 
syntax for its supported operations, refer to the <Command>log(8dce)</Command> 
reference page.
</Para>
<Para>The remainder of this section describes only the <Command>log modify</Command> 
operation and how to use it to establish routings for serviceability 
messages.  Remember that routing is always set on a per-server basis and 
is recorded in the <Command>log</Command> object for each server.
</Para>
<Para>The syntax for the <Command>log modify</Command> operation is
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>log modify {<Symbol Role="Variable">string_binding_to_server</Symbol><Literal> | </Literal><Symbol Role="Variable">RPC_server_namespace_entry</Symbol><Literal>} \
    {-change </Literal><Symbol Role="Variable">serviceability_routing_specifications</Symbol><Literal>}</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>You can specify multiple target servers as a space-separated list.  Specify 
each server by supplying either the RPC string binding that describes 
the server's network location 
(<Symbol Role="Variable">string_binding_to_server</Symbol>) or a namespace entry of the server 
(<Symbol Role="Variable">RPC_server_namespace_entry</Symbol>). When specifying multiple servers, 
you can mix the forms in the same list.
</Para>
<Para>A <Symbol Role="Variable">serviceability_routing_specification</Symbol> is a space-separated 
list of serviceability routing elements.  No spaces are allowed 
within the specification of an individual routing element.  Each routing 
element is a substring consisting of four fields 
containing portable character set (PCS) data, as follows 
(shown in string syntax form):
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">severity</Symbol><Literal>:</Literal><Symbol Role="Variable">output_form</Symbol><Literal>:</Literal><Symbol Role="Variable">destination</Symbol><Literal>[:</Literal><Symbol Role="Variable">application-defined</Symbol><Literal>]</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>where:
</Para>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">severity</Symbol></Term>
<ListItem>
<Para>A message severity level: <Literal>FATAL</Literal>, <Literal>ERROR</Literal>, 
<Literal>WARNING</Literal>, <Literal>NOTICE</Literal>, or <Literal>NOTICE_VERBOSE</Literal>.
<?sml-break><?sml-need 3></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">output_form</Symbol></Term>
<ListItem>
<Para>Specifies how messages of the associated severity level should 
be processed, and must be one of the following:
<?sml-break><?sml-need 3></Para>
<VariableList>
<VarListEntry>
<Term><Literal>BINFILE</Literal></Term>
<ListItem>
<Para>Write these messages as binary log entries
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>TEXTFILE</Literal></Term>
<ListItem>
<Para>Write these messages as human-readable text
<?sml-break><?sml-need 3></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>FILE</Literal></Term>
<ListItem>
<Para>Equivalent to <Literal>TEXTFILE</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>DISCARD</Literal></Term>
<ListItem>
<Para>Do not record these messages
<?sml-break><?sml-need 3></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>STDOUT</Literal></Term>
<ListItem>
<Para>Write these messages as human-readable text to standard output
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>STDERR</Literal></Term>
<ListItem>
<Para>Write these messages as human-readable text to standard error
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>Files written as <Literal>BINFILE</Literal>s can be read and manipulated with a 
set of log file APIs, which are described in the &DCEDd;.
</Para>
<Para>The <Literal>BINFILE</Literal>, <Literal>TEXTFILE</Literal>, and <Literal>FILE</Literal> <Symbol Role="Variable">output_form</Symbol> 
specifiers may be followed by a 2-number specifier of the form
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>.<Symbol Role="Variable">gens</Symbol><Literal>.</Literal><Symbol Role="Variable">count</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>where:
</Para>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">gens</Symbol></Term>
<ListItem>
<Para>Is an integer that specifies the number of files (that is, generations) that
should be kept
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">count</Symbol></Term>
<ListItem>
<Para>Is an integer specifying how many entries (that is, messages) should be
written to each file
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>The multiple files are named by appending a <Literal>.</Literal> (dot) to the simple 
specified name, followed by the current generation number.  When the 
number of entries in a file reaches the maximum specified by 
<Symbol Role="Variable">count</Symbol>, the file is closed, the generation number is 
incremented, and the next file is opened.  
</Para>
<Para><?sml-need 8>When the maximum 
number of files have been created and filled, the 
generation number is reset to <Literal>1</Literal>, and a new file with that 
number is created and written to (thus overwriting the 
already existing file with the same name), and so on. 
Thus the files wrap around to their beginning, and the 
total number of log files never exceeds <Symbol Role="Variable">gens</Symbol>, 
although messages continue to be written as long as 
the program continues writing them.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">destination</Symbol></Term>
<ListItem>
<Para>Specifies where the message should be sent, and is a pathname.  You can leave 
this field blank if the <Symbol Role="Variable">output_form</Symbol> specified is <Literal>DISCARD</Literal>, 
<Literal>STDOUT</Literal>, or <Literal>STDERR</Literal>.  The field can also contain a <Command>%ld</Command> 
string in the filename which, when the file is written, will be replaced 
by the process ID of the program that wrote the message(s).  Filenames may 
<Symbol Role="Variable">not</Symbol> contain : (colon), ; (semicolons), % (percent sign), 
or the space character.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">application-defined</Symbol></Term>
<ListItem>
<Para>Is used for application-specific information.  Standard DCE programs 
ignore it.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Sect4 Id="AGCC.HSTADM.div.14">
<Title>String Syntax</Title>
<Para>The string syntax for a serviceability routing specification is
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">severity</Symbol><Literal>:</Literal><Symbol Role="Variable">output_form</Symbol><Literal>:</Literal><Symbol Role="Variable">destination</Symbol><Literal>[:</Literal><Symbol Role="Variable">application-defined</Symbol><Literal>][; .&ensp;.&ensp;.&ensp;]</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Note that you can define multiple routing specifications as a semi-colon separated 
list.
</Para>
<Para>For example, this specification
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><?sml-need 6>FATAL:TEXTFILE:/dev/console;STDOUT:
ERROR:TEXTFILE.5.100:/tmp/errors
EXIT:DISCARD:
*:FILE:/tmp/svc-log
NOTICE:BINFILE:/tmp/log%ld
WARNING:STDOUT:
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>instructs the serviceability mechanism to do the following:
</Para>
<ItemizedList>
<ListItem>
<Para>Send fatal error messages to the console and to standard output
</Para>
</ListItem>
<ListItem>
<Para>Send other error messages to a log-rolled file
</Para>
</ListItem>
<ListItem>
<Para>Discard normal exit reports
</Para>
</ListItem>
<ListItem>
<Para>Write all messages to a log file
</Para>
</ListItem>
<ListItem>
<Para>Send informational messages to a temporary binary log
</Para>
</ListItem>
<ListItem>
<Para>Send warnings to standard output
</Para>
</ListItem>
</ItemizedList>
</Sect4>
<Sect4 Id="AGCC.HSTADM.div.15">
<Title>Tcl Syntax</Title>
<Para>The Tcl syntax for a serviceability routing specification is
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>{<Symbol Role="Variable">severity&ensp;output_form&ensp;destination&ensp;application-defined</Symbol><Literal>}</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>where <Symbol Role="Variable">severity</Symbol>, <Symbol Role="Variable">output_form</Symbol>, <Symbol Role="Variable">destination</Symbol>, and 
<Symbol Role="Variable">application-defined</Symbol> are specified as previously described.  In Tcl 
syntax, multiple routing specifications take the following form:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>{ {<Symbol Role="Variable">specification</Symbol><Literal>} {</Literal><Symbol Role="Variable">specification</Symbol><Literal>} {</Literal><Symbol Role="Variable">specification</Symbol><Literal>} }
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>For example, the sample specification shown previously for string format 
would be expressed in Tcl syntax as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>{FATAL { {TEXTFILE /dev/console} STDOUT} }
{ERROR TEXTFILE.5.100 /tmp/errors}
{EXIT DISCARD}
{* FILE /tmp/svc-log}
{NOTICE BINFILE /tmp/log%ld }
{WARNING STDOUT {} }
</UserInput></ProgramListing></Para>
</InformalExample>
</Sect4>
</Sect3>
<Sect3 Id="AGCC.HSTADM.div.16">
<Title>Using a Routing File</Title>
<Para>If a file called <Symbol Role="Variable">dce-local-path</Symbol><Filename>/var/svc/routing</Filename>
exists, the contents of the file (if in the proper format) will 
be used to determine the routing of messages written 
by the serviceability mechanism.
</Para>
<Para>The default location of the serviceability routing file is normally 
<Symbol Role="Variable">/opt/dcelocal</Symbol><filename>/var/svc/routing</filename>.
However, you can specify a different location for the file 
by setting the value of the environment variable 
<Literal>DCE_SVC_ROUTING_FILE</Literal> to the complete desired pathname.
</Para>
<Para>The routing file contains lines that specify the 
routing desired for the various kinds of messages (based on message
severity level). Each line consists of three fields as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">severity</Symbol><Literal>:</Literal><Symbol Role="Variable">output_form</Symbol><Literal>:</Literal><Symbol Role="Variable">destination</Symbol><Literal>[:</Literal><Symbol Role="Variable">application-defined</Symbol><Literal>][; .&ensp;.&ensp;.&ensp;]</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>You can supply multiple routings by specifying additional 
<Symbol Role="Variable">output_form</Symbol><Literal>:</Literal><Symbol Role="Variable">destination</Symbol> pairs as a 
semicolon-separated list.
</Para>
<Para>In the routing file, blank lines beginning with the <Literal>#</Literal> 
character are treated as comments.
</Para>
</Sect3>
<Sect3 Id="AGCC.HSTADM.div.17">
<Title>Using Environment Variables</Title>
<Para>Serviceability message routing can also be specified by the 
contents of certain environment variables.  If you use environment 
variables, the routings you specify will override any 
conflicting routings specified by a routing file.
</Para>
<Para>The routings are specified (on the basis of severity level) by 
putting the desired routing instructions in the following 
environment variables:
</Para>
<ItemizedList>
<?sml-need 12>
<ListItem>
<Para><Literal>SVC_FATAL</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>SVC_ERROR</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>SVC_WARNING</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>SVC_NOTICE</Literal>
<?sml-break><?sml-need 4></Para>
</ListItem>
<ListItem>
<Para><Literal>SVC_NOTICE_VERBOSE</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Literal>SVC_BRIEF</Literal>
</Para>
</ListItem>
</ItemizedList>
<Para>Each variable should contain a single string in the following format:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">severity</Symbol><Literal>:</Literal><Symbol Role="Variable">output_form</Symbol><Literal>:</Literal><Symbol Role="Variable">destination</Symbol><Literal>[:</Literal><Symbol Role="Variable">application-defined</Symbol><Literal>][; .&ensp;.&ensp;.&ensp;]</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>You can supply multiple routings by specifying additional 
<Symbol Role="Variable">output_form</Symbol><Literal>:</Literal><Symbol Role="Variable">destination</Symbol> pairs as a 
semicolon-separated list.
</Para>
</Sect3>
</Sect2>
</Sect1>
</Chapter>
<!--+ 10/31/96 16:05:54
    | tagMorph:  $Id: host_admin.sgm,v 1.1.2.10 1996/12/04 22:49:40 carrig Exp $
    | tagMorph library:  $Id: host_admin.sgm,v 1.1.2.10 1996/12/04 22:49:40 carrig Exp $
    | sml-to-docbook:  1.24
    +-->
