<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: script.sgm,v $
# Revision 1.1.2.12  1996/12/09  17:32:34  carrig
# 	{enh,R1.2.2}
# 	No change
# 	[1996/12/09  17:32:15  carrig]
#
# Revision 1.1.2.11  1996/12/04  22:49:49  carrig
# 	{enh,R1.2.2}
# 	JC's edits
# 	[1996/12/04  22:47:47  carrig]
# 
# Revision 1.1.2.10  1996/11/29  20:21:21  carrig
# 	{enh,R1.2.2}
# 	Finished edit changes; must scale graphics
# 	[1996/11/29  20:18:13  carrig]
# 
# Revision 1.1.2.9  1996/11/27  21:44:05  carrig
# 	{enh,R1.2.2}
# 	More editor's comments
# 	[1996/11/27  21:42:19  carrig]
# 
# 	{enh,R1.2.2}
# 	More editor's comments
# 	[1996/11/27  21:29:08  carrig]
# 
# Revision 1.1.2.8  1996/11/26  21:45:41  carrig
# 	{enh,R1.2.2}
# 	Putting in editor's comments
# 	[1996/11/26  21:41:38  carrig]
# 
# Revision 1.1.2.7  1996/11/25  21:51:44  carrig
# 	{enh,R1.2.2}
# 	Started to put in editor's comments
# 	[1996/11/25  21:50:03  carrig]
# 
# Revision 1.1.2.6  1996/11/25  13:57:17  weir
# 	Fixed various Adept errors
# 	[1996/11/25  13:44:46  weir]
# 
# Revision 1.1.2.5  1996/11/07  20:43:58  weir
# 	Cleaned up history
# 	[1996/11/07  20:42:10  weir]
# 
# Revision 1.1.2.4  1996/11/06  20:41:12  carrig
# 	{enh,R1.2.2}
# 	OK for editing
# 	[1996/11/06  20:38:46  carrig]
# 
# Revision 1.1.2.3  1996/11/05  18:59:19  carrig
# 	{enh,R1.2.2}
# 	Second pass
# 	[1996/11/05  18:56:15  carrig]
# 
# Revision 1.1.2.2  1996/11/04  22:04:12  carrig
# 	{enh,R1.2.2}
# 	First pass at corrections
# 	[1996/11/04  22:00:57  carrig]
# 
# Revision 1.1.2.1  1996/11/01  18:21:12  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 	[1996/11/01  18:18:28  wardr]
# 
# Revision 1.1.1.2  1996/11/01  18:18:28  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 
# $EndLog$
-->
<!---->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.V-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- HISTORY-->
<!-- Revision 1.1.4.2  1996/09/27  13:49:55  weir-->
<!-- 	Test-->
<!-- 	[1996/09/27  13:49:21  weir]-->
<!---->
<!-- Revision 1.1.4.1  1996/09/19  13:49:46  sherman-->
<!-- 	{def,13575,R1.2.2}-->
<!-- 	Miscellaneous dcecp fixes}-->
<!-- 	[1996/09/19  13:47:32  sherman]-->
<!-- -->
<!-- Revision 1.1.2.10  1995/05/25  19:01:27  rcb-->
<!-- 	PRENTICE HALL reformat: final changes-->
<!-- 	[1995/05/25  13:08:35  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat - index entries, odds and ends-->
<!-- 	[1995/03/27  19:48:43  rcb]-->
<!-- -->
<!-- 	minor formatting change-->
<!-- 	[1995/03/01  14:20:59  rcb]-->
<!-- -->
<!-- 	additional 1.1 edit change-->
<!-- 	[1995/02/27  17:04:14  rcb]-->
<!-- -->
<!-- 	previous checkins include both incorporation of 1.1 edits and PH reformat-->
<!-- 	[1995/02/23  18:20:47  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/02/22  17:54:18  rcb]-->
<!-- -->
<!-- Revision 1.1.2.9  1994/10/28  12:40:31  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	Added index hits-->
<!-- 	[1994/10/28  12:40:09  wardr]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/10/20  16:23:06  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	Final GA release edits-->
<!-- 	[1994/10/20  16:22:22  wardr]-->
<!-- -->
<!-- 	{edit R1.1}-->
<!-- 	Final fixes for the GA release-->
<!-- -->
<!-- Revision 1.1.2.7  1994/10/04  17:58:29  wardr-->
<!-- 	{enh, CR10014, R1.1}-->
<!-- 	prepare final draft of dcecp information-->
<!-- 	[1994/10/04  17:57:05  wardr]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/06/13  18:10:51  devobj-->
<!-- 	cr10872 - fix copyright-->
<!-- 	[1994/06/13  18:10:15  devobj]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/05/18  12:14:50  wardr-->
<!-- 	{edit R1.1}SGML fixes-->
<!-- 	[1994/05/18  12:14:37  wardr]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/05/12  11:53:17  wardr-->
<!-- 	{enh,CR10014,R1.1}-->
<!-- 	fix build problem-->
<!-- 	[1994/05/12  11:52:52  wardr]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/04/18  18:31:35  wardr-->
<!-- 	{enh, CR10014, R1.1}-->
<!-- 	dcecp work-->
<!-- 	[1994/04/18  18:30:01  wardr]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/04/14  20:42:26  wardr-->
<!-- 	checked out files-->
<!-- 	[1994/04/14  20:38:57  wardr]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/02/24  19:46:35  rom-->
<!-- 	{enh, 10014, R1.1}-->
<!-- 	Add new chapters for dcecp.-->
<!-- 	[1994/02/24  19:45:06  rom]-->
<!-- -->
<!-- -->
<Chapter Id="AGCC.CPSCR.div.1">
<Title>Writing Scripts and dcecp Objects</Title>
<IndexTerm Id="AGCC.CPSCR.indx.1">
<Primary>DCE control program language</Primary>
<Secondary>writing scripts</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPSCR.indx.2">
<Primary>DCE control program language</Primary>
<Secondary>extending</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPSCR.indx.3">
<Primary>DCE control program</Primary>
<Secondary>extending</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPSCR.indx.4">
<Primary>scripts</Primary>
<SeeAlso>DCE control program language</SeeAlso>
</IndexTerm>
<IndexTerm Id="AGCC.CPSCR.indx.5">
<Primary>scripts</Primary>
<Secondary>writing <Command>dcecp</Command></Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPSCR.indx.6">
<Primary>extending</Primary>
<Secondary><Command>dcecp</Command></Secondary>
</IndexTerm>
<Para>The DCE control program supplies a number of <Symbol Role="Variable">objects</Symbol> that offer
administrative access to each manageable component in a DCE cell.  For
instance, the <Command>principal</Command> object lets administrators manage
principal information in the DCE Security Service registry database.
Similarly, the <Command>rpcgroup</Command> object lets administrators manage group
information in CDS.
</Para>
<Para>Some DCE operations affect multiple components as when several
operations must be performed to add a new user to a DCE cell.  To meet
this need, the DCE control program provides <Replaceable>task objects</Replaceable> which
let administrators operate on multiple components with a single
operation.  For instance, the <Literal>user</Literal> task object performs several
operations that include creating principal information in the
registry, adding the principal to an organization and to relevant
groups, creating a CDS directory for the user, and so on.  Task
objects look and behave just like other <Command>dcecp</Command> objects,
implementing the same help system used by other <Command>dcecp</Command> objects.
However, task objects are written using the <Command>dcecp</Command> language
instead of the C programming language.  This makes it easy for
administrators to extend or customize existing scripts.
</Para>
<Para>While the DCE control program provides task objects to handle some
multicomponent operations, variations in cell configurations and
differences in the ways administrators manage their cells make it
impractical for the supplied DCE task objects to satisfy all the needs
of every DCE cell.  For instance, some cells may use DFS or GDS
components, or a cell may implement a cell directory naming scheme that
differs from the standard OSF DCE implementation.  Alternatively, some
DCE implementations could have specialized administrative components,
such as services or repositories, that need distinct <Command>dcecp</Command>
objects for managing them.
</Para>
<Para>To accommodate a cell's specific needs, the DCE control program
language lets administrators create their own scripts.  Administrators
can also extend or modify existing task objects or they can create new
task objects to manage specialized components in a DCE cell.  This
chapter provides information for extending, modifying, or creating the
following kinds of dcecp scripts:
</Para>
<ItemizedList>
<ListItem>
<Para>Informal administration scripts
</Para>
</ListItem>
<ListItem>
<Para>Formal task objects
</Para>
</ListItem>
</ItemizedList>
<!-- This cookie-cutter approach would suffice if all DCE cells were-->
<!-- exactly the same.  But all DCE cells are not created equally.  Some-->
<!-- cells might exist across WANs (wide area networks) while others are-->
<!-- constrained to single LANs (local area networks). Cell complexity can-->
<!-- differ; some cells might contain hierarchies of cells to gain needed-->
<!-- flexibility while other cells can be simple.-->
<Sect1 Id="AGCC.CPSCR.div.2">
<Title>Informal Administration Scripts</Title>
<Para><IndexTerm Id="AGCC.CPSCR.indx.7">
<Primary>scripts</Primary>
<Secondary>informal</Secondary>
<Tertiary>writing in <Command>dcecp</Command></Tertiary>
</IndexTerm>Informal administration scripts let administrators store multiple
operations in a file and replay them whenever necessary.  Informal
scripts are useful for operations that take only one or two arguments
or that just perform simple tasks.  Furthermore, the script's precise
behavior and output can be custom tailored to the needs of its author.
While informal scripts can be shared among administrators
in a cell, they are typically included just in the author's
<Literal>.dcecprc</Literal> file.
</Para>
<Para>Scripts generally consist of one or more procedures created with the
<Command>proc</Command> command.  This lets you invoke the scripted operation by
simply typing the procedure's name at the <Command>dcecp</Command> prompt.
</Para>
<Para>The following simple script prints information
about your current cell and login identity:
</Para>
<InformalExample>
<Para><ProgramListing># Show your current login name and your current cell name.
proc _dcp_whoami {} {
  global _c _u
  puts stdout "You are '$_u' logged into '$_c'."
}
</ProgramListing></Para>
</InformalExample>
<Para>This script can be included in your <Literal>.dcecprc</Literal> file either
directly or by using the <Command>source</Command> command and keeping the actual
script in an external file.  The second method lets other
administrators include your same script by simply pointing to it with
<Command>source</Command> commands in their <Literal>.dcecprc</Literal> files.  This method also
keeps your <Literal>.dcecprc</Literal> file uncluttered, making it easier for others
to understand what is going on.  Alternatively, you can place the
script or a pointer in the <Filename>init.dcecp</Filename> file.  Changes to this
file are available to all users on a host.  For more information about
the <Filename>init.dcecp</Filename> file and the <Literal>.dcecprc</Literal> file, see Section 1.8
of Chapter 1.  The following is an example of the <Command>source</Command> command in a
<Literal>.dcecprc</Literal> file:
</Para>
<InformalExample>
<Para><ProgramListing>source /usr/users/wardr/dcecp/local_lib.dcp
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>.dcp</Literal> filename extension is a convention for naming files
used by the DCE control program.  Another convention precedes
procedure names with <Literal>_dcp</Literal>, as in <Literal>_dcp_whoami</Literal>.  Many
<Command>dcecp</Command> procedures adhere to this convention to distinguish their
names from user-created procedures that do not need to use this
convention.  If you find procedure names like <Literal>_dcp_whoami</Literal> hard
to remember or type, you can rename them.  For instance, you could
rename the procedure to <Literal>whoami</Literal> by using the <Command>rename</Command> command in
the <Literal>.dcecprc</Literal> file, as follows:
</Para>
<InformalExample>
<Para><ProgramListing>rename _dcp_whoami whoami
</ProgramListing></Para>
</InformalExample>
<Para>Restart <Command>dcecp</Command> to pick up any changes.  Now you can
enter <Literal>whoami</Literal> at the DCE control program prompt, as follows:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>whoami</Literal>
You are 'cell_admin' logged into '/.../my_cell.goodco.com'.
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>By chaining operations together, you can create scripts that do more.
For example, the following script lists all the hosts in a DCE cell.
Then it checks whether each host has an object entry in CDS for a
dts-entity.  (This would indicate that a DTS server is available on the
host.)  For each host with an object entry for a dts-entity, the
script does a <Command>clock show</Command> operation which returns the time on
that host.  The script prints the information on the display, formatting
it for readability, and continues looping through all the hosts in the
cell until all host entries have been checked.
</Para>
<Para>Make the <Literal>_dcp_show_clocks</Literal> procedure available to your
<Command>dcecp</Command> session in the same way as the simpler script described
previously. 
<IndexTerm Id="AGCC.CPSCR.indx.8">
<Primary>scripts</Primary>
<Secondary>informal</Secondary>
<Tertiary>example of</Tertiary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing># Show the time on all of the dts servers running in your cell.
proc _dcp_show_clocks {} {
    set x [directory list /.:/hosts]
    foreach n $x {
        if {[catch {object show $n/dts-entity}] == 0} {
            set index [string last "/" $n] 
            set y [string range $n [incr index] end]
            if {[catch {clock show $n/dts-entity} msg] == 0} {
                set i [expr 20 - [string length $y]]
                puts [format "Time on $y is %${i}s %s" " " \
                    [clock show $n/dts-entity]]
            } else {
                set i [expr 20 - [string length $y]]
                puts [format "Time on $y is %${i}s %s" " " \
                    "Server not responding."]
            }
        }
    }
}
</ProgramListing></Para>
</InformalExample>
<!-- .P-->
<!-- The following example script performs a \*Lcell show\*O operation, a-->
<!-- \*Lserver ping\*O operation for some specific servers, and a-->
<!-- \*Lprincipal catalog\*O operation.  The last operation stores the-->
<!-- output of \*Lprincipal catalog\*O operation in a file and compares it-->
<!-- to the previous day's output to see who's been added or removed from-->
<!-- the cell.-->
<!-- -->
<!-- .oS-->
<!-- DO THIS AS A PROC - otherwise you'll have to source it in ...-->
<!-- -->
<!-- puts "Your cell has the following DCE services:\n"-->
<!-- puts [cell show]-->
<!-- puts "\nYour cell has the following principals:\n"-->
<!-- puts [principal catalog -simplename]-->
<!-- .oE-->
<!-- -->
<!-- DIDN"T USE THIS OLD SCRIPT VERSION...-->
<!-- .oS-->
<!-- proc show_clocks {} {-->
<!--     set x [directory list /.:/hosts]-->
<!--     foreach n $x {-->
<!--         if {[catch {object show $n/dts-entity}] == 0} {-->
<!--             set index [string last "/" $n] -->
<!--             set y [string range $n [incr index] end]-->
<!--             if {[catch {set x [clock show $n/dts-entity]}] == 0} {-->
<!--                 puts "Time on $y is $x"-->
<!--             }-->
<!--         }-->
<!--     }-->
<!-- }-->
<!-- .oE-->
</Sect1>
<Sect1 Id="AGCC.CPSCR.div.3">
<Title>Formal Task Objects</Title>
<Para><IndexTerm Id="AGCC.CPSCR.indx.9">
<Primary>task objects</Primary>
<Secondary>creating</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPSCR.indx.10">
<Primary>objects</Primary>
<Secondary>creating</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPSCR.indx.11">
<Primary>scripts</Primary>
<Secondary>formal</Secondary>
<Tertiary>writing in <Command>dcecp</Command></Tertiary>
</IndexTerm>Some DCE environments might have special administration needs that
are not strictly addressed by the standard DCE control program objects.
While you could write and distribute informal scripts to meet this
administration need, you would likely need to document their operation
in some way.  More importantly, though, a complicated operation might
require the use of numerous options to precisely control the script's
behavior.  Rather than invent your own mechanisms to provide help
information and handle complicated argument parsing operations, you
could rely on the existing help system and the <Filename>parseargs</Filename>
facility utilized by other formal task objects supplied with <Command>dcecp</Command>.  
This approach makes your script consistent with other <Command>dcecp</Command> objects.
</Para>
<Para>Formal task objects build on the idea of the informal scripts
presented previously with some important additions:
</Para>
<ItemizedList>
<ListItem>
<?sml-need 4>
<Para>An argument table at the beginning of the script defines operations as
separate procedures within the script.  An argument table can also
define available options.  A <Filename>parseargs</Filename> procedure is called to
parse the arguments and options passed to the script when it is
invoked.
</Para>
</ListItem>
<ListItem>
<Para>Help information for each operation is placed in the argument tables
in the script.  Other script users can get this
information by using standard <Command>dcecp help</Command> operations.
</Para>
</ListItem>
<ListItem>
<Para>Extensive error control is included because you cannnot predict or
control the conditions in which the script executes.
</Para>
</ListItem>
</ItemizedList>
<Para>The rest of this section shows the general structures and
conventions used in a formal task object.  To aid our explanation, we
use the <Command>dcecp user</Command> task object supplied with the DCE control
program. 
</Para>
<Sect2 Id="AGCC.CPSCR.div.4">
<Title>A Model for Task Objects</Title>
<Para>This section examines the parts of the <Literal>user</Literal> task object that
should be emulated in other task objects that you create for use with
the DCE control program.  Adhering to the basic model ensures that your
task object will look and behave consistently with other parts of <Command>dcecp</Command>.
</Para>
<Para>For efficiency and readability, the example does not include all of
the procedures contained in the <Literal>user</Literal> task object.  Furthermore,
we have omitted some repetitive parts of the included procedures,
replacing the omitted parts with vertical ellipses in the code
examples.  The entire <Literal>user</Literal> task object is contained in
<Symbol Role="Variable">dcelocal</Symbol><Filename>/dcecp</Filename>.
</Para>
<Para>Name your object after the entity on which it operates rather than as
a verb such as "show" or "modify."  DCE control program objects are named
for the DCE entity on which they operate.  Primitive objects like
<Command>rpcentry</Command> and <Command>principal</Command> objects operate on single
manageable DCE entities.  Task objects operate at a higher level,
generally invoking several primitive objects to achieve their goal.
The authors of the user task object contrived a higher-level
entity&mdash;a <Replaceable>user</Replaceable>&mdash;as a manageable object.  
</Para>
<Para>The <Literal>user</Literal> object begins with the top level <Command>proc</Command> command and
its argument table that defines the procedures and operations
provided by the <Literal>user</Literal> object.  Use this syntax to
define separate procedures in this argument table:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">verb</Symbol><Literal> command function_call</Literal><Symbol Role="Variable"> procedure_name</Symbol><Literal> "</Literal><Symbol Role="Variable">helptext_string</Symbol><Literal>"</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The call to the <Filename>parseargs</Filename> procedure (defined in a separate file
called <Filename>parseargs.dcp</Filename>) returns the name of the internal procedure
that is to be called along with its arguments.  The <Filename>parseargs</Filename>
procedure is explained in Section 3.2.2.
<IndexTerm Id="AGCC.CPSCR.indx.12">
<Primary>scripts</Primary>
<Secondary>formal</Secondary>
<Tertiary>example of</Tertiary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing role="page-wide">
<?sml-point-size 10>
<!--no-op:  12-->
# proc user - This procedure is the front end for the user task 
# scripts.  All argument checking for the provided switches is done 
# in the individual functions. 
#

proc user { args } {
  set arg_table {
    {create command function_call _dcp_create_user 
       "Create a DCE user" }
    {delete command function_call _dcp_delete_user 
       "Delete a DCE user"}
    {show   command function_call _dcp_show_user 
       "Show the attributes of a DCE user"}
    {help   help  help_list        
       "Print summary of command-line options and abort"}
    {operations operations operation_list 
       "Return valid operations for command."}}

  set verbose_prose  
"This object allows the manipulation of a DCE user.  A user is
represented as a principal and account with membership in a group and
organization as well as having a directory in the CDS namespace.  A user
may be created, deleted or have attribute information returned.  The
argument is a list of either relative or fully qualified principal names.
All fixed attributes of the principal and account object may be specified
when creating a user.  The -force option to the create verb allows the
group or organization for that user to be created if necessary.  The user
is provided a directory in the CDS namespace, with the appropriate ACLs.
Access to create a user requires the correct ACLs on principal, group and
organization directories within the registry and the clearinghouse and
users directory in the CDS namespace."

  set local_args $args

  parseargs $arg_table local_args -found_one
  
  if { [info local help_prose ] > 0 } { return $help_prose }

  if { [info local function_call ] > 0 } {
    return [$function_call local_args]
  } else {
    error "\"user\" object requires a verb to form a command."
  }

}
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
<Para>The next part of the script examines a procedure that takes many
options or attributes as input: the <Literal>_dcp_create_user</Literal> procedure.  
While this
procedure relies on numerous lower-level procedures to do the actual
work of creating a user, the example begins by showing just one of the
lower-level procedures, <Literal>_dcp_create_principal_entry</Literal>.
</Para>
<Para>Then the script continues with the <Literal>_dcp_create_user</Literal> procedure.
Notice that the name of this procedure (and all lower-level
procedures) begins with an underscore.  That is because the Tcl
<Literal>info</Literal> command is frequently used to return the names of all
procedures.  This convention distinguishes these internal procedure
names from procedures like <Literal>user</Literal>, which are documented procedures.
Furthermore, the <Literal>_dcp</Literal> part of the name distinguishes <Command>dcecp</Command>
procedures from other Tcl procedures on a host.
</Para>
<Para>The <Literal>_dcp_create_user</Literal> procedure has an argument table defining
its available options.  This argument table differs from the script's
initial argument table in that it lacks the <Literal>command</Literal> keyword and
the <Literal>function_call</Literal> variable that define separate procedures in
the script. 
</Para>
<Para>Next it initializes variables entered either as options or as
attributes in a list.  A <Literal>process_attribute_list</Literal> procedure (at
the end of the example) actually parses attributes that have been
passed as a list.  Then it does the work of creating the user
information in the registry and in CDS.  Near the end, the cleanup
procedure <Literal>_dcp_cleanup_user_create</Literal> can undo a failed user create
operation.
</Para>
<InformalExample>
<Para><ProgramListing role="page-wide">
<?sml-point-size 10>
<!--no-op:  12-->
 .
 . [several low-level procedures omitted]
 .

#
# This procedure creates a principal in the current registry _s(sec)
# if that principal does not yet exist.
#

proc _dcp_create_principal_entry { principal_name princ_args} {


  set list_of_principals [principal catalog]
  if { [lsearch $list_of_principals $principal_name] == -1} {
    if { [llength $princ_args ] != 0 } {
      principal create $principal_name -attribute $princ_args
    } else 
  } else {
    error "Principal \"$principal_name\" already exists."
  }
}
<?sml-need 8>#
# proc _dcp_create_user - This procedure actually creates a DCE user. 
# Several steps are performed.  If the principal does not exist 
# a new one is created.  If the groups do not exist and a -force switch is
# set, then two new groups will be added.  The user will be added to the 
# groups.  The account will then be created.  An entry in the CDS 
# namespace will then be created with the appropriate ACLs.
#

proc _dcp_create_user { local_args } {
  set arg_table {
    {-alias string alias
          "Add principal named as an alias of specified uid."}
    {-attribute string attribute_list
          "Provide attributes in an attribute list format."}
    {-client string client 
          "Can the account principal be a client."}
    {-description string descr
           "A general description of the account."}
    {-dupkey string dupkey
           "Can the accounts' principal have duplicate keys."}
    {-expdate string expdate
           "When does the account expire."}
 .
 . [repetitive elements omitted]
 .

    {-uid integer uid 
         "User Identifier of the principal to be added."}}

# 
# Initializing some variables.
# 
    upvar 1 local_args cargs 
    set local_args $cargs
    set account_args ""    
    set princ_args ""
    set group_args ""
    set force 0

    parseargs $arg_table local_args -no_leftovers

    if { [info local help_prose ] > 0 } { return }

    if { [llength $local_args] > 1 } {
      error "Unrecognized argument [lindex $local_args 1]."  
    } elseif { [llength $local_args] == 0 } { error "No user name." 
    } else { set account_name $local_args }
<?sml-need 12># 
#  If parseargs returned attributes in a list instead of options, 
#  create an attribute list.  Then call process_attribute_list to 
#  parse the list.
# 
    if { [info local attribute_list] > 0} {
       set pile_of_attributes "alias client descr dupkey expdate\
       forwadabletkt fullname force group home organization maxtktlife \
       maxtktrenew mypwd password postdatedtkt proxiabletkt pwdvalid \
       renewabletkt server quota shell stdgtauth"
       process_attribute_list attribute_list $pile_of_attributes
    }
# 
# If user entered attributes as options rather than in a list,
# check for attribute options.
# 
    if { [info local group] > 0} {
      set account_args [format "%s {%s %s}" $account_args group $group] 
    } else { error "No group name specified." }

    if { [info local organization] > 0} {
      set account_args [format "%s {%s %s}" $account_args organiz \
	  $organization] 
    } else { error "No organization name specified." }

    if { [info local password] > 0} {
      set account_args [format "%s {%s %s}" $account_args password \
	  $password] 
    } else { error "No password specified." }

    if { [info local mypwd] > 0 } {
      set account_args [format "%s {%s %s}" $account_args mypwd $mypwd]  
    } else { error "No admin password specified." }
# 
# principal and group operations both use the principal's fullname
# 
    if { [info local fullname] > 0 } {
      set princ_args [format "%s {%s {%s}}" $princ_args fullname \
	  $fullname]
      set group_args [format "%s {%s {%s}}" $group_args fullname \
	  $fullname]
    }
   
    if { [info local uid] > 0 } { 
      set princ_args [format "%s {%s %s}" $princ_args uid $uid]
    }
 .
 . [repetitive elements omitted]
 .
    
<?sml-need 4>    if { [info local stdtgtauth] > 0 } {
       set account_args [format "%s {%s %s}" $account_args stdtgtauth \
           $stdtgtauth]
    }
<?sml-need 8># 
# set variables if entered as attributes in an attribute list
# 
    set account_name [lindex $account_name 0]
    set group_created 0
    set org_created 0
    set group_arg ""
    set org_arg ""
#     
# do the work - create principal, do group and organization
# operations, create the account, and create directory in CDS
# 
    foreach element $account_name {
      set clup_user "_dcp_cleanup_user_create $element -principal"

      _dcp_create_principal_entry $element $princ_args
      
      if { $force == 1 } {
  	if {[ catch {_dcp_create_group $group group_created} \
	    msg] != 0 } {
              _dcp_cleanup_user_create $element -principal
              error $msg
          }
          if { $group_created == 1 } {
             set group_arg "-group group"
          }
          if {[ catch {_dcp_create_org $organization org_created} \
	    msg] != 0 } {
              set clup_user [concat $clup_user $group_arg]
              eval $clup_user
              error $msg
          } 
          if { $org_created == 1 } {
              set org_arg "-org organization"
          }
      }
      set clup_user [concat $clup_user $group_arg $org_arg]
      if {[catch {_dcp_add_group_entry $group  $element} msg] != 0} {
          eval $clup_user
          error $msg
      }
  
      if {[catch {_dcp_add_org_entry $organization $element} msg] != 0 } {
	  eval $clup_user
          error $msg
      }
   
<?sml-need 5>      if {[catch {_dcp_add_account_entry $element $account_args} \
	msg] != 0} {
          eval $clup_user
          error $msg
      }
      
      if {[catch {_dcp_add_namespace_entry $element} msg] != 0} { 
          eval $clup_user
          error $msg
      }
    }
    set _n $account_name
    return 
}

# 
# _dcp_cleanup_user_create  - This function undoes changes after a
# failure in one of the user create functions as though the operation
# never occurred
# 

proc _dcp_cleanup_user_create {account_name args} {
     
     if { [lsearch $args -principal] != -1 } {
        principal delete $account_name 
     }
     if { [lsearch $args -group] != -1 } { 
        upvar 1 group clean_group
        group delete $clean_group
     }
     if { [lsearch $args -org] != -1 } {
        upvar 1 organization clean_org
        organization delete $clean_org
     }
}

#
# process_attribute_list - Takes an attribute_list and parses out the 
#                          appropriate attributes contained in the
#                          pile_of_attributes variable
#

proc process_attribute_list {attribute_list pile_of_attributes} {

   foreach element $pile_of_attributes { upvar 1 $element _dcp_$element }

   upvar 1 attribute_list _dcp_attribute_list

   set _dcp_attribute_list [check_list_list $_dcp_attribute_list]

<?sml-need 14>   foreach element $_dcp_attribute_list {
       if { [llength $element] != 2 } {
           error "Incorrect attribute list element 
<!--$element\"."-->
       }
       set attribute_name [lindex $element 0]
       set attribute_value [lindex $element 1]
       set _dcp_attr_name [info vars _dcp_$attribute_name*] 
       if {[llength $_dcp_attr_name] > 1} {
           error 
            "Ambiguous attribute "\$attribute_name\" could be: $_dcp_attr_name."
       }
       set [set _dcp_attr_name] $attribute_value
   }
}

proc check_list_list {attribute_list} {

   set not_list_list 0
   set i 1

   foreach element $attribute_list {
        if {[llength $element] != 2 &amp;&amp; [llength $attribute_list] &lt; 3} {
           if {$i == 1} {
              return [format "{%s}" $attribute_list]
           }
        }
        incr i
   }

   return $attribute_list
}
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
<Para RevisionFlag="Changed"><?og-ChangeStart def,13575,R1.2.2,Misc dcecp fixes">The next procedure we discuss in the <Literal>user</Literal> task object is one
that takes a single optional argument and returns lots of output
information: the <Literal>_dcp_show_user</Literal> procedure.  This procedure 
returns the results of <Command>principal show</Command>, and <Command>account show</Command> operations.
<?og-ChangeEnd def,13575,R1.2.2,Misc dcecp fixes"></Para>
<InformalExample>
<Para><ProgramListing><?sml-point-size 10>
<!--no-op:  13-->
#
#_dcp_show_user - This procedure shows the principal and account 
#                 attribute lists for a specified user.
#

proc _dcp_show_user {local_args} {

    upvar 1 local_args cargs 
    set local_args $cargs
  
    parseargs "" local_args -no_leftovers

    if { [info local help_prose ] > 0 } { return }

    if { [llength $local_args] > 1 } {
      error "Unrecognized argument [lindex $local_args 1]."  
    } elseif { [llength $local_args] == 0 } { error "No user name." 
    } else { set account_name $local_args }

    # Take the first element of the account_name in order to 
    # eliminate list nesting. 

    set account_name [lindex $account_name 0]
    set _dcp_principals [principal catalog -simplename]

    # Show each account that has been requested. 

    foreach element $account_name {
      if { [lsearch $_dcp_principals $element] == -1 } {
	error "User \"$element\" does not exist."
      } else {
	set _dcp_user_attributes [principal show $element]
      }

      set _dcp_accounts [account catalog -simplename]
      if { [lsearch $_dcp_accounts $element] == -1 } {
	error "User \"$element\" does not exist."
      } else {
	set _dcp_user_attributes [format "%s\n%s" \
	    $_dcp_user_attributes [account show $element -all]]
      }
    }
    return $_dcp_user_attributes

}
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="AGCC.CPSCR.div.5">
<Title>Using the parseargs Procedure</Title>
<Para><IndexTerm Id="AGCC.CPSCR.indx.13">
<Primary>scripts</Primary>
<Secondary>parsing arguments in</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPSCR.indx.14">
<Primary>parsing</Primary>
<Secondary>arguments in <Command>dcecp</Command> scripts</Secondary>
</IndexTerm>Task objects and scripts that take arguments or options can call the
<Filename>parseargs</Filename> procedure to parse arguments passed along with the
object or script invocation.  The <Filename>parseargs</Filename> procedure is a
script in a separate file that provides a convenient and reusable
method for argument parsing within a <Command>dcecp</Command> script.  The basic
syntax is
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>parseargs <Symbol Role="Variable">parse_options</Symbol> <Symbol Role="Variable">local_args</Symbol> <Symbol Role="Variable">args</Symbol> 
</UserInput></ProgramListing></Para>
</InformalExample>
<?sml-need 2>
<Para>The procedure relies on arguments passed to it by the calling script.
The <Filename>parseargs</Filename> procedure requires the following inputs:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">parse_options</Symbol></Term>
<ListItem>
<Para>The argument table (<Literal>arg_table</Literal>) describing the parsing options.
The <Symbol Role="Variable">parse_options</Symbol> argument can consist of 
five elements, as in the script's top-level argument table, or four 
elements as in lower-level argument
tables for called procedures within a script.  The two syntaxes for
<Symbol Role="Variable">parse_options</Symbol> are
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">verb</Symbol><Literal> command </Literal><Symbol Role="Variable">variable command_name </Symbol><Literal>"</Literal><Symbol Role="Variable">help string</Symbol><Literal>"
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<Para>or
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">-options type variable </Symbol><Literal>"</Literal><Symbol Role="Variable">help string</Symbol><Literal>"
</Literal></UserInput></ProgramListing></Para>
</InformalExample>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">verb</Symbol></Term>
<ListItem>
<Para>Provides top-level parsing.  Typically an operation contains an object
and a verb.  The verb portion generally calls another procedure.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>command</Literal></Term>
<ListItem>
<Para>A keyword indicating that the procedure being defined is a verb of an
object. 
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">variable</Symbol></Term>
<ListItem>
<Para>The name of the variable that holds the value of the
option.  When parsing verbs, the variable is named <Literal>function call</Literal>.
When parsing options, the variable is named for the option being
parsed.  For example, if the option name is <Option>alias</Option>, the variable
is named <Literal>alias</Literal>.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">command_name</Symbol></Term>
<ListItem>
<Para>The procedure name to store in the variable.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">help string</Symbol></Term>
<ListItem>
<Para>The string that describes the use of the verb or option.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">-options</Symbol></Term>
<ListItem>
<Para>The actual string value of the option to be parsed such as <Option>attribute</Option>
or <Option>mypwd</Option>.
<?sml-break><?sml-need 4></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">type</Symbol></Term>
<ListItem>
<Para>The type of variable to be associated with <Option>option</Option>. Acceptable
types are <Literal>integer</Literal>, <Literal>string</Literal>, <Literal>float</Literal>, <Literal>boolean</Literal>,
<Literal>command</Literal>, and <Command>help</Command>.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">local_args</Symbol></Term>
<ListItem>
<Para>The arguments to be parsed.  The <Filename>parseargs</Filename> procedure extracts all of
the recognized entries into a list and resets <Replaceable>local_args</Replaceable> with
the values that were not parsed (or not parsable).  For instance, a
top-level command like <Command>user create</Command> includes options that are
parsed later when the procedure implementing the <Literal>create</Literal>
operation is invoked within the script.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">args</Symbol></Term>
<ListItem>
<Para>One of two flags:
</Para>
<VariableList>
<VarListEntry>
<Term><Option>found_one</Option></Term>
<ListItem>
<Para>Tells the parser to return when one procedure
argument has been found.  In <Command>user create</Command>, for example, the parser would
return after one <Literal>create</Literal> command had been found and processed.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>no_leftovers</Option></Term>
<ListItem>
<Para>Looks for extra options and generates an error if one is found. 
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</ListItem>
</VarListEntry>
</VariableList>
<!-- The only time, currently, that parseargs returns useful message, besides -->
<!-- after an error. is when help or operations are type are requested.  In -->
<!-- this situation the help or operation string are returned. -->
<!-- -->
<!--   proc parseargs {parse_options local_args args} {-->
</Sect2>
<Sect2 Id="AGCC.CPSCR.div.6">
<Title>Invoking Task Objects</Title>
<Para><IndexTerm Id="AGCC.CPSCR.indx.15">
<Primary>scripts</Primary>
<Secondary>making available</Secondary>
</IndexTerm>Once your task object is written (and tested), you need to make it
available for use.  If your script is intended just for your personal
use, you can include it in your <Literal>.dcecprc</Literal> file and invoke it as
described in Section 3.1.
</Para>
<Para>Formal task objects require a few steps to make them behave like other
<Command>dcecp</Command> objects.
</Para>
<OrderedList>
<ListItem>
<Para>Log in as <Literal>root</Literal> and copy the finished script into the
<Symbol Role="Variable">dcelocal</Symbol><Filename>/dcecp</Filename> directory and set the file permissions to
executable. 
</Para>
</ListItem>
<ListItem>
<Para>Start <Command>dcecp</Command> and run the <Literal>auto_mkindex</Literal> utility.
This creates information that informs the DCE control program about
all available objects.  With root privileges, run the following command
in the directory where the task objects reside.  On UNIX systems, this
is often the <Symbol Role="Variable">dcelocal</Symbol><Filename>/dcecp</Filename> directory.
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 3>% <Literal>dcecp</Literal>
dcecp> <Literal>auto_mkindex /opt/dcelocal/dcecp *.dcp</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>To include the new task object name in the <Command>dcecp</Command> help screen,
edit the file <Filename>/opt/dcelocal/dcecp/help.dcp</Filename>.  This file is
displayed in response to the <Command>dcecp help</Command> operation.
</Para>
</ListItem>
</OrderedList>
<Para>You need to make this file available on each DCE host where the script
will be executed.  Generally this means copying the file to each host's
<Filename>/opt/dcelocal/dcecp</Filename> directory and then running the
<Literal>auto_mkindex</Literal> utility on the files in the directory.  You might
want to place the object name in the
<Filename>/opt/dcelocal/dcecp/help.dcp</Filename> file as well.
</Para>
<Para>As a convenience, you could write a script that uses the DCE control
program's <Command>hostdata</Command> object to create the file on each host.  The
script could then run the <Literal>auto_mkindex</Literal> utility using the
<Command>hostdata</Command> object's postprocessor attribute.  Chapter 9 contains
information on using the <Command>dcecp hostdata</Command> object.
<!-- .oS-->
<!-- proc _dcp_broadcast_file {} {-->
<!--     set f [COPYFILE??]-->
<!--     set x [directory list /.:/hosts]-->
<!--     foreach n $x {-->
<!--         if {[catch {object show $n/dts-entity}] == 0} {-->
<!--             set index [string last "/" $n] -->
<!--             set y [string range $n [incr index] end]-->
<!--             if {[catch {clock show $n/dts-entity} msg] == 0} {-->
<!-- HOSTDATA CREATE set i [expr 20 - [string length $y]]-->
<!--                 puts [format "Time on $y is %${i}s %s" " " \\-->
<!--                     [clock show $n/dts-entity]]-->
<!--             } else {-->
<!--                 set i [expr 20 - [string length $y]]-->
<!--                 puts [format "Time on $y is %${i}s %s" " " \\-->
<!--                     "Server not responding."]-->
<!--             }-->
<!--         }-->
<!--     }-->
<!-- }-->
<!-- .oE-->
<!-- 	- Use your platform's standard methods to make files executable.-->
<!-- 	- executed from the current working directory by typing its name after-->
<!-- 	  the \*Ldcecp source\*O command.-->
<!-- 	- executed from a directory named in the PATH environment variable by-->
<!-- 	   typing its name-->
<!-- 	-->
<!--   - explicitly contained in the file /opt/dcelocal/etc/dcecp/init.dcecp-->
<!--   - placed in the directory /opt/dcelocal/dcecp (RUN AUTOMKINDEX-->
<!--   -->
<!--   .H 3 "Invoking a Formal Task Object"-->
<!--   -->
<!--   While you can use any method described above the recommended method is-->
<!--   to ... (make it just like other dcecp objects). -->
</Para>
</Sect2>
</Sect1>
</Chapter>
<!--+ 10/31/96 16:05:54
    | tagMorph:  $Id: script.sgm,v 1.1.2.12 1996/12/09 17:32:34 carrig Exp $
    | tagMorph library:  $Id: script.sgm,v 1.1.2.12 1996/12/09 17:32:34 carrig Exp $
    | sml-to-docbook:  1.24
    +-->
