<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: intro.sgm,v $
# Revision 1.1.2.13  1996/12/09  17:25:10  carrig
# 	{enh,R1.2.2}
# 	No change
# 	[1996/12/09  17:24:56  carrig]
#
# Revision 1.1.2.12  1996/12/04  22:49:42  carrig
# 	{enh,R1.2.2}
# 	JC's edits
# 	[1996/12/04  22:47:38  carrig]
# 
# Revision 1.1.2.11  1996/11/29  20:21:15  carrig
# 	{enh,R1.2.2}
# 	Finished edit changes; must scale graphics
# 	[1996/11/29  20:18:03  carrig]
# 
# Revision 1.1.2.10  1996/11/27  21:43:59  carrig
# 	{enh,R1.2.2}
# 	More editor's comments
# 	[1996/11/27  21:42:11  carrig]
# 
# 	{enh,R1.2.2}
# 	More editor's comments
# 	[1996/11/27  21:29:00  carrig]
# 
# Revision 1.1.2.9  1996/11/26  21:45:35  carrig
# 	{enh,R1.2.2}
# 	Putting in editor's comments
# 	[1996/11/26  21:41:30  carrig]
# 
# Revision 1.1.2.8  1996/11/25  21:51:39  carrig
# 	{enh,R1.2.2}
# 	Started to put in editor's comments
# 	[1996/11/25  21:49:55  carrig]
# 
# Revision 1.1.2.7  1996/11/25  13:57:15  weir
# 	Fixed various Adept errors
# 	[1996/11/25  13:44:44  weir]
# 
# Revision 1.1.2.6  1996/11/07  21:16:01  weir
# 	Commented out some null revflags
# 	[1996/11/07  21:15:38  weir]
# 
# Revision 1.1.2.5  1996/11/07  20:43:52  weir
# 	Cleaned up history
# 	[1996/11/07  20:42:03  weir]
# 
# Revision 1.1.2.4  1996/11/06  20:41:06  carrig
# 	{enh,R1.2.2}
# 	OK for editing
# 	[1996/11/06  20:38:37  carrig]
# 
# Revision 1.1.2.3  1996/11/05  18:59:13  carrig
# 	{enh,R1.2.2}
# 	Second pass
# 	[1996/11/05  18:56:08  carrig]
# 
# Revision 1.1.2.2  1996/11/04  22:04:06  carrig
# 	{enh,R1.2.2}
# 	First pass at corrections
# 	[1996/11/04  22:00:50  carrig]
# 
# Revision 1.1.2.1  1996/11/01  18:21:02  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 	[1996/11/01  18:18:21  wardr]
# 
# Revision 1.1.1.2  1996/11/01  18:18:21  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 
# $EndLog$
-->
<!---->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- HISTORY-->
<!-- Revision 1.1.6.2  1996/09/27  13:49:51  weir-->
<!-- 	Test-->
<!-- 	[1996/09/27  13:49:16  weir]-->
<!---->
<!-- Revision 1.1.6.1  1996/09/19  13:42:36  sherman-->
<!-- 	[def,13462,R1.2.2]-->
<!-- 	Fixed Help commands]-->
<!-- 	[def,13460,R1.2.2]-->
<!-- 	Add key binding precedence text-->
<!-- 	[def,10868,R1.2.2]-->
<!-- 	Multiple commands separated by semi-colons-->
<!-- 	{def,13575,R1.2.2}-->
<!-- 	Miscellaneous dcecp corrections-->
<!-- 	{def,13461,R1.2.2}-->
<!-- 	Changing history command example-->
<!-- 	[1996/09/19  13:40:51  sherman]-->
<!-- -->
<!-- Revision 1.1.4.1  1996/03/12  15:35:25  wardr-->
<!-- 	{edit R1.2.1}-->
<!-- 	Release Edits-->
<!-- 	[1996/03/12  15:35:15  wardr]-->
<!-- -->
<!-- Revision 1.1.2.11  1995/05/25  19:01:04  rcb-->
<!-- 	PRENTICE HALL reformat: final changes-->
<!-- 	[1995/05/25  13:08:21  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat - index entries, odds and ends-->
<!-- 	[1995/03/27  19:48:31  rcb]-->
<!-- -->
<!-- 	prevented hyphenation of option names-->
<!-- 	[1995/03/09  14:58:21  rcb]-->
<!-- -->
<!-- 	fixed typo-->
<!-- 	[1995/03/08  16:47:54  rcb]-->
<!-- -->
<!-- 	fixes to header capitalization-->
<!-- 	[1995/03/08  16:18:19  rcb]-->
<!-- -->
<!-- 	additional 1.1 edit change-->
<!-- 	[1995/02/27  17:01:29  rcb]-->
<!-- -->
<!-- 	previous checkins include both incorporation of 1.1 edits and PH reformat-->
<!-- 	[1995/02/23  18:20:26  rcb]-->
<!-- -->
<!-- 	no change-->
<!-- 	[1995/02/23  14:31:49  rcb]-->
<!-- -->
<!-- 	PRENTICE HALL reformat-->
<!-- 	[1995/02/22  16:31:47  rcb]-->
<!-- -->
<!-- Revision 1.1.2.10  1994/10/28  12:40:28  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	Added index hits-->
<!-- 	[1994/10/28  12:40:04  wardr]-->
<!-- -->
<!-- Revision 1.1.2.9  1994/10/20  16:23:02  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	Final GA release edits-->
<!-- 	[1994/10/20  16:22:16  wardr]-->
<!-- -->
<!-- 	{edit R1.1}-->
<!-- 	Final fixes for the GA release-->
<!-- -->
<!-- Revision 1.1.2.8  1994/10/04  17:58:25  wardr-->
<!-- 	{enh, CR10014, R1.1}-->
<!-- 	prepare final draft of dcecp information-->
<!-- 	[1994/10/04  17:57:01  wardr]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/06/29  12:22:57  wardr-->
<!-- 	{edit R1.1}-->
<!-- 	Initial hooks for dcecp object descriptions-->
<!-- 	[1994/06/29  12:19:01  wardr]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/06/13  18:10:48  devobj-->
<!-- 	cr10872 - fix copyright-->
<!-- 	[1994/06/13  18:10:09  devobj]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/06/13  13:11:00  wardr-->
<!-- 	{enh, CR10014, R1.1}-->
<!-- 	fix typos in examples-->
<!-- 	[1994/06/13  13:10:15  wardr]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/05/18  12:14:46  wardr-->
<!-- 	{edit R1.1}SGML fixes-->
<!-- 	[1994/05/18  12:14:34  wardr]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/04/18  18:31:33  wardr-->
<!-- 	{enh, CR10014, R1.1}-->
<!-- 	dcecp work-->
<!-- 	[1994/04/18  18:29:58  wardr]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/04/14  20:42:23  wardr-->
<!-- 	checked out files-->
<!-- 	[1994/04/14  20:36:04  wardr]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/02/24  19:46:32  rom-->
<!-- 	{enh, 10014, R1.1}-->
<!-- 	Add new chapters for dcecp.-->
<!-- 	[1994/02/24  19:44:41  rom]-->
<!-- -->
<!-- -->
<!-- ************************************************************************-->
<!-- ADMINISTRATION GUIDE (Core)-->
<!-- -->
<!-- New Part I - The DCE Control Program -->
<!-- ************************************************************************-->
<Chapter Id="AGCC.CPINTR.div.1">
<Title>DCE Control Program Introduction</Title>
<Para>DCE is an integrated set of services that supports the development and
execution of distributed applications between heterogeneous networked
computers.  Each DCE environment (called a <Symbol Role="Variable">cell</Symbol>) maintains at least
the following core DCE services: 
</Para>
<ItemizedList>
<ListItem>
<Para>DCE Threads
</Para>
</ListItem>
<ListItem>
<Para>DCE Host Services
</Para>
</ListItem>
<ListItem>
<Para>DCE Cell Directory Service
</Para>
</ListItem>
<ListItem>
<Para>DCE Time Service
</Para>
</ListItem>
<ListItem>
<Para>DCE Security Service
</Para>
</ListItem>
</ItemizedList>
<Para>With the exception of DCE Threads, all of the core services require
administration in one way or another.  Some services, such as CDS and the 
DCE Security Service, usually need more managing than, say, 
the DCE Time Service,
which after you have set it up needs practically no intervention.
If your DCE cell consists of just a few computers and their users, you
could probably manage the naming, time, and security needs of users,
programs, and host systems by logging into individual hosts to perform
any necessary administration tasks.  But most cells will consist of
many, perhaps hundreds or even thousands, of computers and their users.
</Para>
<Para><?sml-need 9>Consequently, the core services in such large cells will likely be 
extensive and complex, with some services being replicated or even partitioned 
across multiple heterogeneous systems.  Some services, such as 
the DCE host services, will exist on every computer in the
cell.  Such large-scale operations demand an administrative interface
that provides consistent and uniform access to DCE administration
functions, wherever they reside, from any and every point in the cell.
This means that administrative operations must work consistently and
predictably regardless of the platform on which they execute.
</Para>
<Para><IndexTerm Id="AGCC.CPINTR.indx.1">
<Primary>DCE control program</Primary>
<Secondary>description of</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.2">
<Primary>DCE control program</Primary>
<SeeAlso>dcecp</SeeAlso>
</IndexTerm>The DCE control program (<Command>dcecp</Command>) 
fills this need, providing consistent, portable, extensible, and
secure access to nearly all DCE administration functions from any
point in a DCE cell.  <Command>dcecp</Command> implements all of the
operations previously performed by using various component control
programs.
</Para>
<Para><Command>dcecp</Command> further streamlines administration by
providing a number of <Replaceable>task objects</Replaceable> for performing complex DCE
operations.  For example, adding a host to a cell requires adding a
host principal to the registry, adding the principal to various
security groups and organizations, creating an account, placing host
information in CDS and probably setting some ACLs on CDS directories.
All of these operations can be accomplished using a single task object.
</Para>
<Sect1 Id="AGCC.CPINTR.div.2">
<Title>Flexible, Portable, and Extensible Administration</Title>
<IndexTerm Id="AGCC.CPINTR.indx.3">
<Primary>DCE control program</Primary>
<Secondary>benefits of</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.4">
<Primary>Tcl</Primary>
<See>Tool Command Language</See>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.5">
<Primary>Tool Command Language</Primary>
<Secondary>its use in <Command>dcecp</Command></Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.6">
<Primary>DCE control program</Primary>
<Secondary>its use of Tcl</Secondary>
</IndexTerm>
<Para><Command>dcecp</Command> is built on a portable command language called
Tcl (pronounced ``tickle''), which stands for Tool Command Language
developed by John K. Ousterhout at the University of California at
Berkeley, California.  Most computers provide a command language of
some sort to give users a flexible and extensible way to access and
use system capabilities.  For instance, many UNIX systems offer
shell language interpreters, and Digital Equipment Corporation's
OpenVMS operating system offers the Digital Command Language (DCL).
But these command languages are not always portable.  Commands and
scripts based on one command language might not work in other command
language environments. 
<!-- .P-->
<!-- Tcl, on the other hand, is a platform-independent command language-->
<!-- that runs on every system where DCE Version 1.1 is installed.  A Tcl-->
<!-- command interpreter and the DCE Control Program which uses it are-->
<!-- provided as part of the DCE Version 1.1 software.  The availability of-->
<!-- both the DCE control program and the Tcl command language offer-->
<!-- important benefits to DCE administrators:-->
</Para>
<Para><?sml-need 4>Tcl, on the other hand, is a platform-independent command language
that runs on every system where DCE is installed.  A Tcl
command interpreter and the DCE control program that uses it are
provided as part of the DCE software.  
</Para>
<Para>The availability of both the DCE control program and the DCE control
program language offer important benefits to DCE administrators:
<!-- .P-->
<!-- Tcl, on the other hand, is a platform-independent command language-->
<!-- that runs on every system where DCE Version 1.1 is installed.  The-->
<!-- \*Ldcecp\*O program's implementation of Tcl is called the DCE control-->
<!-- program language and its Tcl command interpreter is designed expressly-->
<!-- to support the DCE control program language.  Consequently, you will-->
<!-- likely have difficulty if you try to execute some generic (not DCE)-->
<!-- Tcl scripts using the \*Ldcecp\*O command interpreter.  The-->
<!-- availability of the DCE control program and the \*Ldcecp\*O language-->
<!-- offer important benefits to administrators:-->
</Para>
<ItemizedList>
<ListItem>
<Para>You can perform all routine DCE operations from within
a single administrative interface.
</Para>
</ListItem>
<ListItem>
<Para>Most DCE administrative operations are consistently and uniformly
executed from any DCE platform, allowing administrators to
manage just about all DCE operations from any DCE system
in the cell.  DCE platforms that are not UNIX systems
might not handle all DCE control program file operations.
</Para>
</ListItem>
<ListItem>
<Para><Command>dcecp</Command> provides administration <Symbol Role="Variable">objects</Symbol> with
names like <Literal>clearinghouse</Literal>, <Command>principal</Command>, and <Literal>endpoint</Literal>.
This direct approach makes DCE administration intuitive and
consistent.  While for now this has only the appearance of being
object oriented, it is an important step toward a true object-oriented
administration interface.
</Para>
</ListItem>
<ListItem>
<Para><Symbol Role="Variable">Task objects</Symbol> (high-level <Command>dcecp</Command> scripts that perform
complex DCE operations) reduce the training requirements for DCE
administrators.  One need not be a DCE guru to perform routine DCE
administrative tasks.
</Para>
</ListItem>
<ListItem>
<Para>You can adapt the supplied task objects to new uses or write new task
objects or scripts by using the <Command>dcecp</Command> operations along with more
general commands provided within Tcl.
</Para>
</ListItem>
<ListItem>
<Para>The <Command>dcecp</Command> language allows the use of variables, <Literal>if</Literal>
statements, looping functions and other programming operations that
let you boost the power of your operations.  For instance, looping
functions let you repeat operations on multiple objects such as users,
servers, or CDS entries.
</Para>
</ListItem>
<ListItem>
<?sml-need 4>
<Para>Administrators can easily share their tools because scripts 
can be moved to foreign platforms without change.  For
instance, enterprises with multiple cells could use <Command>dcecp</Command>
scripts to propagate a common cell configuration throughout the
enterprise.
</Para>
</ListItem>
</ItemizedList>
<Para RevisionFlag="Changed"><?og-ChangeStart def,13575,R1.2.2,Remove info on non-dcecp control programs">The DCE control program is an administrative interface that
you can use to manage most aspects of the DCE core components.  You
cannot use <Command>dcecp</Command> to manage every aspect of DCE.  For instance, <Command>dcecp</Command> cannot control GDS or DFS.  
<?og-ChangeEnd def,13575,R1.2.2,Remove info on non-dcecp control programs"></Para>
<Para>The chapters in Part 1 discuss how you can use <Command>dcecp</Command> 
to administer the core services in your DCE environment.  We also
discuss how to make your operations do more by using Tcl constructs on
the command line and by writing your own customized operations as
scripts.  We do not provide a complete discussion of Tcl or its
companion toolkit (called <Symbol Role="Variable">Tk</Symbol>) for the X11 window system.  For in-depth
discussions of these topics, refer to <Symbol Role="Variable">Tcl and the Tk Toolkit</Symbol>, John K. Ousterhout, (c)1994, Addison Wesley Publishing Company.
</Para>
</Sect1>
<Sect1 Id="AGCC.CPINTR.div.3">
<Title>DCE Administration Objects</Title>
<Para>A DCE cell consists of many things that need administration.  As
examples, CDS servers (<Symbol Role="Variable">clearinghouses</Symbol>), DTS clocks, and server
location information are all entities in a DCE cell that require
administration in one way or another.  The DCE control program treats
all of DCE's administrative entities as individual administration
objects.  
<IndexTerm Id="AGCC.CPINTR.indx.7">
<Primary>administration objects</Primary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.8">
<Primary>objects</Primary>
<Secondary><Command>dcecp</Command> administration</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.9">
<Primary>DCE control program</Primary>
<Secondary>administration objects</Secondary>
</IndexTerm></Para>
<Para>You operate on an entity by invoking its <Symbol Role="Variable">object</Symbol> name with
some operation.  For example, to check the time of a DTS clock, you
invoke the object's name (<Command>clock</Command>) and the desired operation
(<Literal>show</Literal>) as in the following:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>clock show</Literal>
1994-09-23-10:46:42.016-04:00I-----
dcecp> 
</ProgramListing></Para>
</InformalExample>
<Para>Each administrative entity in DCE has a corresponding administration
object in the DCE control program.  As a few examples, you can manage
CDS clearinghouse operations in a cell by using the <Literal>clearinghouse</Literal> object.  Manage application servers and their configuration information
on DCE hosts by using the <Literal>server</Literal> object.  Compare and manipulate
time information using the <Literal>utc</Literal> object.  Administer users in a DCE
cell with the <Literal>user</Literal> task object.  These examples represent just a few
of the <Command>dcecp</Command> administration objects.  All of the objects are listed
in the <Command>dcecp(8dce)</Command> reference page.
</Para>
</Sect1>
<Sect1 Id="AGCC.CPINTR.div.4">
<Title>Using the DCE Control Program</Title>
<Para>This section provides a quick look at how to start and stop the DCE
control program and how to perform operations.  Additional information
about these topics is contained in the <Command>dcecp</Command> reference pages.
</Para>
<Sect2 Id="AGCC.CPINTR.div.5">
<Title>Starting and Stopping dcecp</Title>
<Para><IndexTerm Id="AGCC.CPINTR.indx.10">
<Primary>DCE control program</Primary>
<Secondary>starting and stopping</Secondary>
</IndexTerm>You can enter <Command>dcecp</Command> operations directly from your operating
system prompt or from within the DCE control program.  If you are
performing just one or two simple <Command>dcecp</Command> operations, you can
invoke them directly at the operating system prompt.  
</Para>
<Para>If you will be doing several operations, you can invoke the DCE
control program and then enter operations at the <Command>dcecp</Command>
prompt.  This method offers several advantages.
</Para>
<ItemizedList>
<ListItem>
<Para>It is more efficient for multiple operations because
<Command>dcecp</Command> is initialized once rather than for each separate operation.
</Para>
</ListItem>
<ListItem>
<Para>The program stores operations in a history facility so they can be
recalled and reused.
</Para>
</ListItem>
<ListItem>
<Para>You avoid the extra keystrokes needed to precede
each operation with the <Command>dcecp</Command> command.
</Para>
</ListItem>
</ItemizedList>
<Para>The following example shows how to invoke the DCE control program and
perform a <Command>directory</Command> operation:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 3>% <Literal>dcecp</Literal>
dcecp> <Literal>directory create /.:/hosts/appserver2 </Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 3>When you are through using the DCE control program, use the <Command>exit</Command>
or <Command>quit</Command> operation to stop the program and return to the
operating system prompt.  The following example illustrates using
the <Command>exit</Command> operation:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>exit</Literal>
%
</ProgramListing></Para>
</InformalExample>
</Sect2>
<Sect2 Id="AGCC.CPINTR.div.6">
<Title>Invoking dcecp Operations</Title>
<IndexTerm Id="AGCC.CPINTR.indx.11">
<Primary>DCE control program</Primary>
<Secondary>invoking operations</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.12">
<Primary>operations</Primary>
<Secondary>invoking</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.13">
<Primary>DCE control program</Primary>
<Secondary>command-line operations</Secondary>
</IndexTerm>
<Para>If you are performing a single <Command>dcecp</Command> operation, you can invoke
it directly from the operating system prompt.  Just precede the
desired operation with the <Command>dcecp</Command> command and the <Option>c</Option> (command-line operation) flag, as follows:
</Para>
<InformalExample>
<Para><ProgramListing>% <Literal>dcecp -c directory list /.:/subsys -simplename</Literal>
HP applications dce sales eng admin accts
% <Literal>dcecp -c cell show</Literal>
{secservers
 /.../my_cell.goodco.com/subsys/dce/sec/master}
{cdsservers 
 /.../my_cell.goodco.com/hosts/krypton}
{dtsservers 
 /.../my_cell.goodco.com/hosts/mars}
{hosts
 /.../my_cell.goodco.com/hosts/earth
 /.../my_cell.goodco.com/hosts/jupiter
 /.../my_cell.goodco.com/hosts/kyrpton
 /.../my_cell.goodco.com/hosts/mars
 /.../my_cell.goodco.com/hosts/mercury
 /.../my_cell.goodco.com/hosts/neptune
 /.../my_cell.goodco.com/hosts/pluto
 /.../my_cell.goodco.com/hosts/saturn
 /.../my_cell.goodco.com/hosts/uranus
 /.../my_cell.goodco.com/hosts/venus}
%
</ProgramListing></Para>
</InformalExample>
<Para><?sml-need 4>You can also enter some limited multiple operations using the
; (semicolon) as a command separator and enclosing the operations in
"" (double quotes). The following example adds a principal to the registry
and then checks that the principal is added:
</Para>
<InformalExample>
<Para><ProgramListing>% <Literal>dcecp -c "principal create S_Preska ; principal show S_Preska"</Literal>
{fullname {}}
{uid 28}
{uuid 0000001c-dc77-21cd-b700-0000c08adf56}
{alias no}
{quota unlimited}
%
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="AGCC.CPINTR.indx.14">
<Primary>DCE control program</Primary>
<Secondary>multiple operations</Secondary>
</IndexTerm>Be careful entering multiple operations via the <Command>dcecp</Command> command
with the <Option>c</Option> option because operation results return to the
<Command>dcecp</Command> interpreter, not to the shell.  An operation like the
following returns the results of just the last operation (<Literal>group list
users</Literal>) to the shell:
</Para>
<InformalExample>
<Para><ProgramListing>% <Literal>dcecp -c "group list staff; group list managers; group list users"</Literal>
/.../ward_cell.osf.org/P_Pestana
/.../ward_cell.osf.org/R_Parsons
/.../ward_cell.osf.org/L_Jones
/.../ward_cell.osf.org/S_Preska
/.../ward_cell.osf.org/N_Long
/.../ward_cell.osf.org/D_Witt
/.../ward_cell.osf.org/C_Pilat
 .
 .
 .
%
</ProgramListing></Para>
</InformalExample>
<Para RevisionFlag="Changed"><?og-ChangeStart def,10868,R1.2.2,Added multiple commands">This particular problem can be overcome by:
</Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed"><?sml-need 13>% <Literal>dcecp -c "puts [group list staff]; puts [group list manager]; puts [group list users]"</Literal>
   .
   .
   .
%
</ProgramListing></Para>
</InformalExample>
<?og-ChangeEnd def,10868,R1.2.2,Added multiple commands">
<Para><IndexTerm Id="AGCC.CPINTR.indx.15">
<Primary>scripts</Primary>
<Secondary>invoking</Secondary>
</IndexTerm>To invoke a <Command>dcecp</Command> script, omit the <Option>c</Option> argument but
include the name of the script.  The following example invokes a script
that lists the names of all hosts in the cell in alphabetical order:
</Para>
<InformalExample>
<Para><ProgramListing><?sml-need 13>% <Literal>dcecp list_hosts</Literal>
earth
jupiter
krypton
mars
mercury
neptune
planets
pluto
saturn
uranus
venus
%
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="AGCC.CPINTR.indx.16">
<Primary>DCE control program</Primary>
<Secondary>invoking operations</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.17">
<Primary>operations</Primary>
<Secondary>invoking within <Command>dcecp</Command></Secondary>
</IndexTerm>When you want to invoke complex or multiple operations, you might want
to invoke operations from within <Command>dcecp</Command>.  The program
provides a convenient history facility and a command-line editing
capability that is useful for recalling and reusing previous
operations.  The following example operations invoke <Command>dcecp</Command>
and add a new user to a DCE cell:
</Para>
<InformalExample>
<Para><ProgramListing>% <Literal>dcecp</Literal>
dcecp> <Literal>principal create J_Jones </Literal>
dcecp> <Literal>group add users -member J_Jones</Literal>
dcecp> <Literal>organization add staff -member J_Jones</Literal>
dcecp> <Literal>account create J_Jones -group users -organization staff \</Literal>
> <Literal>-password change.me -mypwd mxyzptlk</Literal>
dcecp> 
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="AGCC.CPINTR.indx.18">
<Primary>DCE control program</Primary>
<Secondary>abbreviations</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.19">
<Primary>abbreviations</Primary>
</IndexTerm>All <Command>dcecp</Command> object, operation, and option names can be abbreviated
to the shortest unique string when used interactively.  These names
have been chosen with this in mind so that unique abbreviations are
usually not more than one or two characters.
</Para>
<Para>Avoid using object or command abbreviations within scripts as
this limits a script's portability.  Users defining their own commands
could alter the uniqueness of abbreviations, resulting in ambiguous
command names or object names.
</Para>
</Sect2>
</Sect1>
<Sect1 Id="AGCC.CPINTR.div.7">
<Title>Doing More with dcecp</Title>
<Para><IndexTerm Id="AGCC.CPINTR.indx.20">
<Primary>DCE control program</Primary>
<Secondary>uses of</Secondary>
</IndexTerm>The DCE control program accepts commands ranging from simple to
complex, with more complex commands offering greater strength and
versatility.  Although simple commands are the easiest to compose, they
are also limited, usually to performing one operation on a single
object.  So while it is always possible to enter simple commands,
you will probably find that, at times, you want to repeat operations over
several or even many objects, or to perform some operation only under
certain conditions.  For instance you might want to add some entry to a
CDS directory only if some other specified entry already exists in
CDS. <Command>dcecp</Command> makes this possible by utilizing Tcl's
built-in commands that imitate elements commonly found in numerous
programming and shell languages.
<!-- Any control program's main purpose is to interpret commands.  While-->
<!-- simple commands are the easiest to compose, they are also limited,-->
<!-- usually to performing one operation on a single object. -->
</Para>
<Para>The DCE control program contains many C-like constructs that control
command execution.  Some examples are <Literal>if</Literal> statements for conditional
execution, looping commands such as <Literal>while</Literal>, <Command>for</Command>, and
<Command>foreach</Command> used to repeat operations under various conditions, a
<Literal>case</Literal> command for testing values against various patterns, and
<Command>proc</Command> for writing your own customized commands.
</Para>
<Para>The DCE control program also includes other syntactic elements such as
"" (quotes), { } (braces), [ ] &nbsp; (brackets), and \ (backslash),
which it uses to group elements together and for controlling
interpretation of special characters.
</Para>
<Para>Although many features are designed for use in scripts, you will
probably find yourself using some constructs and elements
(particularly quotes, braces, brackets, and backslashes) in
interactive operations as well.  You will need to decide when it makes
sense to perform operations interactively or to use a script.  In general,
complexity and potential for reuse can help you decide.
<!-- DCE Version 1.1 provides several scripts for performing common DCE-->
<!-- operations.  Nevertheless, you may want to modify or adapt these in-->
<!-- some ways or you might want to develop your own scripts.-->
</Para>
<Para>Now let us look at a couple of simple examples that illustrate some DCE
control program and Tcl basics.  Some <Command>dcecp</Command> operations can be very
straightforward like
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>account modify N_Long -expdate 1996-06-30 </Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>This operation lets you change information in the DCE Security Service
registry.  Here, we are changing the account expiration date for the
principal (<Literal>N_Long</Literal>) named in the command line.  While it is relatively
simple to execute this operation for one or two principals, it is more
difficult to change the account expiration date for many principals.
</Para>
<Para><?sml-need 5>Imagine that your organization employs six temporary workers and the
project they are associated with has been extended for three months.
Rather than execute the <Command>account modify</Command> operation six times, you
can use a <Command>dcecp</Command> <Command>foreach</Command> command to loop (repeat) an action for
each item of a list:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>foreach i {N_Long L_Jones P_Sawyer \ </Literal>
> <Literal>D_Witt M_Dougherty S_Preska} { \ </Literal>
> <Literal>account modify $i -expdate 1996-06-30 }</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>In the example, the <Command>foreach</Command> looping command has three arguments:
a variable, a list, and the body.  The variable <Literal>i</Literal> substitutes
sequentially for each item in the list (<Literal>N_Long</Literal>, <Literal>L_Jones</Literal>, 
and so on). 
The <Command>foreach</Command> command executes the body (<Literal>account
modify $i -expdate 1996-06-30</Literal>) for each item in the list.
The <Literal>$i</Literal> variable in 
the body takes on the value of each principal name in the
list, in turn, until all items in the list have been used.  See
Section 2.9.2 for more detailed information about looping commands.
</Para>
<Para>This example illustrates several other important syntax rules.  The
DCE control program uses { } (braces) to determine where command
arguments, such as the script body, begin and end.  For example, the
<Command>foreach</Command> command has three arguments: a variable name, a list,
and a script body.  Normally, command arguments are separated by spaces.
To prevent <Command>dcecp</Command> from incorrectly interpreting the spaces
between list elements as argument separators, we use braces to enclose
the list and disable special interpretation of the spaces.  Thus, all of
the list elements appear as one argument.  Similarly, we use braces to
enclose the individual elements in the script body.
</Para>
<Para>Braces also help <Command>dcecp</Command> determine whether a command is complete;
incomplete commands will have more opening than closing braces.  The
lack of a closing brace at the end of the first line signals
<Command>dcecp</Command> that more command input is coming, so <Command>dcecp</Command> prompts
with the secondary prompt (&gt;). Similarly, the opening brace at the end
of line 2 signals that you are still not finished entering the
command.  This lets you wrap lines without using a \ (backslash) line
wrap character.  The DCE control program executes the command when you
press <Literal>&lt;Return&gt;</Literal>
after the closing brace at the end of line 3.  Chapter 2
contains more information about braces.
</Para>
<Para><?sml-need 5>Now assume that, instead of six temporary workers, your
organization has fifty temporary workers (all in one group called
<Literal>temps</Literal>) for whom you want to add three-month account extensions. We'll still use the <Command>foreach</Command> command but, rather than write all fifty principals directly in the list, use the <Command>dcecp</Command> <Literal>group list temps</Literal> operation to generate a list for you, as follows:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>foreach i [group list temps] {</Literal>
> <Literal>account modify $i -expdate 1996-06-30 } </Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>In this example, we have put the <Literal>group list temps</Literal>
operation in [ ] (brackets).  Called <Symbol Role="Variable">command substitution</Symbol>,
this technique replaces the command inside the brackets with
the results returned by that command.  The results of the <Literal>group
list temps</Literal> operation produces a valid Tcl list that might look
like the following:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>group list temps</Literal>
N_Long
L_Jones
P_Sawyer
D_Witt
M_Dougherty
S_Preska
 .
 .
 .
J_Jones
</ProgramListing></Para>
</InformalExample>
<Para>Here, we have provided a high-level look at some practical uses of
<Command>dcecp</Command>. Of course there is a lot we have not seen, too.  In the next
chapter we will look more closely at some of the <Command>dcecp</Command> operations
that you are likely to use for DCE administration.  Remember that
<Command>dcecp</Command> is based on Tcl, and Tcl has other commands and command
variations we will not discuss.  So be sure you have access to the
standard Tcl publications for detailed information on all of the
commands.
</Para>
</Sect1>
<Sect1 Id="AGCC.CPINTR.div.8">
<Title>When to Use an Interactive Command or Script</Title>
<Para>There is no absolute dividing line for when you should enter commands
interactively or with a script.  In general though, the simpler
operations&mdash;those that perform one or maybe two tasks&mdash;make
the best candidates for interactive use.  The following examples typify
interactive operations:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>directory create /.:/printers</Literal>

dcecp> <Literal>account show w_shakespeare</Literal>

dcecp> <Literal>server start /.:/hosts/curley/config/srvrconf/BBSserver</Literal>
</ProgramListing></Para>
</InformalExample>
<Para>The next example is a little more complicated, so at first you might
choose to run this as a script: 
</Para>
<InformalExample>
<Para><ProgramListing>foreach i [group list temps] {
   account modify $i -expdate 1996-06-30}
</ProgramListing></Para>
</InformalExample>
<Para>Saving a frequently used operation as a script (in a file) has its
advantages; it can help to automate repetitive or complicated tasks
and you can keep it around for possible modification and use in other
situations later on.  Whichever method you choose, as you become more
comfortable using <Command>dcecp</Command> and Tcl, you might find yourself entering
fairly complex operations interactively.  For information on how to
how to create and invoke scripts, refer to Section 1.8.
</Para>
</Sect1>
<Sect1 Id="AGCC.CPINTR.div.9">
<Title>Editing Command Lines </Title>
<Para>We have seen some basic ways to enter interactive <Command>dcecp</Command> commands.
But let us say that now you want to edit the command you are entering or
that you want to recall and modify a command you entered previously.
The DCE control program offers several ways to edit commands.  You can
edit a current command line by using the command-line editing facility.
You can use the <Command>history</Command> command to recall, edit, and reissue a
previously used command.
</Para>
<Sect2 Id="AGCC.CPINTR.div.10" RevisionFlag="Changed">
<Title>Editing the Current Command Line</Title>
<Para><IndexTerm Id="AGCC.CPINTR.indx.21">
<Primary>DCE control program</Primary>
<Secondary>command-line editing</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.22">
<Primary>editing</Primary>
<Secondary>DCE control program</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.23">
<Primary>command-line editing</Primary>
</IndexTerm>You can edit a command line before sending it to <Command>dcecp</Command> by
typing control characters or escape sequences that resemble <Command>ksh</Command>
or <Filename>emacs</Filename> editing commands.  A <Symbol Role="Variable">control character</Symbol>, shown as 
<Literal>&lt;Ctrl-</Literal><Symbol Role="Variable">x</Symbol><Literal>></Literal>, where <Symbol Role="Variable">x</Symbol> is a letter, is entered by holding down
<Literal>&lt;Ctrl></Literal> (or <Literal>&lt;Control></Literal>)
and pressing the letter key.  For example,
<Literal>&lt;Ctrl-A></Literal> is <Literal>&lt;Ctrl></Literal> and 
<Literal>&lt;A></Literal>, pressed at the same time.
Enter an <Symbol Role="Variable">escape sequence</Symbol> by pressing <Literal>Escape</Literal>
followed by one or more characters.  In an escape sequence,
<Literal>&lt;Escape&gt;</Literal> is referred to as <Literal>ESC</Literal>, as in <Literal>&lt;ESC&ensp;f></Literal>
for example.  Case matters in escape sequences (unlike
control characters, which do not distinguish between upper and lower case);
<Literal>&lt;ESC&ensp;F></Literal> is not the same as <Literal>&lt;ESC&ensp;f></Literal>.
</Para>
<Para>You can enter an editing command anywhere on the line, not just at the
beginning.  In addition, a return may also be pressed anywhere on the line,
not just at the end.
</Para>
<Para>Most editing commands accept a repeat count, <Symbol Role="Variable">n</Symbol>,
where <Symbol Role="Variable">n</Symbol> is a number.  Enter a repeat count by pressing
<Literal>&lt;Escape&gt;</Literal>, the number, and then the command to execute.  For example,
<Literal>&lt;ESC&ensp;4></Literal><Literal>&lt;Ctrl-f></Literal> moves forward four characters.  Some of the
descriptions that follow are marked with [<Symbol Role="Variable">n</Symbol>] to identify
commands that accept a repeat count.
</Para>
<Para>The following control characters are accepted:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>&lt;Ctrl-A></Literal></Term>
<ListItem>
<Para>Move to the beginning of the line
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-B></Literal></Term>
<ListItem>
<Para>Move left (backward) [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-D></Literal></Term>
<ListItem>
<Para>Delete character [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-E></Literal></Term>
<ListItem>
<Para>Move to end of line
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-F></Literal></Term>
<ListItem>
<Para>Move right (forward) [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-G></Literal></Term>
<ListItem>
<Para>Ring the bell
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-H></Literal></Term>
<ListItem>
<Para>Delete character before cursor (<Literal>&lt;Backspace&gt;</Literal>) [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-I></Literal></Term>
<ListItem>
<Para>Complete filename (<Literal>&lt;Tab&gt;</Literal>); see following text
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-J></Literal></Term>
<ListItem>
<Para>Done with line (<Literal>&lt;Return&gt;</Literal>)
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-K&gt;</Literal></Term>
<ListItem>
<Para>Kill to end of line (or column [<Symbol Role="Variable">n</Symbol>])
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-L&gt;</Literal></Term>
<ListItem>
<Para>Redisplay line
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-M&gt;</Literal></Term>
<ListItem>
<Para>Done with line (alternate <Literal>&lt;Return&gt;</Literal>)
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-N&gt;</Literal></Term>
<ListItem>
<Para>Get next line from history [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-P&gt;</Literal></Term>
<ListItem>
<Para>Get previous line from history [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-R&gt;</Literal></Term>
<ListItem>
<Para>Search backward (forward if [<Symbol Role="Variable">n</Symbol>]) through history for
text; must start line if text begins with an up arrow
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-T&gt;</Literal></Term>
<ListItem>
<Para>Transpose characters
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-V&gt;</Literal></Term>
<ListItem>
<Para>Insert next character, even if it is an edit command
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-W&gt;</Literal></Term>
<ListItem>
<Para>Wipe to the mark
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>&lt;Ctrl-X&gt;&lt;Ctrl-X&gt;</Literal></Term>
<ListItem>
<Para>Exchange current location and mark
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-Y&gt;</Literal></Term>
<ListItem>
<Para>Yank back last killed text
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-[&gt;</Literal></Term>
<ListItem>
<Para>Start an escape sequence
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-]&gt;</Literal><Symbol Role="Variable">C</Symbol></Term>
<ListItem>
<Para>Move forward to next character <Symbol Role="Variable">C</Symbol>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;Ctrl-?&gt;</Literal></Term>
<ListItem>
<Para>Delete character before cursor (<Literal>&lt;Delete&gt;</Literal>) [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>The following escape sequences are accepted:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>&lt;ESC&gt;&lt;Ctrl-H&gt;</Literal></Term>
<ListItem>
<Para>Delete previous word (<Literal>&lt;Backspace&gt;</Literal>) [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>&lt;ESC&ensp;DEL&gt;</Literal></Term>
<ListItem>
<Para>Delete previous word (<Literal>&lt;Delete&gt;</Literal>) [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>&lt;ESC&ensp;SPC&gt;</Literal></Term>
<ListItem>
<Para>Set the mark (<Literal>&lt;Spacebar&gt;</Literal>); see <Literal>&lt;Ctrl-X&gt;&lt;Ctrl-X&gt;</Literal> and <Literal>&lt;Ctrl-Y&gt;</Literal>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;.&gt;</Literal></Term>
<ListItem>
<Para>Get the last (or [<Symbol Role="Variable">n</Symbol>th]) word from previous line
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;?&gt;</Literal></Term>
<ListItem>
<Para>Show possible completions; see following text
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;&lt;&gt;</Literal></Term>
<ListItem>
<Para>Move to start of history
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;&gt;&gt;</Literal></Term>
<ListItem>
<Para>Move to end of history
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;b&gt;</Literal></Term>
<ListItem>
<Para>Move backward a word [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;d&gt;</Literal></Term>
<ListItem>
<Para>Delete word under cursor [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;f&gt;</Literal></Term>
<ListItem>
<Para>Move forward a word [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;l&gt;</Literal></Term>
<ListItem>
<Para>Make word lowercase [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;u&gt;</Literal></Term>
<ListItem>
<Para>Make word uppercase [<Symbol Role="Variable">n</Symbol>]
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;y&gt;</Literal></Term>
<ListItem>
<Para>Yank back last killed text
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;w&gt;</Literal></Term>
<ListItem>
<Para>Make area up to mark yankable
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>&lt;ESC&ensp;</Literal><Symbol Role="Variable">nn</Symbol><Literal>></Literal></Term>
<ListItem>
<Para>Set repeat count to the number <Symbol Role="Variable">nn</Symbol>
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<?og-ChangeStart def,13460,R1.2.2,Added key binding text precedence">
<Para>In some cases, existing terminal key bindings take
precedence over these <Command>dcecp</Command> control keys.  In particular, the
bindings used for <Literal>erase</Literal>, <Command>kill</Command>, <Literal>eof</Literal>, <Literal>intr</Literal>, <Command>quit</Command>, 
and <Literal>susp</Literal> in
your environment will supercede any <Command>dcecp</Command> bindings for those
same control keys.
In most instances, control keys will not be interpreted by the
terminal but will be passed through to <Command>dcecp</Command>.  One of the few
exceptions is <Command>lnext</Command> (literal next),
which quotes the next character typed.  When you type the
control key that is bound to <Command>lnext</Command> it is interpreted by the
terminal, which will pass the next character typed through to
<Command>dcecp</Command>.
<?og-ChangeEnd def,13460,R1.2.2,Added key binding text precedence"></Para>
<Para>The DCE control program also provides filename completion.  Suppose
the root directory has the following files in it:
</Para>
<InformalExample>
<Para><ProgramListing>bin	vmunix
core	vmunix.old
</ProgramListing></Para>
</InformalExample>
<Para>If you type <Literal>rm&ensp;/v</Literal> and then press
<Literal>&lt;Tab&gt;</Literal>, the command processor
completes as much of the name as
possible by adding <Literal>munix</Literal>.  Because the example name
is not unique, it beeps.  If you press
<Literal>&lt;Escape&gt;</Literal> followed by the ? (question mark), 
it displays the two choices.  The command processor
completes the filename when you then enter the period (which makes the
name unique) followed by 
<Literal>&lt;Tab&gt;</Literal>, as shown in the following:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>rm /v &lt;Tab&gt;munix.&lt;Tab&gt;old
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>In this example, the constant width font indicates text automatically
entered by the command processor.
</Para>
</Sect2>
<Sect2 Id="AGCC.CPINTR.div.11">
<Title>Editing Command Lines with the history Command</Title>
<Para><IndexTerm Id="AGCC.CPINTR.indx.24">
<Primary>DCE control program</Primary>
<Secondary>history</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.25">
<Primary>editing</Primary>
<Secondary>using the history facility</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.26">
<Primary>history</Primary>
<Secondary>DCE control program</Secondary>
</IndexTerm>Sometimes when you are entering interactive commands, you want to
recall and reuse a previously entered command.  Let us say you list the
objects in a CDS directory and then you modify one of the objects.  Now
you want to list the objects again to verify that your modification
took effect.  You can use the <Command>history</Command> command to recall, edit,
and reissue a previously used command.  The history facility saves
only interactive commands.  Commands issued from scripts are not saved
and cannot be recalled. 
</Para>
<Para>The <Command>history</Command> command takes various arguments depending on what you
want to do.  Entering <Command>history</Command> with no arguments lists all the
commands (called <Symbol Role="Variable">events</Symbol>) entered during the current invocation of
<Command>dcecp</Command>, as shown:
</Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed"><?sml-point-size 11>
<!--no-op:  13-->
<?sml-need 8><?og-ChangeStart def,13461,R1.2.2,Add history to list">dcecp> <Literal>history</Literal>
     1  principal create wardr -fullname {Ward Rosenberry} \
          -quota unlimited
     2  group add users -member wardr
     3  organization add consultants -member wardr
     4  account create wardr -mypwd mxyptlk -password qwerty \
          -group users -organization consultants
     5  history
dcecp>
</ProgramListing></Para>
</InformalExample>
<?sml-point-size 12>
<!--no-op:  14-->
<?og-ChangeEnd def,13461,R1.2.2,Add history to list">
<Para>Each history event is independent of previous events.  This means that, if a 
recalled command used a variable, its current value may not be the
same as when it was first entered.  The <Command>history</Command> command itself
generates a history event, too. 
</Para>
<Para>By default, the history list keeps the 20 most recent commands.
You can use the <Literal>history keep</Literal> command to lengthen or shorten the
history list.  For example, the following command lengthens the history
list to keep the 50 most recent events:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>history keep 50</Literal>
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>You can specify events in various ways.  Positive numbers specify
events relative to the earliest event in the list.  Negative numbers
specify events relative to the most recent command.  You can also specify
an event by typing characters that match all or part of a previous
event.
</Para>
<Para>The history facility lets you reuse previous events in many ways.  The
following discussion covers just a few of the history commands you can
use. 
</Para>
<ItemizedList>
<ListItem>
<Para>You can execute a previous command without revision by using the <Literal>history
redo</Literal> command: 
</Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed"><?og-ChangeStart def,13461,R1.2.2,Add history to list">dcecp> <Literal>history</Literal>
           1 directory show /.:/printers
           2 object create /.:/printers/ascii_printer1
           3 object create /.:/printers/ascii_printer2
           4 object create /.:/printers/ascii_printer3
           5 history
dcecp> <Literal>history redo directory</Literal>
directory show /.:/printers
 .
 . [output omitted]
 .
dcecp>
<?og-ChangeEnd def,13461,R1.2.2,Add history to list"></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 10>
<IndexTerm Id="AGCC.CPINTR.indx.27">
<Primary>abbreviations</Primary>
</IndexTerm>You can save the most typing by entering just the unique first
characters of words in a history command.  For instance, you can enter
the <Literal>history redo directory</Literal> command from the previous example as
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>hi r d</Literal>
directory show /.:/printers
 .
 . [output omitted]
 .
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>Other ways to redo commands include <Literal>!!</Literal>, which recalls the most
recent command, and <Literal>!</Literal><Symbol Role="Variable">event number</Symbol> to recall a specific event.
</Para>
</ListItem>
<ListItem>
<IndexTerm Id="AGCC.CPINTR.indx.28">
<Primary>substitutions</Primary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.29">
<Primary>editing</Primary>
<Secondary>command lines</Secondary>
<Tertiary>substitutions</Tertiary>
</IndexTerm>
<Para>You can revise and reexecute a previous command by using the <Literal>history
substitute</Literal> command.  A common use of this command is to
correct typing mistakes.  The command syntax is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>history substitute <Symbol Role="Variable">old new</Symbol> [<Symbol Role="Variable">event number</Symbol>]
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>If you omit the <Symbol Role="Variable">event number</Symbol>, you'll redo the most recent
command.  Replace the <Symbol Role="Variable">old</Symbol> part of the recalled command with
<Symbol Role="Variable">new</Symbol> information:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>history</Literal>
           1 directory show /.:/printers
           2 object create /.:/printers/ascii_printer1
           3 object create /.:/printers/ascii_printer2
           4 object create /.:/printers/ascii_printer3
           5 directory show /.:/printers
           6 history
dcecp> <Literal>hi s printer3 printer4 -3</Literal>
object create /.:/printers/ascii_printer4
dcecp> 
</ProgramListing></Para>
</InformalExample>
<Para>You can also recall and revise the most recent command by using the
<Literal>&caret;</Literal><Symbol Role="Variable">old</Symbol><Literal>&caret;</Literal><Symbol Role="Variable">new</Symbol> syntax familiar to users of the 
UNIX <Command>csh</Command> shell, as follows:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>&caret;4&caret;5</Literal>
object create /.:/printers/ascii_printer5
dcecp>
</ProgramListing></Para>
</InformalExample>
</ListItem>
</ItemizedList>
</Sect2>
</Sect1>
<Sect1 Id="AGCC.CPINTR.div.12">
<Title>Using the dcecp Help Facilities</Title>
<!--

<Para RevisionFlag="Changed"><?og-ChangeStart def,13462,R1.2.2,Fixed dcecp Help output">
<IndexTerm Id="AGCC.CPINTR.indx.30">
<Primary>DCE control program</Primary>
<Secondary>getting help</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.31">
<Primary>help</Primary>
<Secondary>for the DCE control program</Secondary>
</IndexTerm>The DCE control program offers help in several ways:
</Para>

-->

<ItemizedList>
<ListItem>
<Para RevisionFlag="Changed">If you want to see a list of objects provided by the DCE control
program, enter <Command>help</Command> at the <Command>dcecp</Command> prompt as shown in the
following example:
</Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed" role="page-wide">
<?sml-point-size 9>
<!--no-op:  11-->
dcecp> <Literal>help</Literal>
The general format of all dcecp commands is as follows:
  dcecp> &lt;object> &lt;operation> [argument] [options]

In addition to all of the standard tcl commands, dcecp supports many
commands to administer DCE objects.  A dcecp object or task represents
a DCE entity.  Type 'man dcecp_&lt;command&gt;' for more information.  All
of the following dcecp objects and tasks require an operation:
  account        cdsalias       dts            log            rpcprofile
  acl            cdscache       endpoint       name           secval
  attrlist       cdsclient      group          object         server
  aud            cell           host           organization   user
  audevents      cellalias      hostdata       principal      utc
  audfilter      clearinghouse  hostvar        registry       uuid
  audtrail       clock          keytab         rpcentry       xattrschema
  cds            directory      link           rpcgroup

Miscellaneous commands perform specific functions.  Type 'man dcecp'
for more information.  These commands take no operation:
  echo     errtext  login    logout   quit     resolve  shell

To list all dcecp objects:                    dcecp> help -verbose
To list all operations an object supports:    dcecp> &lt;object> help
To list all options for an object operation:  dcecp> &lt;object> help &lt;operation>
For verbose information on a dcecp object:    dcecp> &lt;object> help -verbose
For the manual page of a dcecp object:        dcecp> man dcecp_&lt;object>
dcecp>
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para RevisionFlag="Changed">If you just need to know which operations an object supports, use the
command
</Para>
<InformalExample>
<Para><UserInput><Symbol Role="Variable" RevisionFlag="Changed">object</Symbol><Literal RevisionFlag="Changed"> operations
</Literal></UserInput></Para>
</InformalExample>
<Para RevisionFlag="Changed">which returns
a list of the actions you can take on an object.  The following example
shows how to list the operations available for the <Command>principal</Command>
object: 
</Para>
<InformalExample>
<Para><ProgramListing RevisionFlag="Changed">
dcecp> <Literal>principal operations</Literal>
catalog create delete modify show operations help
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para RevisionFlag="Changed">You can save typing by abbreviating this command to
something like <Command>prin oper</Command>. 
</Para>
</ListItem>
<ListItem>
<Para RevisionFlag="Changed">Get more detailed help about an object and its operations by using the
<Symbol Role="Variable">object</Symbol> <Command>help</Command> command.  The following example returns a
1-line description of each operation supported by the
<Command>principal</Command> object:
</Para>
<InformalExample>

<Para><ProgramListing RevisionFlag="Changed" role="page-wide">
<?sml-point-size 9>
dcecp> <Literal>principal help</Literal>
catalog             Returns all the names of principals in the registry.
create              Creates a DCE principal.
delete              Deletes a principal from the registry.
modify              Changes the information about a principal.
rename              Renames the specified principal.
show                Returns the attributes of a principal.
help                Prints a summary of command-line options.
operations          Returns a list of the valid operations for this command.
dcecp>
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para RevisionFlag="Changed">Get information about available command options by adding an
<Symbol Role="Variable">operation</Symbol> argument to the <Symbol Role="Variable">object</Symbol> <Command>help</Command> command.  The
following example returns a 1-line description of each option
supported by the <Command>principal create</Command> operation:
</Para>
<InformalExample>
<Para>
<ProgramListing RevisionFlag="Changed" role="page-wide">
<?sml-point-size 9>
<!--no-op:  11-->
dcecp> <Literal>principal help create</Literal>
-alias              Indicates the principal name is an alias of the uid.
-attribute          Specify principal attributes in an attribute list format.
-fullname           Fullname of the principal.
-quota              How many registry objects can the principal create.
-uid                User Identifier of the new principal.
-uuid               Orphaned UUID to be adopted by the principal.
dcecp>
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing>
</Para>
</InformalExample>
</ListItem>
<ListItem>
<Para RevisionFlag="Changed">Get help about an object itself by using an <Symbol Role="Variable">object</Symbol> <Literal>help
-verbose</Literal> command.  The following example returns a description of
the <Command>principal</Command> object along with information about how to use the
object:
</Para>
<InformalExample>

<Para><ProgramListing RevisionFlag="Changed" role="page-wide">
<?sml-point-size 10>
<!--no-op:  12-->
dcecp> <Literal>principal help -verbose</Literal>
<?sml-point-size 9>
This object allows manipulation of principal information stored
in the DCE registry.  The argument is a list of either relative or
fully-qualified principal names.  Specify fixed attributes using
attribute options or an attribute list.  Specify any extended attributes
using an attribute list.  Principal operations connect to a registry that
can service the request.  Specify a particular registry by setting the
_s(sec) convenience variable to be a cell-relative or global replica
name, or the binding of the host where the replica exists.  The
completed operation sets the _b(sec) convenience variable to the name
of the registry contacted.
dcecp>
<?sml-point-size 12>
<!--no-op:  14-->
</ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem RevisionFlag="Changed">
<?sml-need 5>
<IndexTerm Id="AGCC.CPINTR.indx.32">
<Primary>help</Primary>
<Secondary>accessing reference pages</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.33">
<Primary>reference pages</Primary>
<Secondary>within <Command>dcecp</Command></Secondary>
</IndexTerm>
<Para>Finally, some POSIX style systems will have reference pages for <Command>dcecp</Command> objects
as well as a Tcl summary reference page.  Each <Command>dcecp</Command> object has its own
reference page that describes the object and the operations available to it.
The general syntax for viewing a <Command>dcecp</Command> object reference page is
</Para>

<Para>
<UserInput>man <Symbol Role="Variable">object_name</Symbol>
</UserInput>
</Para>


<Para RevisionFlag="Changed"><?sml-point-size 9>
The following example shows how to invoke the reference page 
for the <Literal>principal</Literal> object.  Note that you can use 
the <Command>man</Command> command from within <Literal>dcecp</Literal>.
</Para>

<InformalExample>
<Para><ProgramListing>dcecp> <Literal>man principal</Literal>
 .
 . [output omitted]
 .
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>The <Literal>Tcl</Literal> reference page summarizes the Tcl built-in commands.  You can
view the Tcl summary reference page on a UNIX style system by entering
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>man Tcl</Literal>
 .
 . [output omitted]
 .
dcecp>
</ProgramListing></Para>
</InformalExample>
</ListItem>
</ItemizedList>
<?og-ChangeEnd def,13462,R1.2.2,Fixed dcecp Help output">
</Sect1>
<Sect1 Id="AGCC.CPINTR.div.13">
<Title>Customizing dcecp Sessions</Title>
<Para><IndexTerm Id="AGCC.CPINTR.indx.34">
<Primary>DCE control program</Primary>
<Secondary>customizing</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.35">
<Primary>customizing the DCE control program</Primary>
</IndexTerm>The DCE control program includes a number of commands, objects, and
task scripts for performing most of the day-to-day DCE administration
operations.  Nevertheless, as you gain experience using the
<Command>dcecp</Command> interface, you may find you want to add new commands and
capabilities or to customize some existing ones.  The following
sections explain how to add scripts and new objects to your
<Command>dcecp</Command> session.  An object is just a formal implementation of a
script that uses the <Command>dcecp</Command> help system and takes the form of
<Symbol Role="Variable">object operation</Symbol>.  Chapters 2 and 3 explain the fundamentals of
writing <Command>dcecp</Command> scripts and creating new objects.
</Para>
<Sect2 Id="AGCC.CPINTR.div.14">
<Title>Adding Scripts to dcecp Sessions</Title>
<Para>Once you have written a script, you can make it available to
one person or to everyone who is logged into the host by modifying one
or more of the following files invoked when <Command>dcecp</Command> initializes:
<IndexTerm Id="AGCC.CPINTR.indx.36">
<Primary>DCE control program</Primary>
<Secondary>initialization files</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.37">
<Primary>initialization files</Primary>
<Secondary>use of in <Command>dcecp</Command></Secondary>
</IndexTerm></Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>[info library]/init.tcl</Literal></Term>
<ListItem>
<?sml-break>
<Para>This file is read first and contains standard Tcl initialization
commands for the host.  This affects all instances of <Command>dcecp</Command> running on
a host.  The file contains definitions for the Tcl <Literal>unknown</Literal>
command and the <Literal>auto_load</Literal> facility used for initializing all of
the <Command>dcecp</Command> objects.  Administrators should avoid adding
<Command>dcecp</Command> customizations to this file.
<IndexTerm Id="AGCC.CPINTR.indx.38">
<Primary><Filename>init.tcl</Filename></Primary>
<Secondary>use of</Secondary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">dcelocal</Symbol><Filename>/init.dcecp</Filename></Term>
<ListItem>
<?sml-break>
<Para>This file contains <Command>dcecp</Command>-specific startup information for the
host.  This affects all instances of <Command>dcecp</Command> running on a host.
The <Command>dcecp</Command> scripts implementing operations and tasks are stored
in the <Symbol Role="Variable">dcelocal</Symbol><Filename>/dcecp</Filename> directory.  Add customizations in the form
of procedures to this file to make them available to all <Command>dcecp</Command>
users on the host.
<IndexTerm Id="AGCC.CPINTR.indx.39">
<Primary><Filename>init.dcecp</Filename></Primary>
<Secondary>use of</Secondary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Filename>$HOME/.dcecprc</Filename></Term>
<ListItem>
<?sml-break>
<Para>This optional file stores user customizations that affect individual
<Command>dcecp</Command> users (the owners of the <Literal>.dcecprc</Literal> files).  Each DCE
user can maintain a <Literal>.dcecprc</Literal> file and store private
procedures or alias names for operations.  Modified <Literal>.dcecprc</Literal>
files allow flexible administration in environments with multiple
administrators.  For example, different <Literal>.dcecprc</Literal> files for each
administrator could use <Command>dcecp</Command> <Command>source</Command> commands to call
specific commands and task scripts that are tailored to particular
areas of administration.
<IndexTerm Id="AGCC.CPINTR.indx.40">
<Primary><Literal>.dcecprc</Literal></Primary>
<Secondary>use of</Secondary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>The rest of this section illustrates a simple task script and shows
one way to make the script available for personal use.  Our example
begins with the control program's existing <Command>clock</Command> object that
shows the current time.  However, the time is simply a DTS timestamp
from the clock on the local host as in
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>clock show</Literal>
1994-10-03-10:22:59.991-04:00I-----
dcecp> 
</ProgramListing></Para>
</InformalExample>
<Para>Let us say you create a procedure that gets a timestamp from a DTS
server but also displays the name of the DTS server with the time as
in the following example which invokes a user-created procedure called
<Literal>show_clock</Literal>:
</Para>
<InformalExample>
<Para><ProgramListing>dcecp> <Literal>show_clock</Literal>
Time on mars is        1994-09-30-15:03:43.979-04:00I-----
dcecp>
</ProgramListing></Para>
</InformalExample>
<Para>You can make this procedure available to one user by including the
procedure in the user's <Literal>.dcecprc</Literal> file.  The following sample
<Literal>.dcecprc</Literal> file includes user customizations consisting of the
<Literal>_dcp_show_clocks</Literal> procedure and an alias that lets you invoke the
procedure with the simpler <Literal>show_clocks</Literal> command name.  Another
procedure called <Literal>_dcp_whoami</Literal> shows the current login identity
information.  Note the order of operations in the <Literal>.dcecprc</Literal> file.
Procedures are defined at the beginning of the file.  Renaming and
invoking the procedures must occur after the procedures are defined.
<IndexTerm Id="AGCC.CPINTR.indx.41">
<Primary><Literal>.dcecprc</Literal></Primary>
<Secondary>example of</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.42">
<Primary>initialization files</Primary>
<Secondary>example in <Command>dcecp</Command></Secondary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing>##
## Start up commands
##
# A simple command to rerun .dcecprc after modifications
proc .d {} {source $HOME/.dcecprc}

# Show your current login name and your current cell name.
proc _dcp_whoami {} {
  global _c _u
  return "You are '$_u' logged into '$_c'."
}

<?sml-need 19># Show the time on all of the dts servers running in your cell.
proc _dcp_show_clocks {} {
    set x [directory list /.:/hosts]
    foreach n $x {
        if {[catch {object show $n/dts-entity}] == 0} {
            set index [string last "/" $n] 
            set y [string range $n [incr index] end]
            if {[catch {clock show $n/dts-entity} msg] == 0} {
                set i [expr 20 - [string length $y]]
                puts [format "Time on $y is %${i}s %s" " " \
                    [clock show $n/dts-entity]]
            } else {
                set i [expr 20 - [string length $y]]
                puts [format "Time on $y is %${i}s %s" " " \
                   "Server not responding."]
            }
        }
    }
}

# Give some procs usable names
rename _dcp_whoami whoami
rename _dcp_show_clocks show_clocks

# If I am authorized, say so
if {$_u != ""} {
  whoami
}
</ProgramListing></Para>
</InformalExample>
<Para>The <Command>rename</Command> command near the end of the file lets you invoke the
<Literal>_dcp_show_clocks</Literal> and <Literal>_dcp_whoami</Literal> procedures using the
easier command names <Literal>show_clocks</Literal> and <Literal>whoami</Literal>.
</Para>
<Para>When you start <Command>dcecp</Command>, the last part of this file
invokes the <Literal>_dcp_whoami</Literal> procedure if you are logged into DCE. If
the <Literal>_u</Literal> convenience variable is set, the <Literal>_dcp_whoami</Literal>
procedure prints your current login identity as follows:
</Para>
<InformalExample>
<Para><ProgramListing>% <Literal>dcecp</Literal>
You are '<Replaceable>principal_name</Replaceable>' logged into '<Replaceable>cell_name</Replaceable>'. 
dcecp>
</ProgramListing></Para>
</InformalExample>
<!-- .P-->
<!-- Here is an example \*Linit.dcecp\*O file.  It calls in a \*Ldcecp\*O-->
<!-- script that lets users enter commands using a \*Vverb object\*O-->
<!-- syntax rather than the \*Vobject verb\*O syntax normally expected by-->
<!-- \*Ldcecp\*O. This function is available to all users logging into the-->
<!-- host where this file resides.-->
<!-- -->
<!-- 	Numbered callouts briefly explain the purpose of each modification and-->
<!-- 	point to a relevant section for more detailed explanation.-->
<!-- -->
<!-- .oS-->
<!-- # File: init.dcecp-->
<!-- -->
<!-- # This means that all users on a host will have the verb-->
<!-- # command by default.  So you can type:-->
<!-- # -->
<!-- #       show dir /.:-->
<!-- # 	and have it work.-->
<!-- # -->
<!-- # Host specific dcecp initialization-->
<!-- -->
<!-- source $dcecp_library/verb-object.dcecp-->
<!-- .oE	-->
</Sect2>
<Sect2 Id="AGCC.CPINTR.div.15">
<Title>Adding New Objects to the DCE Control Program</Title>
<Para><IndexTerm Id="AGCC.CPINTR.indx.43">
<Primary>DCE control program</Primary>
<Secondary>adding new objects</Secondary>
</IndexTerm>
<IndexTerm Id="AGCC.CPINTR.indx.44">
<Primary>administration objects</Primary>
<Secondary>adding new objects</Secondary>
</IndexTerm>If you have written a script as a formal <Command>dcecp</Command> object, you can
make it available by including the new object in the same directory
where other task objects reside.  On UNIX systems, this is often
<Symbol Role="Variable">dcelocal</Symbol><Filename>/dcecp</Filename>.  As a rule, you should add the new object to
each host in the DCE cell.  Chapter 3 describes how you can use the
<Command>dcecp</Command> <Command>hostdata</Command> object to copy scripts or other files to
every host in a cell.
</Para>
<Para>When you install a new script, you must run the <Literal>auto_mkindex</Literal>
utility to make the new object available to other users on the host.
For more information about running the <Literal>auto_mkindex</Literal> utility, see
Chapter 3.
</Para>
</Sect2>
</Sect1>
</Chapter>
<!--+ 10/31/96 16:05:54
    | tagMorph:  $Id: intro.sgm,v 1.1.2.13 1996/12/09 17:25:10 carrig Exp $
    | tagMorph library:  $Id: intro.sgm,v 1.1.2.13 1996/12/09 17:25:10 carrig Exp $
    | sml-to-docbook:  1.24
    +-->
