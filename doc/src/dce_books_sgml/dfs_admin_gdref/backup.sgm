<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: backup.sgm,v $
# Revision 1.1.2.6  1996/12/15  23:01:45  wardr
# 	{edit,R1.2.2}
# 	[D[DFiformatting problems before penultimate build
# 	[1996/12/15  23:00:05  wardr]
#
# Revision 1.1.2.5  1996/12/14  23:14:06  wardr
# 	{edit,R1.2.2}
# 	Fixed figure problems
# 	[1996/12/14  23:12:22  wardr]
# 
# Revision 1.1.2.4  1996/11/06  18:46:56  weir
# 	Cleaned up history
# 	[1996/11/06  18:45:45  weir]
# 
# Revision 1.1.2.3  1996/10/28  17:33:41  carrig
# 	{enh,R1.2.2}
# 	Ready for editor
# 	[1996/10/28  17:19:26  carrig]
# 
# Revision 1.1.2.2  1996/10/24  20:10:15  carrig
# 	{enh,R1.2.2}
# 	Fixed tables
# 	[1996/10/24  20:08:13  carrig]
# 
# Revision 1.1.2.1  1996/10/22  20:42:34  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 	[1996/10/22  20:40:58  wardr]
# 
# Revision 1.1.1.2  1996/10/22  20:40:58  wardr
# 	{edit,R1.2.2}
# 	Initial checkin after sgml conversion
# 
# $EndLog$
-->
<!---->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<!---->
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the-->
<!-- src directory for the full copyright text.-->
<!---->
<!---->
<!-- HISTORY-->
<!-- Revision 1.1.11.1  1996/05/14  19:52:06  wardr-->
<!-- 	{enh,R1.2.2}-->
<!-- 	Removed changebars-->
<!-- 	[1996/05/14  19:51:01  wardr]-->
<!---->
<!-- Revision 1.1.8.7  1995/12/29  17:23:12  wfl-->
<!-- 	{edit, R1.2.1}-->
<!-- 	made copy edits-->
<!-- 	[1995/12/29  17:22:25  wfl]-->
<!-- -->
<!-- Revision 1.1.8.6  1995/10/13  14:44:32  wfl-->
<!-- 	{edit,R1.2.1}-->
<!-- 	Fixed Change Bar Problem-->
<!-- 	[1995/10/13  14:43:52  wfl]-->
<!-- -->
<!-- Revision 1.1.8.5  1995/10/04  15:54:20  wfl-->
<!-- 	{def, 13140, R1.2.1}-->
<!-- 	Fixed quotes in change markers-->
<!-- 	[1995/10/04  15:54:00  wfl]-->
<!-- -->
<!-- Revision 1.1.8.4  1995/09/16  16:06:21  wfl-->
<!-- 	{enh,13106,R1.2.1}-->
<!-- 	Update backup system-->
<!-- 	{enh,13111,R1.2.1}-->
<!-- 	Support for sparse files-->
<!-- 	[1995/09/16  16:05:58  wfl]-->
<!-- -->
<!-- Revision 1.1.8.3  1995/08/25  17:32:00  jeff-->
<!-- 	Testing some more.-->
<!-- 	[1995/08/25  17:31:38  jeff]-->
<!-- -->
<!-- Revision 1.1.8.2  1995/08/25  15:59:24  jeff-->
<!-- 	More testing (4, 5, 6, ...)-->
<!-- 	[1995/08/25  15:59:07  jeff]-->
<!-- -->
<!-- Revision 1.1.8.1  1995/08/25  15:57:01  wfl-->
<!-- 	Testing (1,2,3...)-->
<!-- 	[1995/08/25  15:56:33  wfl]-->
<!-- -->
<!-- Revision 1.1.6.14  1995/07/24  18:42:35  weir-->
<!-- 	Prentice-Hall corrections-->
<!-- 	[1995/07/24  18:41:58  weir]-->
<!-- -->
<!-- Revision 1.1.6.12  1994/10/14  19:35:29  jeff-->
<!-- 	{defect, 12535, R1.1}-->
<!-- 	Incorporate dcecp commands in DFS documentation.-->
<!-- 	[1994/10/14  19:32:19  jeff]-->
<!-- -->
<!-- Revision 1.1.6.11  1994/08/10  17:09:59  jeff-->
<!-- 	Editorial and related corrections.-->
<!-- 	[1994/08/10  17:09:31  jeff]-->
<!-- -->
<!-- Revision 1.1.6.10  1994/07/08  17:23:05  jeff-->
<!-- 	Correct editorial problems.-->
<!-- 	[1994/07/08  17:22:02  jeff]-->
<!-- -->
<!-- Revision 1.1.6.9  1994/05/19  20:53:53  jeff-->
<!-- 	{defect, 10688, R1.1}-->
<!-- 	Correct Tape Coordinator configuration steps.-->
<!-- -->
<!-- 	{defect, 8118, R1.1}-->
<!-- 	Correct use of double quotes.-->
<!-- 	[1994/05/19  20:53:03  jeff]-->
<!-- -->
<!-- Revision 1.1.6.8  1994/05/06  13:52:15  jeff-->
<!-- 	{defect, 10552, R1.1}-->
<!-- 	Fix index entry inconsistencies.-->
<!-- 	[1994/05/06  13:49:02  jeff]-->
<!-- -->
<!-- Revision 1.1.6.7  1994/04/28  22:22:18  jeff-->
<!-- 	{defect, 10439, R1.1}-->
<!-- 	Correct cross-references for reorganization of DFS documentation.-->
<!-- 	[1994/04/28  22:17:24  jeff]-->
<!-- -->
<!-- Revision 1.1.6.6  1993/10/14  12:31:33  kdu-->
<!-- 	{def,9099,R1.0.3}-->
<!-- 	Fix fms examples.-->
<!-- 	[1993/10/14  12:30:27  kdu]-->
<!-- -->
<!-- Revision 1.1.6.5  1993/10/13  20:51:48  tmw-->
<!-- 	Added index entries for second version of master index.-->
<!-- 	[1993/10/13  20:50:35  tmw]-->
<!-- -->
<!-- Revision 1.1.6.4  1993/09/16  11:31:15  kdu-->
<!-- 	{def,5778,R1.0.3}-->
<!-- 	Short forms of machine names.-->
<!-- 	[1993/09/16  11:30:45  kdu]-->
<!-- -->
<!-- Revision 1.1.6.3  1993/08/11  00:34:28  jeff-->
<!-- 	Changed versions for defect fixes from 1.0.2A to 1.0.3.-->
<!-- 	[1993/08/11  00:19:22  jeff]-->
<!-- -->
<!-- Revision 1.1.6.2  1993/07/30  18:06:21  kdu-->
<!-- 	{def,8386,R1.0.3}-->
<!-- 	Incorporate OSF editorial comments into DFS Admin Guide and related-->
<!-- 	documentation.-->
<!-- 	[1993/07/30  18:05:11  kdu]-->
<!-- -->
<!-- Revision 1.1.4.8  1993/02/24  00:57:38  jeff-->
<!-- 	Fix for defects 5795, 6832, and 6835.-->
<!-- 	[1993/02/24  00:56:44  jeff]-->
<!-- -->
<!-- Revision 1.1.4.7  1993/02/09  01:44:58  jeff-->
<!-- 	Fix for defect 7156, correct dump/restore restrictions.-->
<!-- 	[1993/02/09  01:42:08  jeff]-->
<!-- -->
<!-- Revision 1.1.4.6  1993/02/04  01:45:54  jeff-->
<!-- 	Fix for defect 7073.-->
<!-- 	[1993/02/04  01:45:24  jeff]-->
<!-- -->
<!-- Revision 1.1.4.5  1993/01/28  19:06:14  dbelch-->
<!-- 	Embedding copyright notice-->
<!-- 	[1993/01/28  18:30:18  dbelch]-->
<!-- -->
<!-- Revision 1.1.4.4  1993/01/27  21:10:15  buckler-->
<!-- 	Fixed cross-refs and figure calls for new book org-->
<!-- 	[1993/01/27  21:07:15  buckler]-->
<!-- -->
<!-- Revision 1.1.4.3  1993/01/10  21:03:23  jeff-->
<!-- 	Small editorial changes; no explicit defect.-->
<!-- 	[1993/01/10  21:02:52  jeff]-->
<!-- -->
<!-- Revision 1.1.4.2  1992/08/26  12:10:55  weir-->
<!-- 	Moved to dce1.0.2doc-->
<!-- 	[1992/08/26  12:04:43  weir]-->
<!-- -->
<!-- Revision 1.1.2.7  1992/07/05  20:55:27  jeff-->
<!-- 	Reformatted table.-->
<!-- 	[1992/07/05  20:54:52  jeff]-->
<!-- -->
<!-- 	Reformatted table for consistency.-->
<!-- 	[1992/07/05  20:46:30  jeff]-->
<!-- -->
<!-- Revision 1.1.2.6  1992/07/02  17:11:01  jeff-->
<!-- 	Corrected ACL permissions and small editorial stuff.-->
<!-- 	[1992/07/02  17:02:51  jeff]-->
<!-- -->
<!-- Revision 1.1.2.5  1992/06/07  02:08:48  jeff-->
<!-- 	Clarified the description of the DCE pathname used to-->
<!-- 	specify a machine name.-->
<!-- 	[1992/06/07  01:44:40  jeff]-->
<!-- -->
<!-- Revision 1.1.2.4  1992/05/12  16:20:15  jeff-->
<!-- 	Verified and/or modified italics and other editorial-->
<!-- 	aspects of the file.-->
<!-- 	[1992/05/12  14:36:49  jeff]-->
<!-- -->
<!-- Revision 1.1.2.3  1992/04/22  13:21:43  jeff-->
<!-- 	Fixed some small formatting problems (to parallel fixes-->
<!-- 	in second backup chapter).-->
<!-- 	[1992/04/21  21:02:33  jeff]-->
<!-- -->
<!-- Revision 1.1.2.2  1992/04/16  22:09:01  jeff-->
<!-- 	No changes.-->
<!-- 	[1992/04/16  22:07:17  jeff]-->
<!-- -->
<!-- Revision 1.1  1992/01/29  16:14:56  damon-->
<!-- 	Initial revision-->
<!-- -->
<!---->
<!-- (c) Copyright 1991, Open Software Foundation, Inc.  ALL RIGHTS RESERVED-->
<!--no-op:  Copyright (C) 1989, 1991, Transarc Corporation-->
<!--no-op:  The Gulf Tower-->
<!--no-op:  707 Grant Street-->
<!--no-op:  Pittsburgh, PA  15219-->
<!-- CHANGED-->
<!-- 12-10-91:  In Section 9.3.3.1.3, Step 2, changed Any to All.-->
<!-- 12-10-91:  In Section 9.3.1.1, 9.3.4, and 9.4.1, changed "m or -" to-->
<!--            "m or M" (changed em dashes to Ms).-->
<!-- 12-10-91:  In Section 9.2.2.3, removed 2 dashes from second line of-->
<!--            example output for fms command.-->
<!-- END CHANGED-->
<!--DOCUMENTSTYLE [12pt]{book}-->
<Chapter Id="DFSAGR.BKUP.div.1">
<Title>Configuring the Backup System</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.1">
<Primary>Backup System</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<Para>The DFS Backup System can help you automate the process of making permanent
copies of filesets on tape.  You can create a full backup, which includes all
of the data from every file in a fileset, or you can back up data
incrementally, copying only those files that have changed since a previous
dump.  In the same fashion, you can restore filesets completely, or you can do
an incremental, date-specific restore, which recreates the filesets as they
were before a specific date.  Because both DCE LFS filesets and exported
non-LFS file systems have entries in the Fileset Location Database (FLDB),
the DFS Backup System can be used with both types of filesets.
</Para>
<Para>This chapter introduces the DFS Backup System.  It describes configuration
issues related to the performance of backup and restore operations.  Chapter
10 provides specific details about listing information from the Backup
Database, backing up and restoring data, and administering the Backup Database.
Refer to this chapter for information about configuring the Backup System and
preparing it for backing up and restoring data; refer to Chapter 10 for
information about backing up and restoring data.
</Para>
<Sect1 Id="DFSAGR.BKUP.div.2">
<Title>Introduction to the Backup System</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.2">
<Primary>incremental dumps</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.3">
<Primary>full dumps</Primary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.4">
<Primary>dump sets</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<Para>With the DFS Backup System, you control many aspects of the backup process,
including how often backups are performed, which filesets are backed up, and
whether full or incremental backups are made.  A dump or dump set
is the result of performing a backup operation; it includes data from all
of the filesets that were copied onto tape at the same time.  A full dump 
includes data from every file in a fileset; an incremental dump includes only 
those files in the fileset that changed since a previous dump was made.  The 
backup process is also referred to as <Replaceable>dumping a fileset family</Replaceable> or 
<Replaceable>creating a dump set</Replaceable>.
</Para>
<Para>Once a fileset has been dumped, the DFS Backup System can be used to restore
it.  When restoring a fileset, the DFS Backup System first restores a full dump
of the fileset.  It then restores the changes to the fileset from any
incremental dumps that were made since the full dump.  Two types of restores
are possible: a <Replaceable>full restore</Replaceable>, which recreates the fileset as it was at
its last dump, including changes from the last full dump and any incremental
dumps that were made since the last full dump; and a <Replaceable>date-specific
restore</Replaceable>, which recreates the fileset as it was at the time of its last dump
before an indicated date. The Backup System restores the last full dump and any
incremental dumps of the fileset that were done before the specified date, so
the fileset is current according to the last dump made before that date.
<IndexTerm Id="DFSAGR.BKUP.indx.5">
<Primary>sparse file support</Primary>
<Secondary>about</Secondary>
</IndexTerm></Para>
<Para>Sparse files contained in the backup fileset remain mostly
sparse when dumped or restored.  Any 64 KB chunk of a file that contains
actual data expands to fill 64 KB on the disk.  However, if a 64 KB chunk
does not contain data it does not require physical space on the
disk. This 64 KB granularity is imposed to ensure high-performance data access.
</Para>
<Para><IndexTerm Id="DFSAGR.BKUP.indx.6">
<Primary>stackers</Primary>
<Secondary>support for</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.7">
<Primary>jukeboxes</Primary>
<Secondary>support for</Secondary>
</IndexTerm>The Backup System can be used in conjunction with a variety of
automated backup devices, including stackers and jukeboxes.  Through a
user-defined configuration file, you can specify parameters to
configure the Backup System's Tape Coordinator to control automated
backup equipment.  The Tape Coordinator can then call executable
routines, change tapes, select the proper tape, and handle errors.
</Para>
<Para>The Backup System can be used to dump and restore data between different types
of file systems.  For example, data dumped from a DCE LFS fileset can be
restored to a DCE LFS fileset or to any type of non-LFS fileset.  Likewise,
data dumped from a non-LFS fileset can be restored to a DCE LFS fileset or to
a different type of non-LFS fileset.  Note that incompatible information may 
be lost when a fileset is dumped and restored between file system types; for 
example, ACLs on objects in a DCE LFS fileset may be lost if the fileset is 
restored to a file system that does not support ACLs. (Refer to your vendor's
documentation to verify the level of support for dump and restore operations
between different types of file systems.)
<?sml-break><?sml-need 20></Para>
<Para><IndexTerm Id="DFSAGR.BKUP.indx.8">
<Primary>Backup Database</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.9">
<Primary>Backup Server</Primary>
<Secondary>about</Secondary>
</IndexTerm>The Backup Database records the schedule for backups, the locations of the
Backup System's Tape Coordinators, the groups of filesets (fileset families)
that can be dumped, and other administrative information.  One Backup Database
exists per cell; it is used to back up data from all administrative domains in
the cell.  A master copy of the Backup Database is maintained on one machine
and replicated on other machines in the cell.  Ubik creates and synchronizes
the master and secondary copies of the database. (See Chapter 2 for more
information about Ubik.) In addition, the DFS Backup System provides facilities
to back up the database by copying it to tape so that it can be restored if
necessary.  You can also remove specific configuration and dump information
from the database if needed.
</Para>
<Para><IndexTerm Id="DFSAGR.BKUP.indx.10">
<Primary><Filename>admin.bak</Filename> file</Primary>
</IndexTerm>The Backup Database is maintained by the Backup Server, or <Command>bakserver</Command>
process.  The Backup Server must run on each machine that stores a copy of the
Backup Database.  Only the administrative users and members of the groups
included in the <Filename>admin.bak</Filename> administrative list can issue <Command>bak</Command>
commands, which are used to configure and administer the Backup System and to
back up and restore data.  Like the Backup Database, the <Filename>admin.bak</Filename> file is
installed on one machine (usually the System Control machine) and copied to all
machines that house copies of the Backup Database.
</Para>
<Para>Some operating systems have their own backup commands. If your operating system
has commands named <Command>bak</Command>, make certain that you use the complete pathname
(<Symbol Role="Variable">dceshared</Symbol><Filename>/bin/bak</Filename>) when issuing DFS <Command>bak</Command> commands.  Note that
<Command>bak</Command> commands can presently be used to affect the Backup Database in the
local cell only.
<IndexTerm Id="DFSAGR.BKUP.indx.11" SpanEnd="DFSAGR.BKUP.indx.1"></Para>
<Sect2 Id="DFSAGR.BKUP.div.3">
<Title>Tape Coordinator Machines</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.12">
<Primary>Tape Coordinator machines</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.13">
<Primary><Command>butc</Command> program</Primary>
</IndexTerm>
<Para>A Tape Coordinator machine is a machine on which backup and restore operations
are physically conducted.  To qualify as a Tape Coordinator machine, a machine
</Para>
<ItemizedList>
<ListItem>
<Para>Should be in a physically secure location.
</Para>
</ListItem>
<ListItem>
<Para>Must have one or more tape drives attached.
</Para>
</ListItem>
<ListItem>
<Para>Must be configured as at least a DCE client machine. Fewer configuration steps
are required if the machine is also configured as some type of DFS server
machine.
</Para>
</ListItem>
<ListItem>
<Para>Must be properly configured as a Tape Coordinator machine. For example, it
must house the required configuration file, and it must have the necessary
entries in the Backup Database.
</Para>
</ListItem>
<ListItem>
<Para>If you are using automated backup equipment (such as a stacker or
jukebox), the Tape Coordinator machine must house the user-defined
configuration file (which has the necessary parameters to control the
specialized backup equipment).
</Para>
</ListItem>
<ListItem>
<Para>Must run one instance of the <Command>butc</Command> (BackUp Tape Coordinator or just Tape
Coordinator) process for each tape drive.
</Para>
</ListItem>
</ItemizedList>
<Para>The <Command>butc</Command> program must be active when you issue a <Command>bak</Command> command that
involves either a tape drive or an operation being performed by a tape drive.
For optimum efficiency, run several tape drives (and their Tape Coordinators).
Start one <Command>butc</Command> process on a Tape Coordinator machine for each tape drive
attached to the machine.  Each Tape Coordinator controls the behavior of its
associated drive and accepts service requests from the <Command>bak</Command> program.
</Para>
<Para><IndexTerm Id="DFSAGR.BKUP.indx.14">
<Primary>Tape Coordinator IDs (TCIDs)</Primary>
<Secondary>about</Secondary>
</IndexTerm>A Tape Coordinator ID (TCID) identifies a Tape Coordinator; each TCID must be
unique in the Backup System of the local cell.  When you issue <Command>bak</Command>
commands, specify a Tape Coordinator by specifying its TCID with the
<Option>tcid</Option> option.  Depending on the command, the <Command>bak</Command> or <Command>butc</Command>
program contacts one or more of the following: the Backup Database (by way of
the Backup Server), the FLDB, or Fileset Server processes.
</Para>
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.4">
<Title>Fileset Families and Fileset Family Entries</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.15">
<Primary>fileset families</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.16">
<Primary>wildcards</Primary>
<Secondary>use in Backup System</Secondary>
</IndexTerm>
<Para>When creating backups, you copy groups of filesets, known as <Symbol Role="Variable">fileset families</Symbol>,
to tape.  A fileset family includes all of the filesets that you want to dump
together onto the same tape (or tapes, if the fileset family contains a large
number of filesets).  All of the filesets in a fileset family are dumped to
tape with the same frequency (for example, once a day or once a week).
</Para>
<Para>Fileset family entries (also referred to as <Symbol Role="Variable">fileset entries</Symbol>) define the
filesets included in a fileset family.  Each entry has three fields: the File
Server machine name, the aggregate name, and the fileset name.  Because filesets
can be moved from File Server to File Server, the first two fields are usually
designated with a <Literal>.*</Literal> wildcard, so a person backing up the filesets does
not need to know the File Server machine and aggregate on which they reside.
The last field, fileset name, is often specified with a regular expression
pattern that matches certain fileset names.
Within the Backup System, regular expression characters and the <Literal>.*</Literal> wildcard
can be used in many arguments. (See Section 9.3.3 for a description of these
characters and their interpretations.)
</Para>
<Para>With the Backup System, regular expression characters and the <Literal>.*</Literal> wildcard
can be used in many arguments. (See Section 9.3.2 for a description of these
characters and their interpretations.)
<IndexTerm Id="DFSAGR.BKUP.indx.17" SpanEnd="DFSAGR.BKUP.indx.12"></Para>
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.5">
<Title>Dump Hierarchies and Dump Levels</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.18">
<Primary>dump hierarchies</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.19">
<Primary>incremental dumps</Primary>
<Secondary>parent dump level</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.20">
<Primary>dump levels</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.21">
<Primary>dump sets</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<Para>A dump hierarchy is a logical structure that helps define the
relationship between full and incremental dumps.  As mentioned previously, an
incremental dump includes only the files that changed since the fileset was 
last dumped; when creating an incremental dump, the Backup System uses a 
previous dump, known as the dump's <Symbol Role="Variable">parent</Symbol>, to serve as a reference point 
on which to base the incremental dump.
</Para>
<Para>A dump set is the product of dumping a fileset family at a certain dump
level, which is an entry in the dump hierarchy.  The dump set is a collection of
data from filesets dumped at the same time and in the same manner (fully or
incrementally).  To create a dump set, you specify (with the <Command>bak dump</Command>
command) both the fileset family and the dump level.  The Backup System keeps
all of the data in a dump set together on a tape (or set of tapes, if the 
dump set is too large to fit on a single tape).  The name of the dump set 
consists of the name of the fileset family and the last component of the name 
of the dump level joined by a dot
(<Symbol Role="Variable">fileset_family_name</Symbol><Literal>.</Literal><Symbol Role="Variable">dump_level</Symbol>).
</Para>
<Para>Each dump level can be associated with an expiration date that specifies when
a tape containing data from that dump level can be overwritten.  The expiration
date is transferred to any backup tape that contains a dump made at that level.
When dumping to tape, the system checks the tape for an expiration date.  If
the tape's expiration date has not expired (if it is in the future), the system
does not overwrite the tape; if no expiration date is defined for the tape or
if the tape's expiration date has expired (if it is in the past), the system
overwrites the tape, but only with a dump set of the same name.
</Para>
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.6">
<Title>Command and Monitoring Windows</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.22">
<Primary>command windows</Primary>
<Secondary>in Backup System</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.23">
<Primary>monitoring windows</Primary>
<Secondary>in Backup System</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.24">
<Primary>Tape Coordinators</Primary>
<Secondary>monitoring</Secondary>
</IndexTerm>
<Para>A single terminal session can be used to issue <Command>bak</Command> commands to the Tape
Coordinators on all Tape Coordinator machines.  The session corresponds to a
command shell called the <Symbol Role="Variable">command window</Symbol>, which can be opened and closed
without affecting the Tape Coordinators.  This session can be run from any
machine in the cell.  Multiple command windows can be used, but they are not
necessary.
<?sml-break><?sml-need 20></Para>
<Para>A separate terminal session must be used for each Tape Coordinator and
associated tape drive running on a machine; a terminal session of this type is
referred to as a Tape Coordinator's <Symbol Role="Variable">monitoring window</Symbol>.  The window must be a
connection to the Tape Coordinator machine whose Tape Coordinator and tape
drive it is monitoring.  The Tape Coordinator runs in the foreground, so no
further commands can be issued in the monitoring window.  The monitoring window
must remain open while the Tape Coordinator runs so that you can see the Tape
Coordinator's prompts.
</Para>
<Note>
<Para>When using automated backup equipment, such as a stacker or jukebox,
you can set parameters in the user-defined configuration file to use
default responses for all questions.  This allows the automated backup
equipment to run unattended. See Section 9.3.2 for more information.
</Para>
</Note>
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.7">
<Title>Privileges Required to Use the Backup System</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.25">
<Primary>administrative lists</Primary>
<Secondary>in Backup System</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.26">
<Primary><Filename>admin.bak</Filename> file</Primary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.27">
<Primary><Filename>admin.fl</Filename> file</Primary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.28">
<Primary><Filename>admin.ft</Filename> file</Primary>
</IndexTerm>
<Para>Three administrative lists, or <Command>admin</Command> files, determine the users who can
perform specific backup and restore operations.  Depending on the operation to
be performed, you must be included in one or more of the following files:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Filename>admin.bak</Filename> file on each server machine on which the Backup Database
is stored.  You must be listed in this file for any operation initiated by a
<Command>bak</Command> command.
</Para>
</ListItem>
<ListItem>
<Para>The <Filename>admin.fl</Filename> file on each server machine on which the FLDB is stored.
You must be included in this file for any operation that involves the Fileset
Location Server (FL Server), such as backing up or restoring filesets.
</Para>
</ListItem>
<ListItem>
<Para>The <Filename>admin.ft</Filename> file on any File Server machine from which you dump filesets
or to which you restore filesets.  You must be listed in this file for any
command that involves the Fileset Server, such as backing up or restoring
filesets.
</Para>
</ListItem>
</ItemizedList>
<Para>To avoid confusion, include any user who works with the Backup System on all
three administrative lists on the appropriate machines.  The operations in this
chapter direct users to verify that they, meaning they or a group to which
they belong, are included in the appropriate administrative lists
(<Filename>admin.bak</Filename>, <Filename>admin.fl</Filename>, and <Filename>admin.ft</Filename>).  Use the <Command>bos
lsadmin</Command> command to display the members of an administrative list.
</Para>
<Note>
<Para>If you have not included users who are to issue <Command>bak</Command>
commands on all three of these administrative lists, some commands may not
work as detailed in this and the following chapter.
</Para>
</Note>
</Sect2>
</Sect1>
<Sect1 Id="DFSAGR.BKUP.div.8">
<Title>Standard Information in this Chapter</Title>
<Para>The following subsections present standard options and arguments common to many
of the commands described in this chapter.  They also present some common
operations repeated throughout this chapter.
</Para>
<Sect2 Id="DFSAGR.BKUP.div.9">
<Title>Standard Options and Arguments</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.29">
<Primary>fileset families</Primary>
<Secondary>name format</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.30">
<Primary>dump levels</Primary>
<Secondary>name format</Secondary>
</IndexTerm>
<Para>The following options and arguments are used with many of the commands
described in this chapter.  If an option or argument is not described with a
command in the text, a description of it appears here. (See Part 2 of this
guide and reference for complete details about each command.)
</Para>
<ItemizedList>
<ListItem>
<Para>The <Option>tapehost</Option> <Symbol Role="Variable">machine</Symbol> option is the machine for which a Tape
Coordinator is to be added.  You can specify the machine's DCE pathname (for
example, <Replaceable>/.../abc.com/hosts/bak1</Replaceable>), its host name (for example,
<Literal>bak1.abc.com</Literal>), or its IP address (for example, <Literal>11.22.33.44</Literal>).
</Para>
</ListItem>
<ListItem>
<Para>The <Option>family</Option> <Symbol Role="Variable">fileset_family_name</Symbol> option is the name of the 
fileset family to be used in the command.  The name must be unique within the 
Backup Database of the local cell.  It can be no longer than 31 characters.  It 
can include any characters, but to avoid confusion when dump set names are 
created, it should not include a <Literal>.</Literal> (dot).  Any regular expression 
characters entered on the shell command line must be escaped with a <Literal>&bsol;</Literal> 
(backslash); for example, <Literal>usr&bsol;*</Literal> for a fileset family named <Literal>usr*</Literal>. 
To make it easier to track the contents of a fileset family, its name should 
give some indication of the contents of the fileset entries it contains;
for example, use the name <Literal>user</Literal> for the fileset family that includes 
all user filesets in the file system.
</Para>
</ListItem>
<ListItem>
<Para>The <Option>level</Option> <Symbol Role="Variable">dump_level</Symbol> option is the name of the dump level to be 
used in the command.  The complete pathname of a dump level must always 
be specified.  There are two types of dump levels:
<?sml-break><?sml-need 20></Para>
<ItemizedList>
<ListItem>
<Para>Full dumps, which consist of a name preceded by a single <Filename>/</Filename> (slash) (for
example, <Literal>/full</Literal>).
</Para>
</ListItem>
<ListItem>
<Para>Incremental dumps, which consist of multiple elements that resemble a UNIX 
pathname listing the dump levels that serve as the parents of the dump level, 
starting with a full dump level and proceeding in order down the hierarchy; for
example, <Literal>/full/weekly/monday</Literal>.  An incremental dump level can consist of
any number of elements; when defining a new dump level, all of the elements
except the last one must already exist.  Each level in a dump level name must
be preceded by a <Filename>/</Filename> (slash).
</Para>
</ListItem>
</ItemizedList>
<Para>Dump levels should have meaningful names that give some indication of their
purpose.  A single element in a dump level name can be no longer than 28
characters, and the complete name can be no longer than 256 characters.  Dump
level names can include any characters, but to avoid confusion when dump set
names are created, they should not include a <Literal>.</Literal> (dot).  Regular
expression characters included in a dump level name must be escaped with a
<Literal>&bsol;</Literal> (backslash) or <Literal>"&thinsp;"</Literal> (double quotes).  The complete pathname of
each dump level must be unique within the Backup Database of the local cell.
<IndexTerm Id="DFSAGR.BKUP.indx.31">
<Primary>dump levels</Primary>
<Secondary>expiration dates</Secondary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>The <Option>expires</Option> <Symbol Role="Variable">date</Symbol> option is the expiration date for a dump level. 
Expiration dates can be specified in one of two ways:
</Para>
<ItemizedList>
<ListItem>
<Para>Relative expiration dates, which use the keyword <Literal>in</Literal> to indicate a number
of years, months, or days to be added to the current date to calculate the
expiration date.  When the system dumps a fileset at this level, it calculates
the time at which the dump set expires by adding the values to the start time
of the dump operation.  Relative expiration dates are expressed as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>in</Literal> [<Symbol Role="Variable">integer</Symbol><Literal>y</Literal>] [<Symbol Role="Variable">integer</Symbol><Literal>m</Literal>] [<Symbol Role="Variable">integer</Symbol><Literal>d</Literal>]
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>At least one value must be provided; multiple values must be listed in the
order shown, with the appropriate unit abbreviation (<Literal>y</Literal>, <Literal>m</Literal>, or
<Literal>d</Literal>) used with each value.  For example, <Literal>in 1y 6m 2d</Literal> causes the
system to add 1 year, 6 months, and 2 days to the current date to calculate
the expiration date.
<?sml-break><?sml-need 20></Para>
</ListItem>
<ListItem>
<Para>Absolute expiration dates, which use the keyword <Literal>at</Literal> to represent a
specific date and, optionally, time to use as the expiration date.  Absolute
expiration dates are expressed as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>at </Literal><Symbol Role="Variable">mm</Symbol><Filename>/</Filename><Symbol Role="Variable">dd</Symbol><Filename>/</Filename><Symbol Role="Variable">yy</Symbol> [<Symbol Role="Variable">hh</Symbol><Literal>:</Literal><Symbol Role="Variable">mm</Symbol>]
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>If you specify a time, you must use 24-hour time. For example, <Literal>at 11/22/92
11:36</Literal> specifies an expiration date and time of 22 November 1992 at 11:36
a.m.  If no time is provided, a default time of 00:00 (12:00 a.m.) on the
indicated date is used.
</Para>
</ListItem>
</ItemizedList>
<Para>If you omit the <Option>expires</Option> option from a command, tapes created at dump
levels specified with the command have no expiration dates; they can be
overwritten at any time.  Also, although the <Option>expires</Option> options are 
followed by ellipses, you can specify only one expiration date.  The 
ellipses are included only to accommodate the DFS command parser.
</Para>
</ListItem>
<ListItem>
<Para>The <Option>tcid</Option> <Symbol Role="Variable">tc_number</Symbol> option is the TCID of the Tape Coordinator to 
be used for the command.  Legal values are integers from 0 (zero) to 1023.  If 
this option is omitted, the Tape Coordinator with a TCID of 0 is used to 
execute the command by default.
</Para>
</ListItem>
</ItemizedList>
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.10">
<Title>Standard Commands and Operations</Title>
<Para>The following subsections describe commands and operations that are used 
frequently in this chapter.  If a command or operation is described in detail 
here, it generally is not described in depth in later sections of this 
chapter where it is used.
</Para>
<Sect3 Id="DFSAGR.BKUP.div.11">
<Title>Starting a Tape Coordinator</Title>
<Para>Before performing a backup or restore operation, you must install at least
one tape drive on a Tape Coordinator machine and define its corresponding Tape
Coordinator in both the <Symbol Role="Variable">dcelocal</Symbol><Literal>/var/dfs/backup/TapeConfig</Literal> file and
the Backup Database. (See Section 9.3.1 for a description of these and other
configuration operations that must be performed.) This section explains how to
start a Tape Coordinator.  You must have a Tape Coordinator running any time you
access a tape drive for use with the Backup System.
</Para>
<OrderedList>
<ListItem>
<Para>Make certain that you have the <Literal>w</Literal> (write) and <Literal>x</Literal> (execute) 
permissions on the <Symbol Role="Variable">dcelocal</Symbol><Filename>/var/dfs/backup</Filename> directory, which is the 
directory in which the Tape Coordinator creates its <Filename>TL</Filename> (log) and 
<Filename>TE</Filename> (error) files.
</Para>
</ListItem>
<ListItem>
<Para>Start a new terminal session on the Tape Coordinator machine to use as the
monitoring window for the Tape Coordinator.  It must remain open while the Tape
Coordinator runs.
</Para>
</ListItem>
<ListItem>
<Para>In the newly opened window, issue the <Command>butc</Command> command to start the Tape
Coordinator.  The binary file for the <Command>butc</Command> program resides in the
<Symbol Role="Variable">dceshared</Symbol><Filename>/bin</Filename> directory.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>butc</Command> [<Option>tcid </Option><Symbol Role="Variable">tc_number</Symbol>] [<Option>debuglevel </Option><Symbol Role="Variable">trace_level</Symbol>]
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Option>debuglevel</Option> <Symbol Role="Variable">trace_level</Symbol> option specifies the type of 
messages to be displayed.  There are two valid arguments:
</Para>
<VariableList>
<VarListEntry>
<Term>1</Term>
<ListItem>
<Para>Indicates that the Tape Coordinator is to report on its activities as 
it restores filesets, in addition to prompting for new tapes as necessary.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>0</Term>
<ListItem>
<Para>Indicates that the Tape Coordinator is only to prompt for new tapes; it also
displays some output as necessary for operations that it executes.  This is the
default.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</ListItem>
</OrderedList>
<Note>
<Para>If you are using an automated backup device, such as a stacker or
jukebox, you can create a user-defined configuration file to control
that device. This file is read by the <Command>butc</Command> command and is used
to configure a Tape Coordinator. (See Section 9.3.2.for more information.)
</Para>
</Note>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.12">
<Title>Stopping a Tape Coordinator</Title>
<Para>When you are finished using a Tape Coordinator, you should stop it from
running.  To stop a Tape Coordinator process, enter an interrupt signal
(<Literal>&lt;Ctrl-c></Literal> or its equivalent) in the Tape Coordinator's monitoring window.
<?sml-break><?sml-need 20></Para>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.13">
<Title>Determining Tape Size and End-of-File Mark Size</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.32">
<Primary>tapes</Primary>
<Secondary>determining size</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.33">
<Primary>EOF marks</Primary>
<Secondary>determining size</Secondary>
</IndexTerm>
<Para>The size of a tape determines the amount of data the Backup System can place
on it.  The tape size differs for different tape drives.  In addition, the
Backup System appends an end-of-file (EOF) mark after each fileset it dumps
to tape.  The size of the mark also affects the amount of space available for
backup data on a tape.  The values used for both of these figures are specified 
in the <Literal>TapeConfig</Literal> file once for each tape drive.  Note that an EOF mark 
is appended after each fileset, not after each file.
</Para>
<Para>If you do not know the tape capacity or EOF mark size for a tape drive, use
the <Command>fms</Command> (file mark size) command to determine these values.  The binary
file for this command resides in the <Symbol Role="Variable">dceshared</Symbol><Filename>/bin</Filename> directory.  This 
command produces terminal output and an <Filename>FMSLog</Filename> file in the current 
directory; both the output and the <Filename>FMSLog</Filename> file list the tape capacity 
and the size of the EOF mark for the drive.
</Para>
<Note>
<Para>Because this command inserts file marks onto the entire tape, it can take from
several hours to more than a day to complete.
</Para>
</Note>
<Para>To determine the EOF mark size for a tape drive, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Make certain you have the <Literal>w</Literal> (write), <Literal>x</Literal> (execute), and <Literal>i</Literal>
(insert) ACL permissions on the directory from which the command is issued. 
If the <Filename>FMSLog</Filename> file already exists in the directory, you need to have 
only the <Literal>w</Literal> permission on the file.
</Para>
</ListItem>
<ListItem>
<Para>Insert a tape into the tape drive.  The tape is overwritten while the command
executes; you may want to use a blank tape or one that can be recycled.
</Para>
</ListItem>
<ListItem>
<Para>Enter the <Command>fms</Command> command:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>fms -device </Command><Symbol Role="Variable">device_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Option>device</Option> <Symbol Role="Variable">device_name</Symbol> option specifies the name of the tape 
drive.
</Para>
<Para>An example of this command and its terminal output follows; the
command also writes similar information to the <Filename>FMSLog</Filename> file.
In the example, the tape size for the drive named
<Filename>/dev/rmth1h</Filename> is 2,136,604,672 bytes; the EOF mark size for the
drive is 1,910,220 bytes.
<?sml-break><?sml-need 20></Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Literal>fms /dev/rmth1h</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>wrote block: 130408
Finished data capacity test - rewinding
wrote 1109 blocks, 1109 file marks
Finished file mark test
Tape capacity is 2136604672 bytes
File marks are 1910220 bytes
</ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
<IndexTerm Id="DFSAGR.BKUP.indx.34" SpanEnd="DFSAGR.BKUP.indx.32">
<IndexTerm Id="DFSAGR.BKUP.indx.35" SpanEnd="DFSAGR.BKUP.indx.33">
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.14">
<Title>Using the Interactive Interface</Title>
<Para>You can use the <Command>bak</Command> commands in regular command mode or in interactive
mode.  If you use interactive mode, not the following:
</Para>
<ItemizedList>
<ListItem>
<Para>You do not need to enter the string <Command>bak</Command> with each <Command>bak</Command> command; 
the <ComputerOutput>bak></ComputerOutput> prompt replaces the command shell prompt.
</Para>
</ListItem>
<ListItem>
<Para>You do not have to escape regular expression characters; in regular command
mode, you must place all regular expressions and wildcards in "&thinsp;" (double 
quotes) or escape each with a <Literal>&bsol;</Literal> (backslash).
</Para>
</ListItem>
<ListItem>
<Para>You can track executing and pending operations with the <Command>bak jobs</Command>
command; in regular command mode, you cannot track operations.
</Para>
</ListItem>
<ListItem>
<Para>You can cancel currently executing and pending operations with the <Command>bak
kill</Command> command; in regular command mode, you cannot use the <Command>bak kill</Command>
command.
</Para>
</ListItem>
<ListItem>
<Para>You do not have to establish a new connection each time you issue a command,
so execution time is quicker; in regular command mode, each command establishes
new connections to the <Command>bakserver</Command> and <Command>flserver</Command> processes, as
necessary.
</Para>
</ListItem>
</ItemizedList>
<Para>Most of the operations described in this chapter are presented in regular
command mode.  Where appropriate, some operations include steps introduced as
<Replaceable>Optional</Replaceable> to indicate where working in interactive mode could be useful.
The <Command>bak jobs</Command> and <Command>bak kill</Command> commands can be entered <Replaceable>only</Replaceable> in
interactive mode.
<?sml-break><?sml-need 20></Para>
<Sect4 Id="DFSAGR.BKUP.div.15">
<Title>Entering Interactive Mode</Title>
<Para>Enter the <Command>bak</Command> command:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak</Command>
</UserInput></ProgramListing></Para>
</InformalExample>
</Sect4>
<Sect4 Id="DFSAGR.BKUP.div.16">
<Title>Leaving Interactive Mode</Title>
<Para>Enter the <Literal>quit</Literal> command at the <ComputerOutput>bak></ComputerOutput> prompt:
</Para>
<InformalExample>
<Para><ProgramListing><ComputerOutput>bak> </ComputerOutput><UserInput><Literal>quit</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
</Sect4>
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="DFSAGR.BKUP.div.17">
<Title>Configuring the Backup System</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.36">
<Primary>Backup System</Primary>
<Secondary>configuring</Secondary>
</IndexTerm>
<Para>Before using the Backup System for backing up and restoring data, you must
ensure that certain conditions have been met.  The following subsections 
explain in detail how to perform the following prerequisite tasks:
</Para>
<ItemizedList>
<ListItem>
<Para>Configuring Tape Coordinator machines
</Para>
</ListItem>
<ListItem>
<Para>Defining fileset families and fileset family entries
</Para>
</ListItem>
<ListItem>
<Para>Defining a dump hierarchy of dump levels
</Para>
</ListItem>
<ListItem>
<Para>Labeling tapes, if necessary
</Para>
</ListItem>
</ItemizedList>
<Para>See Chapter 10 for information on inspecting the status of these prerequisites.
If all of the prerequisites are met, turn to the appropriate section in Chapter
10 for information on using the Backup System.
<?sml-break><?sml-need 20></Para>
<Sect2 Id="DFSAGR.BKUP.div.18">
<Title>Configuring a Tape Coordinator Machine</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.37">
<Primary>Tape Coordinator machines</Primary>
<Secondary>configuring</Secondary>
</IndexTerm>
<Para>Setting up a Tape Coordinator machine consists of using <Command>bak</Command> commands to
configure the Tape Coordinators for the machine.  You must also create the
<Literal>TapeConfig</Literal> file, which includes a line for each Tape Coordinator on the
machine.  Each line defines the
</Para>
<ItemizedList>
<ListItem>
<Para>Size of tapes used in the drive, in kilobyte, megabyte, or gigabyte units.
</Para>
</ListItem>
<ListItem>
<Para>End-of-file (EOF) mark size for the drive.  EOF marks are placed between
filesets on a tape.  The size of the EOF mark can differ for each type of tape
drive.
</Para>
</ListItem>
<ListItem>
<Para>Device name (for example, <Filename>/dev/rst0</Filename>) of the drive.
</Para>
</ListItem>
<ListItem>
<Para>Tape Coordinator ID (TCID) of the drive.
</Para>
</ListItem>
</ItemizedList>
<Para>Each tape drive and its Tape Coordinator must be assigned a TCID in the range
from 0 to 1023; the TCID must be unique in the Backup Database of the local
cell.  When assigning the TCID, you must define the ID number in the Backup
Database with the <Command>bak addhost</Command> command; you must also include the TCID
in the entry for the tape drive in the <Literal>TapeConfig</Literal> file on the local disk
of the Tape Coordinator machine.
</Para>
<Para>Perform the following tasks once, when you initially configure a Tape
Coordinator machine:
</Para>
<OrderedList>
<ListItem>
<Para>Prepare the tape drives.
</Para>
</ListItem>
<ListItem>
<Para>Create the <Literal>TapeConfig</Literal> file that defines the tape parameters for each
drive.
</Para>
</ListItem>
<ListItem>
<Para>Create an entry in the Backup Database for the Tape Coordinator for each drive.
</Para>
</ListItem>
</OrderedList>
<Para>The following subsections describe the steps necessary to configure a machine
as a Tape Coordinator machine.  The instructions in Section 9.3.1.1 are required
only if the machine to be configured as a Tape Coordinator machine is not a DFS
server machine of some type (the machine must at least be a DCE client).  The
instructions in Section 9.3.1.2 are required for any machine to be configured
as a Tape Coordinator machine.
<?sml-break><?sml-need 20></Para>
<Sect3 Id="DFSAGR.BKUP.div.19">
<Title>Steps Required for a Client-Only Machine</Title>
<Para>You must perform the following steps to configure a DCE client that is not a
DFS server machine of some type (for example, a File Server machine or a Backup
Database machine) as a Tape Coordinator machine.  For a client-only machine,
perform these steps before you perform the steps in Section 9.3.1.2; perform
the steps on the machine that is to be configured as a Tape Coordinator
machine.  Do not perform these steps for a machine that is configured as some
type of DFS server machine.
</Para>
<OrderedList>
<ListItem>
<Para>Verify that the <Symbol Role="Variable">dcelocal</Symbol><Filename>/var/dfs</Filename> and <Symbol Role="Variable">dcelocal</Symbol><Filename>/var/dfs/backup</Filename>
directories exist on the machine.  Create the directories if they do not already
exist.
</Para>
</ListItem>
<ListItem>
<Para>Verify that you have the permissions necessary to create and modify principals
and accounts in the Registry Database (for example, you need the <Literal>i</Literal>
(insert) permission to create a principal in the <Literal>hosts/</Literal><Symbol Role="Variable">hostname</Symbol>
directory, where <Symbol Role="Variable">hostname</Symbol> is the name of the machine to be configured
as a Tape Coordinator machine).  If necessary, use the <Command>dcecp acl show</Command>
command to determine your permissions for a directory.
</Para>
</ListItem>
<ListItem>
<Para>Use the <Command>dcecp principal create</Command> command to create a DFS server principal
for the client machine that is to be configured as a Tape Coordinator machine:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>dcecp</Command>
dcecp> <Literal>principal create hosts/</Literal><Symbol Role="Variable">hostname</Symbol><Filename>/dfs-server</Filename>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>In the command, <Symbol Role="Variable">hostname</Symbol> is the name of the machine to be configured
as a Tape Coordinator machine (for example, <Literal>client1</Literal>).  The DFS server
principal created in this step is used in all subsequent steps that require
the DFS server principal of the machine. (Machines configured as some type of
DFS server machine receive DFS server principals when they are configured.)
<?sml-break><?sml-need 20></Para>
</ListItem>
<ListItem>
<Para>Use the <Command>dcecp account create</Command> command to create an account for the DFS
server principal of the machine:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>dcecp> <Literal>account create hosts/</Literal><Symbol Role="Variable">hostname</Symbol><Literal>/dfs-server \
</Literal>> <Literal>-group subsys/dce/dfs-admin -org none \
</Literal>> \ 
<Option>password</Option> <Symbol Role="Variable">acct_password</Symbol> <Option>mypwd</Option> <Symbol Role="Variable">your_password</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>In the command, <Literal>hosts/</Literal><Symbol Role="Variable">hostname</Symbol><Filename>/dfs-server</Filename> is the DFS server
principal for which an account is to be created.  The remaining options provide
the following information:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Option>group</Option> <Replaceable>subsys/dce/dfs-admin</Replaceable> option specifies that the primary group
of the account is to be the group named <Literal>subsys/dce/dfs-admin</Literal>. (The DFS
server principals of all machines configured as some type of DFS server machine
are added to this group when the machines are configured.)
</Para>
</ListItem>
<ListItem>
<Para>The <Option>org</Option> none option specifies that the organization of the account is
to be the organization named <Literal>none</Literal>.
</Para>
</ListItem>
<ListItem>
<Para>The <Option>password</Option> <Symbol Role="Variable">acct_password</Symbol> option provides the password for the
account of the DFS server principal.  Choose a string that you can remember.
You use the <Command>dcecp keytab add</Command> command to generate a random password for
the account later in these instructions, so you do not need to enter a complex
password at this time.
</Para>
</ListItem>
<ListItem>
<Para>The <Option>mypwd</Option> <Symbol Role="Variable">your_password</Symbol> option is your password (the password for
the DCE account to which you are currently authenticated).
</Para>
</ListItem>
</ItemizedList>
<?sml-break>
<?sml-need 20>
</ListItem>
<ListItem>
<Para>Use the <Command>dcecp keytab add</Command> command to add a server encryption key for the
DFS server principal to the default local keytab file, <Filename>/krb5/v5srvtab</Filename>.
The <Command>dced</Command> process recognizes the keytab file by the name <Literal>self</Literal>.  The
command creates the keytab file if the file does not already exist.  Use the
<Option>member</Option> option to specify the name of the DFS server principal, and
use the <Option>key</Option> option to specify the password that you entered for the
principal's account in the previous step.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>dcecp> <Literal>keytab add self -member hosts/</Literal><Symbol Role="Variable">hostname</Symbol><Literal>/dfs-server \
</Literal>> \ 
<Option>key</Option> <Symbol Role="Variable">acct_password</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>Use the <Command>dcecp keytab add</Command> command to create a new server encryption key
for the DFS server principal.  Use the <Option>member</Option> option to specify the name
of the DFS server principal.  The <Option>random</Option> option directs the command to
generate a random string for use as the principal's server encryption key,
and the <Option>registry</Option> option directs the command to update the password
of the principal's account in the registry database to match the randomly
generated encryption key.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>dcecp> <Literal>keytab add self -member hosts/</Literal><Symbol Role="Variable">hostname</Symbol><Literal>/dfs-server \
</Literal>> \
<Option>random</Option> <Option>registry</Option></UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>Use the <Command>dcecp acl modify</Command> command with the <Literal>-add</Literal> option to add an
entry for the group <Literal>subsys/dce/dfs-admin</Literal> to the ACL of the entry for the
DFS server principal in the security namespace.  The <Option>add</Option> option provides
the ACL entry to be added to the ACL of the principal's entry.  The permissions
included in the ACL entry allow members of the specified group to perform all
required operations on the principal's entry.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>dcecp> <Literal>acl modify /.../</Literal><Symbol Role="Variable">cellname</Symbol><Filename>/sec/principal/hosts/</Filename><Symbol Role="Variable">hostname</Symbol><Literal>/dfs-server \
</Literal>> \ 
<Option>add</Option> <Replaceable>{group subsys/dce/dfs-admin rcDnfmag}</Replaceable>
dcecp> <Command>exit</Command>
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
<Para>Once you have completed these steps, perform all of the steps in Section
9.3.1.2.
</Para>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.20">
<Title>Steps Required for All Machines</Title>
<Para>You must perform the following steps to configure any machine as a Tape
Coordinator machine.  If the machine to be configured is a DCE client but
not a DFS server machine of some type, you must perform all of the steps in
Section 9.3.1.1 before performing the steps in this section.  If the machine
is configured as some type of DFS server machine, you do not need to perform
the steps in Section 9.3.1.1.
</Para>
<OrderedList>
<ListItem>
<Para>Install one or more drives on the machine according to the manufacturer's
instructions.  The Backup System can track a maximum of 1024 drives in a cell.
<?sml-break><?sml-need 20></Para>
</ListItem>
<ListItem>
<Para>Verify that you have the <Literal>w</Literal> (write) and <Literal>x</Literal> (execute) permissions on 
the <Symbol Role="Variable">dcelocal</Symbol><Filename>/var/dfs/backup</Filename> directory (the directory in which you must
create the <Literal>TapeConfig</Literal> file).
</Para>
</ListItem>
<ListItem>
<Para>Create the <Symbol Role="Variable">dcelocal</Symbol><Literal>/var/dfs/backup/TapeConfig</Literal> file on the machine
with a text editor.  Use a single line in the file for each tape drive attached
to the Tape Coordinator machine, recording the following information:
</Para>
<ItemizedList>
<ListItem>
<IndexTerm Id="DFSAGR.BKUP.indx.38">
<Primary>tapes</Primary>
<Secondary>recommended size</Secondary>
</IndexTerm>
<Para>The tape size of the tapes to be used in the drive.  The Tape Coordinator uses
this capacity as the size of all tapes used in the drive.  It is recommended
that you use a number 10 to 15% lower than the actual tape capacity to allow
for tape variations.  The following abbreviations can be used for the tape size
unit of measurement (the default is kilobytes); do not leave a space between
the number and the letter.
</Para>
<ItemizedList>
<ListItem>
<Para>Kilobytes: k or K (for example, 2k or 2K)
</Para>
</ListItem>
<ListItem>
<Para>Megabytes: m or M (for example, 2m or 2M)
</Para>
</ListItem>
<ListItem>
<Para>Gigabytes: g or G (for example, 2g or 2G)
</Para>
</ListItem>
</ItemizedList>
<?sml-break>
<?sml-need 20>
</ListItem>
<ListItem>
<IndexTerm Id="DFSAGR.BKUP.indx.39">
<Primary>EOF marks</Primary>
<Secondary>range of sizes</Secondary>
</IndexTerm>
<Para>The EOF mark size for the type of tape to be used in the
drive.  The Backup System appends an EOF mark after each fileset dumped to
tape.  The size of this mark can affect the amount of space available for
backup data.  The EOF mark size can vary from 2 kilobytes to more than 2
megabytes, depending on the type of tape drive used.  It is recommended that
you increase the actual file mark size by 10 to 15% to allow for tape
variations.
</Para>
<Para>If you do not specify a unit of measurement, the default unit used for the
EOF size is bytes (<Symbol Role="Variable">not</Symbol> kilobytes, as for tape capacity).  To indicate
other units, use the same abbreviations as for tape capacity.
</Para>
</ListItem>
<ListItem>
<Para>The device name of the tape drive.  The format of this name varies with each
operating system.  For example, in the UNIX operating system, a valid device
name is <Filename>/dev/rst0</Filename>.
</Para>
</ListItem>
<ListItem>
<IndexTerm Id="DFSAGR.BKUP.indx.40">
<Primary>Tape Coordinator IDs (TCIDs)</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<Para>The TCID for the Tape Coordinator associated with the drive.  The Backup
System can track a maximum of 1024 tape drives; legal values are integers from
0 to 1023.  You do not have to assign the numbers in sequence, and you
can skip numbers.  The TCID for any Tape Coordinator must be unique among all
TCIDs in the local cell.
</Para>
<Para>Because the <Command>bak</Command> commands that require you to specify a TCID always use a
default TCID of 0, assign a TCID of 0 to the Tape Coordinator for
the drive that you will use most often; this enables you to omit the 
<Option>tcid</Option> option as often as possible.
</Para>
</ListItem>
</ItemizedList>
<Para>If you do not know the tape size or the EOF mark size for the tape drive,
determine them by using the <Command>fms</Command> command, as described in Section
9.2.2.3.
</Para>
<Para>Following is an example listing of the contents of the <Literal>TapeConfig</Literal> file
for a machine with two drives.  The tape size for each drive is 2 gigabytes;
the EOF mark size for each drive is 1 megabyte.  The respective TCIDs of the
two drives are 0 and 1.
</Para>
<InformalExample>
<Para><ProgramListing>2g 1m /dev/rmth0h 0
2G 1M /dev/rmth1h 1
</ProgramListing></Para>
</InformalExample>
<?sml-break>
<?sml-need 20>
</ListItem>
<ListItem>
<Para>Ensure that the <Command>bak</Command> and <Command>butc</Command> binary files are stored on the local
machine.  The <Command>bak</Command> file should be stored in the <Symbol Role="Variable">dcelocal</Symbol><Filename>/bin</Filename>
directory; the <Command>butc</Command> file should be stored in the <Symbol Role="Variable">dceshared</Symbol><Filename>/bin</Filename>
directory (a symbolic link to the file may exist from the <Symbol Role="Variable">dcelocal</Symbol><Filename>/bin</Filename>
directory).
</Para>
</ListItem>
<ListItem>
<Para>Verify that the individuals who are to use the Backup System are included in
the appropriate administrative lists (see Section 9.1.5); if necessary, issue
the <Command>bos lsadmin</Command> command to check.  You also need to ensure that you are
included in the <Filename>admin.bak</Filename> list to issue the <Command>bak addhost</Command> command
that follows.  To add someone to a list, issue the <Command>bos addadmin</Command> command.
</Para>
</ListItem>
<ListItem>
<Para>Verify that the <Command>bakserver</Command> process is running on the cell's Backup
Database machines.  If necessary, issue the <Command>bos status</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para><Replaceable>Optional</Replaceable>.  At this point, you can issue the <Command>bak</Command> command at the
system prompt to enter interactive mode.  The advantages of interactive mode
are described in Section 9.2.2.4.  The command in the following step assumes
that regular command mode is used, not interactive mode.
</Para>
</ListItem>
<ListItem>
<Para>Enter the <Command>bak addhost</Command> command to create an entry in the Backup Database
for each Tape Coordinator, defining its TCID:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak addhost -tapehost </Command><Symbol Role="Variable">machine</Symbol> [<Option>tcid </Option><Symbol Role="Variable">tc_number</Symbol>]
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Repeat the <Command>bak addhost</Command> command for each Tape Coordinator to be added.
</Para>
</ListItem>
</OrderedList>
<IndexTerm Id="DFSAGR.BKUP.indx.41" SpanEnd="DFSAGR.BKUP.indx.37">
</Sect3>
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.21">
<Title>Creating a User-Defined Configuration File</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.42">
<Primary>stackers</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.43">
<Primary>jukeboxes</Primary>
<Secondary>about</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.44">
<Primary>Backup System</Primary>
<Secondary>user-defined configuration file</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.45">
<Primary>user-defined configuration file</Primary>
<Secondary>use with Backup System</Secondary>
</IndexTerm>
<Para>You can create a user-defined configuration file to support automated
backup equipment, such as stackers and jukeboxes.  These devices
automatically switch tapes during a dump. Jukeboxes can also
automatically fetch the proper tapes for a restore operation. To
handle the varying requirements of automated backup equipment, the
user-defined configuration file calls executable routines that you
create to operate your backup equipment. Through the user-defined
configuration file, you can select the level of automation you want
the Tape Coordinator to use.
</Para>
<Para>Each backup device on a Tape Coordinator machine can have its own
user-defined configuration file. The file must reside in the
<Symbol Role="Variable">dcelocal</Symbol><Filename>/var/dfs/backup</Filename> directory and it must have a
name in of the form <Literal>conf_</Literal><Symbol Role="Variable">tape_device</Symbol>, where
<Symbol Role="Variable">tape_device</Symbol> specifies
the relevant device. A separate file is required
for each backup device.
</Para>
<Para><IndexTerm Id="DFSAGR.BKUP.indx.46">
<Primary><Command>butc</Command> program</Primary>
<Secondary>interaction with user-defined configuration program</Secondary>
</IndexTerm>When starting a Tape Coordinator, the <Command>butc</Command> program reads the
<Literal>conf_</Literal>Vtape_device file and configures the Tape Coordinator
based on the parameter settings it finds in the file. The
configuration file parameters are the following:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>MOUNT</Literal></Term>
<ListItem>
<Para>Names a file that contains an executable routine.  The routine can
mount an automated backup device, such as a stacker or jukebox.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>UNMOUNT</Literal></Term>
<ListItem>
<Para>Names a file that contains an executable routine to perform tape
unmount operations for an automated backup device.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>ASK</Literal></Term>
<ListItem>
<Para>Can be used to force all Backup System prompts to accept the
default answers rather than query the operator.  This does not affect
the initial prompt to mount the first tape. This parameter is useful
for fully automating the backup process.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>AUTOQUERY</Literal></Term>
<ListItem>
<Para>Can be used to disable the initial Tape Coordinator prompt to mount the
first tape. This parameter is also useful for fully automating the
backup process.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>NAME_CHECK</Literal></Term>
<ListItem>
<Para>Can be set to prevent the Backup System from checking tape names.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>FILE</Literal></Term>
<ListItem>
<Para>Can be used to direct the dump to tape or to a specified file.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>The following sections define each of the parameters in
detail. Section 9.3.2.7 contains annotated sample scripts that
illustrate typical routines to control automated backup equipment.
</Para>
<Sect3 Id="DFSAGR.BKUP.div.22">
<Title>The MOUNT Parameter</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.47">
<Primary>user-defined configuration program</Primary>
<Secondary><Literal>MOUNT</Literal> parameter</Secondary>
</IndexTerm>
<Para>By default, the Backup System prompts the operator to mount a tape
before opening the tape device file.  However, the <Literal>MOUNT</Literal>
parameter provides a mechanism to load a tape through an automated
backup device.  The <Literal>MOUNT</Literal> parameter takes an absolute pathname as
an argument:
</Para>
<Para> <Literal>MOUNT /</Literal><Symbol Role="Variable">pathname</Symbol>
</Para>
<Para>The specified file contains the executable routine to load the
tape.  
</Para>
<Para>The following information is passed from the Backup System to
the executable routine:
</Para>
<ItemizedList>
<ListItem>
<Para>The tape device pathname.
</Para>
</ListItem>
<ListItem>
<Para>The tape operation, which is selected by issuing one of the
corresponding <Command>bak</Command> commands. The set of tape operations follows:
</Para>
<ItemizedList>
<ListItem>
<Para><Command>dump</Command>
</Para>
</ListItem>
<ListItem>
<Para><Literal>labeltape</Literal>
</Para>
</ListItem>
<ListItem>
<Para><Command>readlabel</Command>
</Para>
</ListItem>
<ListItem>
<Para><Command>restore</Command>
</Para>
</ListItem>
<ListItem>
<Para><Command>restoredb</Command>
</Para>
</ListItem>
<ListItem>
<Para><Command>savedb</Command>
</Para>
</ListItem>
<ListItem>
<Para><Command>scantape</Command>
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para>The number of times the tape has been requested. If an error occurs
when the tape device is opened, this value is incremented by one and
the executable routine is called again.
</Para>
</ListItem>
<ListItem>
<Para>The tape name. If no tape name is specified, <Literal>none</Literal> is passed to
the executable routine.
</Para>
</ListItem>
<ListItem>
<Para>The dump ID. This is a unique indentification code assigned by the Backup
System. If no dump ID is specified, <Literal>none</Literal> is passed to
the executable routine.
</Para>
</ListItem>
</ItemizedList>
<Note Remap="notes">
<Para>If you do not specify the <Literal>MOUNT</Literal> parameter, the Backup System
prompts the operator to mount the first tape.
</Para>
<Para>You can use the <Literal>AUTOQUERY</Literal> parameter to prevent the Backup
System from prompting the operator to mount the first tape. Section
9.3.2.4 discusses this parameter.
</Para>
<Para>If the executable routine returns an exit code of 0, the backup
process continues. An exit code of 1 aborts the backup
process. Any other exit code causes the backup process to prompt the
operator for the correct tape.
</Para>
<Para>To abort the <Literal>MOUNT</Literal> parameter routine, type an <Literal>a</Literal>
(for abort) in the Tape Coordinator monitoring window. The process
then aborts the executable routine and prompts the operator to mount
the correct tape.
</Para>
</Note>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.23">
<Title>The UNMOUNT Parameter</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.48">
<Primary>user-defined configuration file</Primary>
<Secondary><Literal>UNMOUNT</Literal> parameter</Secondary>
</IndexTerm>
<Para>Like the <Literal>MOUNT</Literal> parameter, the <Literal>UNMOUNT</Literal> parameter specifies
a file that contains an executable routine. In this case, the
executable routine is used to remove a tape from an automated
backup device. The <Literal>UNMOUNT</Literal> parameter takes an absolute pathname
as an argument:
</Para>
<Para><Literal>UNMOUNT /</Literal><Symbol Role="Variable">pathname</Symbol>
</Para>
<Para>The file specified by the <Literal>UNMOUNT</Literal> parameter is executed when the
Backup System closes a tape device (whether the
close operation succeeds or fails). 
</Para>
<Para>The Backup System passes the following information to the executable
routine:
</Para>
<ItemizedList>
<ListItem>
<Para>The tape device file path and name.
</Para>
</ListItem>
<ListItem>
<Para>The tape operation, which in this case is <Command>unmount</Command>. 
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.24">
<Title>The ASK Parameter</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.49">
<Primary>user-defined configuration file</Primary>
<Secondary><Acronym>SK</Acronym> parameter</Secondary>
</IndexTerm>
<Para>The <Literal>ASK</Literal> parameter determines whether the Backup System should
prompt the operator when an error occurs or simply use the default
responses. The <Literal>ASK</Literal> parameter does not disable the initial prompt
to mount a tape.  The parameter takes the following arguments:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>YES</Literal></Term>
<ListItem>
<Para>Enables operator prompts for all error cases. Not specifying the
<Literal>ASK</Literal> parameter has the same result.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>NO</Literal></Term>
<ListItem>
<Para>Disables operator prompts for all error cases and assumes the default
responses.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>The possible error conditions are:
</Para>
<ItemizedList>
<ListItem>
<Para>A <Command>bak restore</Command> operation fails to restore a volume.  The
<Literal>YES</Literal> argument causes the Backup System to ask whether the
operator wishes to continue the restore operation. The <Literal>NO</Literal>
argument continues the restore.
</Para>
</ListItem>
<ListItem>
<Para>A <Command>bak dump</Command> operation fails to dump a volume.  The <Literal>YES</Literal>
argument causes the Backup System to ask whether the dump for that
volume should be retried, the volume should be omitted, or the dump
operation should be aborted. The <Literal>NO</Literal> argument proceeds with the
dump but omits the volume.
</Para>
</ListItem>
<ListItem>
<Para>A <Command>bak scantape</Command> operation cannot determine whether there is a next
tape in the dump set. The <Literal>YES</Literal> argument causes the Backup System
to ask whether there are more tapes to be dumped. The <Literal>NO</Literal> argument
assumes that there are more tapes.
</Para>
</ListItem>
<ListItem>
<Para>A <Command>bak labeltape</Command> operation attempts to label a non-expired
tape. The <Literal>YES</Literal> argument causes the Backup System to ask whether
the operation should proceed.  The <Literal>NO</Literal> argument does not label the
tape. 
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.25">
<Title>The AUTOQUERY Parameter</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.50">
<Primary>user-defined configuration file</Primary>
<Secondary><Literal>AUTOQUERY</Literal> parameter</Secondary>
</IndexTerm>
<Para>The <Literal>AUTOQUERY</Literal> parameter disables the Backup System's initial
prompt to mount a tape. Use the <Literal>AUTOQUERY</Literal> parameter in
conjunction with the <Literal>ASK</Literal> parameter to disable all prompting from
the Backup System. The <Literal>AUTOQUERY</Literal> parameter has the following
arguments:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>YES</Literal></Term>
<ListItem>
<Para>Enables the operator prompt for the first tape in the dump set. Not
specifying the <Literal>AUTOQUERY</Literal> parameter provides the same result.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>NO</Literal></Term>
<ListItem>
<Para>Disables the operator prompt for the first tape. A <Literal>NO</Literal> argument
is similar to the <Option>noautoquery</Option> option for the <Command>butc</Command> command. 
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.26">
<Title>The NAME_CHECK Parameter</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.51">
<Primary>user-defined configuration file</Primary>
<Secondary><Literal>NAME_CHECK</Literal> parameter</Secondary>
</IndexTerm>
<Para>The <Literal>NAME_CHECK</Literal> parameter prevents the Backup System from
checking tape names. The parameter has the following valid arguments:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>YES</Literal></Term>
<ListItem>
<Para>Enables tape name checking. The Tape Coordinator verifies that the
tape name is either <Literal>NULL</Literal> or the same name as the dump set.  Not
specifying the <Literal>NAME_CHECK</Literal> parameter provides the same result.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>NO</Literal></Term>
<ListItem>
<Para>Disables tape name checking. Any non-expired tape is acceptable. 
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>Disabling name checking is useful for recycling tapes without first
relabeling them.
</Para>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.27">
<Title>The FILE Parameter</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.52">
<Primary>user-defined configuration file</Primary>
<Secondary><Literal>FILE</Literal> parameter</Secondary>
</IndexTerm>
<Para>The <Literal>FILE</Literal> parameter specifies whether the dump and restore
operations will write to or read from a tape or a file. The parameter
has the following valid arguments:
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>YES</Literal></Term>
<ListItem>
<Para>Dump and restore operations use a file. The target pathname
is specified in the
<Filename>/opt/dcelocal/var/dfs/backup/TapeConfig</Filename> file. 
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>NO</Literal></Term>
<ListItem>
<Para>Dump and restore operations use a tape device. Not specifying the
<Literal>FILE</Literal> parameter provides the same result.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>Keep these points in mind when using this parameter:
</Para>
<ItemizedList>
<ListItem>
<Para>If the Tape Coordinator needs another file to continue an operation,
it prompts the operator to mount another tape but then continues the
operation using the pathname specified in the
<Filename>/opt/dcelocal/var/dfs/backup/TapeConfig</Filename> file. A good practice is
to specify a pathname that is a link to another file. If you must
then provide another file name, you can take advantage of the prompt
for a new tape to change the link to a new pathname.
</Para>
</ListItem>
<ListItem>
<Para>Do not specify the <Literal>YES</Literal> argument when using a tape device or the <Literal>NO</Literal>
argument when using a file.  Neither arrangement works.
</Para>
</ListItem>
<ListItem>
<Para>If you specify <Literal>YES</Literal>, all <Literal>ioctl</Literal> calls are removed. Data is
still written in 16 KB blocks; however, the position of database
records is not a filemark position (as is normal with
tapes). Positioning to a volume is done directly with a <Literal>seek</Literal>
call.
</Para>
</ListItem>
</ItemizedList>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.28">
<Title>Sample User-Defined Configuration Files</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.53">
<Primary>user-defined configuration file</Primary>
<Secondary>example files</Secondary>
</IndexTerm>
<Para>The following sample <Literal>conf_</Literal>Vtape_device files show how
you might structure configuration files for stackers, jukeboxes, or
file dumps. They are examples only and are not recommendations.
</Para>
<Para>There are two general considerations concerning the
<Literal>conf_</Literal>Vtape_device files (these considerations are
discussed in detail in section 9.3.2.1.), as follows:
</Para>
<OrderedList>
<ListItem>
<Para>The Backup System passes the following parameters to the
<Literal>conf_</Literal>Vtape_device file:
</Para>
<ItemizedList>
<ListItem>
<Para>The tape device pathname
</Para>
</ListItem>
<ListItem>
<Para>The tape operation
</Para>
</ListItem>
<ListItem>
<Para>The number of times the tape has been requested
</Para>
</ListItem>
<ListItem>
<Para>The tape name
</Para>
</ListItem>
<ListItem>
<Para>The dump ID
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para>The Backup System responds to exit codes from the
<Literal>conf_</Literal>Vtape_device file in the following ways:
</Para>
<VariableList>
<VarListEntry>
<Term>Exit code 0</Term>
<ListItem>
<Para>Continue the backup process.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Exit code 1</Term>
<ListItem>
<Para>Abort the backup process.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Any other exit code</Term>
<ListItem>
<Para>Prompt the operator for the correct tape.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</ListItem>
</OrderedList>
<Sect4 Id="DFSAGR.BKUP.div.29">
<Title><Literal>Sample conf_</Literal>Vtape_device<Literal> File for Stackers</Literal></Title>
<Para>The following is an example of a configuration file
for dealing with stacker-type automated backup equipment:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>AUTOQUERY NO 
ASK YES
MOUNT /opt/backup/stacker0.1
NAME_CHECK NO
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This file specifies the following:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Literal>AUTOQUERY</Literal> parameter tells the Backup System not to prompt
the operator to mount the first tape.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>ASK</Literal> parameter tells the Backup System to prompt the operator
when an error occurs during the backup process.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>MOUNT</Literal> parameter tells the Backup System to call the file
<Literal>/opt/backup/stacker0.1</Literal> and execute the routine in that file to
initialize the stacker.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>NAME_CHECK</Literal> parameter tells the Backup System not to ensure
that the name of the next tape in the stack matches the dump set name.
</Para>
</ListItem>
</ItemizedList>
<Para>The previous example calls the <Literal>/opt/backup/stacker0.1</Literal> file to
initialize the stacker and load a tape. The following is an example of
the routine that might be contained in that file:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>#! /bin/csh -f

set devicefile = $1
set operation  = $2
set trys       = $3
set tapename   = $4
set tapeid     = $5

set exit_continue    = 0
set exit_abort       = 1
set exit_interactive = 2

# -----------------------------------------------------

if (${trys} > 1) then
   echo "Too many tries"
   exit ${exit_interactive}
endif

if ((${operation} == "dump")       | \
    (${operation} == "savedb"))    then

   stCmd_NextTape ${devicefile}
   if (${status} != 0) exit ${exit_interactive}
   echo "Will continue"
   exit ${exit_continue}
endif

if ((${operation} == "labeltape")  | \
    (${operation} == "readlabel")) then
   echo "Will continue"
   exit ${exit_continue}
endif

echo "Prompt for tape"
exit ${exit_interactive}
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This routine makes use of only two of the parameters passed to it by
the Backup System: <Literal>trys</Literal> and <Literal>operation</Literal>. It is a good
practice to watch the number of attempts and exit if it exceeds one
(which implies that the stacker is out of tapes). Note that this
routine calls <Literal>stCmd_NextTape</Literal> for <Command>dump</Command> or <Command>savedb</Command>
operations; however, your file should call whatever routine is
required to load the next tape for your stacker. Also note that the
routine sets the appropriate exit code to prompt an operator to load a
tape if either the stacker cannot load a tape or a restore operation
is in process.
</Para>
</Sect4>
<Sect4 Id="DFSAGR.BKUP.div.30">
<Title><Literal>Sample conf_</Literal>Vtape_device<Literal> File for Jukeboxes</Literal></Title>
<Para>The following sample <Literal>conf_</Literal>Vtape_device file configures
the Backup System to control a jukebox device, and includes an
<Literal>UNMOUNT</Literal> parameter:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>MOUNT /opt/backup/jukebox0.1
UNMOUNT /opt/backup/jukebox0.1
ASK NO
NAME_CHECK NO
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This file specifies the following:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Literal>MOUNT</Literal> parameter tells the Backup System to call the file
<Literal>/opt/backup/jukebox0.1</Literal> and execute the routine in that file to
mount a tape.
</Para>
</ListItem>
<ListItem>
<Para>When the Backup System closes a tape device, it calls the file
<Literal>/opt/backup/jukebox0.1</Literal> and executes the routine to remove the
tape from the jukebox.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>ASK</Literal> parameter tells the Backup System not to prompt the
operator for the initial tape.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>NAME_CHECK</Literal> parameter tells the Backup System not to ensure
that the name of the next tape in the stack matches the dump set name.
</Para>
</ListItem>
</ItemizedList>
<Para>The following sample <Literal>conf_</Literal>Vtape_device file shows the use
of the <Literal>trys</Literal> and <Literal>operation</Literal> parameters:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>#! /bin/csh -f

set devicefile = $1
set operation  = $2
set trys       = $3
set tapename   = $4
set tapeid     = $5

set exit_continue    = 0
set exit_abort       = 1
set exit_interactive = 2

# -----------------------------------------------------

if (${trys} > 1) then
   echo "Too many trys"
   exit ${exit_interactive}
endif

if ((${operation} == "labeltape")  | \
    (${operation} == "readlabel")) then
   echo "Won't read or write a tape label"
   exit ${exit_abort}
endif

if ((${operation} == "unmount") then
   jbComd_UnMountTape $(devicefile)
   exit
endif
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This routine makes use of two of the parameters passed to it by
the Backup System: <Literal>trys</Literal> and <Literal>operation</Literal>. The <Literal>trys</Literal>
parameter monitors the number of attempts to load a tape. If the
number of attempt exceeds one, the jukebox is unable to load a tape
and the routine will exit and return an exit code of 2 (which will
cause the Backup System to prompt the operator to load a tape).
</Para>
<Para>In this scenario, tape names are not checked before using a tape as
part of a dump set (recall that the <Literal>NAMECHECK</Literal> parameter was set
to <Literal>NO</Literal>, disabling tape name checking). Therefore, if the
<Literal>labeltape</Literal> or <Command>readlabel</Command> operations are attempted the
routine echoes a message saying that these operations cannot be
performed. The executable routine then returns an exit code of 1,
which causes the Backup System to abort the operation.
</Para>
<Para>If an <Command>unmount</Command> is executed, the routine calls the 
<Literal>jbComd_UnMountTap</Literal> function to remove the tape from the drive.
</Para>
</Sect4>
<Sect4 Id="DFSAGR.BKUP.div.31">
<Title><Literal>Sample conf_</Literal>Vtape_device<Literal> File for Dump to File</Literal></Title>
<Para>The following sample <Literal>conf_</Literal>Vtape_device file configures
the Backup System to dump directly to a file.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>MOUNT /opt/backup/file
FILE YES
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This file specifies the following:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Literal>MOUNT</Literal> parameter calls an executable routine in the
<Literal>/opt/backup/file</Literal> file.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>FILE</Literal> parameter is set to <Literal>YES</Literal>, indicating that the
information should be dumped directly to a file.  The pathname for the
target dump file is set in the
<Symbol Role="Variable">dcelocal</Symbol><Literal>/var/dfs/backup/TapeConfig</Literal> file.
</Para>
</ListItem>
</ItemizedList>
<Para>The following is an example of a routine that might be contained
<Literal>opt/backup/file</Literal> that demonstrates how to configure the Backup
System to handle dumps to a file.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>#! /bin/csh -f

set devicefile = $1
set operation  = $2
set trys       = $3
set tapename   = $4
set tapeid     = $5

set exit_continue    = 0
set exit_abort       = 1
set exit_interactive = 2

# -----------------------------------------------------

if (${trys} > 1) then
   echo "Too many trys"
   exit ${exit_interactive}
endif

if (${operation} == "labeltape") then
   echo "Won't label a tape/file"
   exit ${exit_abort}
endif

if ((${operation} == "dump")       | \
    (${operation} == "restore")    | \
    (${operation} == "savedb")     | \
    (${operation} == "restoredb")) then

   /bin/rm -f ${devicefile}
   /bin/ln -s /hsm/${tapename}_${tapeid} ${devicefile}
   if (${status} != 0) exit ${exit_abort}
endif
exit ${exit_continue}
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>This routine makes use of two of the parameters passed to it by
the Backup System: <Literal>trys</Literal> and <Literal>operation</Literal>. The <Literal>trys</Literal>
parameter monitors the number of attempts to write to or read from a
file. If the number of attempts exceeds one, the Backup System is
unable to write to or read from the file specified in the
<Symbol Role="Variable">dcelocal</Symbol><Literal>/var/dfs/backup/TapeConfig</Literal> file. The routine
then exits and returns an exit code of 2 (which causes the Backup
System to prompt the operator to load a tape). The operator can use
this opportunity to change the name of the file specified in the
<Symbol Role="Variable">dcelocal</Symbol><Literal>/var/dfs/backup/TapeConfig</Literal> file. 
</Para>
<Para>In this scenario, tape names are not checked before using a tape as
part of a dump set (recall that the <Literal>NAMECHECK</Literal> parameter was set
to <Literal>NO</Literal>, disabling tape name checking). Therefore, if the
<Literal>labeltape</Literal> or <Command>readlabel</Command> operations are attempted the
sample routine echoes a message saying that these operations
cannot be performed. The executable routine then returns an exit code
of 1, which causes the Backup System to abort the operation.
</Para>
<Para>A <Command>dump</Command>, <Command>restore</Command>, <Command>savedb</Command>, or <Command>restoredb</Command>
operation links to a new file using the <Literal>tapename</Literal> and
<Literal>tapeid</Literal> to build the file name.  The <Literal>tapename</Literal> and
<Literal>tapeid</Literal> are used so that <Command>restore</Command> operations can easily link
to the proper file. 
<IndexTerm Id="DFSAGR.BKUP.indx.54" SpanEnd="DFSAGR.BKUP.indx.44"><IndexTerm Id="DFSAGR.BKUP.indx.55" SpanEnd="DFSAGR.BKUP.indx.45"><IndexTerm Id="DFSAGR.BKUP.indx.56" SpanEnd="DFSAGR.BKUP.indx.53"></Para>
</Sect4>
</Sect3>
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.32">
<Title>Defining Fileset Families and Fileset Family Entries</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.57">
<Primary>fileset families</Primary>
<Secondary>name format</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.58">
<Primary>wildcards</Primary>
<Secondary>in fileset family entries</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.59">
<Primary>fileset families</Primary>
<Secondary>entries</Secondary>
</IndexTerm>
<Para>Before actually performing a backup, you must create one or more fileset
families in the Backup Database.  A fileset family defines the groups of
filesets that are to be dumped together.  Fileset family names can be no 
longer than 31 characters, and they can include any characters.  Avoid using a 
dot in the name of a fileset family; when a dump set is transferred to 
tape, the fileset family name and the last component of the dump level name 
are automatically joined by a dot to form the name of the dump set.
<?sml-break><?sml-need 20></Para>
<Para>In regular command (noninteractive) mode, characters from the regular
expression character set used in the name of a fileset family must be escaped
with a <Literal>&bsol;</Literal> (backslash) to prevent the command shell from expanding them;
for example, <Literal>usr&bsol;*</Literal> for a fileset family named <Literal>usr*</Literal>.  Because they
have no meaning in the name of a fileset family, regular expression characters
are not recommended.
</Para>
<Para>Once you define a fileset family, you must then define the fileset family
entries in the family.  Each fileset family entry is defined in terms of one or
more filesets and the location of each fileset on a File Server machine and
aggregate.  Each fileset family entry consists of three fields, with each field
separated by a space.  Following are the legal values for each field in a
fileset family entry:
</Para>
<ItemizedList>
<ListItem>
<Para>File Server Machine Name: The name of the File Server machine that houses
the filesets.  You can specify the machine's DCE pathname (for example,
<Replaceable>/.../abc.com/hosts/fs1</Replaceable>), its host name (for example, <Literal>fs1.abc.com</Literal>),
or its IP address (for example, <Literal>11.22.33.44</Literal>).  You can also use the
special <Literal>.*</Literal> wildcard for this field; this wildcard matches all of the
File Server machines in the cell.
</Para>
</ListItem>
<ListItem>
<Para>Aggregate Name: The device name or aggregate name of the aggregate on
which the filesets reside.  You can use the <Literal>.*</Literal> wildcard for this field; 
the wildcard matches all aggregate names.
</Para>
</ListItem>
<ListItem>
<Para>Fileset Name: The names of the filesets to be backed up.  You can use the 
<Literal>.*</Literal> wildcard for this field to match all fileset names.  The following 
regular expression characters can also be used in this field of an entry: 
</Para>
<ItemizedList>
<ListItem>
<Para>The <Literal>*</Literal> (asterisk) character matches any number of repetitions of the 
previous character.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>[ ]</Literal> (brackets) characters around a list of characters match any 
single instance of the characters in the list but no other characters.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>&caret;</Literal> (circumflex) character as the first character in a bracketed set 
of characters matches any single character other than the characters that 
follow it in the list.
<?sml-break><?sml-need 20></Para>
</ListItem>
<ListItem>
<Para>The <Literal>?</Literal> (question mark) character matches any single character or no 
character.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>.</Literal> (dot) character matches any single character, but a character 
must be present.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>&bsol;</Literal> (backslash) character before any other regular expression 
character, including itself, matches the literal value of the character.
</Para>
</ListItem>
</ItemizedList>
<Para>In noninteractive mode, you must surround an entire string with "&thinsp;" (double
quotes) if it contains regular expression characters or you must escape each
regular expression character with a <Literal>&bsol;</Literal> (backslash); for example, use
<Literal>"user&bsol;..*&bsol;.bak"</Literal> or <Literal>user&bsol;&bsol;..&bsol;*&bsol;&bsol;.bak</Literal> to indicate all of the
filesets that begin with the prefix <Literal>user.</Literal> and end with the extension
<Literal>.bak</Literal>.  Otherwise, the command shell attempts to resolve the regular
expression characters rather than pass them to the <Command>bak</Command> command
interpreter for resolution.  Note that the <Literal>.*</Literal> notation is interpreted as
a single wildcard that must be surrounded with double quotes in noninteractive
mode (<Literal>".*"</Literal>).  Characters specified in regular expressions are case
sensitive.
</Para>
</ListItem>
</ItemizedList>
<Para>All fileset family names must be unique within the Backup Database of the
local cell.  Create and delete fileset families with the <Command>bak addftfamily</Command>
and <Command>bak rmftfamily</Command> commands.  Create and delete fileset family entries
with the <Command>bak addftentry</Command> and <Command>bak rmftentry</Command> commands.
<IndexTerm Id="DFSAGR.BKUP.indx.60" SpanEnd="DFSAGR.BKUP.indx.58"></Para>
<Sect3 Id="DFSAGR.BKUP.div.33">
<Title>Suggestions for Creating Fileset Family Entries</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.61">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>addftentry</Command></Secondary>
</IndexTerm>
<Para>The <Command>bak addftentry</Command> command has arguments that correspond to the three
fields in a fileset family entry: <Option>server</Option> for the File Server machine
name field, <Option>aggregate</Option> for the aggregate name field, and
<Option>fileset</Option> for the fileset name field.  By combining these arguments in
different ways, you can create fileset entries for different groupings of
filesets.  Table 9-1 summarizes some suggested groupings.
<?sml-break><?sml-break><?sml-need 20><?sml-indent -.5i><?sml-size -1>
</Para>
<Table Frame="all" Remap="center" Orient="Port">
<Title>Suggestions for Creating Fileset Family Entries</Title>
<TGroup Rowsep="0" Colsep="0" Cols="3">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1.75*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1.75*" Colname="col2" Colnum="2">
<ColSpec Rowsep="1" Align="Left" Colwidth="1.4*" Colname="col3" Colnum="3">
<TBody>
<Row>
<Entry Rowsep="1"><Literal>For Entries That Include:</Literal></Entry>
<Entry Rowsep="1"><Literal>Use:</Literal></Entry>
<Entry Rowsep="1"><Literal>For Example:</Literal></Entry>
</Row>
<Row>
<Entry rowsep="1">All filesets in the cell's file
system
</Entry>
<Entry rowsep="1">The wildcard for all three
arguments
</Entry>
<Entry rowsep="1"><Literal>".*"
<?sml-break>".*"
<?sml-break>".*"
<!-- _-->
</Literal></Entry>
</Row>
<Row>
<Entry rowsep="1">Every fileset on a specific File
Server machine
</Entry>
<Entry rowsep="1">Machine name with
<Option>server</Option> and wildcard for
<Option>aggregate</Option> and
<Option>fileset</Option>
</Entry>
<Entry rowsep="1"><Literal>/.../abc.com/hosts/fs1
<?sml-break>".*"
<?sml-break>".*"
<!-- _-->
</Literal></Entry>
</Row>
<Row>
<Entry rowsep="1">Filesets on aggregates of the
same name
</Entry>
<Entry rowsep="1">The aggregate name with
<Option>aggregate</Option> and the wildcard
for <Option>server</Option> and <Option>fileset</Option>
</Entry>
<Entry rowsep="1"><Literal>".*"
<?sml-break>/dev/lv01
<?sml-break>".*"
<!-- _-->
</Literal></Entry>
</Row>
<Row>
<Entry rowsep="1">Every fileset with a common
string of letters (such as a
<Literal>.backup</Literal> extension)
</Entry>
<Entry rowsep="1">The wildcard for <Option>server</Option> and
<Option>aggregate</Option>, and a character
string/regular expression for
<Option>fileset</Option>
</Entry>
<Entry rowsep="1"><Literal>".*"
<?sml-break>".*"
<?sml-break>".*&bsol;.backup"
<!-- _-->
</Literal></Entry>
</Row>
<Row>
<Entry rowsep="1">All filesets on an aggregate
</Entry>
<Entry rowsep="1">The machine name with
<Option>server</Option>, the aggregate name
with <Option>aggregate</Option>, and the
wildcard for <Option>fileset</Option>
</Entry>
<Entry rowsep="1"><Literal>/.../abc.com/hosts/fs2
<?sml-break>/dev/lv02
<?sml-break>".*"
<!-- _-->
</Literal></Entry>
</Row>
<Row>
<Entry rowsep="1">Every fileset on each File
Server machine's similarly
named aggregate that includes
a common string of letters in
its name (such as a <Literal>user.</Literal>
prefix)
</Entry>
<Entry rowsep="1">The wildcard for <Option>server</Option>, the
aggregate name with
<Option>aggregate</Option>, and a character
string/regular expression for
<Option>fileset</Option>
</Entry>
<Entry rowsep="1"><Literal>".*"
<?sml-break>/dev/lv03
<?sml-break>"user&bsol;..*"
<!-- _-->
</Literal></Entry>
</Row>
<Row>
<Entry rowsep="1">Every fileset on one aggregate
with a common string of letters
in its name (such as a <Command>sys</Command>
prefix and a <Literal>.readonly</Literal>
extension)
</Entry>
<Entry rowsep="1">The machine name with
<Option>server</Option>, the aggregate name
with <Option>aggregate</Option>, and a
character string/regular
expression for <Option>fileset</Option>
</Entry>
<Entry rowsep="1"><Literal>/.../abc.com/hosts/fs3
<?sml-break>/dev/lv04
<?sml-break>"sys.*&bsol;.readonly"
</Literal></Entry>
</Row>
</TBody>
</TGroup>
</Table>
<?sml-size +1>
<Para>
<?sml-indent +.5i><?sml-break>
<!-- -->
</Para>
<Para>Include in a fileset family only those filesets that you wish to dump to the 
same tape at the same time (for example, weekly or daily) and in the same 
manner (fully or incrementally).
</Para>
<Para>The two main types of fileset families are those based on a common fileset
location (File Server machine and aggregate) and those based on similar
contents (as reflected by a fileset name).  Because filesets can be moved
between machines and aggregates, use name-based fileset family entries rather
than location-based ones.  For name-based entries, specify the <Literal>.*</Literal> 
wildcard for the <Option>server</Option> and <Option>aggregate</Option> arguments of the <Command>bak 
addftentry</Command> command.
<IndexTerm Id="DFSAGR.BKUP.indx.62" SpanEnd="DFSAGR.BKUP.indx.61"><IndexTerm Id="DFSAGR.BKUP.indx.63" SpanEnd="DFSAGR.BKUP.indx.59"></Para>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.34">
<Title>Adding a Fileset Family to the Backup Database</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.64">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>addftfamily</Command></Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.65">
<Primary>fileset families</Primary>
<Secondary>basis for forming</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.66">
<Primary>fileset families</Primary>
<Secondary>adding to Backup Database</Secondary>
</IndexTerm>
<Para>To add a fileset family to the Backup Database, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.
If necessary, issue the <Command>bos lsadmin</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para>Issue the <Command>bak addftfamily</Command> command to create the fileset
family.  The fileset family remains empty until you use the <Command>bak
addftentry</Command> command to define entries in it.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak addftfamily -family </Command><Symbol Role="Variable">fileset_family_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.35">
<Title>Adding a Fileset Family Entry to a Fileset Family</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.67">
<Primary>fileset families</Primary>
<Secondary>adding entries</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.68">
<Primary>Backup Database</Primary>
<Secondary>fileset families</Secondary>
</IndexTerm>
<Para>To add a fileset family entry to a fileset family, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
<?sml-break><?sml-need 20></Para>
</ListItem>
<ListItem>
<Para>Define the entries in a fileset family that was previously created with the 
<Command>bak addftfamily</Command> command; the Backup System automatically assigns each 
entry an index number, starting with 1 for the first entry in each fileset 
family.  This number is used if the fileset entry needs to be removed.
</Para>
<InformalExample>
<Para><ProgramListing>$ <UserInput><Command>bak addftentry -family </Command><Symbol Role="Variable">fileset_family_name</Symbol> <Option>server</Option> <Symbol Role="Variable">machine </Symbol><Option>aggregate </Option><Symbol Role="Variable">name</Symbol> &bsol;
<Option>fileset</Option> <Symbol Role="Variable">name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Option>server</Option> <Symbol Role="Variable">machine</Symbol> option is the File Server machine that houses
the filesets to be included in the entry.  Legal values for a specific machine
are the machine's DCE pathname, the machine's host name, or the machine's IP
address.  You can also use the <Literal>.*</Literal> wildcard, which matches all machine
names.
</Para>
<Para>The <Option>aggregate</Option> <Symbol Role="Variable">name</Symbol> option is the device name or aggregate name
of the aggregate that houses the filesets to be included in the entry.  The
<Literal>.*</Literal> wildcard can be used to match the names of all aggregates.
</Para>
<Para>The <Option>fileset</Option> <Symbol Role="Variable">name</Symbol> option is the name of a fileset to be included
in the entry.  The <Literal>.*</Literal> wildcard or any of the regular expression characters
described previously can be used to match the names of multiple filesets.
</Para>
</ListItem>
</OrderedList>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.36">
<Title>Deleting Fileset Families from the Backup Database</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.69">
<Primary>fileset families</Primary>
<Secondary>deleting from Backup Database</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.70">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>rmftfamily</Command></Secondary>
</IndexTerm>
<Para>To delete a fileset family from the Backup Database, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para>Issue the <Command>bak rmftfamily</Command> command to delete each fileset family that you 
no longer need.  It is not necessary to delete the fileset entries in each 
fileset family first; they are deleted automatically when the family is 
removed.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak rmftfamily -family </Command><Symbol Role="Variable">fileset_family_name</Symbol>...
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
<?sml-break>
<?sml-need 20>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.37">
<Title>Deleting a Fileset Family Entry from a Fileset Family</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.71">
<Primary>fileset families</Primary>
<Secondary>deleting entries</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.72">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>lsftfamilies</Command></Secondary>
</IndexTerm>
<Para>To delete a fileset family entry from a fileset family, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para>Issue the <Command>bak lsftfamilies</Command> command to determine the index number of the
entry that you want to delete.  This is necessary only if the fileset family 
contains multiple entries, in which case this command is used to list the 
entries; if the family contains a single entry, the index is 1.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak lsftfamilies -family </Command><Symbol Role="Variable">fileset_family_name</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>Use the <Command>bak rmftentry</Command> command to delete the entry:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak rmftentry -family </Command><Symbol Role="Variable">fileset_family_name</Symbol> <Option>entry</Option> \
<Symbol Role="Variable">fileset_entry_index</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Option>entry</Option> <Symbol Role="Variable">fileset_entry_index</Symbol> option is the index for the entry
that you want to delete.
</Para>
</ListItem>
</OrderedList>
<IndexTerm Id="DFSAGR.BKUP.indx.73" SpanEnd="DFSAGR.BKUP.indx.68">
</Sect3>
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.38">
<Title>Defining a Dump Hierarchy of Dump Levels</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.74">
<Primary>dump hierarchies</Primary>
<Secondary>establishing</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.75">
<Primary>incremental dump levels</Primary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.76">
<Primary>parent dump level</Primary>
</IndexTerm>
<Para>A dump hierarchy consists of one or more full dump levels and any incremental
dump levels that you create with the <Command>bak adddump</Command> command.  The dump levels
define how fileset families are to be dumped; all fileset family entries in a
fileset family are dumped at the same time and in the same way (fully or
incrementally).  A dump of a fileset family at a particular dump level produces
a dump set.  To create a dump set, specify the name of the fileset family and
the level at which that family is to be dumped when you initiate the dump with
the <Command>bak dump</Command> command. (See Chapter 10 for a description of the <Command>bak
dump</Command> command.)
<?sml-break><?sml-need 20></Para>
<Para>A dump hierarchy is defined by the dump levels it contains.  The term <Symbol Role="Variable">full
dump level</Symbol> refers to a dump level used when creating full dumps, the term
<Symbol Role="Variable">incremental dump level</Symbol> refers to a dump level used when creating
incremental dumps, and the term <Symbol Role="Variable">parent dump level</Symbol> refers to a dump level that
serves as the reference point for an incremental dump level.  Both full dump
levels and incremental dump levels can serve as parent dump levels.
</Para>
<Para>Each dump level in the hierarchy can be associated with an expiration date
that specifies the date and time at which a tape that contains a dump set made
at that level can be overwritten.  Expiration dates are specified with the
<Command>bak adddump</Command> or <Command>bak setexp</Command> command.  A dump level's expiration date
is automatically placed on a tape that contains a dump made at that level to
provide an extra level of protection against accidental erasure of the
information on the tape.
</Para>
<Para>Whenever a tape is used, the Backup System always checks to see whether the
tape already contains a dump set.  If the tape contains a dump set, the Backup
System overwrites the tape only with a dump set of the same name.  If the
Backup System determines that it can overwrite the dump set, it then determines
whether an expiration date exists on the tape; if no expiration date is 
associated with a tape or if the expiration date associated with a tape has 
expired, the system overwrites the dump set on the tape with a dump set of 
the same name.  However, if the tape's expiration date has not expired, the
system refuses to overwrite the tape.
<IndexTerm Id="DFSAGR.BKUP.indx.77">
<Primary>dump hierarchies</Primary>
<Secondary>general issues</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.78">
<Primary>dump hierarchies</Primary>
<Secondary>structure and format</Secondary>
</IndexTerm></Para>
<Para>Following are some general issues to consider when building a dump hierarchy:
</Para>
<ItemizedList>
<ListItem>
<Para>A dump level can have any number of elements.  The <Filename>/</Filename> (slash) is used as a
metacharacter to separate different levels in the dump hierarchy.  Regardless
of its level in the dump hierarchy (full or incremental), each element in a
dump level name must be preceded by a <Filename>/</Filename> (slash).
</Para>
</ListItem>
<ListItem>
<Para>Any characters can be included in a dump level name.  Regular expression
characters included in a name must be properly escaped with a <Literal>&bsol;</Literal>
(backslash) or <Literal>"&thinsp;"</Literal> (double quotes).
</Para>
</ListItem>
<ListItem>
<Para>Do not include a <Literal>.</Literal> (dot) in the name of a dump level.  When a dump set 
is transferred to tape, the last component of the dump level name becomes part 
of the dump set name.  The elements of the dump set name (the fileset family 
name and the last component of the dump level name) are joined by a dot.  For
example, if a fileset family named <Command>sys</Command> is dumped at the incremental dump
level <Literal>/weekly/monday</Literal>, the dump set name is <Literal>sys.monday</Literal>.
<?sml-break><?sml-need 20></Para>
</ListItem>
<ListItem>
<Para>The maximum length for any single element in a dump level name is 28
characters.  This does not include the / (slash) that precedes the element.
</Para>
</ListItem>
<ListItem>
<Para>The maximum length for the complete name of a dump level (full or incremental)
is 256 characters.  This includes any / (slashes) that are part of the name.
</Para>
</ListItem>
<ListItem>
<Para>A dump level is specified by its pathname.  A level can share parents, but the
level itself must have a unique name.  Following are examples of different dump
specifications:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Literal>/full</Literal> specification defines a full dump level.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>/full/week1</Literal> specification defines an incremental dump level, 
<Literal>/week1</Literal>, with <Literal>/full</Literal> as its parent.
</Para>
</ListItem>
<ListItem>
<Para>The <Literal>/full/week1/thursday</Literal> specification defines <Literal>/thursday</Literal> as a 
dump level that refers to <Literal>/week1</Literal> as its parent; <Literal>/week1</Literal> refers 
to <Literal>/full</Literal> as its parent.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para>The dump level that you use as the parent for an incremental dump must already
exist in the hierarchy when you define the incremental dump.  The complete
pathname of each dump level must be unique within the Backup Database of the
local cell.
</Para>
</ListItem>
<ListItem>
<Para>A dump hierarchy can contain more than one full dump level; each level defines
a separate subhierarchy in which you can create different relationships between
the dump levels.  The following two common methods are available to relate the
incremental dumps in a subhierarchy to the full dump level and to one another:
</Para>
<ItemizedList>
<ListItem>
<Para>Each incremental dump refers to the same full dump as its parent.  With this
method, the dump sets created at each of the incremental levels contain all
of the files in the fileset family that changed since the family was last 
dumped at the full level.
</Para>
</ListItem>
<ListItem>
<Para>Each incremental dump level (other than the first) refers to a preceding
incremental dump level as its parent, rather than to the full dump level.  With
this method, each incremental dump includes only those files modified since a
dump was last done at its parent level.  When you restore files dumped in this
fashion, however, you must access more tapes: the tape that contains the full
dump and the tape for each incremental dump done afterward.
</Para>
</ListItem>
</ItemizedList>
<?sml-break>
<?sml-need 20>
<Para>The two types of hierarchies can be mixed within a single subhierarchy by
setting some incremental dumps to refer to the full dump level as their parent
and setting others to refer to preceding incremental levels.
</Para>
</ListItem>
<ListItem>
<Para>There is no implied relationship between a fileset family and a dump
subhierarchy; you can dump any fileset family at any level in any subhierarchy.
When dumping a fileset, <Replaceable>do not</Replaceable> alternate between incremental dumps from
different subhierarchies.  To dump a fileset according to a different
subhierarchy, start at the full dump level.
</Para>
</ListItem>
<ListItem>
<Para>Use names in the hierarchy that correspond to real-world times; these can help
you remember when to create dumps at the different levels.  However, the Backup
System does not automatically back up filesets according to the names assigned
in the dump hierarchy; it does not interpret dump level names, nor does it
automatically perform an incremental dump on Thursday simply because there is
a dump level called <Literal>thursday</Literal>.
</Para>
</ListItem>
</ItemizedList>
<Para>A few general guidelines for using a dump hierarchy follow:
</Para>
<ItemizedList>
<ListItem>
<Para>To set up a group of tapes for archiving, make certain that you use unique dump
names; for example, <Literal>monday1</Literal>, <Literal>tuesday1</Literal>, <Literal>monday2</Literal>, or
<Literal>tuesday2</Literal>.
</Para>
</ListItem>
<ListItem>
<Para>To recycle tapes, use dump levels with the same name; for example,
<Literal>monday</Literal> or <Literal>tuesday</Literal>.
</Para>
</ListItem>
<ListItem>
<Para>To archive tapes and recycle them at a later time, simply perform backups
with a new set of tapes; the old set of tapes can then be archived.  This
creates multiple entries for the dump in the Backup Database.  To restore
filesets with multiple entries in the database, use the correct dump date to
restore the correct information.
</Para>
</ListItem>
</ItemizedList>
<Para>The Backup System prevents you from using out-of-date configuration
information.  For example, if a user deletes a full dump level in a hierarchy,
and another user tries to start an incremental backup based on that full dump
level, the incremental backup fails.  The second user must view the dump
hierarchy with the <Command>bak lsdumps</Command> command.  This command updates the
hierarchy with the most recent changes and lets the user determine another
dump level to use with the command. (See Chapter 10 for more information on
the <Command>bak lsdumps</Command> command.)
<IndexTerm Id="DFSAGR.BKUP.indx.79" SpanEnd="DFSAGR.BKUP.indx.77"><?sml-break><?sml-need 20></Para>
<Sect3 Id="DFSAGR.BKUP.div.39">
<Title>Examples of Dump Hierarchies</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.80">
<Primary>dump hierarchies</Primary>
<Secondary>examples</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.81">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>adddump</Command></Secondary>
</IndexTerm>
<Para>Following are examples of two possible dump hierarchies. Each hierarchy backs
up data in a different way.
</Para>
<Para>The first dump hierarchy is used to back up user data (data from
user filesets).  Because this data changes frequently, it is dumped at the
end of each working day, starting with a full dump at the beginning of
the week (Sunday) and continuing with incremental dumps Monday through
Friday.  Each incremental dump refers to the full dump as its parent,
rather than to the previous day's incremental dump.  As a result, each
incremental dump contains all of the data that has changed since the full dump
was performed.  The following commands are used to establish this dump
hierarchy:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Literal>bak adddump /sunday</Literal>
$ <Literal>bak adddump /sunday/monday</Literal>
$ <Literal>bak adddump /sunday/tuesday</Literal>
$ <Literal>bak adddump /sunday/wednesday</Literal>
$ <Literal>bak adddump /sunday/thursday</Literal>
$ <Literal>bak adddump /sunday/friday</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<IndexTerm Id="DFSAGR.BKUP.indx.82">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>lsdumps</Command></Secondary>
</IndexTerm>
<Para>You can use the <Command>bak lsdumps</Command> command to display the dump hierarchy. In
the following example, <Literal>/sunday</Literal> is the full dump used for the hierarchy:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak lsdumps</Command>
</UserInput></ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>/sunday
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;/monday
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;/tuesday
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;/wednesday
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;/thursday
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;/friday
</ProgramListing></Para>
</InformalExample>
<?sml-break>
<?sml-need 20>
<Para>The second dump hierarchy is used to back up filesets containing
system binary files.  Because these files do not change often, they are
backed up only once a week, starting with a full dump at the beginning
of the month and followed by an incremental dump at the beginning of each
subsequent week.  Each weekly dump refers to the previous week's dump as
its parent, rather than to the initial full dump.  Therefore, each weekly
dump contains only those files that changed in the past week, rather
than everything that changed since the full dump was performed.  The
following commands establish this dump hierarchy:
<IndexTerm Id="DFSAGR.BKUP.indx.83">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>adddump</Command></Secondary>
</IndexTerm></Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Literal>bak adddump /month</Literal>
$ <Literal>bak adddump /month/week1</Literal>
$ <Literal>bak adddump /month/week1/week2</Literal>
$ <Literal>bak adddump /month/week1/week2/week3</Literal>
$ <Literal>bak adddump /month/week1/week2/week3/week4</Literal>
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>You can use the <Command>bak lsdumps</Command> command to display the dump hierarchy. The
following example shows <Literal>/month</Literal> as the full dump for the hierarchy:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak lsdumps</Command>
</UserInput></ProgramListing></Para>
</InformalExample>
<InformalExample>
<Para><ProgramListing>/month
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;/week1
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;/week2
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;/week3
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;/week4
</ProgramListing></Para>
</InformalExample>
<Para><IndexTerm Id="DFSAGR.BKUP.indx.84" SpanEnd="DFSAGR.BKUP.indx.74"></Para>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.40">
<Title>Defining a Dump Level</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.85">
<Primary>dump levels</Primary>
<Secondary>defining</Secondary>
</IndexTerm>
<Para>To define a dump level, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para>Issue the <Command>bak adddump</Command> command to define one or more dump levels:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak adddump -level </Command><Symbol Role="Variable">dump_level</Symbol>... [<Option>expires </Option><Symbol Role="Variable">date</Symbol>...]
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
<?sml-break>
<?sml-need 20>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.41">
<Title>Changing a Dump Level's Expiration Date</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.86">
<Primary>dump levels</Primary>
<Secondary>expiration dates</Secondary>
</IndexTerm>
<Para>To change a dump level's expiration date, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para>Issue the <Command>bak setexp</Command> command to set the expiration dates of one or more
dump levels:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak setexp -level </Command><Symbol Role="Variable">dump_level</Symbol>... <Option>expires </Option><Symbol Role="Variable">date</Symbol>...
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.42">
<Title>Deleting a Dump Level</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.87">
<Primary>dump levels</Primary>
<Secondary>deleting</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.88">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>rmdump</Command></Secondary>
</IndexTerm>
<Para>To delete a dump level, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para>Issue the <Command>bak rmdump</Command> command to delete a dump level.  All dump levels
for which the level serves as the parent, either directly or indirectly, are
also deleted automatically.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak rmdump -level </Command><Symbol Role="Variable">dump_level</Symbol>
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
</Sect3>
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.43">
<Title>Labeling Tapes</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.89">
<Primary>tapes</Primary>
<Secondary>labeling</Secondary>
</IndexTerm>
<Para>A tape's magnetic label provides information about the tape and the data it
contains.  The Backup System checks each tape before it writes to it; if
the label on the tape is unacceptable, the dump cannot proceed until you insert
an acceptable tape in the drive.  A tape's label records the following
information:
</Para>
<ItemizedList>
<ListItem>
<Para>The name of the tape, indicating its contents.  The name of the tape is composed
of three fields, all of which are separated by dots: 
<Symbol Role="Variable">fileset_family_name</Symbol><Literal>.</Literal><Symbol Role="Variable">dump_level</Symbol><Literal>.</Literal><Symbol Role="Variable">index</Symbol> (the dump set name with an 
additional tape index).  The following three types of tape names are 
acceptable: 
</Para>
<ItemizedList>
<ListItem>
<Para>The complete name of the tape in the form 
<Symbol Role="Variable">fileset_family_name</Symbol><Literal>.</Literal><Symbol Role="Variable">dump_level</Symbol><Literal>.</Literal><Symbol Role="Variable">index</Symbol>, where the values of
<Symbol Role="Variable">fileset_family_name</Symbol> and <Symbol Role="Variable">dump_level</Symbol> match values that you 
provide with the <Command>bak dump</Command> command.  The <Symbol Role="Variable">index</Symbol> is this tape's place 
in the sequence of tapes used for the complete dump set; if the dump set 
fits on one tape, the index for that tape is the numeral 1.
</Para>
</ListItem>
<ListItem>
<Para>An indicator of empty, or null, created with the <Command>bak labeltape</Command> command.
The Backup System replaces the null indicator with the correct name when it
puts dump sets onto the tape.
</Para>
</ListItem>
<ListItem>
<Para>No name, indicating it is an unused tape.  Again, the Backup System generates
the correct name as it transfers a dump set to the tape.
</Para>
</ListItem>
</ItemizedList>
</ListItem>
<ListItem>
<Para>The size of the tape.  Use a number and a letter (k or K for kilobytes, m or M
for megabytes, or g or G for gigabytes) to indicate a size, as described in
Section 9.3.1 for the <Literal>TapeConfig</Literal> file.  Because the Backup System always
uses the size specified in the <Literal>TapeConfig</Literal> file, the size you include in
the label of the tape is intended for information purposes only.
</Para>
</ListItem>
</ItemizedList>
<Para>When you label a tape, you can specify its name only, its size only, or both
its name and its size.  When you dump data to a tape, the expiration date of
the dump level at which you dump the data is copied to the label of the tape.
If a tape has an expiration date that has not expired, the Backup System
refuses to overwrite the tape.  If the tape's expiration date has expired, or
if the tape contains no expiration date, the Backup System overwrites the
tape with a dump set that has an acceptable name.
</Para>
<Para>It is not essential to prelabel tapes before data is transferred to them; the
Backup System can use unlabeled tapes or partially labeled tapes, which
are tapes that include only the name of the tape or the size of the tape. 
However, you may want to prelabel a tape in the following situations:
</Para>
<ItemizedList>
<ListItem>
<Para>You want to automate the backup process as much as possible. For
manually loaded tape drives, if tapes are prelabeled with the correct
name, the individual performing backups needs to respond to prompts
only when the system requests a tape. For automated backup devices, if
the tapes are prelabeled the backup process will proceed
uninterrupted.
</Para>
</ListItem>
<ListItem>
<Para>You wish to reuse a tape, putting a different dump set on it.  The Backup System
will not use a tape if the label reflects the name of a different dump set or
if the label contains an unexpired expiration date.  Labeling a tape 
overwrites its expiration date, as well as its name and size.
</Para>
</ListItem>
</ItemizedList>
<Note>
<Para>You can force the Backup System to ignore the tape label and use any
unexpired tape for dumps.  See Section 9.3.2.5 for information about the
<Literal>NAME_CHECK</Literal> parameter in the user-defined configuration file.
</Para>
</Note>
<Sect3 Id="DFSAGR.BKUP.div.44">
<Title>Reading the Label on a Tape</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.90">
<Primary>tapes</Primary>
<Secondary>reading labels</Secondary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.91">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>readlabel</Command></Secondary>
</IndexTerm>
<Para>To read the label on a tape, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>If it is not already running, start the Tape Coordinator for the tape drive
that you want to use with the operation. (See Section 9.2.2.1 for information
on using the <Command>butc</Command> command to start a Tape Coordinator.)
</Para>
</ListItem>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para>Place the tape in the drive, and issue the <Command>bak readlabel</Command> command to read
the label on the tape.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak readlabel </Command>[<Option>tcid </Option><Symbol Role="Variable">tc_number</Symbol>]
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
</Sect3>
<Sect3 Id="DFSAGR.BKUP.div.45">
<Title>Labeling a Tape</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.92">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Literal>labeltape</Literal></Secondary>
</IndexTerm>
<Para>To label a tape, do the following:
</Para>
<OrderedList>
<ListItem>
<Para>If it is not already running, start the Tape Coordinator for the tape drive
that you want to use with the operation. (See Section 9.2.2.1 for information
on using the <Command>butc</Command> command to start a Tape Coordinator.)
</Para>
</ListItem>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para>Issue the <Command>bak labeltape</Command> command to label the tape.  This command executes
in the background. (See Chapter 10 for more information about commands that
execute in the background.)
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak labeltape </Command>[<Option>tape </Option><Symbol Role="Variable">tape_name</Symbol>] [<Option>size </Option><Symbol Role="Variable">tape_size</Symbol>] \
[<Option>tcid </Option><Symbol Role="Variable">tc_number</Symbol>]
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The <Option>tape</Option> <Symbol Role="Variable">tape_name</Symbol> option is the name of the tape. It must have 
the form <Symbol Role="Variable">fileset_family_name</Symbol><Literal>.</Literal><Symbol Role="Variable">dump_level</Symbol><Literal>.</Literal><Symbol Role="Variable">index</Symbol>.  If this 
option is omitted, the tape is marked as empty with the null indicator.
<?sml-break><?sml-need 20></Para>
<Para>The <Option>size</Option> <Symbol Role="Variable">tape_size</Symbol> option is the capacity of the tape. The 
default unit is kilobytes.  You can add a g or G to the number to indicate 
gigabytes or an m or M to indicate megabytes.  This is for information purposes
only; the Backup System uses the tape size recorded in the <Literal>TapeConfig</Literal>
file whenever it uses a tape drive.  If this option is omitted, the tape size
specified for the drive in the <Literal>TapeConfig</Literal> file is used.
</Para>
</ListItem>
<ListItem>
<Para>Place the tape in the drive, and press <Literal>&lt;Return></Literal> in the corresponding Tape
Coordinator's monitoring window.
</Para>
</ListItem>
</OrderedList>
<IndexTerm Id="DFSAGR.BKUP.indx.93" SpanEnd="DFSAGR.BKUP.indx.89">
</Sect3>
</Sect2>
</Sect1>
<Sect1 Id="DFSAGR.BKUP.div.46">
<Title>Adding and Removing Tape Coordinators</Title>
<Para>As mentioned in Section 9.3.1, a separate Tape Coordinator process is
associated with each tape drive on a Tape Coordinator machine.  Each Tape
Coordinator has an associated port, or address.  You must assign the port a
TCID and use that number in any commands issued to the Tape Coordinator;
<Command>bak</Command> commands that involve a tape drive have a <Option>tcid</Option> option for
this purpose.  The Backup System identifies and contacts a Tape Coordinator by
its TCID.
</Para>
<Para>The Backup System can track a maximum of 1024 tape drives.  Valid TCIDs are the
integers from 0 to 1023.  You do not have to assign the numbers in sequence, and
you can skip numbers.  The drive with the TCID of 0 is used by default.  You can
use the <Command>bak lshosts</Command> command to list the Tape Coordinators that have
entries in the Backup Database.
</Para>
<Para>Section 9.4.1 describes the steps used to add a Tape Coordinator to an existing
Tape Coordinator machine.  The steps assume that you have already configured the
Tape Coordinator machine to which the Tape Coordinator is to be added according
to the instructions in Section 9.3.1.  You use the <Command>bak addhost</Command> command to
add an entry for a Tape Coordinator to the Backup Database.
</Para>
<Para>Section 9.4.2 describes the steps used to remove an existing Tape Coordinator.
You use the <Command>bak rmhost</Command> command to remove an entry for a Tape Coordinator
from the Backup Database.
</Para>
<Para>Remember to edit the <Literal>TapeConfig</Literal> file accordingly when you add or remove
a Tape Coordinator.  The <Literal>TapeConfig</Literal> file defines the mapping between a
Tape Coordinator and a tape drive on a Tape Coordinator machine.
<?sml-break><?sml-need 20></Para>
<Sect2 Id="DFSAGR.BKUP.div.47">
<Title>Adding a Tape Coordinator</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.94">
<Primary>Tape Coordinators</Primary>
<Secondary>adding</Secondary>
</IndexTerm>
<Para>To add a Tape Coordinator to an <Replaceable>existing</Replaceable> Tape Coordinator machine,
perform the following steps on the Tape Coordinator machine:
</Para>
<OrderedList>
<ListItem>
<Para>Install the drive on the machine according to the manufacturer's instructions.
</Para>
</ListItem>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
</Para>
</ListItem>
<ListItem>
<Para>Verify that you have the <Literal>w</Literal> (write) permission on the 
<Symbol Role="Variable">dcelocal</Symbol><Literal>/var/dfs/backup/TapeConfig</Literal> file.
</Para>
</ListItem>
<ListItem>
<IndexTerm Id="DFSAGR.BKUP.indx.95">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>lshosts</Command></Secondary>
</IndexTerm>
<Para>Choose the TCID for the drive.  Enter the <Command>bak lshosts</Command> command to check
previously assigned TCIDs:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak lshosts</Command>
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
<ListItem>
<Para>Using a text editor, add a line for the new tape drive to the
<Symbol Role="Variable">dcelocal</Symbol><Literal>/var/dfs/backup/TapeConfig</Literal> file.  Use a single line in the
file for each tape drive, recording the following information:
</Para>
<ItemizedList>
<ListItem>
<Para>The tape size of the tapes to be used in the drive.  The Tape Coordinator uses
this capacity as the size of all tapes used in the drive.  It is recommended
that you use a number 10 to 15% lower than the actual tape capacity to allow
for tape variations.  The following abbreviations can be used for the tape size
unit of measurement (the default is kilobytes); do not leave a space between
the number and the letter.
</Para>
<ItemizedList>
<ListItem>
<Para>Kilobytes: k or K (for example, 2k or 2K)
</Para>
</ListItem>
<ListItem>
<Para>Megabytes: m or M (for example, 2m or 2M)
</Para>
</ListItem>
<ListItem>
<Para>Gigabytes: g or G (for example, 2g or 2G)
</Para>
</ListItem>
</ItemizedList>
<?sml-break>
<?sml-need 20>
</ListItem>
<ListItem>
<Para>The EOF mark size for the type of tape to be used in the drive.  The Backup
System appends an EOF mark after each fileset dumped to tape.  The size of this
mark can affect the amount of space available for backup data.  The EOF mark
size can vary from 2 kilobytes to more than 2 megabytes, depending on the type
of tape drive used.  It is recommended that you increase the actual file mark
size by 10 to 15% to allow for tape variations.
<IndexTerm Id="DFSAGR.BKUP.indx.96">
<Primary>end of file mark size</Primary>
</IndexTerm>
<IndexTerm Id="DFSAGR.BKUP.indx.97">
<Primary>EOF mark size</Primary>
</IndexTerm></Para>
<Para>If you do not specify a unit of measurement, the default used for the EOF size
is bytes (<Symbol Role="Variable">not</Symbol> kilobytes, as for tape capacity).  To indicate other units,
use the same abbreviations as for tape capacity.
</Para>
</ListItem>
<ListItem>
<Para>The device name of the tape drive.  The format of this name varies with each
operating system.
</Para>
</ListItem>
<ListItem>
<Para>The TCID for the Tape Coordinator associated with the drive.  Legal values are
integers from 0 to 1023.
</Para>
</ListItem>
</ItemizedList>
<Para>If you do not know the tape size or EOF mark size for the tape drive, determine
them by using the <Command>fms</Command> command described in Section 9.2.2.3.
</Para>
</ListItem>
<ListItem>
<IndexTerm Id="DFSAGR.BKUP.indx.98">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>addhost</Command></Secondary>
</IndexTerm>
<Para>Enter the <Command>bak addhost</Command> command to define an entry in the Backup Database
for the Tape Coordinator:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak addhost -tapehost </Command><Symbol Role="Variable">machine</Symbol> [<Option>tcid </Option><Symbol Role="Variable">tc_number</Symbol>]
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
<IndexTerm Id="DFSAGR.BKUP.indx.99" SpanEnd="DFSAGR.BKUP.indx.94">
</Sect2>
<Sect2 Id="DFSAGR.BKUP.div.48">
<Title>Removing a Tape Coordinator</Title>
<IndexTerm Id="DFSAGR.BKUP.indx.100">
<Primary>Tape Coordinators</Primary>
<Secondary>removing</Secondary>
</IndexTerm>
<Para>To remove a Tape Coordinator from a Tape Coordinator machine, perform the
following steps on the Tape Coordinator machine:
</Para>
<OrderedList>
<ListItem>
<Para>Verify that you are included in the appropriate administrative lists.  If
necessary, issue the <Command>bos lsadmin</Command> command to check.
<?sml-break><?sml-need 20></Para>
</ListItem>
<ListItem>
<Para>Verify that you have the <Literal>w</Literal> (write) permission on the
<Symbol Role="Variable">dcelocal</Symbol><Literal>/var/dfs/backup/TapeConfig</Literal> file.
</Para>
</ListItem>
<ListItem>
<Para>Using a text editor, remove the line that defines the Tape Coordinator from
the <Symbol Role="Variable">dcelocal</Symbol><Literal>/var/dfs/backup/TapeConfig</Literal> file.
<IndexTerm Id="DFSAGR.BKUP.indx.101">
<Primary><Command>bak</Command> command suite</Primary>
<Secondary><Command>rmhost</Command></Secondary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>Enter the <Command>bak rmhost</Command> command to delete the entry for the Tape Coordinator
from the Backup Database:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>$ <Command>bak rmhost </Command>[<Option>tcid </Option><Symbol Role="Variable">tc_number</Symbol>]
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</OrderedList>
<IndexTerm Id="DFSAGR.BKUP.indx.102" SpanEnd="DFSAGR.BKUP.indx.100">
<IndexTerm Id="DFSAGR.BKUP.indx.103" SpanEnd="DFSAGR.BKUP.indx.36">
</Sect2>
</Sect1>
</Chapter>
<!--+ 10/19/96 18:43:16
    | tagMorph:  $Id: backup.sgm,v 1.1.2.6 1996/12/15 23:01:45 wardr Exp $
    | tagMorph library:  $Id: backup.sgm,v 1.1.2.6 1996/12/15 23:01:45 wardr Exp $
    | sml-to-docbook:  1.23
    +-->
