<!--
# COPYRIGHT NOTICE
# Copyright (c) 1990-1996 Open Software Foundation, Inc. 
# ALL RIGHTS RESERVED (DCE). See the file named COPYRIGHT.DCE in the 
# src directory for the full copyright text. 
# 
# 
# HISTORY
# $Log: cert_intro_policy.3sec,v $
# Revision 1.1.2.9  1996/12/17  20:50:02  damon
# 	Expanded OSF C O P Y R I G H T   N O T I C E
# 	[1996/12/17  20:47:11  damon]
#
# Revision 1.1.2.8  1996/12/15  17:13:19  weir
# 	Various updates etc.
# 	[1996/12/15  17:12:08  weir]
# 
# Revision 1.1.2.7  1996/12/12  00:30:57  weir
# 	Fixed SGML errors
# 	[1996/12/12  00:30:32  weir]
# 
# Revision 1.1.2.6  1996/12/12  00:11:39  weir
# 	Editorial corrections
# 	[1996/12/12  00:10:10  weir]
# 
# Revision 1.1.2.5  1996/12/07  22:33:43  weir
# 	Set revision flag
# 	[1996/12/07  22:32:10  weir]
# 
# Revision 1.1.2.4  1996/12/07  20:27:01  carrig
# 	{enh,R1.2.2}
# 	VarLists, Tables
# 	[1996/12/07  20:18:34  carrig]
# 
# Revision 1.1.2.3  1996/12/06  23:45:49  weir
# 	Updates
# 	[1996/12/06  23:44:19  weir]
# 
# Revision 1.1.2.2  1996/12/01  20:18:48  weir
# 	Removed thinsp entities
# 	[1996/12/01  20:12:14  weir]
# 
# Revision 1.1.2.1  1996/11/29  17:54:18  weir
# 	Initial submission
# 	[1996/11/29  17:47:03  weir]
# 
# $EndLog$
# 
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<RefEntry RevisionFlag="changed" Id="DCEADR.MAN435.rsml.1">
<RefMeta>
<RefEntryTitle>policy_intro</RefEntryTitle>
<ManVolNum>3sec</ManVolNum>
</RefMeta>
<RefNameDiv>
<RefName><Literal>policy_intro</Literal></RefName>
<RefPurpose>Introduction to the policy module registration and service
facility
</RefPurpose>
</RefNameDiv>
<!-- -->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.2.3  1996/11/19  18:55:22  wardr-->
<!-- 	{edit,R1.2.2}-->
<!-- 	Init capped heads and added PDG pointer-->
<!-- 	[1996/11/19  18:48:27  wardr]-->
<!---->
<!-- Revision 1.1.2.2  1996/11/18  19:57:03  weir-->
<!-- 	No change-->
<!-- 	[1996/11/18  19:55:02  weir]-->
<!-- -->
<!-- Revision 1.1.2.1  1996/10/15  21:10:22  weir-->
<!-- 	Initial submission-->
<!-- 	[1996/10/15  21:09:04  weir]-->
<!-- -->
<!-- - -->
<!-- -->
<!-- -->
<!-- -->
<RefSect1>
<Title>Description</Title>
<Para>This reference page describes the data types used by the policy module
registration and service API.</para>
<!-- -->
<para>
The routines documented here are intended for the use of policy implementors.
Regular users invoke a policy via the high-level API
(e.g., <Function>pkc_retrieve_keyinfo(3sec)</Function>,
<Function>pkc_get_key_count(3sec)</Function>,
<Function>pkc_get_key_data(3sec)</Function>, etc.) which calls the routines
documented below internally.</para>
<!-- -->
<!-- -->
<!-- -->
<RefSect2>
<Title>Accessing Policy Modules</Title>
<Para>Policy modules are identified by OIDs (object identifiers). A policy
module is accessed by passing its identifying OID to
<Filename MoreInfo="RefEntry">pkc_plcy_lookup_policy(3sec)</Filename>.
<!-- -->
<!-- -->
<!-- -->
</Para>
<Para>There are two ways of retrieving a key: either by looking up the
desired policy module and then explicitly calling its
<Function>(retrieve_keyinfo)()</Function> routine; or by simply calling the
<Filename MoreInfo="RefEntry">pkc_plcy_retrieve_keyinfo(3sec)</Filename>
routine, identifying the desired policy by means of an OID passed directly to the
call. The latter method, in which the operation is performed in one step, is the
recommended one.
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
</Para>
</RefSect2>
<RefSect2>
<Title>Policy Flags Data Type</Title>
<Para>The <StructName Role="typedef">pkc_plcy_flags_t</StructName> data type is used to
record various information about a policy module. It is defined as follows:
<!-- -->
</Para>
<Synopsis><Literal>
typedef struct {char threadsafe; char multi_session;} pkc_plcy_flags_t;
</Literal>
<!-- -->
<!-- -->
</Synopsis>
<Para>The structure contains two fields which have the following meanings:
<!-- -->
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>threadsafe</Literal></Term>
<ListItem>
<Para>Has a non-zero (TRUE) value if the policy's <Function>retrieve_keyinfo()</Function>
function may be safely called simultaneously (within a single policy
session) by multiple threads.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>multi_session</Literal></Term>
<ListItem>
<Para>Has a non-zero (TRUE) value if the policy implementation supports multiple
simultaneous policy sessions.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
</RefSect2>
<RefSect2>
<Title>Policy Module Data Type</Title>
<Para>The <StructName Role="typedef">pkc_policy_t</StructName> data type is used to
register a new policy module
with the certification API. It fully describes a policy module's functionality,
and provides entry points to its key retrieval functions. It is defined as follows:
<!-- -->
<!-- -->
</Para>
<Synopsis><Literal>typedef struct {</Literal>
	<Literal>OM_uint32 version;</Literal>
	<Literal>gss_OID_desc policy_id;</Literal>
	<Literal>pkc_plcy_flags_t flags;</Literal>
	<Literal>char reserved[32 - sizeof(pkc_plcy_flags_t)];</Literal>
	<Literal>char * (* name) (void);</Literal>
	<Literal>unsigned32 (*open) (void** </Literal><Symbol Role="Variable">context</Symbol><Literal>);</Literal>
	<Literal>unsigned32 (*close) (void** </Literal><Symbol Role="Variable">context</Symbol><Literal>);</Literal>
	<Literal>unsigned32 (*establish_trustbase) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
				</Literal><Literal>const pkc_trust_list_t &amp; </Literal><Symbol Role="Variable">initial_trust</Symbol><Literal>,
				</Literal><Literal>const utc_t * </Literal><Symbol Role="Variable">date</Symbol><Literal>,
				</Literal><StructName Role="typedef">pkc_usage_t </StructName><Symbol Role="Variable">desired_usage</Symbol><Literal>,
				</Literal><Literal>char </Literal><Symbol Role="Variable">initial_explicit_policy_required</Symbol><Literal>,
				</Literal><Literal>pkc_trust_list_t &amp; </Literal><Symbol Role="Variable">out_trust</Symbol><Literal>);


	</Literal><Literal>unsigned32 (*retrieve_keyinfo) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
				</Literal><Literal>const pkc_trust_list_t &amp;</Literal><Symbol Role="Variable">trust</Symbol><Literal>,
				</Literal><Literal>const x500name &amp;</Literal><Symbol Role="Variable">subjectName</Symbol><Literal>,
				</Literal><Literal>const utc_t * </Literal><Symbol Role="Variable">date</Symbol><Literal>,
				</Literal><Literal>const uuid_t &amp; </Literal><Symbol Role="Variable">domain</Symbol><Literal>,
				</Literal><StructName Role="typedef">pkc_key_usage_t </StructName><Symbol Role="Variable">desired_usage</Symbol><Literal>,
				</Literal><Literal>char </Literal><Symbol Role="Variable">initial_explicit_policy_required</Symbol><Literal>,
				</Literal><Literal>pkc_key_information_t &amp;</Literal><Symbol Role="Variable">key</Symbol><Literal>);
	</Literal><Literal>unsigned32 (*delete_trustbase) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
				</Literal><Literal>void ** </Literal><Symbol Role="Variable">trust_base_handle</Symbol><Literal>);
	</Literal><Literal>unsigned32 (*delete_keyinfo) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
				</Literal><Literal>void ** </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>);
	</Literal><Literal>unsigned32 (*get_key_count) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
				</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
				</Literal><Literal>size_t * </Literal><Symbol Role="Variable">key_count</Symbol><Literal>);
	</Literal><Literal>unsigned32 (*get_key_data) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
				</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
				</Literal><Literal>unsigned </Literal><Symbol Role="Variable">key_index</Symbol><Literal>,
				</Literal><Literal>unsigned char ** </Literal><Symbol Role="Variable">key_data</Symbol><Literal>,
				</Literal><Literal>size_t * </Literal><Symbol Role="Variable">key_length</Symbol><Literal>);
	</Literal><Literal>unsigned32 (*get_key_trust) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
				</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
				</Literal><Literal>unsigned </Literal><Symbol Role="Variable">key_index</Symbol><Literal>,
				</Literal><Literal>certification_flags_t * </Literal><Symbol Role="Variable">flags</Symbol><Literal>
				</Literal><Literal>uuid_t * </Literal><Symbol Role="Variable">domain</Symbol><Literal>,
				</Literal><Literal>pkc_generic_key_usage_t * </Literal><Symbol Role="Variable">usages</Symbol><Literal>);
	</Literal><Literal>unsigned32 (*get_key_certifier_count) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
				</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
				</Literal><Symbol Role="Variable">unsigned </Symbol><Symbol Role="Variable">key_index</Symbol><Literal>,
				</Literal><Literal>size_t * </Literal><Symbol Role="Variable">ca_count</Symbol><Literal>);
	</Literal><Literal>unsigned32 (*get_key_certifier_info) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
				</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
				</Literal><Literal>unsigned </Literal><Symbol Role="Variable">key_index</Symbol><Literal>,
				</Literal><Literal>unsigned </Literal><Symbol Role="Variable">ca_index</Symbol><Literal>,
				</Literal><Literal>char ** </Literal><Symbol Role="Variable">ca_name</Symbol><Literal>,
				</Literal><Literal>utc_t * </Literal><Symbol Role="Variable">certification_start</Symbol><Literal>,
				</Literal><Literal>utc_t * </Literal><Symbol Role="Variable">certification_expiration</Symbol><Literal>,
				</Literal><Literal>char  * </Literal><Symbol Role="Variable">is_crl_valid</Symbol><Literal>,
				</Literal><Literal>utc_t * </Literal><Symbol Role="Variable">last_crl_seen</Symbol><Literal>,
				</Literal><Literal>utc_t * </Literal><Symbol Role="Variable">next_crl_expected</Symbol><Literal>);
<!-- -->
<!-- -->
</Literal><Literal>} pkc_policy_t;</Literal>
</Synopsis>
<!-- -->
<Para>The <Function>(name)()</Function>, <Function>(open)()</Function>,
<Function>(close)()</Function>, <Function>(establish_trustbase()</Function>,
<Function>(*get_key_count)()</Function>, <Function>(*get_key_data)()</Function>,
<Function>(*get_key_trust)()</Function>, <Function>(*get_key_certifier_count)()</Function>,
<Function>(*get_key_certifier_info)()</Function>, and
<Function>(*retrieve_keyinfo)()</Function> routines must be implemented by the application
implementing the module and registered using the
<Filename MoreInfo="RefEntry">pkc_register_policy(3sec)</Filename> routine. Note, however,
that only <Function>(*retrieve_keyinfo)()</Function>,
<Function>(*get_key_count)()</Function>, <Function>(*get_key_certifier_count)()</Function>
and <Function>(*get_key_data)()</Function> are required.
<!-- -->
<!-- -->
<!-- -->
Explanations of all the fields in <StructName Role="typedef">pkc_policy_t</StructName>
are contained in the following subsections.
<!-- -->
<!-- -->
</Para>
</RefSect2>
<RefSect2>
<Title>Policy Module Data Fields</Title>
<Para>The structure contains the following data fields:
<!-- -->
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>version</Literal></Term>
<ListItem>
<Para>Identifies the version of the certification API for which the module is
implemented. The value of this field is always <Literal>pkc_V1</Literal> for
DCE 1.2.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>policy_id</Literal></Term>
<ListItem>
<Para>An object identifier that identifies the policy.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>flags</Literal></Term>
<ListItem>
<Para>Describes whether the module's key retrieval function is threadsafe, and
whether the module supports simultaneous policy sessions.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<Para>The <Literal>version</Literal> and <Replaceable>alg_id</Replaceable>
fields are required for all versions of this data structure. Other fields
may be version dependent.
<!-- -->
<!-- -->
</Para>
</RefSect2>
<RefSect2>
<Title>Policy Module Functions</Title>
<Para><Literal>NULL</Literal> may be supplied as the address of the
<Function>(name)()</Function>, <Function>(open)()</Function>,
<Function>(establish_trustbase)()</Function> or <Function>(close)()</Function>
routines, if the policy module does not provide or require the corresponding
feature; the presence of these functions in a policy module is optional.
However, all policy modules must provide <Function>(*retrieve_keyinfo)()</Function>,
<Function>(*get_key_count)()</Function>, <Function>(*get_key_certifier_count)()</Function>
and <Function>(*get_key_data)()</Function> functions.
<!-- -->
<!-- -->
<?sml-new-page>
<!-- -->
</Para>
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Name</Title>
<Para><Function>(name)()</Function> &mdash; Returns the policy name as a string,
suitable for use in diagnostic or auditing messages
</Para>
<Para>This routine is optional.
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>char * (* name) (void);</Literal>
</Synopsis>
<!-- -->
<!-- -->
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para>The name should be returned in storage allocated using the
<Function>pkc_malloc()</Function> function defined in
<Filename>pkc_common.h</Filename>. The caller of this routine is
expected to invoke <Function>pkc_free(3sec)</Function>to release
the storage once the name is no longer required.</para>
<para>
Note that this is the only policy module routine that may be called without first calling
the <Function>(open)()</Function> routine.</Para>
</RefSect1>
<!-- -->
<!-- -->
<?sml-new-page>
<!-- -->
<RefSect1>
<Title>Name</Title>
<Para><Function>(open)()</Function> &mdash; Opens and initializes the policy module
</Para>
<Para><Function>(close)()</Function> &mdash; Closes the policy module
</Para>
<Para>Both these routines are optional.
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*open) (void** </Literal><Symbol Role="Variable">context</Symbol><Literal>);</Literal>
</Synopsis>
<Synopsis>
<Literal>unsigned32 (*close) (void** </Literal><Symbol Role="Variable">context</Symbol><Literal>);</Literal>
</Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Output</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state information
required by the module across calls.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para>Before invoking any policy routines (e.g., <Function>(retrieve_keyinfo)()</Function>),
the certification API will invoke the module's <Function>(open)()</Function> function.
Once the module's <Function>(close)()</Function> routine has been invoked, the
certification facility will invoke <Function>(open)()</Function> again before making
any further calls to the module.
<!-- -->
<!-- -->
</Para>
<Para>Both the <Function>(open)()</Function> and the <Function>(close)()</Function>
routines require only one argument, <Symbol Role="Variable">context</Symbol>. If the
policy module requires state information to be maintained between calls, it may use
the <Symbol Role="Variable">context</Symbol> parameter to do this. The information is
initialized by the <Function>(open)()</Function> routine and returned as an opaque
object to the caller, who then passes the parameter to subsequent
<Function>(retrieve_keyinfo)()</Function>, <Function>(establish_trustbase)()</Function>,
or <Function>(close)()</Function> calls.
</Para>
<Para>Note that if the <Function>(open)()</Function> routine stores any state
in the <Symbol Role="Variable">context</Symbol> parameter, the
<Function>(close)()</Function> routine should free this storage.
<!-- -->
<!-- -->
<?sml-new-page>
<!-- - -->
</Para>
</RefSect1>
<RefSect1>
<Title>Name</Title>
<Para><Function>(establish_trustbase)()</Function> &mdash; Initializes a trust base
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*establish_trustbase) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
	</Literal><Literal>const pkc_trust_list_t &amp; </Literal><Symbol Role="Variable">initial_trust</Symbol><Literal>,
	</Literal><Literal>const utc_t * </Literal><Symbol Role="Variable">date</Symbol><Literal>,
	</Literal><Literal>char </Literal><Symbol Role="Variable">initial_explicit_policy_required</Symbol><Literal>,
	</Literal><Literal>pkc_trust_list_t &amp; </Literal><Symbol Role="Variable">out_trust</Symbol><Literal>);
</Literal></Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Input</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state
information required by the module across calls.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">initial_trust</Symbol></Term>
<ListItem>
<Para>Specifies the caller's initial trust.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">date</Symbol></Term>
<ListItem>
<Para>Specifies time for which information is to be returned.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">initial_explicit_policy_required</Symbol></Term>
<ListItem>
<Para>Specifies whether the initial certificate must explicitly contain
the active policy in its policies field.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
</RefSect2>
<RefSect2>
<Title>Output</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">out_trust</Symbol></Term>
<ListItem>
<Para>An extended trust list.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para>This is a one-time call made by an application to initialize a trust
base. It returns the <Symbol Role="Variable">out_trust</Symbol> parameter,
which contains an extended trust list. After this call is made, the application
can call <Function>(retrieve_keyinfo)()</Function> to obtain the public keys of
any particular principal. If the trust base does not change,
<Function>(retrieve_keyinfo)()</Function> can be used to look up another principal's
public key without incurring the cost of another call to
<Function>(establish_trustbase)()</Function>. A trust base will not change unless the
<Symbol Role="Variable">initial_trust</Symbol> list changes.
<!-- -->
<!-- -->
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Name</Title>
<Para><Function>(*delete_trustbase)()</Function> &mdash; Frees storage allocated
for a trust base
</Para>
<Para>This routine is optional.
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*delete_trustbase) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
	</Literal><Literal>void ** </Literal><Symbol Role="Variable">trust_base_handle</Symbol><Literal>);
</Literal></Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Input</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state information
required by the module across calls.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">keys_handle</Symbol></Term>
<ListItem>
<Para>A policy specific structure, contained in the
<StructName Role="typedef">keyinfo_t</StructName> structure passed by
the original caller.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Name</Title>
<Para><Function>(*delete_keyinfo)()</Function> &mdash; Frees storage allocated for
key information
</Para>
<Para>This routine is optional.
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*delete_keyinfo) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
	</Literal><Literal>void ** </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>);
</Literal></Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Input</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state information
required by the module across calls.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">keys_handle</Symbol></Term>
<ListItem>
<Para>A policy specific structure, contained in the
<StructName Role="typedef">keyinfo_t</StructName> structure passed by
the original caller.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para><Function>(*delete_keyinfo)()</Function> frees storage that was allocated for
key information.
<!-- -->
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Name</Title>
<Para><Function>(*get_key_count)()</Function> &mdash; Returns number of keys
</Para>
<Para>This routine is optional.
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*get_key_count) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
	</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
	</Literal><Literal>size_t * </Literal><Symbol Role="Variable">key_count</Symbol><Literal>);
</Literal></Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Input</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state information required
by the module across calls.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">keys_handle</Symbol></Term>
<ListItem>
<Para>A policy specific structure, contained in the
<StructName Role="typedef">keyinfo_t</StructName> structure passed by
the original caller.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
</RefSect2>
<RefSect2>
<Title>Output</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">key_count</Symbol></Term>
<ListItem>
<Para>Number of keys for the principal.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para><Function>(*get_key_count)()</Function> returns the number of keys for the principal.
This value is determined by reference to the policy-specific structure pointed to by
<Symbol Role="Variable">keys_handle</Symbol>, a field in the
<StructName Role="typedef">keyinfo_t</StructName> structure passed by the original caller.
<!-- -->
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Name</Title>
<Para><Function>(*get_key_data)()</Function> &mdash; Returns a public key
</Para>
<Para>This routine is optional.
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*get_key_data) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
	</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
	</Literal><Literal>unsigned </Literal><Symbol Role="Variable">key_index</Symbol><Literal>,
	</Literal><Literal>unsigned char ** </Literal><Symbol Role="Variable">key_data</Symbol><Literal>,
	</Literal><Literal>size_t * </Literal><Symbol Role="Variable">key_length</Symbol><Literal>);
</Literal></Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Input</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state information
required by the module across calls.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">keys_handle</Symbol></Term>
<ListItem>
<Para>A policy specific structure, contained in the
<StructName Role="typedef">keyinfo_t</StructName> structure passed by
the original caller (see <Filename MoreInfo="RefEntry">pkc_intro(3sec)).
<!-- -->
</Filename></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">key_index</Symbol></Term>
<ListItem>
<Para>Index (ranging from 0 to <Replaceable>key_count</Replaceable> &minus; 1) of
the key desired.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
</RefSect2>
<RefSect2>
<Title>Output</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">key_data</Symbol></Term>
<ListItem>
<Para>The encoded public key.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">key_length</Symbol></Term>
<ListItem>
<Para>Length of the key data returned.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para><Function>(*get_key_data)()</Function> returns the public key
specified by <Symbol Role="Variable">index</Symbol>. The
<Symbol Role="Variable">key_data</Symbol> returned is extracted from
the policy-specific structure pointed to by <Symbol Role="Variable">keys_handle</Symbol>,
a field in the <StructName Role="typedef">keyinfo_t</StructName> structure
passed by the original caller.
</Para>
<Para><Symbol Role="Variable">key_data</Symbol> should be returned in storage allocated using the
<Function>pkc_malloc()</Function> function defined in <Filename>pkc_common.h</Filename>.
<!-- -->
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Name</Title>
<Para><Function>(*get_key_trust)()</Function> &mdash; Returns information about key trust
</Para>
<Para>This routine is optional.
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*get_key_trust) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
	</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
	</Literal><Literal>unsigned </Literal><Symbol Role="Variable">key_index</Symbol><Literal>,
	</Literal><Literal>certification_flags_t * </Literal><Symbol Role="Variable">flags</Symbol><Literal>
	</Literal><Literal>uuid_t * </Literal><Symbol Role="Variable">domain</Symbol><Literal>,
	</Literal><Literal>pkc_generic_key_usage_t * </Literal><Symbol Role="Variable">usages</Symbol><Literal>);
</Literal></Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Input</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state
information required by the module across calls.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">keys_handle</Symbol></Term>
<ListItem>
<Para>A policy specific structure, contained in the
<StructName Role="typedef">keyinfo_t</StructName> structure passed by the
original caller (see <Filename MoreInfo="RefEntry">pkc_intro(3sec)).
<!-- -->
</Filename></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">key_index</Symbol></Term>
<ListItem>
<Para>Index (ranging from 0 to <Replaceable>key_count</Replaceable> &minus; 1) of
the key desired.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
</RefSect2>
<RefSect2>
<Title>Output</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">flags</Symbol></Term>
<ListItem>
<Para>Information about the trust that can be placed in the key (see below).
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<!-- -->
<!-- -->
<!-- -->
<VarListEntry>
<Term><Symbol Role="Variable">domain</Symbol></Term>
<ListItem>
<para>
Indicates domain of retrieved key. A value of
<Literal>sec_pk_domain_unspecified</Literal> or <Literal>NULL</Literal>
means that the policy does not distinguish keys by domain.</para>
</ListItem>
</VarListEntry>
<!-- -->
<!-- -->
<!-- -->
<VarListEntry>
<Term><Symbol Role="Variable">usages</Symbol></Term>
<ListItem>
<para>
Indicates usage key is intended for.</para>
<!-- -->
</ListItem>
</VarListEntry>
<!-- -->
<!-- -->
</VariableList>
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para><Function>(*get_key_trust)()</Function> returns information about
the trust reposed in the key specified by <Symbol Role="Variable">index</Symbol>.
This information is determined by reference to the policy-specific structure
pointed to by <Symbol Role="Variable">keys_handle</Symbol>, a field in the
<StructName Role="typedef">keyinfo_t</StructName> structure passed by the
original caller.
</Para>
<Para>The returned <StructName Role="typedef">certification_flags_t</StructName>
structure describes the trust that can be placed in the key. It contains the
following fields:
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>trust_type</Literal>
</Para>
<Para>A <StructName Role="typedef">trust_type_t</StructName> value, which will be one of the following:
<!-- -->
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>UNTRUSTED</Literal>
</Para>
<Para>No trust (e.g., unauthenticated).
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para><Literal>DIRECT_TRUST</Literal>
</Para>
<Para>Direct trust via third party (e.g., authenticated registry).
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para><Literal>CERTIFIED_TRUST</Literal>
</Para>
<Para>Trust certified by caller's trust base.
<!-- -->
</Para>
</ListItem>
</ItemizedList>
<!-- -->
</ListItem>
<ListItem>
<Para><Literal>missing_crls</Literal>
</Para>
<Para>A <Literal>char</Literal>; its value is TRUE (not 0) if one or more CRLs are
missing.
<!-- -->
</Para>
</ListItem>
<ListItem>
<Para><Literal>revoked</Literal>
</Para>
<Para>A <Literal>char</Literal> whose value is TRUE (not 0) if any certificate
has been revoked (even if it was still valid at the retrieval time).</Para>
<!-- -->
</ListItem>
</ItemizedList>
<!-- -->
<!-- -->
<!-- ------------------------------------------------------------- -->
<!-- -->
<para>
If <Literal>domain</Literal> and <Literal>usages</Literal> are
passed as non-<Literal>NULL</Literal> pointers, upon successful return these
parameters will describe the domain and permitted usage(s) of the specified
key. Policies that do not distinguish keys according to domain will indicate a
domain of <Literal>sec_pk_domain_unspecified</Literal>; policies that do not
distinguish keys according to usage will indicate all usages are permitted.
</para>
<para>
The returned <Literal>usages</Literal> is a bit mask which describes
the usage(s), if any, which the key is restricted to. The value is
formed by AND-ing together one or more of the following constants:</para>
<!-- -->
<!-- -->
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_AUTHENTICATION</Literal></Term>
<ListItem><para>
The key can be used to authenticate a user</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_INTEGRITY</Literal></Term>
<ListItem><para>
The key can be used to provide integrity protection</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_KEY_ENCIPHERMENT</Literal></Term>
<ListItem><para>
The key can be used to encrypt user keys</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_DATA_ENCIPHERMENT</Literal></Term>
<ListItem><para>
The key can be used to encrypt user data</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_KEY_AGREEMENT</Literal></Term>
<ListItem><para>
The key can be used for key-exchange</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_NONREPUDIATION</Literal></Term>
<ListItem><para>
The key can be used for non-repudiation</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_CAKEY_USAGE_KEY_CERT_SIGN</Literal></Term>
<ListItem><para>
The key can be used to sign key certificates</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_CAKEY_USAGE_OFFLINE_CRL_SIGN</Literal></Term>
<ListItem><para>
The key can be used to sign CRLs</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_CAKEY_USAGE_TRANSACTION_SIGN</Literal></Term>
<ListItem><para>
The key can be used to sign transactions</para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<para>
A returned <Literal>usages</Literal> value of <Literal>NULL</Literal>
(or a value with all bits set) means that the key is suitable for any
usage.</para>
<!-- -->
<!-- ============================================================= -->
<!-- -->
<!-- -->
</RefSect1>
<!-- -->
<!-- -->
<!-- -->
<RefSect1>
<Title>Name</Title>
<Para><Function>(*get_key_certifier_count)()</Function> &mdash; Returns number of key's certifying
authorities
</Para>
<Para>This routine is optional.
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*get_key_certifier_count) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
	</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
	</Literal><Symbol Role="Variable">unsigned </Symbol><Symbol Role="Variable">key_index</Symbol><Literal>,
	</Literal><Literal>size_t * </Literal><Symbol Role="Variable">ca_count</Symbol><Literal>);
</Literal></Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Input</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state information required
by the module across calls.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">keys_handle</Symbol></Term>
<ListItem>
<Para>A policy specific structure, contained in the <StructName Role="typedef">keyinfo_t</StructName> structure passed by
the original caller (see <Filename MoreInfo="RefEntry">pkc_intro(3sec)).
<!-- -->
</Filename></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">key_index</Symbol></Term>
<ListItem>
<Para>Index (ranging from 0 to <Replaceable>key_count</Replaceable> &minus; 1)
of the key desired.
<!-- -->
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
</RefSect2>
<RefSect2>
<Title>Output</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">ca_count</Symbol></Term>
<ListItem>
<Para>Number of certifying authorities for the key.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para><Function>(*get_key_certifier_count)()</Function> returns the number
of certifying authorities for the key specified by
<Symbol Role="Variable">index</Symbol>. This information is determined from
the policy-specific structure pointed to by <Symbol Role="Variable">keys_handle</Symbol>,
a field in the <StructName Role="typedef">keyinfo_t</StructName> structure passed
by the original caller.
<!-- -->
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Name</Title>
<Para><Function>(*get_key_certifier_info)()</Function> &mdash; Returns information about a certifying
authority
</Para>
<Para>This routine is optional.
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*get_key_certifier_info) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
	</Literal><Literal>void * </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>,
	</Literal><Literal>unsigned </Literal><Symbol Role="Variable">key_index</Symbol><Literal>,
	</Literal><Literal>unsigned </Literal><Symbol Role="Variable">ca_index</Symbol><Literal>,
	</Literal><Literal>char ** </Literal><Symbol Role="Variable">ca_name</Symbol><Literal>,
	</Literal><Literal>utc_t * </Literal><Symbol Role="Variable">certification_start</Symbol><Literal>,
	</Literal><Literal>utc_t * </Literal><Symbol Role="Variable">certification_expiration</Symbol><Literal>,
	</Literal><Literal>char  * </Literal><Symbol Role="Variable">is_crl_valid</Symbol><Literal>,
	</Literal><Literal>utc_t * </Literal><Symbol Role="Variable">last_crl_seen</Symbol><Literal>,
	</Literal><Literal>utc_t * </Literal><Symbol Role="Variable">next_crl_expected</Symbol><Literal>);
</Literal></Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Input</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state
information required by the module across calls.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">keys_handle</Symbol></Term>
<ListItem>
<Para>A policy specific structure, contained in the
<StructName Role="typedef">keyinfo_t</StructName> structure passed by
the original caller (see <Filename MoreInfo="RefEntry">pkc_intro(3sec)).
<!-- -->
</Filename></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">key_index</Symbol></Term>
<ListItem>
<Para>Index (ranging from 0 to <Replaceable>key_count</Replaceable> &minus; 1)
of the key desired.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">ca_index</Symbol></Term>
<ListItem>
<Para>Index of the certifier about whom information is desired.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
</RefSect2>
<RefSect2>
<Title>Output</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">ca_name</Symbol></Term>
<ListItem>
<Para>The name of the certifier.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">certification_start</Symbol></Term>
<ListItem>
<Para>Time at which certification by this certifier starts.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">certification_expiration</Symbol></Term>
<ListItem>
<Para>Time at which certification by this certifier ends.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">is_crl_valid</Symbol></Term>
<ListItem>
<Para>If TRUE, there is a certificate revocation list for this
certifier.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">last_crl_seen</Symbol></Term>
<ListItem>
<Para>Time at which certificate revocation list was last seen.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">next_crl_expected</Symbol></Term>
<ListItem>
<Para>Time at which next certificate revocation list is expected.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para><Function>(*get_key_certifier_info)()</Function> returns information about the
certifying authority specified by <Symbol Role="Variable">ca_index</Symbol> for the key specified
by <Symbol Role="Variable">key_index</Symbol>.
</Para>
<Para>The desired information is extracted by the routine from 
the policy-specific structure pointed to by <Symbol Role="Variable">keys_handle</Symbol>,
a field in the <StructName Role="typedef">keyinfo_t</StructName> structure passed by the original caller.
</Para>
<Para>Note that any of the return parameters may be passed as NULL if the
corresponding information is not required.
</Para>
<Para>The <Symbol Role="Variable">certifier_name</Symbol> parameter should be returned in storage allocated
using the <Function>pkc_malloc()</Function> function defined in <Filename>pkc_common.h</Filename>.
<!-- -->
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Name</Title>
<Para><Function>(retrieve_keyinfo)()</Function> &mdash; Returns the public key for the specified principal
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Synopsis</Title>
<Synopsis><Literal>unsigned32 (*retrieve_keyinfo) (void ** </Literal><Symbol Role="Variable">context</Symbol><Literal>,
	</Literal><Literal>const void * </Literal><Symbol Role="Variable">trust_base_handle</Symbol><Literal>,
	</Literal><Literal>const x500name &amp; </Literal><Symbol Role="Variable">subjectName</Symbol><Literal>,
	</Literal><Literal>const utc_t * </Literal><Symbol Role="Variable">date</Symbol><Literal>,
	</Literal><Literal>const uuid_t &amp; </Literal><Symbol Role="Variable">domain</Symbol><Literal>,
	</Literal><StructName Role="typedef">pkc_key_usage_t </StructName><Symbol Role="Variable">desired_usage</Symbol><Literal>,
	</Literal><Literal>char </Literal><Symbol Role="Variable">initial_explicit_policy_required</Symbol><Literal>,
	</Literal><Literal>void ** </Literal><Symbol Role="Variable">keys_handle</Symbol><Literal>);
</Literal></Synopsis>
<!-- -->
</RefSect1>
<RefSect1>
<Title>Parameters</Title>
<RefSect2>
<Title>Input</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">context</Symbol></Term>
<ListItem>
<Para>An opaque (to the caller) data structure containing any state information
required by the module across calls.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">trust_base_handle</Symbol></Term>
<ListItem>
<Para>Specifies trust base.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">subjectName</Symbol></Term>
<ListItem>
<Para>Specifies the desired subject name.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">date</Symbol></Term>
<ListItem>
<Para>Specifies time for which information is to be returned.
</Para>
</ListItem>
</VarListEntry>
<!-- -->
<!-- -->
<!-- -->
<VarListEntry>
<Term><Symbol Role="Variable">domain</Symbol></Term>
<ListItem>
<Para>
Specifies the particular domain to which the key-search operation
should be restricted. Specify <Literal>sec_pk_domain_unspecified</Literal>
or <Literal>NULL</Literal> to indicate that keys for any domain should be
retrieved.
</Para>
</ListItem>
</VarListEntry>
<!-- -->
<!-- -->
<!-- -->
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">desired_usage</Symbol></Term>
<ListItem>
<Para>Specifies the one or more specific usages to which
the key-search operation should be restricted.</Para>
</ListItem>
</VarListEntry>
<!-- -->
<!-- -->
<!-- -->
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">initial_explicit_policy_required</Symbol></Term>
<ListItem>
<Para>Specifies whether the initial certificate must explicitly contain
the active policy in its policies field.
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
</RefSect2>
<RefSect2>
<Title>Output</Title>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">keys_handle</Symbol></Term>
<ListItem>
<Para>The handle to the public key for the specified target principal.
<!-- -->
<!-- -->
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<!-- -->
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Description</Title>
<Para>The <Function>(retrieve_keyinfo)()</Function> routine reads the
certificate for the specified principal name, verifies it, and (if the
verification is successful) extracts the public key stored in it and
returns it to the caller.
</Para>
<Para>The returned key information handle can be interrogated by various
<Literal>pkc_cert_</Literal> routines to extract the actual key and determine
the degree of trust that can be placed in the returned key.</Para>
<!-- -->
<!-- -->
<!-- -->
<para>
If <Literal>domain</Literal> and <Literal>desired_usage</Literal> are
passed as non-<Literal>NULL</Literal> pointers, upon successful return these
parameters will describe the domain and permitted usage(s) of the specified
key. Policies that do not distinguish keys according to domain will indicate a
domain of <Literal>sec_pk_domain_unspecified</Literal>; policies that do not
distinguish keys according to usage will indicate all usages are permitted.
</para>
<para>
The <Literal>desired_usage</Literal> parameter consists of a bit mask, formed
by AND-ing together one or more of the constants:</para>
<!-- -->
<!-- -->
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_AUTHENTICATION</Literal></Term>
<ListItem><para>
The key can be used to authenticate a user</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_INTEGRITY</Literal></Term>
<ListItem><para>
The key can be used to provide integrity protection</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_KEY_ENCIPHERMENT</Literal></Term>
<ListItem><para>
The key can be used to encrypt user keys</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_DATA_ENCIPHERMENT</Literal></Term>
<ListItem><para>
The key can be used to encrypt user data</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_KEY_AGREEMENT</Literal></Term>
<ListItem><para>
The key can be used for key-exchange</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_KEY_USAGE_NONREPUDIATION</Literal></Term>
<ListItem><para>
The key can be used for non-repudiation</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_CAKEY_USAGE_KEY_CERT_SIGN</Literal></Term>
<ListItem><para>
The key can be used to sign key certificates</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_CAKEY_USAGE_OFFLINE_CRL_SIGN</Literal></Term>
<ListItem><para>
The key can be used to sign CRLs</para>
</ListItem>
</VarListEntry>
<!-- -->
<VarListEntry role="linebreak">
<Term><Literal>PKC_CAKEY_USAGE_TRANSACTION_SIGN</Literal></Term>
<ListItem><para>
The key can be used to sign transactions</para>
</ListItem>
</VarListEntry>
</VariableList>
<!-- -->
<!-- -->
<para>
A <Literal>NULL</Literal> can be specified for <Literal>desired_usage</Literal>
to indicate that keys for any usage should be retrieved.
</para>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<Para>Note that some of the routine's parameters relate to X.509 version 3
certificates, support for which is not committed for DCE 1.2. The API has
been designed with the intent that it be capable of supporting all currently
defined versions of X.509, so that it need not change when version 3 support
is added. For version 1 or version 2 policies and certificates, the
<Symbol Role="Variable">desired_usage</Symbol> parameter will be ignored, and the
<Symbol Role="Variable">initial_explicit_policy_required</Symbol> parameter must
be zero (specifying that the policy need not explicitly appear in the
first certificate).
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
</Para>
</RefSect1>
<RefSect1>
<Title>Related Information</Title>
<Para>
Functions:
<Filename MoreInfo="RefEntry">pkc_plcy_delete_keyinfo(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_delete_trustbase(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_establish_trustbase(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_get_key_certifier_count(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_get_key_certifier_info(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_get_key_count(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_get_key_data(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_get_key_trust(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_get_registered_policies(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_lookup_policy(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_retrieve_key(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_plcy_retrieve_keyinfo(3sec)</Filename>,
<Filename MoreInfo="RefEntry">pkc_register_policy(3sec)</Filename>.
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
</Para>
</RefSect1>
<!--+ 11/27/96 19:46:25
    | tagMorph:  $Id: cert_intro_policy.3sec,v 1.1.2.9 1996/12/17 20:50:02 damon Exp $
    | tagMorph library:  $Id: cert_intro_policy.3sec,v 1.1.2.9 1996/12/17 20:50:02 damon Exp $
    | sml-to-docbook:  1.25
    +-->
</RefEntry>
