<!--
# @OSF_COPYRIGHT@
# 
# 
# HISTORY
# $Log: rpc_intro.3rpc,v $
# Revision 1.1.2.9  1996/12/15  16:36:51  carrig
# 	{enh,R1.2.2}
# 	Final edits
# 	[1996/12/15  16:11:46  carrig]
#
# Revision 1.1.2.8  1996/12/11  20:39:48  wardr
# 	{edit,R1.2.2}
# 	fixed parsing problems
# 	[1996/12/11  20:36:07  wardr]
# 
# Revision 1.1.2.7  1996/12/10  22:39:05  wardr
# 	{edit,R1.2.2}
# 	Fixing sgml
# 	[1996/12/10  22:35:13  wardr]
# 
# Revision 1.1.2.6  1996/12/09  22:23:42  wardr
# 	{edit,R1.2.2}
# 	Fixed conversion problems
# 	[1996/12/09  22:06:08  wardr]
# 
# Revision 1.1.2.5  1996/12/07  16:45:21  carrig
# 	{enh,R1.2.2}
# 	Var List Entry
# 	[1996/12/07  16:45:02  carrig]
# 
# Revision 1.1.2.4  1996/12/04  21:40:12  wardr
# 	{edit,R1.2.2}
# 	Fixed initial conversion problems
# 	[1996/12/04  21:35:59  wardr]
# 
# Revision 1.1.2.3  1996/12/02  21:00:28  carrig
# 	{enh,R1.2.2}
# 	VarListEntry
# 	[1996/12/02  20:56:40  carrig]
# 
# Revision 1.1.2.2  1996/12/01  19:22:32  weir
# 	Removed thinsp entities
# 	[1996/12/01  19:19:28  weir]
# 
# Revision 1.1.2.1  1996/11/29  17:15:17  weir
# 	Initial submission
# 	[1996/11/29  17:11:37  weir]
# 
# $EndLog$
-->
<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1993, v.4001
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V2.4//EN" [
]>
-->
<RefEntry Id="DCEADR.MAN199.rsml.1">
<RefMeta>
<RefEntryTitle>rpc_intro</RefEntryTitle>
<ManVolNum>3rpc</ManVolNum>
</RefMeta>
<RefNameDiv>
<RefName><Literal>rpc_intro</Literal></RefName>
<RefPurpose>Introduction to the DCE RPC API runtime</RefPurpose>
</RefNameDiv>
<!-- COPYRIGHT NOTICE-->
<!-- Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.-->
<!-- ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for-->
<!-- the full copyright text.-->
<!-- -->
<!-- -->
<!-- OLD HISTORY-->
<!-- Revision 1.1.4.1  1996/11/18  19:57:12  wardr-->
<!-- 	{edit,R1.2.2}-->
<!-- 	Init capped heads and added PDG pointer-->
<!-- 	[1996/11/18  19:34:17  wardr]-->
<!---->
<!-- Revision 1.1.2.12  1995/06/21  13:20:25  buckler-->
<!-- 	More 1.1 edits.-->
<!-- 	[1995/06/20  18:58:05  buckler]-->
<!-- -->
<!-- 	More 1.1 edits.-->
<!-- 	[1995/06/19  16:54:21  buckler]-->
<!-- -->
<!-- 	More 1.1 edits.-->
<!-- 	[1995/06/19  16:19:18  buckler]-->
<!-- -->
<!-- Revision 1.1.2.11  1995/06/07  20:11:04  buckler-->
<!-- 	1.1 edits  Prentice Hall reformat-->
<!-- 	[1995/06/07  20:06:08  buckler]-->
<!-- -->
<!-- Revision 1.1.2.9  1995/05/18  16:31:26  rcb-->
<!-- 	PRENTICE HALL reformat: preliminary fiddling-->
<!-- 	[1995/05/18  16:30:56  rcb]-->
<!-- -->
<!-- Revision 1.1.2.8  1994/11/03  23:45:57  neilson-->
<!-- 	Substituted macros for book names in cross refs.-->
<!-- 	[1994/11/03  01:39:32  neilson]-->
<!-- -->
<!-- Revision 1.1.2.7  1994/10/18  18:22:43  zahn-->
<!-- 	{enh,5284,R1.1}-->
<!-- -->
<!-- 	Added M. Romagna's technical review comments.-->
<!-- 	[1994/10/18  18:22:28  zahn]-->
<!-- -->
<!-- Revision 1.1.2.6  1994/07/14  19:04:24  jshirley-->
<!-- 	(def,10220,R1.1}-->
<!-- 	Remove references to rpcd and sec_clientd.-->
<!-- 	[1994/07/14  18:44:13  jshirley]-->
<!-- -->
<!-- Revision 1.1.2.5  1994/06/13  17:03:47  devobj-->
<!-- 	cr10872 - fix copyright-->
<!-- 	[1994/06/13  16:47:34  devobj]-->
<!-- -->
<!-- Revision 1.1.2.4  1994/05/05  19:29:41  zahn-->
<!-- 	Added a note about including an application that-->
<!-- 	has used the ACF encode and decode attributes as-->
<!-- 	a prerequisite for using the IDL encoding services.-->
<!-- 	[1994/05/05  19:29:18  zahn]-->
<!-- -->
<!-- Revision 1.1.2.3  1994/05/03  18:12:45  zahn-->
<!-- 	Removed use of bookdef macro for Appication Development-->
<!-- 	Guide-Core Components.  Looks like it was the build breaking-->
<!-- 	culprit.-->
<!-- 	[1994/05/03  18:12:29  zahn]-->
<!-- -->
<!-- Revision 1.1.2.2  1994/04/13  19:15:48  zahn-->
<!-- 	{enh,5284,R1.1}-->
<!-- -->
<!-- 	Added documentation for character and code set i14y.-->
<!-- -->
<!-- 	(enh,9601,R1.1}-->
<!-- -->
<!-- 	Added documentation for IDL encoding services.-->
<!-- -->
<!-- 	{enh,9773,R1.1}-->
<!-- -->
<!-- 	Added documentation for character/code set registry.-->
<!-- -->
<!-- 	{def,9262,R1.1}-->
<!-- -->
<!-- 	Deleted "stub support routine" list and list of rpc_ss-->
<!-- 	calls.  Merged rpc_sm call list into "DCE RPC routines"-->
<!-- 	list.  This work is part of de-emphasizing use of rpc_ss-->
<!-- 	routines and emphasizing use of rpc_sm routines.-->
<!-- -->
<!-- 	(def,9908,R1,1}-->
<!-- -->
<!-- 	Deleted note about connectionful RPC being unsupported-->
<!-- 	because it's no longer true.-->
<!-- -->
<!-- 	(def,8443,R1.1}-->
<!-- -->
<!-- 	Removed listing of dce_error_inq_text() from list of-->
<!-- 	DCE RPC routines because it's moving to man3dce.-->
<!-- -->
<!-- 	Fixed all documentation references to use macros defined in bookdefs.mac.-->
<!-- 	[1994/04/13  19:15:32  zahn]-->
<!-- -->
<!-- Revision 1.1.2.1  1994/04/11  20:37:03  rom-->
<!-- 	{def, 10326, R1.1}-->
<!-- 	Incorporate a later version of intro.3rpc.-->
<!-- 	[1994/04/11  20:00:20  rom]-->
<!-- -->
<!-- 	{def, 10326, R1.1}-->
<!-- 	Rename intro.3rpc to rpc_intro.3rpc.-->
<!-- 	[1994/04/11  19:49:52  rom]-->
<!-- -->
<!---->
<!-- (c) Copyright 1991, Open Software Foundation, Inc.  ALL RIGHTS RESERVED-->
<!--   HISTORY COMMENTS:-->
<!---->
<!--   DATE:                            COMMENT:-->
<!---->
<!--	Mon Nov 11, 1991                 Initial file submission to HP-->
<!--                                    for final integration at IBM.-->
<!--                                   -->
<!---->
<!-- ********************************************************************-->
<!-- Copyright (c) 1991 Hewlett-Packard Co. and Digital Equipment Corp. *-->
<!-- All rights reserved.                                               *-->
<!-- ********************************************************************-->
<!-- .cS-->
<!-- .nr H1 1  - Commented out because it undesirably reset a chapter counter.-->
<!-- .cE-->
<RefSect1>
<Title>Description</Title>
<Para>This introduction gives general information about the DCE RPC application
programming interface (API) and
an overview of the following parts of the DCE RPC API runtime:
<IndexTerm Id="DCEADR.MAN199.indx.1">
<Primary>API overview</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.2">
<Primary>Application Programming Interface</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.3">
<Primary>DCE RPC Application Programming Interface</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.4">
<Primary>RPC</Primary>
<Secondary>Application Programming Interface</Secondary>
</IndexTerm>
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para>Runtime services
</Para>
</ListItem>
<ListItem>
<Para>Environment variables
</Para>
</ListItem>
<ListItem>
<Para>Data types and structures
</Para>
</ListItem>
<ListItem>
<Para>Permissions required
</Para>
</ListItem>
<ListItem>
<Para>Frequently used routine arguments
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<RefSect2>
<Title>General Information</Title>
<Para>The following subsections contain
topics, beyond those directly related to the RPC API,
that application programmers need to know.
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term>IDL-to-C Mappings</Term>
<ListItem>
<Para>The Interface Definition Language (IDL) compiler converts an
interface definition into output files.  The <Filename MoreInfo="RefEntry">rpc_intro(1rpc)</Filename>
reference page in the
<!--\*EOSF DCE Command Reference\*O-->
&DCEAr;
contains a summary of the <Literal>idl</Literal> command, which
invokes the IDL compiler.
<IndexTerm Id="DCEADR.MAN199.indx.5">
<Primary><Literal>idl</Literal> command</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.6">
<Primary>commands</Primary>
<Secondary><Literal>idl</Literal></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.7">
<Primary>IDL compiler</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.8">
<Primary>Interface Definition Language compiler</Primary>
</IndexTerm></Para>
<Para>Additional information about the IDL compiler appears in the following table,
which shows the IDL base types and the IDL-to-C mappings.
<IndexTerm Id="DCEADR.MAN199.indx.9">
<Primary>IDL base types</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.10">
<Primary>IDL-to-C mappings</Primary>
</IndexTerm>
<!--  *****************-->
<!-- WRITER'S NOTE: The remainder of this section, beginning with-->
<!-- The following table lists the IDL base data type specifiers.-->
<!-- is shared with the rpc_intro(1rpc) reference page.-->
<!-- Changes to either copy of the text apply to both copies.-->
<!--  *****************-->
</Para>
<Para>The following table lists the IDL base data type specifiers.
Where applicable, the table shows the size of the corresponding
transmittable type and the type macro emitted by the IDL compiler for
resulting declarations.
<IndexTerm Id="DCEADR.MAN199.indx.11">
<Primary><Literal>idl_</Literal> macros</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.12">
<Primary>macros</Primary>
<Secondary><Literal>idl_</Literal></Secondary>
</IndexTerm></Para>
<Para><!-- .TB "Base Data Type Specifiers\(emrpc_intro(3rpc)"-->
</Para>
<InformalTable Frame="all" Remap="center" Orient="Port">
<TGroup Rowsep="0" Colsep="0" Cols="5">
<ColSpec Rowsep="1" Colsep="1" Align="Center" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Colsep="1" Align="Center" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col3" Colnum="3">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col4" Colnum="4">
<ColSpec Rowsep="1" Align="Left" Colwidth="1*" Colname="col5" Colnum="5">
<TBody>
<Row>
<Entry Rowsep="1" Colsep="0" Namest="col1" Nameend="col5"><Literal>Base Data Type Specifiers&mdash;rpc_intro(3rpc)</Literal></Entry>
<Entry Rowsep="1"><!-- WARNING: ghost column #6: -->
<!-- WARNING: ghost column #7: -->
<!-- WARNING: ghost column #8: -->
</Entry>
</Row>
<Row>
<Entry Colsep="0"></Entry>
<Entry Colsep="0"><Literal>Specifier</Literal></Entry>
<Entry></Entry>
<Entry></Entry>
<Entry><Literal>Type Macro</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1" Colsep="0"><Literal>(sign)</Literal></Entry>
<Entry Rowsep="1" Colsep="0"><Literal>(size)</Literal></Entry>
<Entry Rowsep="1"><Literal>(type)</Literal></Entry>
<Entry Rowsep="1"><Literal>Size</Literal></Entry>
<Entry Rowsep="1"><Literal>Emitted by idl</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry><Literal>small</Literal></Entry>
<Entry><Literal>int</Literal></Entry>
<Entry>8 bits</Entry>
<Entry><Literal>idl_small_int</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry><Literal>short</Literal></Entry>
<Entry><Literal>int</Literal></Entry>
<Entry>16 bits</Entry>
<Entry><Literal>idl_short_int</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry><Literal>long</Literal></Entry>
<Entry><Literal>int</Literal></Entry>
<Entry>32 bits</Entry>
<Entry><Literal>idl_long_int</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry><Literal>hyper</Literal></Entry>
<Entry><Literal>int</Literal></Entry>
<Entry>64 bits</Entry>
<Entry><Literal>idl_hyper_int</Literal></Entry>
</Row>
<Row>
<Entry><Literal>unsigned</Literal></Entry>
<Entry><Literal>small</Literal></Entry>
<Entry><Literal>int</Literal></Entry>
<Entry>8 bits</Entry>
<Entry><Literal>idl_usmall_int</Literal></Entry>
</Row>
<Row>
<Entry><Literal>unsigned</Literal></Entry>
<Entry><Literal>short</Literal></Entry>
<Entry><Literal>int</Literal></Entry>
<Entry>16 bits</Entry>
<Entry><Literal>idl_ushort_int</Literal></Entry>
</Row>
<Row>
<Entry><Literal>unsigned</Literal></Entry>
<Entry><Literal>long</Literal></Entry>
<Entry><Literal>int</Literal></Entry>
<Entry>32 bits</Entry>
<Entry><Literal>idl_ulong_int</Literal></Entry>
</Row>
<Row>
<Entry><Literal>unsigned</Literal></Entry>
<Entry><Literal>hyper</Literal></Entry>
<Entry><Literal>int</Literal></Entry>
<Entry>64 bits</Entry>
<Entry><Literal>idl_uhyper_int</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry></Entry>
<Entry><Literal>float</Literal></Entry>
<Entry>32 bits</Entry>
<Entry><Literal>idl_short_float</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry></Entry>
<Entry><Literal>double</Literal></Entry>
<Entry>64 bits</Entry>
<Entry><Literal>idl_long_float</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry></Entry>
<Entry><Literal>char</Literal></Entry>
<Entry>8 bits</Entry>
<Entry><Literal>idl_char</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry></Entry>
<Entry><Literal>boolean</Literal></Entry>
<Entry>8 bits</Entry>
<Entry><Literal>idl_boolean</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry></Entry>
<Entry><Literal>byte</Literal></Entry>
<Entry>8 bits</Entry>
<Entry><Literal>idl_byte</Literal></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry></Entry>
<Entry><Literal>void</Literal></Entry>
<Entry>&mdash;</Entry>
<Entry><StructName Role="typedef">idl_void_p_t</StructName></Entry>
</Row>
<Row>
<Entry></Entry>
<Entry></Entry>
<Entry><StructName Role="typedef">handle_t</StructName></Entry>
<Entry>&mdash;</Entry>
<Entry><Literal>&mdash;</Literal></Entry>
</Row>
</TBody>
</TGroup>
</InformalTable>
<Para>Note that you can use the <Literal>idl_</Literal> macros in the code you write for
an application to ensure that your type declarations are consistent
with those in the stubs, even when the application is ported to
another platform.  The <Literal>idl_</Literal> macros are especially useful when
passing constant values to RPC calls.  For maximum portability, all
constants passed to RPC calls declared in your network interfaces
should be cast to the appropriate type because the size of integer
constants (like the size of the <Literal>int</Literal> data type) is unspecified in
the C language.
</Para>
<Para>The <Literal>idl_</Literal> macros are defined in <Filename>dce/idlbase.h</Filename>, which
is included by header files that the IDL compiler generates.
<IndexTerm Id="DCEADR.MAN199.indx.13">
<Primary><Literal>idlbase.h</Literal></Primary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Management Commands for Programmers</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.14">
<Primary>programmer commands</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.15">
<Primary>RPC</Primary>
<Secondary>management commands</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.16">
<Primary>DCE RPC management commands</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.17">
<Primary>commands</Primary>
<Secondary>programmer</Secondary>
</IndexTerm>
<Para>In addition to the <Literal>idl</Literal> command for programmers, DCE RPC provides
two management commands
for the RPC control program and the DCE host daemon, as follows:
</Para>
<ItemizedList>
<ListItem>
<Para>The <Literal>rpccp</Literal> control program
accesses the RPC control program (RPCCP).  This
program provides a set of commands for accessing the
operations of the RPC Name Service Interface (NSI).
RPCCP also supports showing the elements of the local endpoint map and
removing elements from it.
<IndexTerm Id="DCEADR.MAN199.indx.18">
<Primary><Literal>rpccp</Literal> command</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.19">
<Primary>commands</Primary>
<Secondary><Literal>rpccp</Literal></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.20">
<Primary>commands</Primary>
<Secondary>management</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.21">
<Primary>management commands</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.22">
<Primary>RPC</Primary>
<Secondary>control program</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.23">
<Primary>control program</Primary>
<Secondary>RPC</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.24">
<Primary>RPC</Primary>
<Secondary>name service interface operations</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.25">
<Primary>NSI operations</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.26">
<Primary>name service interface operations</Primary>
</IndexTerm></Para>
<Para><?sml-need 7>You can manage the name service with RPCCP commands
or with DCE RPC runtime routines.  For example, suppose you want to obtain
the members of a group.  You can give the <Literal>show group</Literal> command
to RPCCP or you can write an application program that calls
the following DCE RPC runtime routines:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_ns_group_mbr_inq_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_group_mbr_inq_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_group_mbr_inq_done()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
</ListItem>
<ListItem>
<Para>The <Literal>dced</Literal> command starts the DCE host daemon.
The daemon maintains the local endpoint map for RPC servers and looks
up endpoints for RPC clients.
<IndexTerm Id="DCEADR.MAN199.indx.27">
<Primary><Literal>dced</Literal> command</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.28">
<Primary>commands</Primary>
<Secondary><Literal>dced</Literal></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.29">
<Primary>DCE host</Primary>
<Secondary>daemon</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.30">
<Primary>daemon</Primary>
<Secondary>DCE host</Secondary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<Para>See the &DCEAr; for more information about
these two management commands.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</RefSect2>
<RefSect2>
<Title>Overview of DCE RPC Runtime Services</Title>
<IndexTerm Id="DCEADR.MAN199.indx.31">
<Primary>DCE RPC runtime services</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.32">
<Primary>RPC</Primary>
<Secondary>runtime services</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.33">
<Primary>runtime services, DCE RPC</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.34">
<Primary>services, DCE RPC runtime</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.35">
<Primary>DCE RPC runtime routines</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.36">
<Primary>RPC</Primary>
<Secondary>runtime routines</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.37">
<Primary>runtime routines, DCE RPC</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.38">
<Primary>routines</Primary>
<Secondary>DCE RPC runtime</Secondary>
</IndexTerm>
<Para>The RPC runtime services consist of RPC routines that perform a variety
of operations.
</Para>
<Para>Note that the RPC API is thread safe and synchronous cancel safe (in
the context of POSIX threads).  However, the RPC API is not
asynchronous cancel safe.  For more information about threads and
their cancellation, see the &DCEDk;.
<IndexTerm Id="DCEADR.MAN199.indx.39">
<Primary>threads</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.40">
<Primary>POSIX threads</Primary>
</IndexTerm></Para>
<Para><!--no-op:  l-->
The rest of this overview consists of the following items:
</Para>
<ItemizedList>
<ListItem>
<Para>An explanation of abbreviations in the names of the
RPC runtime routines
</Para>
</ListItem>
<ListItem>
<Para>An alphabetical list of DCE RPC runtime routines.  With each routine
name is its description and the type of application program that most
likely calls the routine. 
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<IndexTerm Id="DCEADR.MAN199.indx.41">
<Primary>abbreviations in routine names</Primary>
</IndexTerm>
<Para><?sml-need 6>An alphabetical list of abbreviations in the names of
the DCE RPC routines follows.
The list can help you remember the names more easily.
For example, consider the routine name <Function>rpc_mgmt_ep_elt_inq_begin()</Function>.
Use the next list to expand the name to ``RPC management endpoint
element inquiry begin,'' which summarizes the description
``Creates an inquiry context for viewing the elements in a local
or remote endpoint map.  (Management).''
</Para>
<VariableList>
<VarListEntry>
<Term><Literal>auth</Literal></Term>
<ListItem>
<Para>authentication, authorization
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>com</Literal></Term>
<ListItem>
<Para>communications
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>cs</Literal></Term>
<ListItem>
<Para>character/code set interoperability
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>dce</Literal></Term>
<ListItem>
<Para>distributed computing environment
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>dflt</Literal></Term>
<ListItem>
<Para>default
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>elt</Literal></Term>
<ListItem>
<Para>element
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>ep</Literal></Term>
<ListItem>
<Para>endpoint
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>exp</Literal></Term>
<ListItem>
<Para>expiration
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>fn</Literal></Term>
<ListItem>
<Para>function
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>id</Literal></Term>
<ListItem>
<Para>identifier
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>idl_es</Literal></Term>
<ListItem>
<Para>IDL encoding services
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>if</Literal></Term>
<ListItem>
<Para>interface
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>inq</Literal></Term>
<ListItem>
<Para>inquiry
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>mbr</Literal></Term>
<ListItem>
<Para>member
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>mgmt</Literal></Term>
<ListItem>
<Para>management
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>ns</Literal></Term>
<ListItem>
<Para>name service
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>protseq</Literal></Term>
<ListItem>
<Para>protocol sequence
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>rgy</Literal></Term>
<ListItem>
<Para>DCE character and code set registry
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>rpc</Literal></Term>
<ListItem>
<Para>remote procedure call
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>stats</Literal></Term>
<ListItem>
<Para>statistics
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>An alphabetical list of the RPC runtime routines follows.
<IndexTerm Id="DCEADR.MAN199.indx.42">
<Primary>routines</Primary>
<Secondary>RPC runtime</Secondary>
</IndexTerm>With each routine name is its description and the type of application
program that most likely calls the routine.
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Function>cs_byte_from_netcs()</Function></Term>
<ListItem>
<Para>Converts international character data from a network code set
to a local code set. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>cs_byte_local_size()</Function></Term>
<ListItem>
<Para>Calculates the necessary buffer size for a code set conversion
from a network code set to a local code set. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>cs_byte_net_size()</Function></Term>
<ListItem>
<Para>Calculates the necessary buffer size for a code set conversion
from a local code set to a network code set. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>cs_byte_to_netcs()</Function></Term>
<ListItem>
<Para>Converts international character data from a local code set
to a network code set. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>dce_cs_loc_to_rgy()</Function></Term>
<ListItem>
<Para>Maps a local name for a code set to a code set value
in the code set registry. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>dce_cs_rgy_to_loc()</Function></Term>
<ListItem>
<Para>Maps a code set value in the code set registry to a
the local name for a code set. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>idl_es_decode_buffer()</Function></Term>
<ListItem>
<Para>Returns a buffer decoding handle. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>idl_es_decode_incremental()</Function></Term>
<ListItem>
<Para>Returns an incremental decoding handle. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>idl_es_encode_dyn_buffer()</Function></Term>
<ListItem>
<Para>Returns a dynamic buffer encoding handle. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>idl_es_encode_fixed_buffer()</Function></Term>
<ListItem>
<Para>Returns a fixed buffer encoding handle. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>idl_es_encode_incremental()</Function></Term>
<ListItem>
<Para>Returns an incremental encoding handle. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>idl_es_handle_free()</Function></Term>
<ListItem>
<Para>Frees an IDL encoding services handle. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>idl_es_inq_encoding_id()</Function></Term>
<ListItem>
<Para>Identifies an application encoding operation. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_copy()</Function></Term>
<ListItem>
<Para>Returns a copy of a binding handle.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_free()</Function></Term>
<ListItem>
<Para>Releases binding handle resources.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_from_string_binding()</Function></Term>
<ListItem>
<Para>Returns a binding handle from a string representation of a
binding handle.  (Client or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_inq_auth_client()</Function></Term>
<ListItem>
<Para>Returns authentication and authorization information from the
binding handle for an authenticated client.  (Server).
<?sml-break><?sml-need 8></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_inq_auth_info()</Function></Term>
<ListItem>
<Para>Returns authentication and authorization information from a
server binding handle.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_inq_object()</Function></Term>
<ListItem>
<Para>Returns the object UUID from a binding handle.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_reset()</Function></Term>
<ListItem>
<Para>Resets a server binding handle so the host remains specified, but the
server instance on that host is unspecified.  (Client or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_server_from_client()</Function></Term>
<ListItem>
<Para>Converts a client binding handle to a server binding handle.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_set_auth_info()</Function></Term>
<ListItem>
<Para>Sets authentication and authorization information into a server
binding handle.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_set_object()</Function></Term>
<ListItem>
<Para>Sets the object UUID value into a server binding handle.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_to_string_binding()</Function></Term>
<ListItem>
<Para>Returns a string representation of a binding handle.  (Client, server,
or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_binding_vector_free()</Function></Term>
<ListItem>
<Para>Frees the memory used
to store a vector and binding handles.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_cs_binding_set_tags()</Function></Term>
<ListItem>
<Para>Places code set tags into a server binding handle.
(Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_cs_char_set_compat_check()</Function></Term>
<ListItem>
<Para>Evaluates character set compatibility between a client and a server.
(Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_cs_eval_with_universal()</Function></Term>
<ListItem>
<Para>Evaluates a server's supported character sets and code sets during
the server binding selection process. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_cs_eval_without_universal()</Function></Term>
<ListItem>
<Para>Evaluates a server's supported character sets and code sets during
the server binding selection process. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_cs_get_tags()</Function></Term>
<ListItem>
<Para>Retrieves code set tags from a binding handle.
(Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ep_register()</Function></Term>
<ListItem>
<Para>Adds to, or replaces, server address information in
the local endpoint map.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ep_register_no_replace()</Function></Term>
<ListItem>
<Para>Adds to server address information in the
local endpoint map.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ep_resolve_binding()</Function></Term>
<ListItem>
<Para>Resolves a partially bound server binding handle into a
fully bound server binding handle.  (Client or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ep_unregister()</Function></Term>
<ListItem>
<Para>Removes server address information from the
local endpoint map.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_if_id_vector_free()</Function></Term>
<ListItem>
<Para>Frees a vector and the interface identifier structures it
contains.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_if_inq_id()</Function></Term>
<ListItem>
<Para>Returns the interface identifier for
an interface specification.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_ep_elt_inq_begin()</Function></Term>
<ListItem>
<Para>Creates an inquiry context for viewing the elements in a local or
remote endpoint map.  (Management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_ep_elt_inq_done()</Function></Term>
<ListItem>
<Para>Deletes the inquiry context for viewing the elements in a local or
remote endpoint map.  (Management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_ep_elt_inq_next()</Function></Term>
<ListItem>
<Para>Returns one element at a time from a local or
remote endpoint map.  (Management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_ep_unregister()</Function></Term>
<ListItem>
<Para>Removes server address information from a local or
remote endpoint map.  (Management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_inq_com_timeout()</Function></Term>
<ListItem>
<Para>Returns the communications timeout value in
a binding handle.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_inq_dflt_protect_level()</Function></Term>
<ListItem>
<?sml-break>
<Para>Returns the default protection level for
an authentication service.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_inq_if_ids()</Function></Term>
<ListItem>
<Para>Returns a vector of interface identifiers of interfaces
a server offers.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_inq_server_princ_name()</Function></Term>
<ListItem>
<?sml-break>
<Para>Returns a server's principal name.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_inq_stats()</Function></Term>
<ListItem>
<Para>Returns RPC runtime statistics.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_is_server_listening()</Function></Term>
<ListItem>
<Para>Tells whether a server is listening for remote procedure
calls.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_set_authorization_fn()</Function></Term>
<ListItem>
<Para>Establishes an authorization function for processing remote calls to
a server's management routines.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_set_cancel_timeout()</Function></Term>
<ListItem>
<Para>Sets the lower bound on the time to wait before timing out after
forwarding a cancel.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_set_com_timeout()</Function></Term>
<ListItem>
<Para>Sets the communications timeout value in a binding handle.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_set_server_stack_size()</Function></Term>
<ListItem>
<Para>Specifies the stack size for each server thread.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_stats_vector_free()</Function></Term>
<ListItem>
<Para>Frees a statistics vector.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_mgmt_stop_server_listening()</Function></Term>
<ListItem>
<Para>Tells a server to stop listening for remote procedure
calls.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_network_inq_protseqs()</Function></Term>
<ListItem>
<Para>Returns all protocol sequences supported by both the RPC runtime and
the operating system.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_network_is_protseq_valid()</Function></Term>
<ListItem>
<Para>Tells whether the specified protocol sequence is supported by both the
RPC runtime and the operating system.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_export()</Function></Term>
<ListItem>
<Para>Establishes a name service database entry with binding handles or
object UUIDs for a server.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_import_begin()</Function></Term>
<ListItem>
<Para>Creates an import context for an
interface and an object in the name service database.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_import_done()</Function></Term>
<ListItem>
<Para>Deletes the import context for searching the name service database.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_import_next()</Function></Term>
<ListItem>
<Para>Returns a binding handle of a compatible server (if found) from the
name service database.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_inq_entry_name()</Function></Term>
<ListItem>
<Para>Returns the name of an entry in the name service database from which
the server binding handle came.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_lookup_begin()</Function></Term>
<ListItem>
<Para>Creates a lookup context for an
interface and an object in the name service database.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_lookup_done()</Function></Term>
<ListItem>
<Para>Deletes the lookup context for searching the name service database.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_lookup_next()</Function></Term>
<ListItem>
<Para>Returns a list of binding handles of one or more compatible servers
(if found) from the name service database.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_select()</Function></Term>
<ListItem>
<Para>Returns a binding handle from a list
of compatible server binding handles.  (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_binding_unexport()</Function></Term>
<ListItem>
<Para>Removes the binding handles for an interface,
or object UUIDs, from an entry in the name service database.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_entry_expand_name()</Function></Term>
<ListItem>
<Para>Expands the name of a name service entry.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_entry_object_inq_begin()</Function></Term>
<ListItem>
<Para>Creates an inquiry context for viewing
the objects of an entry in the name service database.
(Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_entry_object_inq_done()</Function></Term>
<ListItem>
<Para>Deletes the inquiry context for viewing
the objects of an entry in the name service database.
(Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_entry_object_inq_next()</Function></Term>
<ListItem>
<Para>Returns one object at a time from an
entry in the name service database.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_group_delete()</Function></Term>
<ListItem>
<Para>Deletes a group attribute.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_group_mbr_add()</Function></Term>
<ListItem>
<Para>Adds an entry name to a group; if
necessary, creates the entry.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_group_mbr_inq_begin()</Function></Term>
<ListItem>
<Para>Creates an inquiry context for viewing group members.  (Client, server,
or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_group_mbr_inq_done()</Function></Term>
<ListItem>
<Para>Deletes the inquiry context for a group.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_group_mbr_inq_next()</Function></Term>
<ListItem>
<Para>Returns one member name at a time
from a group.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_group_mbr_remove()</Function></Term>
<ListItem>
<Para>Removes an entry name from a group.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_import_ctx_add_eval()</Function></Term>
<ListItem>
<Para>Adds an evaluation routine to an import context.
(Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_binding_unexport()</Function></Term>
<ListItem>
<Para>Removes multiple binding handles, or object UUIDs, from an entry in the
name service database.  (Management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_entry_create()</Function></Term>
<ListItem>
<Para>Creates an entry in the name service database.  (Management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_entry_delete()</Function></Term>
<ListItem>
<Para>Deletes an entry from the name service database.  (Management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_entry_inq_if_ids()</Function></Term>
<ListItem>
<Para>Returns the list of interfaces exported to an entry in
the name service database.
(Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_free_codesets()</Function></Term>
<ListItem>
<Para>Frees a code sets array that has been allocated in memory. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_handle_set_exp_age()</Function></Term>
<ListItem>
<Para>Sets a handle's expiration age for local copies of name service data.
(Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_inq_exp_age()</Function></Term>
<ListItem>
<Para>Returns the application's global expiration age for local copies of
name service data. (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_read_codesets()</Function></Term>
<ListItem>
<Para>Reads the code sets attribute associated with an RPC server entry
in the name service database. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_remove_attribute()</Function></Term>
<ListItem>
<Para>Removes an attribute from an RPC server entry in the name service database.
(Server, management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_set_attribute()</Function></Term>
<ListItem>
<Para>Adds an attribute to an RPC server entry in the name service database.
(Server, management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_mgmt_set_exp_age()</Function></Term>
<ListItem>
<Para>Modifies the application's global expiration age for local
copies of name service data.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_profile_delete()</Function></Term>
<ListItem>
<Para>Deletes a profile attribute.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_profile_elt_add()</Function></Term>
<ListItem>
<Para>Adds an element to a profile.  If necessary, creates the
entry.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_profile_elt_inq_begin()</Function></Term>
<ListItem>
<Para>Creates an inquiry context for viewing the elements in a profile.
(Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_profile_elt_inq_done()</Function></Term>
<ListItem>
<Para>Deletes the inquiry context for a profile.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_profile_elt_inq_next()</Function></Term>
<ListItem>
<Para>Returns one element at a time from a profile.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_ns_profile_elt_remove()</Function></Term>
<ListItem>
<Para>Removes an element from a profile.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_object_inq_type()</Function></Term>
<ListItem>
<Para>Returns the type of an object.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_object_set_inq_fn()</Function></Term>
<ListItem>
<Para>Registers an object inquiry function.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_object_set_type()</Function></Term>
<ListItem>
<Para>Assigns the type of an object.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_protseq_vector_free()</Function></Term>
<ListItem>
<Para>Frees the memory used by a vector and its
protocol sequences.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_rgy_get_codesets()</Function></Term>
<ListItem>
<Para>Gets supported code sets information from the local host.
(Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_rgy_get_max_bytes()</Function></Term>
<ListItem>
<Para>Gets the maximum number of bytes that a code set uses to encode one character.
(Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_inq_bindings()</Function></Term>
<ListItem>
<Para>Returns binding handles for communication
with a server.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_inq_if()</Function></Term>
<ListItem>
<Para>Returns the manager entry point vector registered for an interface.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_listen()</Function></Term>
<ListItem>
<Para>Tells the RPC runtime to listen for remote procedure calls.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_register_auth_info()</Function></Term>
<ListItem>
<Para>Registers authentication information with the RPC runtime.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_register_if()</Function></Term>
<ListItem>
<Para>Registers an interface with the RPC runtime.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_unregister_if()</Function></Term>
<ListItem>
<Para>Unregisters an interface from the RPC runtime.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_use_all_protseqs()</Function></Term>
<ListItem>
<Para>Tells the RPC runtime to use all supported protocol sequences for
receiving remote procedure calls.  (Server).
<?sml-break><?sml-need 8></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_use_all_protseqs_if()</Function></Term>
<ListItem>
<Para>Tells the RPC runtime to use all the
protocol sequences and endpoints specified in the
interface specification for receiving remote procedure calls.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_use_protseq()</Function></Term>
<ListItem>
<Para>Tells the RPC runtime to use the
specified protocol sequence for receiving remote procedure calls.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_use_protseq_ep()</Function></Term>
<ListItem>
<Para>Tells the RPC runtime to use the
specified protocol sequence combined with the
specified endpoint for receiving remote procedure calls.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_server_use_protseq_if()</Function></Term>
<ListItem>
<Para>Tells the RPC runtime to use the
specified protocol sequence combined with the
endpoints in the interface specification
for receiving remote procedure calls.  (Server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_allocate()</Function></Term>
<ListItem>
<Para>Allocates memory within the RPC stub memory management scheme. 
(Usually server, possibly client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_client_free()</Function></Term>
<ListItem>
<Para>Frees memory allocated by the current memory allocation
and freeing mechanism used by the client stubs. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_destroy_client_context()</Function></Term>
<ListItem>
<Para>Reclaims the client memory resources for a context handle, and sets the
context handle to NULL. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_disable_allocate()</Function></Term>
<ListItem>
<Para>Releases resources and allocated memory within the RPC stub memory
management scheme. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_enable_allocate()</Function></Term>
<ListItem>
<Para>Enables the stub memory management environment. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_free()</Function></Term>
<ListItem>
<Para>Frees memory allocated by the <Function>rpc_sm_allocate()</Function> routine.
(Usually server, possibly client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_get_thread_handle()</Function></Term>
<ListItem>
<Para>Gets a thread handle for the stub memory management environment. 
(Usually server, possibly client).
<?sml-break><?sml-need 4></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_set_client_alloc_free()</Function></Term>
<ListItem>
<Para>Sets the memory allocation and freeing mechanism used by the client
stubs. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_set_thread_handle()</Function></Term>
<ListItem>
<Para>Sets a thread handle for the stub memory management environment. 
(Usually server, possibly client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_sm_swap_client_alloc_free()</Function></Term>
<ListItem>
<Para>Exchanges the current memory allocation and freeing mechanism
used by the client stubs with one supplied by the client. (Client).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_string_binding_compose()</Function></Term>
<ListItem>
<Para>Combines the components of a string binding into
a string binding.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_string_binding_parse()</Function></Term>
<ListItem>
<Para>Returns, as separate strings, the components of a
string binding.  (Client or server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>rpc_string_free()</Function></Term>
<ListItem>
<Para>Frees a character string allocated by
the runtime.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>uuid_compare()</Function></Term>
<ListItem>
<Para>Compares two UUIDs and determines their
order.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>uuid_create()</Function></Term>
<ListItem>
<Para>Creates a new UUID.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>uuid_create_nil()</Function></Term>
<ListItem>
<Para>Creates a nil UUID.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>uuid_equal()</Function></Term>
<ListItem>
<Para>Determines if two UUIDs are equal.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>uuid_from_string()</Function></Term>
<ListItem>
<Para>Converts a string UUID to its
binary representation.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>uuid_hash()</Function></Term>
<ListItem>
<Para>Creates a hash value for a UUID.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>uuid_is_nil()</Function></Term>
<ListItem>
<Para>Determines if a UUID is nil.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>uuid_to_string()</Function></Term>
<ListItem>
<Para>Converts a UUID from a binary representation to
a string representation.  (Client, server, or management).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>wchar_t_from_netcs()</Function></Term>
<ListItem>
<Para>Converts international character data from a network code set
to a local code set. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>wchar_t_local_size()</Function></Term>
<ListItem>
<Para>Calculates the necessary buffer size for a code set conversion
from a network code set to a local code set. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>wchar_t_net_size()</Function></Term>
<ListItem>
<Para>Calculates the necessary buffer size for a code set conversion
from a local code set to a network code set. (Client, server).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Function>wchar_t_to_netcs()</Function></Term>
<ListItem>
<Para>Converts international character data from a local code set
to a network code set. (Client, server).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</RefSect2>
<RefSect2>
<Title>Environment Variables</Title>
<Para>The RPC NSI
routines use the following environment variables:
</Para>
<ItemizedList>
<ListItem>
<Para><Literal>RPC_DEFAULT_ENTRY</Literal>
<IndexTerm Id="DCEADR.MAN199.indx.43">
<Primary>environment variables</Primary>
<Secondary><Literal>RPC_DEFAULT_ENTRY</Literal></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.44">
<Primary><Literal>RPC_DEFAULT_ENTRY</Literal></Primary>
</IndexTerm></Para>
<Para>Designates the default entry in
the name service database
that the import and lookup routines use
as the starting point to search for
binding information for a compatible server.
Normally, the starting entry is a profile.
</Para>
<Para>An application that uses a default entry name must
define this environment variable.  The RPC runtime does not provide
a default.
</Para>
<Para>For example, suppose that a client application needs to search
the name service database for a server binding handle.  The application
can use the <Function>rpc_ns_binding_import_begin()</Function> routine as part
of the search.  If so, the application must specify, to the
routine's <Symbol Role="Variable">entry_name</Symbol> parameter, the name of the entry in the
name service database at which to begin the search.
If the search is to begin at the entry that the
<Literal>RPC_DEFAULT_ENTRY</Literal> environment variable specifies, then the
application must specify the value NULL to
parameter <Symbol Role="Variable">entry_name</Symbol> in <Literal>rpc_ns_binding_import_begin()</Literal>.
</Para>
</ListItem>
<ListItem>
<Para><Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal>
<IndexTerm Id="DCEADR.MAN199.indx.45">
<Primary>environment variables</Primary>
<Secondary><Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.46">
<Primary><Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal></Primary>
</IndexTerm></Para>
<Para>Specifies the syntax of the name
provided in the <Literal>RPC_DEFAULT_ENTRY</Literal> environment variable.
In addition, provides the syntax for those
RPC NSI routines that allow a default value for the name syntax argument.
</Para>
<Para>If the <Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal> environment variable is not defined,
the RPC runtime uses the <Literal>rpc_c_ns_syntax_dce</Literal> name syntax.
</Para>
<Para><?sml-need 8>(For the valid name syntaxes in this reference page and for
the valid syntax values, see the table in the
description of the frequently used routine argument <Symbol Role="Variable">name_syntax</Symbol>,
which appears later in this reference page.)
<!-- -->
<!-- -->
<!-- .LI-->
<!-- \*LRPC_DEBUG\*O-->
<!-- .iX "environment variables" "\*LRPC_DEBUG\*O"-->
<!-- .iX "\*LRPC_DEBUG\*O"-->
<!-- .PP-->
<!-- Appears for the sole purpose of telling you not to set it and not to use it.-->
<!-- -->
<!-- -->
</Para>
</ListItem>
</ItemizedList>
<Para>Optionally, each application defines either or both of the first
two environment variables.
The application can change the value of either one, or both,
at any time during runtime.
</Para>
</RefSect2>
<RefSect2>
<Title>RPC Data Types and Structures</Title>
<IndexTerm Id="DCEADR.MAN199.indx.47">
<Primary>RPC</Primary>
<Secondary>data types and structures</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.48">
<Primary>RPC</Primary>
<Secondary>structures and data types</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.49">
<Primary>data types and structures</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.50">
<Primary>structures and data types</Primary>
</IndexTerm>
<Para>The following subsections contain
the data types and structures used by client, server,
and management application programs.
</Para>
<Para>Much of the information in this section is derived from
the &DCEDg;.  You may want to refer
to the appropriate volume of this
book as you read this section.  For example, this section
contains a brief description of a binding handle.  The &DCEDk; 
explains binding handles in detail.
It also explains concepts related to binding handles, such as
binding information and string bindings.
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term>Binding Handle</Term>
<ListItem>
<Para>A binding handle is
a pointer-size opaque variable containing information the RPC runtime
uses to manage binding information.  The RPC runtime uses
binding information
to establish a client/server relationship that allows the execution of
remote procedure calls.
<IndexTerm Id="DCEADR.MAN199.indx.51">
<Primary>binding handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.52">
<Primary>handle</Primary>
<Secondary>binding</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.53">
<Primary>binding information</Primary>
</IndexTerm></Para>
<Para>Based on the context where it is created, a binding handle is
considered a server binding handle or a
client binding handle.
<IndexTerm Id="DCEADR.MAN199.indx.54">
<Primary>binding handle</Primary>
<Secondary>client</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.55">
<Primary>binding handle</Primary>
<Secondary>server</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.56">
<Primary>client binding handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.57">
<Primary>server binding handle</Primary>
</IndexTerm></Para>
<Para>A server binding handle is a reference to the binding information necessary
for a client to establish a relationship with a specific server.  Many
RPC API runtime routines return a server binding handle that you can
use to make a remote procedure call.
</Para>
<Para>A server binding handle refers to several components
of binding information.
One is the network address of a server's host system.
Each server instance has one or more transport addresses (endpoints).
A well-known endpoint is
a stable address on the host, while a dynamic endpoint is an
address that the RPC runtime requests for the server.
Some transport protocols provide fewer well-known endpoints than
dynamic endpoints.
<IndexTerm Id="DCEADR.MAN199.indx.58">
<Primary>endpoint</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.59">
<Primary>endpoint</Primary>
<Secondary>well-known</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.60">
<Primary>endpoint</Primary>
<Secondary>dynamic</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.61">
<Primary>dynamic endpoint</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.62">
<Primary>well-known endpoint</Primary>
</IndexTerm></Para>
<Para>If binding information contains an endpoint,
the corresponding binding handle is a fully bound binding handle.  If the
information lacks an endpoint, the binding handle is
a partially bound binding handle.
<IndexTerm Id="DCEADR.MAN199.indx.63">
<Primary>binding handle</Primary>
<Secondary>fully bound</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.64">
<Primary>binding handle</Primary>
<Secondary>partially bound</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.65">
<Primary>fully bound binding handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.66">
<Primary>partially bound binding handle</Primary>
</IndexTerm></Para>
<Para><?sml-need 8>The RPC runtime creates and provides a client binding handle to a called
remote procedure as the
<StructName Role="typedef">handle_t</StructName> parameter.  The client binding handle contains information
about the calling client.
A client binding handle cannot be used to make a remote procedure call.
A server uses the client binding handle.
The <Function>rpc_binding_server_from_client()</Function> routine
converts a client binding handle to a server binding handle.  You can use the
resulting server binding handle to make a remote procedure call.
</Para>
<Para>For an explanation of making a remote procedure call with
a partially bound binding handle, see the &DCEDk;.
For an explanation of failures associated with
such a call, see the explanation of status code
<Literal>rpc_s_wrong_boot_time</Literal> in the &DCETg;.
</Para>
<Para>Binding information can contain an object UUID.
The default object UUID associated with a binding handle is a nil UUID.
Clients can obtain a nonnil UUID in various ways, such as from a string
representation of binding information (a string binding), or by
importing it.
</Para>
<Para>The following table contains the RPC runtime routines that operate
on binding handles.  The table also specifies the type of binding
handle, client or server, allowed.
</Para>
<Para><?sml-need 3.5i>
<!--.TB "Client and Server Binding Handles"-->
</Para>
<?sml-indent -1.1i>
<InformalTable Frame="all" Remap="center" Orient="Port">
<TGroup Rowsep="0" Colsep="0" Cols="3">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="2.5*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Rowsep="1" Align="Left" Colwidth="1*" Colname="col3" Colnum="3">
<TBody>
<Row>
<Entry Rowsep="1" Colsep="0" Align="Center" Namest="col1" Nameend="col3"><Literal>Client and Server Binding Handles</Literal></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>Routine</Literal></Entry>
<Entry Rowsep="1"><Literal>Input Argument</Literal></Entry>
<Entry Rowsep="1"><Literal>Output Argument</Literal></Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_copy()</Function></Entry>
<Entry>Server
</Entry>
<Entry>Server
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_free()</Function></Entry>
<Entry>Server
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_from_string_binding()</Function></Entry>
<Entry>None
</Entry>
<Entry>Server
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_inq_auth_client()</Function></Entry>
<Entry>Client
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_inq_auth_info()</Function></Entry>
<Entry>Server
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_inq_object()</Function></Entry>
<Entry>Server or client
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_reset()</Function></Entry>
<Entry>Server
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_server_from_client()</Function></Entry>
<Entry>Client
</Entry>
<Entry>Server
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_set_auth_info()</Function></Entry>
<Entry>Server
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_set_object()</Function></Entry>
<Entry>Server
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_to_string_binding()</Function></Entry>
<Entry>Server or client
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_binding_vector_free()</Function></Entry>
<Entry>Server
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_ns_binding_export()</Function></Entry>
<Entry>Server
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_ns_binding_import_next()</Function></Entry>
<Entry>None
</Entry>
<Entry>Server
</Entry>
</Row>
<Row>
<Entry><Function>rpc_ns_binding_inq_entry_name()</Function></Entry>
<Entry>Server
</Entry>
<Entry>None
</Entry>
</Row>
<Row>
<Entry><Function>rpc_ns_binding_lookup_next()</Function></Entry>
<Entry>None
</Entry>
<Entry>Server
</Entry>
</Row>
<Row>
<Entry><Function>rpc_ns_binding_select()</Function></Entry>
<Entry>Server
</Entry>
<Entry>Server
</Entry>
</Row>
<Row>
<Entry><Function>rpc_server_inq_bindings()</Function></Entry>
<Entry>None
</Entry>
<Entry>Server
</Entry>
</Row>
</TBody>
</TGroup>
</InformalTable>
<?sml-indent +1.1i>
<Para>If the input argument type is
only a client or only a server, the routines return the status code
<Literal>rpc_s_wrong_kind_of_binding</Literal> when an application provides the incorrect
binding handle type.
</Para>
<Para>An application can share a single binding handle across multiple
threads of execution.  The RPC runtime, instead of the application,
manages binding handle concurrency control across concurrent remote
procedure calls that use a single binding handle.  However, the
client application has responsibility for binding handle concurrency
control for operations that read or modify a binding handle.  
</Para>
<Para><?sml-need 8>The related
routines are as follows:
<IndexTerm Id="DCEADR.MAN199.indx.67">
<Primary>threads</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.68">
<Primary>binding handle</Primary>
<Secondary>concurrency control</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.69">
<Primary>concurrency control</Primary>
</IndexTerm>
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_binding_free()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_binding_reset()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_binding_set_auth_info()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_binding_set_object()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_resolve_binding()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_mgmt_set_com_timeout()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>For example, suppose an application shares a binding handle across two
threads of execution and it resets the binding handle endpoint in one of
the threads (by calling <Function>rpc_binding_reset()</Function>).
The binding handle in the other thread is then
also reset.  Similarly, freeing the binding handle in one thread
(by calling <Function>rpc_binding_free()</Function>) frees the
binding handle in the other thread.
</Para>
<Para>If you do not want this effect, your application can create a
copy of a binding handle by calling <Function>rpc_binding_copy()</Function>.
An operation on one binding handle then has no effect on
the second binding handle.
</Para>
<Para>Clients and servers can access and set object UUIDs by using
<Function>rpc_binding_inq_object()</Function> and
<Function>rpc_binding_set_object()</Function>.
</Para>
<Para>Routines requiring a binding handle as an argument show a data type of
<StructName Role="typedef">rpc_binding_handle_t</StructName>.  Binding handle arguments are passed
by value.
<IndexTerm Id="DCEADR.MAN199.indx.70">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">rpc_binding_handle_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.71">
<Primary><StructName Role="typedef">rpc_binding_handle_t</StructName> data type</Primary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Binding Vector</Term>
<ListItem>
<Para>The binding vector data structure contains a list of binding handles
over which a server application can receive remote procedure calls.
<IndexTerm Id="DCEADR.MAN199.indx.72">
<Primary>binding vector</Primary>
</IndexTerm></Para>
<Para>The binding vector contains a count member (<Symbol Role="Variable">count</Symbol>), followed by
an array of binding handle (<Symbol Role="Variable">binding_h</Symbol>) elements.
</Para>
<Para>The C language representation of a binding vector is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>typedef struct {
               unsigned32    count;
               rpc_binding_handle_t  binding_h[1];
               } rpc_binding_vector_t;
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The RPC runtime creates binding handles when a server application registers
protocol sequences.  To obtain a binding vector, a server application calls the
<Function>rpc_server_inq_bindings()</Function> routine.
</Para>
<Para><?sml-need 8>A client application obtains a binding vector of compatible servers from the
name service database by calling the routine
<Function>rpc_ns_binding_lookup_next()</Function>.
</Para>
<Para>In both routines, the RPC runtime allocates memory
for the binding vector.  An application calls the
<Function>rpc_binding_vector_free()</Function> routine to free the binding vector.
</Para>
<Para>An application, when it is finished with an individual binding handle
in a binding vector, frees the binding handle by calling
<Function>rpc_binding_free()</Function>.  This routine also sets the
corresponding pointer in the binding vector to NULL.
</Para>
<Para>Note that you should not decrement the <Symbol Role="Variable">count</Symbol> field in a
binding vector structure when you call the <Function>rpc_binding_free()</Function> routine to
free an individual binding handle.
</Para>
<Para>The following routines require a binding vector and show an
argument data type of <StructName Role="typedef">rpc_binding_vector_t</StructName>:
<IndexTerm Id="DCEADR.MAN199.indx.73">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">rpc_binding_vector_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.74">
<Primary><StructName Role="typedef">rpc_binding_vector_t</StructName> data type</Primary>
</IndexTerm>
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_binding_vector_free()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_register()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_register_no_replace()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_unregister()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_export()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_lookup_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_select()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_inq_bindings()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Boolean</Term>
<ListItem>
<Para>Routines that require a Boolean-valued argument or return a Boolean value
show a data type of <Literal>boolean32</Literal>.  DCE RPC provides the
integer constants TRUE (1) and FALSE (0)
for use as Boolean values.
<IndexTerm Id="DCEADR.MAN199.indx.75">
<Primary>data types</Primary>
<Secondary><Literal>boolean32</Literal></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.76">
<Primary><Literal>boolean32</Literal> data type</Primary>
</IndexTerm>
<!-- place after boolean32 definition-->
<IndexTerm Id="DCEADR.MAN199.indx.77">
<Primary>data types</Primary>
<Secondary><Literal>rpc_cs_c_set_t*O</Literal></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.78">
<Primary><Replaceable>rpc_cs_c_set_t</Replaceable> data type</Primary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Code Set</Term>
<ListItem>
<Para>A code set is a mapping of the members of a character
set to specific numeric code values.  Different code
sets use different numeric code values to represent
the same character.  In general, operating systems
use string names to refer to the code sets that the
system supports.  It is common for different operating
systems to use different string names to refer to
the same code set. 
</Para>
<Para><?sml-need 8>Distributed applications that run in a network of heterogeneous
operating systems need to be able to identify the character sets and
code sets that client and server machines are using
to avoid losing data during communications between each other.
</Para>
<Para>DCE RPC supports transparent automatic conversion for
characters that are members of the DCE Portable Character Set (DCE PCS)
and which are encoded in the ASCII and U.S. EBCDIC code sets.
The RPC runtime automatically converts DCE PCS characters encoded
in ASCII or U.S. EBCDIC, if necessary, when they are passed over the 
network between client and server.
</Para>
<Para>DCE RPC applications that need to transfer character data
that is outside the DCE PCS character set and ASCII and U.S.
EBCDIC encodings (international characters) can use special
IDL constructs and a set of DCE RPC routines to set up their
applications so that they can pass this international character
data with minimal or no loss between client and server applications.
An example of such an application would be one that used European,
Chinese, or Japanese characters mapped to EUC, Big5, or SJIS encodings.
Together, the IDL constructs and the DCE RPC routines provide
a method of automatic code set conversion for applications
that transfer international character data in heterogeneous code
set environments. 
</Para>
<Para>DCE provides a mechanism to uniquely identify a code set;
this mechanism is the code set registry.  The code set
registry assigns a unique identifier to each character
set and code set.  Because the registry provides code set
identifiers that are consistent across a network of heterogeneous
operating systems, it provides a method for clients
and servers in a heterogeneous environment to use to 
identify code sets without having to rely on operating
system-specific string names.
</Para>
<Para>The code set data structure contains a 32-bit hexadecimal
value (<Symbol Role="Variable">c_set</Symbol>) that uniquely identifies
the code set followed by a 16-bit decimal value
(<Symbol Role="Variable">c_max_bytes</Symbol>) that indicates the maximum number of
bytes this code set uses to encode one character in this
code set.
</Para>
<Para>The value for <Symbol Role="Variable">c_set</Symbol> is one of the registered values
in the code set registry.
</Para>
<Para>The following routines require a code set value:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>cs_byte_from_netcs()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>cs_byte_local_size()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>cs_byte_net_size()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>cs_byte_to_netcs()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_cs_loc_to_rgy()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>dce_cs_rgy_to_loc()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_cs_get_tags()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_cs_binding_set_tags()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_rgy_get_max_bytes()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>wchar_t_from_netcs()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>wchar_t_local_size()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>wchar_t_net_size()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>wchar_t_to_netcs()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>In these routines, the code set value shows a data type of <Literal>unsigned32</Literal>.
</Para>
<Para>The RPC stub buffer sizing routines <Symbol Role="Variable">*</Symbol><Literal>_net_size()</Literal> and
<Symbol Role="Variable">*</Symbol><Literal>_local_size</Literal> use the value of <Symbol Role="Variable">c_max_bytes</Symbol> to calculate
the size of a buffer for code set conversion.
</Para>
<Para>The C language representation of a code set structure is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>typedef struct {
        long            c_set;
        short           c_max_bytes;
} rpc_cs_c_set_t;
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>The code set data structure is a member of the code sets array.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Code Sets Array</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.79">
<Primary>data types</Primary>
<Secondary><Literal>rpc_codeset_mgmt_t*O</Literal></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.80">
<Primary><StructName Role="typedef">rpc_codeset_mgmt_t</StructName> data type</Primary>
</IndexTerm>
<Para>The code sets array contains the list of the code sets that
a client or server supports.  The structure consists of a version number
member (<Symbol Role="Variable">version</Symbol>), followed by a count member (<Symbol Role="Variable">count</Symbol>), followed
by an array of code set data structures (<Symbol Role="Variable">rpc_cs_c_set_t</Symbol>).
This array is declared to be a conformant array so that
its size will be determined at runtime.  The <Symbol Role="Variable">count</Symbol> member
indicates the number of code sets contained in the array.
</Para>
<Para>The first element in the code sets array represents
the client or server process's local code set.
</Para>
<Para><?sml-need 6>The second element through the <Symbol Role="Variable">n</Symbol>th element
represents one or more intermediate code sets that
the process can use to transmit character data over
the network.  Client or server processes can convert
into an intermediate code set when their host system does
not provide a converter for the other's local code set but
does provide a converter for the intermediate code set.
</Para>
<Para>DCE RPC routines for character/code sets compatibility
evaluation and code set conversion support one intermediate
code set, which is the ISO 10646 Universal character/code set.
Consequently, DCE requires host systems running applications
that transfer international characters to provide converters
for this code set.
</Para>
<Para>System administrators for machines in internationalized
DCE cells (that is, cells of machines that run applications that
use the DCE character/code sets compatibility evaluation
and conversion functionality) and who want to use
other intermediate code sets can run the <Literal>csrc</Literal> utility
and specify that their intermediate code set(s) be used in preference
to ISO 10646.
</Para>
<Para>The remaining elements in the array represent other
code sets that the process's host supports (that is,
code sets for which the system provides converters).
</Para>
<Para>The C language representation of a code set structure is
as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>typedef struct rpc_codeset_mgmt_t {
        unsigned32      version;
        long            count;
        [size_is(count)] rpc_cs_c_set_t codesets[];
} rpc_codeset_mgmt_t, *rpc_codeset_mgmt_p_t;
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>Client and server applications and DCE RPC routines for automatic
code set conversion obtain a code sets array by calling the
routine <Function>rpc_rgy_get_codesets()</Function>.  Server applications
user the code sets array as input to the
<Function>rpc_ns_mgmt_set_attribute()</Function> routine, which registers
their supported code sets in the name service database.
Client applications look up a server's supported code sets in
the name service database by calling the routine
<Function>rpc_ns_mgmt_read_codesets()</Function> and then use their
code sets array to evaluate their supported code
sets against the code sets that the server supports.
</Para>
<Para><?sml-need 6>The following DCE RPC routines require a code sets array
and show an argument data type of <StructName Role="typedef">rpc_codeset_mgmt_t</StructName>:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_ns_mgmt_read_codesets()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_rgy_get_codesets()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>Server applications that use <Function>rpc_ns_mgmt_set_attribute()</Function>
to register their supported code sets in the name service database
also specify the code sets array, but show an argument data type
of <Literal>void</Literal>.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Conversion Type</Term>
<ListItem>
<Para>The conversion type data structure is an enumerated type that RPC
stub buffer sizing routines return to indicate whether
character data conversion is necessary and whether or not existing
storage is sufficient for the stub to store the results of the
conversion.  The conversion type can be one of the following values:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>idl_cs_no_convert</Literal></Term>
<ListItem>
<Para>No code set conversion is required.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>idl_cs_in_place_convert</Literal></Term>
<ListItem>
<Para>Code set conversion can be performed in a single storage area.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>idl_cs_new_buffer_convert</Literal></Term>
<ListItem>
<Para>The converted data must be written to a new storage area.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>The C language representation of a conversion type structure is
as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>typedef enum {
        idl_cs_no_convert,
        idl_cs_in_place_convert,
        idl_cs_new_buffer_convert,
} idl_cs_convert_t;
</UserInput></ProgramListing></Para>
</InformalExample>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Endpoint Map Inquiry Handle</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.81">
<Primary>endpoint map inquiry handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.82">
<Primary>handle</Primary>
<Secondary>endpoint map inquiry</Secondary>
</IndexTerm>
<Para>An endpoint map inquiry handle is a pointer-size opaque variable
containing information the RPC runtime uses to access the elements in
a local or remote endpoint map.  The description of the
<Function>rpc_ep_register()</Function> routine lists the contents of an element.
</Para>
<Para><?sml-need 6>The following routines require an endpoint map inquiry handle and
show an argument data type of <StructName Role="typedef">rpc_ep_inq_handle_t</StructName>:
<IndexTerm Id="DCEADR.MAN199.indx.83">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">rpc_ep_inq_handle_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.84">
<Primary><StructName Role="typedef">rpc_ep_inq_handle_t</StructName> data type</Primary>
</IndexTerm>
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_mgmt_ep_elt_inq_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_mgmt_ep_elt_inq_done()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_mgmt_ep_elt_inq_next()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Global Name</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.85">
<Primary>global name</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.86">
<Primary>name</Primary>
<Secondary>global</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.87">
<Primary>cell name</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.88">
<Primary>name</Primary>
<Secondary>cell</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.89">
<Primary>cell-relative name</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.90">
<Primary>name</Primary>
<Secondary>cell-relative</Secondary>
</IndexTerm>
<Para>The NSI uses global names for the names of
name service entries.  A global name includes both a cell name and
a cell-relative name composed of a directory pathname and a leaf name.
For a description of global names, see the &DCEAi;.
The cell name is assigned to a cell root at its creation.  When you specify
only a cell-relative name to an NSI operation, the NSI automatically
expands the name into a global name by inserting the local cell name.
Thus, the name of a member in a group or in a profile element is always
stored as a global name.  When returning the name of a name service entry
or a member, NSI operations return global names.
</Para>
<Para>For example, even when you specify a cell-relative name as
the <Symbol Role="Variable">member_name</Symbol> parameter to routine <Function>rpc_ns_group_mbr_add()</Function>,
when you read that group member (by calling
<Function>rpc_ns_group_mbr_inq_next()</Function>), you will receive the corresponding
global name.
<IndexTerm Id="DCEADR.MAN199.indx.91">
<Primary>IDL encoding service handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.92">
<Primary>handle</Primary>
<Secondary>IDL encoding service</Secondary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>IDL Encoding Service Handle</Term>
<ListItem>
<Para>An IDL encoding service handle is a pointer-size opaque variable
that points to functions that control how data encoding or decoding
is performed.  The following routines return an IDL encoding service
handle and show an argument data type of <StructName Role="typedef">idl_es_handle_t</StructName>:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>idl_es_encode_incremental()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>idl_es_decode_buffer()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>idl_es_decode_incremental()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>idl_es_encode_dyn_buffer()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>idl_es_encode_fixed_buffer()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>The <Function>idl_es_handle_free()</Function> and <Function>idl_es_inq_encoding_id()</Function>
routines require an IDL encoding service handle.
</Para>
<Para><?sml-need 5>Note that in order to use the IDL encoding services, you must include
a header file that has been generated for an application that has used
the <Literal>encode</Literal> and <Literal>decode</Literal> ACF attributes on one or more of its
operations.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Interface Handle and Specification</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.93">
<Primary>interface handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.94">
<Primary>interface specification</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.95">
<Primary>handle</Primary>
<Secondary>interface</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.96">
<Primary>specification</Primary>
<Secondary>interface</Secondary>
</IndexTerm>
<Para>An interface handle is a pointer-size opaque variable containing
information the RPC runtime uses to access the interface specification data
structure.
</Para>
<Para>The DCE IDL compiler automatically creates an interface specification data
structure from each IDL file and creates a global variable of type
<StructName Role="typedef">rpc_if_handle_t</StructName> for the interface specification.
</Para>
<Para>The DCE IDL compiler places an interface handle declaration
in the generated <Symbol Role="Variable">interface-name</Symbol><Literal>.h</Literal> file.  The compiler generates
this header file for each interface.
</Para>
<Para>Routines requiring the interface handle as an argument show a data type
of <StructName Role="typedef">rpc_if_handle_t</StructName>.
</Para>
<Para>The form of each interface handle name is as follows:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para>For the client:
</Para>
<Para><Symbol Role="Variable">if-name</Symbol><Literal>_v</Literal><Symbol Role="Variable">major-version</Symbol><Literal>_</Literal><Symbol Role="Variable">minor-version</Symbol><Literal>_c_ifspec</Literal>
</Para>
</ListItem>
<ListItem>
<Para>For the server:
</Para>
<Para><Symbol Role="Variable">if-name</Symbol><Literal>_v</Literal><Symbol Role="Variable">major-version</Symbol><Literal>_</Literal><Symbol Role="Variable">minor-version</Symbol><Literal>_s_ifspec</Literal>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>where
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para>The <Symbol Role="Variable">if-name</Symbol> variable is the interface identifier
specified in the IDL file.
</Para>
</ListItem>
<ListItem>
<Para>The <Symbol Role="Variable">major-version</Symbol> variable is the interface's major-version
number specified in the IDL file.
</Para>
</ListItem>
<ListItem>
<Para>The <Symbol Role="Variable">minor-version</Symbol> variable is the interface's minor-version
number specified in the IDL file.
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>An example is <Literal>notes_v1_2_c_ifspec</Literal>
</Para>
<Para>The maximum combined length of the interface identifier
and interface version number is 19 characters.
</Para>
<Para>Since the major-version and minor-version numbers must each be at
least 1 character, the interface name can be no more than 17
characters.  This limits the interface handle name to 31 or
fewer characters.
</Para>
<Para>No concurrency control is required for interface handles.
</Para>
<Para>The following routines require an interface handle and show an
argument data type of <StructName Role="typedef">rpc_if_handle_t</StructName>:
<IndexTerm Id="DCEADR.MAN199.indx.97">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">rpc_if_handle_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.98">
<Primary><StructName Role="typedef">rpc_if_handle_t</StructName> data type</Primary>
</IndexTerm>
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_ep_register()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_register_no_replace()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_resolve_binding()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_unregister()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_if_inq_id()</Function>  
<!-- .LI-->
<!-- \*Lrpc_if_register_auth_info(\|)\*O-->
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_export()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_import_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_lookup_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_unexport()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_inq_if()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_register_if()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_unregister_if()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_use_all_protseqs_if()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_use_protseq_if()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Interface Identifier</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.99">
<Primary>interface identifier</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.100">
<Primary>identifier</Primary>
<Secondary>interface</Secondary>
</IndexTerm>
<Para>The interface identifier (id) data structure contains
the interface UUID and major-version and
minor-version numbers of an interface.
The interface identifier is a subset of the data contained in the
interface specification structure.
<IndexTerm Id="DCEADR.MAN199.indx.101">
<Primary>data structures</Primary>
<Secondary>interface identifier</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.102">
<Primary>interface identifier data structure</Primary>
</IndexTerm></Para>
<Para>The C language representation of an interface identifier structure is
as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>typedef struct {
               uuid_t      uuid;
               unsigned16  vers_major;
               unsigned16  vers_minor;
               } rpc_if_id_t;
</UserInput></ProgramListing></Para>
</InformalExample>
<Para><?sml-need 5>Routines that require an interface identifier structure show a data type
of <Literal>rpc_if_id_t</Literal>.  In those routines, the application is
responsible for providing memory for the structure.
<IndexTerm Id="DCEADR.MAN199.indx.103">
<Primary>data types</Primary>
<Secondary><Replaceable>rpc_if_id_t</Replaceable></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.104">
<Primary><Replaceable>rpc_if_id_t</Replaceable> data type</Primary>
</IndexTerm></Para>
<Para>The <Function>rpc_if_inq_id()</Function>
routine returns the interface identifier from an
interface specification.
The following routines require an interface identifier:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_mgmt_ep_elt_inq_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_mgmt_ep_elt_inq_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_mgmt_ep_unregister()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_mgmt_binding_unexport()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_profile_elt_add()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_profile_elt_inq_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_profile_elt_inq_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_profile_elt_remove()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Interface Identifier Vector</Term>
<ListItem>
<Para>The interface identifier vector data structure contains
a list of interfaces offered by a server.
<IndexTerm Id="DCEADR.MAN199.indx.105">
<Primary>data structures</Primary>
<Secondary>interface identifier vector</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.106">
<Primary>interface identifier vector data structure</Primary>
</IndexTerm>The interface identifier vector contains a count member (<Symbol Role="Variable">count</Symbol>),
followed by an array of pointers to interface identifiers (<Literal>rpc_if_id_t</Literal>).
</Para>
<Para>The C language representation of an interface identifier vector is
as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>typedef struct {
               unsigned32     count;
               rpc_if_id_t    *if_id[1];
               } rpc_if_id_vector_t;
</UserInput></ProgramListing></Para>
</InformalExample>
<IndexTerm Id="DCEADR.MAN199.indx.107">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">rpc_if_id_vector_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.108">
<Primary><StructName Role="typedef">rpc_if_id_vector_t</StructName> data type</Primary>
</IndexTerm>
<Para>The interface identifier vector is a read-only vector.  To obtain a vector of
the interface identifiers registered by a server with the RPC runtime, an
application calls the <Function>rpc_mgmt_inq_if_ids()</Function> routine.  To obtain a
vector of the interface identifiers exported by a server to a
name service database,
an application calls the <Function>rpc_ns_mgmt_entry_inq_if_ids()</Function> routine.
</Para>
<Para>The RPC runtime allocates memory for the
interface identifier vector.  The application
calls the <Function>rpc_if_id_vector_free()</Function> routine to free the interface
identifier vector.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Manager Entry Point Vector</Term>
<ListItem>
<Para>The manager entry point vector (EPV) is an array of pointers to
remote procedures.
<IndexTerm Id="DCEADR.MAN199.indx.109">
<Primary>manager entry point vector</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.110">
<Primary>vector</Primary>
<Secondary>manager entry point</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.111">
<Primary>entry point vector</Primary>
<Secondary>manager</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.112">
<Primary>data structures</Primary>
<Secondary>manager entry point vector</Secondary>
</IndexTerm></Para>
<Para>The DCE IDL compiler automatically generates a manager EPV data type,
into the header file generated by the IDL compiler, for
use in constructing manager EPVs.  The data type is named as follows:
</Para>
<Para><Symbol Role="Variable">if-name</Symbol><Literal>_v</Literal><Symbol Role="Variable">major-version</Symbol><Literal>_</Literal><Symbol Role="Variable">minor-version</Symbol><Literal>_epv_t</Literal>
<IndexTerm Id="DCEADR.MAN199.indx.113">
<Primary>manager entry point vector data type</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.114">
<Primary>data structures</Primary>
<Secondary>manager entry point vector</Secondary>
</IndexTerm></Para>
<Para>where
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para>The <Symbol Role="Variable">if-name</Symbol> variable is the interface identifier specified
in the IDL file.
</Para>
</ListItem>
<ListItem>
<Para>The <Symbol Role="Variable">major-version</Symbol> variable is the interface's major-version
number specified in the IDL file.
</Para>
</ListItem>
<ListItem>
<Para>The <Symbol Role="Variable">minor-version</Symbol> variable is the interface's minor-version
number specified in the IDL file.
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>By default, the DCE IDL compiler automatically creates and initializes
a manager EPV.
DCE IDL creates this EPV assuming that a manager routine of the same
name exists for each procedure in
the interface (as specified in the IDL file).
</Para>
<Para>The DCE IDL compiler can define a client entry point vector
<IndexTerm Id="DCEADR.MAN199.indx.115">
<Primary>client entry point vector</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.116">
<Primary>vector</Primary>
<Secondary>client entry point</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.117">
<Primary>entry point vector</Primary>
<Secondary>client</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.118">
<Primary>data structures</Primary>
<Secondary>client entry point vector</Secondary>
</IndexTerm>with addresses of local routines.  Client applications can call
these routines.  For more information about
client entry point vectors, see the
explanation of the <Literal>&minus;cepv</Literal> argument in the
<Filename MoreInfo="RefEntry">idl(1rpc)</Filename> reference page.
</Para>
<Para>If the server offers multiple implementations of the same interface, the server
must create additional manager EPVs, one for each implementation.  Each EPV
must contain exactly one entry point (address of a function) for each procedure
defined in the IDL file.  The server application declares and initializes one
manager EPV variable of type
<Symbol Role="Variable">if-name</Symbol><Literal>_v</Literal><Symbol Role="Variable">major-version</Symbol><Literal>_</Literal><Symbol Role="Variable">minor-version</Symbol><Literal>_epv_t</Literal>
for each implementation of the interface.
</Para>
<Para>The <Function>rpc_server_register_if()</Function> and <Function>rpc_server_inq_if()</Function> routines
use the manager EPV data type and show the manager EPV argument as having an
<StructName Role="typedef">rpc_mgr_epv_t</StructName> data type.
<IndexTerm Id="DCEADR.MAN199.indx.119">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">rpc_mgr_epv_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.120">
<Primary><StructName Role="typedef">rpc_mgr_epv_t</StructName> data type</Primary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Name Service Handle</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.121">
<Primary>name service handle</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.122">
<Primary>handle</Primary>
<Secondary>name service</Secondary>
</IndexTerm>
<Para>A name service handle is a pointer-size opaque variable
containing information the
RPC runtime uses to return the following RPC data from the
name service database:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para>Server binding handles
</Para>
</ListItem>
<ListItem>
<Para>UUIDs of resources offered by a server
</Para>
</ListItem>
<ListItem>
<Para>Profile members
</Para>
</ListItem>
<ListItem>
<Para>Group members
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>The following routines require a name service handle and
show an argument data type of <StructName Role="typedef">rpc_ns_handle_t</StructName>:
<IndexTerm Id="DCEADR.MAN199.indx.123">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">rpc_ns_handle_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.124">
<Primary><StructName Role="typedef">rpc_ns_handle_t</StructName> data type</Primary>
</IndexTerm>
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_ns_binding_import_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_import_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_import_done()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_lookup_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_lookup_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_lookup_done()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_entry_object_inq_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_entry_object_inq_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_entry_object_inq_done()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_group_mbr_inq_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_group_mbr_inq_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_group_mbr_inq_done()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_profile_elt_inq_begin()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_profile_elt_inq_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_profile_elt_inq_done()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_mgmt_handle_set_exp_age()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>The scope of a name service handle is from a <Symbol Role="Variable">*</Symbol><Literal>_begin()</Literal> routine through
the corresponding <Symbol Role="Variable">*</Symbol><Literal>_done()</Literal> routine.
</Para>
<Para>Applications have responsibility for concurrency control
of name service handles across threads.
<!-- .iX "threads"-->
<IndexTerm Id="DCEADR.MAN199.indx.125">
<Primary>name service handle</Primary>
<Secondary>concurrency control</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.126">
<Primary>concurrency control</Primary>
</IndexTerm><?sml-break><?sml-need 7></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Protocol Sequence</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.127">
<Primary>protocol sequence</Primary>
</IndexTerm>
<Para>A protocol sequence is a character string identifying the network
protocols used to establish a relationship between a client and server.
The protocol sequence contains a set of options that the RPC runtime
must know about.  The following options are in this set:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para>The RPC protocol used for communications
(choices are <Literal>ncacn</Literal> and <Literal>ncadg</Literal>).
</Para>
</ListItem>
<ListItem>
<Para>The format used in the network address supplied in the binding
(choice is <Literal>ip</Literal>).
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo formats,-->
<!-- ** replace the 1 line just before the ".cS" symbol with the following 1 line.-->
<!-- (choices are \*Lip\*O, \*Ldnet\*O, and \*Losi\*O).-->
<!-- DIGITAL_END-->
<!-- .cE-->
</Para>
</ListItem>
<ListItem>
<Para>The transport protocol used for communications
(choices are <Literal>tcp</Literal> and <Literal>udp</Literal>).
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo transport protocols,-->
<!-- ** replace the 1 line just before the ".cS" symbol with the following 1 line.-->
<!-- (choices are \*Ltcp\*O, \*Ludp\*O, \*Lnsp\*O, and \*Ldna\*O).-->
<!-- DIGITAL_END-->
<!-- .cE-->
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>Because only certain combinations of these options are valid (are
useful for interoperation), RPC provides predefined strings
that represent the valid combinations.  RPC applications use only
these strings.
</Para>
<Para>The following table contains predefined strings representing valid
protocol sequences.  In the descriptions NCA is an abbreviation of
Network Computing Architecture.
<IndexTerm Id="DCEADR.MAN199.indx.128">
<Primary>Network Computing Architecture</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.129">
<Primary>protocol sequences</Primary>
<Secondary>valid</Secondary>
</IndexTerm>
<!-- .TB "Valid Protocol Sequences"-->
</Para>
<InformalTable Frame="All" Remap="center" Orient="Port">
<TGroup Rowsep="0" Colsep="0" Cols="2">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Align="Left" Colwidth="1*" Colname="col2" Colnum="2">
<TBody>
<Row>
<Entry Rowsep="1" Colsep="0" Align="Center" Namest="col1" Nameend="col2"><Literal>Valid Protocol Sequences</Literal></Entry>
<Entry Rowsep="1"></Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>Protocol Sequence</Literal></Entry>
<Entry Rowsep="1"><Literal>Description</Literal></Entry>
</Row>
<Row>
<Entry><Literal>ncacn_ip_tcp</Literal></Entry>
<Entry>NCA Connection over Internet Protocol:
Transmission Control Protocol
</Entry>
</Row>
<Row>
<Entry><Literal>ip</Literal> or <Literal>ncadg_ip_udp</Literal></Entry>
<Entry>NCA Datagram over Internet Protocol:
User Datagram Protocol
</Entry>
</Row>
</TBody>
</TGroup>
</InformalTable>
<IndexTerm Id="DCEADR.MAN199.indx.130">
<Primary><Literal>ncacn_ip_tcp</Literal> protocol sequence</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.131">
<Primary><Literal>ip</Literal> protocol sequence</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.132">
<Primary><Literal>ncadg_ip_udp</Literal> protocol sequence</Primary>
</IndexTerm>
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,-->
<!-- ** add here the following 4 lines.-->
<!-- ncacn_dnet_nsp@NCA Connection over DECnet:-->
<!-- @Network Services Protocol (DECnet Phase IV)-->
<!-- ncacn_osi_dna@NCA Connection over Open Systems-->
<!-- @Interconnection: DNA Session Control-->
<!-- @(DECnet Phase V)-->
<!-- DIGITAL_END-->
<!-- .cE-->
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,-->
<!-- ** add here the following 2 lines.-->
<!-- \*Ldds\*O or \*Lncadg_dds\*O@NCA Datagram over Domain Datagram-->
<!-- @Service-->
<!-- DIGITAL_END-->
<!-- .cE-->
<Para>A server application can use a particular protocol sequence only if
the operating system software supports that protocol.
A server chooses to accept remote procedure
calls over some or all of the supported protocol sequences.
</Para>
<Para>Client and server applications can determine if a protocol sequence
is supported by both the RPC runtime and the operating system.  The
applications make this determination by calling
the following routines:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_network_inq_protseqs()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_network_is_protseq_valid()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para><?sml-need 5>The following routines allow server applications to register
protocol sequences with the runtime:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_server_use_all_protseqs()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_use_all_protseqs_if()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_use_protseq()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_use_protseq_ep()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_server_use_protseq_if()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>Those routines requiring a protocol sequence argument show a data type of
<Literal>unsigned_char_t *</Literal>.
<IndexTerm Id="DCEADR.MAN199.indx.133">
<Primary>data types</Primary>
<Secondary><Literal>unsigned_char_t *</Literal></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.134">
<Primary><Literal>unsigned_char_t *</Literal> data type</Primary>
</IndexTerm></Para>
<Para>A client can use the protocol sequence strings to construct a string binding
using the <Function>rpc_string_binding_compose()</Function> routine.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Protocol Sequence Vector</Term>
<ListItem>
<Para>The protocol sequence vector data structure contains a list of
protocol sequences over which the RPC runtime can send or receive
remote procedure calls.
<IndexTerm Id="DCEADR.MAN199.indx.135">
<Primary>data structures</Primary>
<Secondary>protocol sequence vector</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.136">
<Primary>protocol sequence vector data structure</Primary>
</IndexTerm>The protocol sequence vector contains a count member (<Symbol Role="Variable">count</Symbol>),
followed by an array of pointers to protocol sequence strings
(<Symbol Role="Variable">protseq</Symbol>).
</Para>
<Para>The C language representation of a protocol sequence vector is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>typedef struct {
               unsigned32       count;
               unsigned_char_t  *protseq[1];
               } rpc_protseq_vector_t;
</UserInput></ProgramListing></Para>
</InformalExample>
<IndexTerm Id="DCEADR.MAN199.indx.137">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">rpc_protseq_vector_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.138">
<Primary><StructName Role="typedef">rpc_protseq_vector_t</StructName> data type</Primary>
</IndexTerm>
<Para>The protocol sequence vector is a read-only vector.
To obtain a protocol sequence vector, a server application calls the
<Function>rpc_network_inq_protseqs()</Function> routine.  The RPC runtime allocates memory
for the protocol sequence vector.  The server application calls the
<Function>rpc_protseq_vector_free()</Function> routine to free the protocol
sequence vector.
<?sml-break><?sml-need 8></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Statistics Vector</Term>
<ListItem>
<Para>The statistics vector data structure contains
statistics from the RPC runtime on a per address space basis.
<IndexTerm Id="DCEADR.MAN199.indx.139">
<Primary>data structures</Primary>
<Secondary>statistics vector</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.140">
<Primary>statistics vector data structure</Primary>
</IndexTerm>The statistics vector contains a count member (<Symbol Role="Variable">count</Symbol>),
followed by an array of statistics.
Each array element contains an <Literal>unsigned32</Literal> value.  The following
list describes the statistics indexed by the specified constant:
</Para>
<VariableList>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_stats_calls_in</Literal></Term>
<ListItem>
<Para>The number of remote procedure calls received by the runtime.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_stats_calls_out</Literal></Term>
<ListItem>
<Para>The number of remote procedure calls initiated by the runtime.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_stats_pkts_in</Literal></Term>
<ListItem>
<Para>The number of network packets received by the runtime.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Literal>rpc_c_stats_pkts_out</Literal></Term>
<ListItem>
<Para>The number of network packets sent by the runtime.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>The C language representation of a statistics vector is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>typedef struct {
               unsigned32       count;
               unsigned32       stats[1];
               } rpc_stats_vector_t;
</UserInput></ProgramListing></Para>
</InformalExample>
<IndexTerm Id="DCEADR.MAN199.indx.141">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">rpc_stats_vector_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.142">
<Primary><StructName Role="typedef">rpc_stats_vector_t</StructName> data type</Primary>
</IndexTerm>
<Para>To obtain runtime statistics, an application calls the
<Function>rpc_mgmt_inq_stats()</Function> routine.  The RPC runtime allocates memory
for the statistics vector.  The application calls the
<Function>rpc_mgmt_stats_vector_free()</Function> routine to free the statistics vector.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>String Binding</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.143">
<Primary>string binding</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.144">
<Primary>binding</Primary>
<Secondary>string</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.145">
<Primary>binding handle</Primary>
</IndexTerm>
<Para>A string binding contains the character representation of a binding handle.
</Para>
<Para>String bindings are a convenient way of representing portions of a
binding handle.  However, you cannot use string bindings directly to
make remote procedure calls.  You must first call the routine
<Function>rpc_binding_from_string_binding()</Function>, which
converts a string binding to a binding handle.
</Para>
<Para>A string binding does not contain all the information from a
binding handle.  For example, a call to 
<Function>rpc_binding_to_string_binding()</Function> does not translate the
authentication information sometimes associated with a binding handle into
the resulting string binding.
</Para>
<Para>You can begin the development of a distributed application by having its
servers communicate their binding information to clients by using
string bindings.  This communication allows a
server to establish a client/server relationship without using the
local endpoint map or the name service database.
</Para>
<Para><?sml-need 10>In this case, the server calls none of the <Function>rpc_ep_register()</Function>,
<Function>rpc_ep_register_no_replace()</Function>, and <Function>rpc_ns_binding_export()</Function>
routines.  Instead, the server
calls only routine <Function>rpc_server_inq_bindings()</Function> to obtain
a vector of binding handles.  The server obtains binding handles one
at a time from the vector and calls
routine <Function>rpc_binding_to_string_binding()</Function> to convert each binding handle
into a string binding.
The resulting string binding is always fully bound and may
contain a nonnil object UUID. The server then makes some or all of
its string bindings available to clients.  One way is placing
the string bindings in a file to be read by clients or users or both.
Another way is delivering the string bindings to clients or users
by means of a file, mail, or paper.
</Para>
<Para>You can continue the distributed application's development by changing
the application so that servers use the local endpoint map and the
name service database to communicate their binding information.
</Para>
<Para>To find the server, a client obtains a string binding
containing a protocol sequence that the client runtime
supports and, optionally, an object UUID that the client requires.
The client then calls routine <Function>rpc_binding_from_string_binding()</Function> to
convert the string binding into a server binding handle.
</Para>
<Para>Other useful routines for working with string bindings are
<Function>rpc_string_binding_compose()</Function>, which creates a string binding
from its component parts, and <Function>rpc_string_binding_parse()</Function>,
which separates a string binding into its component parts.
</Para>
<Para>The two formats of a string binding follow.  The four fields
represent
the object UUID, RPC protocol sequence, network address, and
endpoint and network
options of the binding.
A delimiter character such as <Literal>@</Literal> (at sign) or <Literal>:</Literal> (colon)
separates each field.  A string binding does not contain any whitespace.
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">object-uuid</Symbol> <Literal>@</Literal> <Symbol Role="Variable">rpc-prot-seq</Symbol> <Literal>:</Literal> <Symbol Role="Variable">nw-addr</Symbol> [<Symbol Role="Variable">endpoint</Symbol><Literal>, </Literal><Symbol Role="Variable">opt</Symbol> ...]
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>or
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Symbol Role="Variable">object-uuid</Symbol> <Literal>@</Literal> <Symbol Role="Variable">rpc-prot-seq</Symbol> <Literal>:</Literal> <Symbol Role="Variable">nw-addr</Symbol> [<Symbol Role="Variable">endpoint </Symbol><Literal>= </Literal><Symbol Role="Variable">endpoint</Symbol><Literal>, </Literal><Symbol Role="Variable">opt</Symbol> ...]
</UserInput></ProgramListing></Para>
</InformalExample>
<?sml-break>
<?sml-need 8>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">object-uuid</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.146">
<Primary>string binding</Primary>
<Secondary>object UUID portion</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.147">
<Primary>object UUID portion of a string binding</Primary>
</IndexTerm>
<Para>This field specifies the UUID of the object operated on by the remote
procedure that is called with this string binding.  The RPC runtime,
at the server, maps the object's type to a manager entry point
vector (EPV) to invoke the
correct manager routine.  The explanation of the
routine <Function>rpc_server_register_if()</Function> discusses mapping object UUIDs
to manager EPVs.
</Para>
<Para>This field is optional.  If you do not provide it the RPC runtime assumes
a nil UUID.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>@</Literal></Term>
<ListItem>
<Para>This symbol is the delimiter character for the object UUID
field.  If you specify an
object UUID you must follow it with this symbol.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term><Symbol Role="Variable">rpc-protocol-sequence</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.148">
<Primary>string binding</Primary>
<Secondary>protocol sequence portion</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.149">
<Primary>protocol sequence portion of a string binding</Primary>
</IndexTerm>
<Para>This field specifies the protocol sequence used for making
remote procedure calls.  The valid protocol sequences are as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput><Literal>ncacn_ip_tcp</Literal>
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,-->
<!-- ** add here the following 4 lines.-->
<!-- .PP-->
<Literal>ncacn_dnet_nsp</Literal>
<!-- .PP-->
<Literal>ncacn_osi_dna</Literal>
<!-- DIGITAL_END-->
<!-- .cE-->
<Literal>ncadg_ip_udp</Literal>
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,-->
<!-- ** add here the following 2 lines.-->
<!-- .PP-->
<Literal>ncadg_dds</Literal>
<!-- DIGITAL_END-->
<!-- .cE-->
</UserInput></ProgramListing></Para>
</InformalExample>
<Para>More information about these valid protocol sequences appears in the
preceding table.
</Para>
<Para>This field is required.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>:</Literal></Term>
<ListItem>
<Para>This symbol is the delimiter character for the RPC protocol sequence
field.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">nw-addr</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.150">
<Primary>string binding</Primary>
<Secondary>network address portion</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.151">
<Primary>network address portion of a string binding</Primary>
</IndexTerm>
<Para>This field specifies the address (<Symbol Role="Variable">addr</Symbol>) of a host on a
network (<Symbol Role="Variable">nw</Symbol>) that
receives remote procedure calls made with this string binding.  The
format and content of the network address depends on the value of
<Symbol Role="Variable">rpc-protocol-sequence</Symbol> as follows:
</Para>
<Para><Literal>ncacn_ip_tcp</Literal> and <Literal>ncadg_ip_udp</Literal>
</Para>
<Para>Specify an Internet address using the common Internet address
notation or host name.
</Para>
<Para>Two examples with common Internet address notation are <Literal>128.10.2.30</Literal>
and <Literal>#126.15.1.28</Literal>.  The second example shows the use of the
optional <Literal>#</Literal> (number sign) character.
</Para>
<Para>An example with a host name is <Literal>ko</Literal>.
</Para>
<Para><?sml-need 9>If the specified host name is multihomed, the binding handle that is returned
from the routine <Function>rpc_binding_from_string_binding()</Function> contains
a host address.  It is the first host address returned from
the system library call that
translates a host name to a host address for the network address format
in the protocol sequence.
To control the host address used, specify the
network address using the common Internet address notation instead of
a host name.
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,-->
<!-- ** add the following three values and descriptions for \*Vnw-addr\*O:-->
<!-- ** \*Lncacn_dnet_nsp\*O, \*Lncacn_osi_dna\*O, and \*Lncadg_dds\*O.-->
<!-- .LI "\*Lncacn_dnet_nsp\*O"-->
<!-- .PP-->
<!-- Specify a DECnet Phase IV host address using the host name or area-->
<!-- and node syntax.  When you use the host name, do not include a-->
<!-- trailing pair of colons (::).-->
<!-- .PP-->
<!-- An example of a host name is \*Lsage\*O-->
<!-- .PP-->
<!-- An example of an area node is \*L4.120\*O-->
<!-- .LI "\*Lncacn_osi_dna\*O"-->
<!-- .PP-->
<!-- Specify a DECnet Phase V host address using a Cell Directory Service-->
<!-- (CDS) full name, a node synonym, area and node syntax, or an NSAP.-->
<!-- .PP-->
<!-- An example of a CDS full name is \*L.dec.eng.nac.dss.node\*O-->
<!-- .PP-->
<!-- An example of a node synonym is \*Lsage\*O-->
<!-- .PP-->
<!-- If the specified node synonym is multihomed, the binding handle returned-->
<!-- from routine \*Lrpc_binding_from_string_binding\*O contains-->
<!-- a host address.  It is the first-->
<!-- host address returned from the system library call-->
<!-- that translates a node synonym to a host address for the-->
<!-- network address format in the protocol sequence.  To control the-->
<!-- host address used, specify the-->
<!-- network address using a CDS full name, area node syntax, or an NSAP-->
<!-- instead of a node synonym.-->
<!-- .PP-->
<!-- An example of an area node is \*L4.120\*O-->
<!-- .PP-->
<!-- (If you choose this form of address the RPC runtime assumes that-->
<!-- the transport is NSP; consequently, the RPC runtime ignores any-->
<!-- options flags that indicate transport.)-->
<!-- .PP-->
<!-- An example of an NSAP is \*L%x49003FAA000400E4FD20\*O-->
<!-- .PP-->
<!-- The string representing the NSAP is a percent sign followed by the-->
<!-- letter \*Cx\*O followed by hexadecimal digits.  No separators are-->
<!-- allowed in the string.  Finally, any transport options in the-->
<!-- string binding are ignored since the NSAP specified the transport-->
<!-- to be used as part of its value.-->
<!-- .LI "\*Lncadg_dds\*O"-->
<!-- .PP-->
<!-- Specify the Hewlett-Packard/Apollo Domain host address using the syntax-->
<!-- for a host name or a network and node ID.-->
<!-- .PP-->
<!-- An example of a host name is \*C//saab\*O-->
<!-- .PP-->
<!-- An example of a network and node ID is \*C29C05.21B34-->
<!-- DIGITAL_END-->
<!-- .cE-->
</Para>
<Para>The network address field is optional.  If you do not supply this
field, the string binding refers to your local host.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>[</Literal></Term>
<ListItem>
<Para>This symbol is the delimiter character specifying that
one endpoint and zero or more options follow.  If the string binding contains
at least one endpoint, this symbol is required.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">endpoint</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.152">
<Primary>string binding</Primary>
<Secondary>endpoint portion</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.153">
<Primary>endpoint portion of a string binding</Primary>
</IndexTerm>
<Para>This field specifies the endpoint,
or address of a specific server instance on a host, to
receive remote procedure calls made with this string binding.  Optionally
the keyword <Literal>endpoint=</Literal> can precede the endpoint specifier.
</Para>
<Para>The format and content of the endpoint depends on the specified protocol
sequence as follows:
</Para>
<Para><Literal>ncacn_ip_tcp</Literal> and <Literal>ncadg_ip_udp</Literal>
<!-- .PP-->
<!-- Specify an Internet port number.-->
<!-- .PP-->
<!-- An example of an Internet port number is \*L1025\*O.-->
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,-->
<!-- ** add the following three values and descriptions for \*Vnw-addr\*O:-->
<!-- ** \*Lncacn_dnet_nsp\*O, \*Lncacn_osi_dna\*O, and \*Lncadg_dds\*O.-->
<!-- .PP-->
<!-- \*Lncacn_dnet_nsp\*O-->
<!-- .PP-->
<!-- Specify a DECnet Phase IV object name or object number.-->
<!-- .PP-->
<!-- An example of an object name is \*Ctestname\*O-->
<!-- .PP-->
<!-- An example of an object number is \*C#17\*O-->
<!-- .PP-->
<!-- The \*C#\*O (number sign) character must precede an object number.-->
<!-- .PP-->
<!-- \*Lncacn_osi_dna\*O-->
<!-- .PP-->
<!-- Specify a DECnet Phase V object name or object number.-->
<!-- .PP-->
<!-- An example of an object name is \*Cfal\*O-->
<!-- .PP-->
<!-- An example of an object number is \*C#17\*O-->
<!-- .PP-->
<!-- The \*C#\*O (number sign) character must precede an object number.-->
<!-- .LI "\*Lncadg_dds\*O"-->
<!-- .PP-->
<!-- \*LTBS\*O-->
<!-- DIGITAL_END-->
<!-- .cE-->
</Para>
<Para>The endpoint field is optional.  For more information about endpoints,
see the information on binding handles in this reference page.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>,</Literal></Term>
<ListItem>
<Para>This symbol is the delimiter character specifying that option data
follows.  If an option follows, this delimiter is required.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">option</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.154">
<Primary>string binding</Primary>
<Secondary>option portion</Secondary>
</IndexTerm>
<Para>This field specifies any options.  Each option is specified as
<Symbol Role="Variable">option name</Symbol><Literal>=</Literal><Symbol Role="Variable">option value</Symbol>.
</Para>
<Para>The format and content of the option depends on the specified protocol
sequence as follows:
</Para>
<Para><Literal>ncacn_ip_tcp</Literal> and <Literal>ncadg_ip_udp</Literal>
</Para>
<Para>There are no Internet options.
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,-->
<!-- ** add the following three values and descriptions for \*Vnw-addr\*O:-->
<!-- ** \*Lncacn_dnet_nsp\*O, \*Lncacn_osi_dna\*O, and \*Lncadg_dds\*O.-->
<!-- .PP-->
<!-- .LI "\*Lncacn_dnet_nsp\*O"-->
<!-- .PP-->
<!-- There are no DECnet Phase IV options.-->
<!-- .PP-->
<!-- \*Lncacn_osi_dna\*O-->
<!-- .PP-->
<!-- Specify a DECnet Phase V option.  Presently one option exists for-->
<!-- selecting a transport.  The option name is \*Ltpid\*O (for transport-->
<!-- protocol identifier).  The option value is either \*Lcots\*O (for-->
<!-- connection-oriented transport service) or \*Lnsp\*O (for network-->
<!-- services protocol).-->
<!-- .PP-->
<!-- An example of a transport option is \*Ctpid=cots\*O.  Another-->
<!-- example of a transport option is \*Ctpid=nsp\*O.-->
<!-- .LI "\*Lncadg_dds\*O"-->
<!-- .PP-->
<!-- \*LTBS\*O-->
<!-- DIGITAL_END-->
<!-- .cE-->
</Para>
<Para>The <Symbol Role="Variable">option</Symbol> field is optional.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal>]</Literal></Term>
<ListItem>
<Para>This symbol is the delimiter character specifying that one endpoint
and zero or more options precede.
If the string binding contains at least one endpoint, this symbol is
required.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<Para>The <Literal>&bsol;</Literal> (backslash) character is
treated as an escape character for all string binding fields.
</Para>
<Para>Examples of valid string bindings follow.  In each example <Symbol Role="Variable">obj-uuid</Symbol>
represents a UUID in string form.  In other words, the symbol <Symbol Role="Variable">obj-uuid</Symbol>
can represent the UUID 308fb580-1eb2-11ca-923b-08002b1075a7.
</Para>
<InformalExample>
<Para><ProgramListing><Symbol Role="Variable">obj-uuid</Symbol>@ncacn_ip_tcp:16.20.16.27[2001]
<Symbol Role="Variable">obj-uuid</Symbol>@ncacn_ip_tcp:16.20.16.27[endpoint=2001]
</ProgramListing></Para>
</InformalExample>
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** Next are 15 more examples of Digital Equipment Corporation and HP/Apollo-->
<!-- ** string bindings (a paragraph of explanation precedes the 15th example).-->
<!-- \*Vobj-uuid\*C@ncacn_dnet_nsp:took[elf_server]-->
<!-- \*Vobj-uuid\*C@ncacn_dnet_nsp:took[endpoint=elf_server]-->
<!-- ncacn_osi_dna:took[fal]-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:took[#17]-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:4.32[dlogin]-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:4.32[#17]-->
<!-- ncacn_osi_dna:took[fal,tpid=nsp]-->
<!-- ncacn_osi_dna:took[#17,tpid=cots]-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:4.32[dlogin,tpid=nsp]-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:4.32[dlogin]-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:.lkg.took[my_server_with_long_name,tpid=nsp]-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:.lkg.took[my_server_with_long_name,tpid=cots]-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:%x49003FAA000400E4FD20[dtr,tpid=nsp]-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:%x49003FAA000400E4FD21[#63,tpid=cots]\*O-->
<!-- .PP-->
<!-- The following example is a valid string binding, but the \*Ltpid\*O option-->
<!-- is ignored because using the DECnet Phase IV network address-->
<!-- implies \*Lnsp\*O, not \*Lcots\*O:-->
<!-- .oS-->
<!-- \*Vobj-uuid\*C@ncacn_osi_dna:4.32[#42,tpid=cots]\*O-->
<!-- .oE-->
<!-- DIGITAL_END-->
<!-- .cE-->
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>String UUID</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.155">
<Primary>string UUID</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.156">
<Primary>UUID</Primary>
<Secondary>string</Secondary>
</IndexTerm>
<Para>A string UUID contains the character representation of a UUID.
A string UUID consists of multiple fields of hexadecimal characters.
Each field has a fixed length, and dashes separate the fields.
An example of a string UUID follows:
</Para>
<InformalExample>
<Para><ProgramListing>989c6e5c-2cc1-11ca-a044-08002b1bb4f5
</ProgramListing></Para>
</InformalExample>
<Para>When you supply a string UUID as an input argument to an RPC runtime
routine, you can enter the alphabetic hexadecimal characters in
either uppercase or lowercase letters.  The RPC runtime routines
that return a string UUID always return the hexadecimal characters in
lowercase letters.
</Para>
<Para>The following routines require a string UUID:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_string_binding_compose()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>uuid_from_string()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>The following routines return a string UUID:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_string_binding_parse()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>uuid_to_string()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>Unsigned Character String</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.157">
<Primary>unsigned character string</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.158">
<Primary>character string</Primary>
<Secondary>unsigned</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.159">
<Primary>string</Primary>
<Secondary>unsigned character</Secondary>
</IndexTerm>
<Para>DCE RPC treats all characters in strings as unsigned characters.  Those
routines with character string arguments show a data type of
<Literal>unsigned_char_t *</Literal>.
<IndexTerm Id="DCEADR.MAN199.indx.160">
<Primary><StructName Role="typedef">unsigned_char_t</StructName> data type</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.161">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">unsigned_char_t</StructName></Secondary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry role="linebreak">
<Term>UUID Vector</Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.162">
<Primary>UUID vector data structure</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.163">
<Primary>data structures</Primary>
<Secondary>UUID vector</Secondary>
</IndexTerm>
<Para>The UUID vector data structure contains a list of UUIDs.
The UUID vector contains a count member (<Symbol Role="Variable">count</Symbol>),
followed by an array of pointers to UUIDs.
</Para>
<Para>The C language representation of a UUID vector is as follows:
</Para>
<InformalExample>
<Para><ProgramListing><UserInput>typedef struct
{
    unsigned32    count;
    uuid_t        *uuid[1];
} uuid_vector_t;
</UserInput></ProgramListing></Para>
</InformalExample>
<IndexTerm Id="DCEADR.MAN199.indx.164">
<Primary>data types</Primary>
<Secondary><StructName Role="typedef">uuid_vector_t</StructName></Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.165">
<Primary><StructName Role="typedef">uuid_vector_t</StructName> data type</Primary>
</IndexTerm>
<Para>An application constructs a UUID vector to contain object UUIDs to be
exported or unexported from the name service database.  The following routines
require a UUID vector and show an argument data type of
<StructName Role="typedef">uuid_vector_t</StructName>:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_ep_register()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_register_no_replace()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ep_unregister()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_export()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_unexport()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_mgmt_binding_unexport()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
</ListItem>
</VarListEntry>
</VariableList>
</RefSect2>
<RefSect2>
<Title>Permissions Required</Title>
<Para>To use the NSI routines to access
entries in a Cell Directory Service (CDS) database, you need
<IndexTerm Id="DCEADR.MAN199.indx.166">
<Primary>RPC</Primary>
<Secondary>ACL permissions for NSI routines</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.167">
<Primary>NSI</Primary>
<Secondary>ACL permissions for routines</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.168">
<Primary>ACL</Primary>
<Secondary>permissions for RPC NSI routines</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.169">
<Primary>access control list</Primary>
<Secondary>permissions for RPC NSI routines</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.170">
<Primary>CDS</Primary>
<Secondary>ACL permissions for NSI routines</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.171">
<Primary>permissions (ACL) for NSI routines</Primary>
</IndexTerm>access control list (ACL) permissions.
Depending on the NSI operation, you need ACL permissions to the parent
directory or the CDS object entry (the name service entry) or both.
</Para>
<Para>The ACL permissions are as follows:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para>To create an entry, you need insert permission to the parent directory.
<IndexTerm Id="DCEADR.MAN199.indx.172">
<Primary>insert permission</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>To read an entry, you need read permission to the CDS object entry.
<IndexTerm Id="DCEADR.MAN199.indx.173">
<Primary>read permission</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>To write to an entry, you need write permission to the CDS object entry.
<IndexTerm Id="DCEADR.MAN199.indx.174">
<Primary>write permission</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>To delete an entry, you need delete permission either to the CDS object entry
or to the parent directory.
<IndexTerm Id="DCEADR.MAN199.indx.175">
<Primary>delete permission</Primary>
</IndexTerm></Para>
</ListItem>
<ListItem>
<Para>To test an entry, you need either test permission or read permission
to the CDS object entry.
<IndexTerm Id="DCEADR.MAN199.indx.176">
<Primary>test permission</Primary>
</IndexTerm></Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>Note that write permission does not imply read permission.
</Para>
<Para>To find the ACL permissions for the NSI routines whose names
begin with <Literal>rpc_ns</Literal>, see these routines' reference pages.
</Para>
<Para>The non-NSI routines whose names do not begin with <Literal>rpc_ns</Literal> do
not need ACL permissions, so their reference pages do not specify any.
</Para>
</RefSect2>
<RefSect2>
<Title>Frequently Used Routine Parameters</Title>
<IndexTerm Id="DCEADR.MAN199.indx.177">
<Primary>frequently used routine parameters</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.178">
<Primary>parameters</Primary>
<Secondary>frequently used routine</Secondary>
</IndexTerm>
<Para>A few parameters are common to many of the DCE RPC routines.
These parameters are described fully here and again
briefly on the specific routine reference pages.
</Para>
<VariableList>
<VarListEntry>
<Term><Symbol Role="Variable">binding</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.179">
<Primary><Symbol Role="Variable">binding</Symbol> parameter</Primary>
</IndexTerm>
<Para>Used as an input or output parameter.
</Para>
<Para>Returns a binding handle for making remote procedure calls to a server.
</Para>
<Para>A client obtains a binding handle by calling one of the following routines:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_binding_copy()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_binding_from_string_binding()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_import_next()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_ns_binding_select()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
<Para>Creating a binding handle establishes a relationship
between a client and a server.  However, the relationship
does not involve any communications between the client and server.
The communications occur when a client makes a remote
procedure call.
</Para>
<Para>As an input parameter to a remote procedure call, <Symbol Role="Variable">binding</Symbol> specifies
a binding handle that refers to binding information.  The client's
RPC runtime uses this binding information to make a remote procedure call
to a server.
</Para>
<Para>Server manager routines can extract client information
from a client binding handle by using the following routines:
<!--no-op:  l-->
</Para>
<ItemizedList>
<ListItem>
<Para><Function>rpc_binding_inq_auth_client()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_binding_inq_object()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_binding_to_string_binding()</Function>
</Para>
</ListItem>
<ListItem>
<Para><Function>rpc_string_binding_parse()</Function>
</Para>
</ListItem>
</ItemizedList>
<!--no-op:  b-->
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">name</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.180">
<Primary><Symbol Role="Variable">name</Symbol> parameter</Primary>
</IndexTerm>
<Para>Used as an input/output parameter.
</Para>
<Para>When used as an input parameter, the value of this parameter depends
on the syntax selected in the
<Symbol Role="Variable">name_syntax</Symbol> parameter.  If it is allowed by the called routine,
the value NULL
specifies that the routine uses
the name specified in the <Literal>RPC_DEFAULT_ENTRY</Literal> environment variable.
Specifying NULL also has the called routine use the name syntax
that the environment variable <Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal> specifies.
<IndexTerm Id="DCEADR.MAN199.indx.181">
<Primary><Literal>RPC_DEFAULT_ENTRY</Literal> environment variable</Primary>
</IndexTerm></Para>
<Para>For a <Symbol Role="Variable">name_syntax</Symbol> value of <Literal>rpc_c_ns_syntax_dce</Literal>,
use the DCE naming rules to specify parameter <Symbol Role="Variable">name</Symbol>.
</Para>
<Para>As an output parameter, returns an entry in the name service database
in the form of a character string that includes a terminating null
character.
The value of this parameter depends on the syntax selected in
<Symbol Role="Variable">name_syntax</Symbol>.
</Para>
<Para>For a <Symbol Role="Variable">name_syntax</Symbol> value of <Literal>rpc_c_ns_syntax_dce</Literal>,
<Symbol Role="Variable">name</Symbol> is returned using the DCE naming syntax.
</Para>
<Para>The DCE RPC runtime allocates memory for the returned string.  The application
is responsible for calling the <Function>rpc_string_free()</Function> routine to deallocate
the string.
</Para>
<Para>If an application does not want a returned name string, the application
usually specifies NULL for this parameter.
The one exception is routine <Function>rpc_ns_entry_expand_name()</Function>;
it always returns a name string.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">name_syntax</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.182">
<Primary><Symbol Role="Variable">name_syntax</Symbol> parameter</Primary>
</IndexTerm>
<Para>Used as an input parameter, an integer value that specifies the syntax
of an entry name.  When allowed by
the called routine, a value of <Literal>rpc_c_ns_syntax_default</Literal>
specifies that the routine uses the syntax
specified in the <Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal>
environment variable.
The following table lists the valid syntaxes that applications can use
in DCE RPC for entries in the name service database.
</Para>

<InformalTable Frame="all" Remap="center" Orient="Port">
<TGroup Rowsep="0" Colsep="0" Cols="3">
<ColSpec Rowsep="1" Colsep="1" Align="Left" Colwidth="1*" Colname="col1" Colnum="1">
<ColSpec Rowsep="1" Colsep="1" Align="Center" Colwidth="1*" Colname="col2" Colnum="2">
<ColSpec Rowsep="1" Align="Left" Colwidth="1*" Colname="col3" Colnum="3">
<TBody>
<!--.TB "Valid Name Syntaxes"-->
<IndexTerm Id="DCEADR.MAN199.indx.183">
<Primary>name syntaxes</Primary>
<Secondary>valid</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.184">
<Primary>syntaxes</Primary>
<Secondary>valid name</Secondary>
</IndexTerm>
<Row>
<Entry Rowsep="1" Colsep="0" Align="Center" Namest="col1" Nameend="col3"><Literal>Valid Name Syntaxes</Literal></Entry>
<Entry Rowsep="1"><!-- WARNING: ghost column #4: -->
</Entry>
</Row>
<Row>
<Entry Rowsep="1"><Literal>Constant</Literal></Entry>
<Entry Rowsep="1" Align="Left"><Literal>Value</Literal></Entry>
<Entry Rowsep="1"><Literal>Description</Literal></Entry>
</Row>
<Row>
<Entry><Literal>rpc_c_ns_syntax_default</Literal></Entry>
<Entry>0</Entry>
<Entry>Default syntax</Entry>
</Row>
<Row>
<Entry><Literal>rpc_c_ns_syntax_dce</Literal></Entry>
<Entry>3</Entry>
<Entry>DCE</Entry>
</Row>
</TBody>
</TGroup>
</InformalTable>
<!-- .cS-->
<!-- DIGITAL_BEGIN-->
<!-- ** To include Digital Equipment Corporation and HP/Apollo formats,-->
<!-- ** insert the following line in the table:-->
<!-- rpc_c_ns_syntax_dec_dns%1%DECdns-->
<!-- DIGITAL_END-->
<!-- .cE-->
<Para>The <Symbol Role="Variable">name_syntax</Symbol> parameter tells routines how to parse the
entry name specified in an input <Symbol Role="Variable">name</Symbol> parameter or specifies the
syntax to use when returning an entry name as an output <Symbol Role="Variable">name</Symbol>
parameter.
</Para>
<Para><?sml-need 5>If the <Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal> environment variable is not
defined, the RPC runtime uses the <Literal>rpc_c_ns_syntax_dce</Literal> name syntax.
<IndexTerm Id="DCEADR.MAN199.indx.185">
<Primary><Literal>RPC_DEFAULT_ENTRY_SYNTAX</Literal> environment variable</Primary>
</IndexTerm></Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">string</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.186">
<Primary><Symbol Role="Variable">string</Symbol> parameter</Primary>
</IndexTerm>
<Para>Used as an input or output parameter.
</Para>
<Para>Returns a character string, which always includes the
terminating null character <Literal>\0</Literal>.
The DCE RPC runtime allocates memory for the returned string.  The application
calls the <Function>rpc_string_free()</Function> routine to deallocate the memory occupied by
the string.
</Para>
<Para>If there is no data for the requested string, the routine returns the string
<Literal>\0</Literal>.  For example, if the string binding passed to routine
<Function>rpc_string_binding_parse()</Function> does not contain an object UUID,
the routine returns
<Literal>\0</Literal> as the value of the object UUID string.  The application must
call the <Function>rpc_string_free()</Function> routine to deallocate the memory occupied by
this string.
</Para>
<Para>If an application does not require a returned output string, the application
specifies NULL for this parameter.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">status</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.187">
<Primary><Symbol Role="Variable">status</Symbol> parameter</Primary>
</IndexTerm>
<Para>Each routine in the RPC API returns a DCE status code indicating whether the
routine completed successfully or, if not, why not.  A return value
of <Literal>rpc_s_ok</Literal> indicates success.  All other return values signify
routine failure.  The status codes listed for each RPC runtime routine
are the most likely, but not necessarily all, the status codes
that the routine can return.
<IndexTerm Id="DCEADR.MAN199.indx.188">
<Primary>DCE status codes</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.189">
<Primary>status codes</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.190">
<Primary>error codes</Primary>
</IndexTerm></Para>
<Para>The status code argument has a data type of <Literal>unsigned32</Literal>.
</Para>
<Para>To translate a DCE status code to a text message, call the
routine <Function>dce_error_inq_text()</Function>.
<IndexTerm Id="DCEADR.MAN199.indx.191">
<Primary>exceptions</Primary>
<Secondary>for RPC applications</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.192">
<Primary>exception codes</Primary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.193">
<Primary>RPC</Primary>
<Secondary>exceptions</Secondary>
</IndexTerm>
<IndexTerm Id="DCEADR.MAN199.indx.194">
<Primary>exceptions</Primary>
<SeeAlso>RPC status codes</SeeAlso>
</IndexTerm></Para>
<Para>Note that RPC exceptions are equivalent to RPC status codes.  To
identify the status code that corresponds to a given exception, replace
the <Literal>_x_</Literal> string
of the exception with the string <Literal>_s_</Literal>; for example, the exception
<Literal>rpc_x_already_listening</Literal> is equivalent to the status code
<Literal>rpc_s_already_listening</Literal>.
</Para>
<Para>For more information about the RPC status codes,
see the &DCETg;.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Symbol Role="Variable">uuid</Symbol></Term>
<ListItem>
<IndexTerm Id="DCEADR.MAN199.indx.195">
<Primary><Symbol Role="Variable">uuid</Symbol> parameter</Primary>
</IndexTerm>
<Para>Used as an input or output parameter.
</Para>
<Para>When you need to specify a nil UUID to a <Symbol Role="Variable">uuid</Symbol> input parameter
in any of the DCE RPC routines, you can supply the value NULL.
</Para>
</ListItem>
</VarListEntry>
</VariableList>
<?sml-break>
<?sml-need .75i>
</RefSect2>
</RefSect1>
<RefSect1>
<Title>Related Information</Title>
<Para><!--no-op:  l-->
Books:  &DCEDi;, &DCEDk;, &DCEDd;, &DCEAr;, &DCETg;.
<!--no-op:  b-->
</Para>
</RefSect1>
<!--+ 11/27/96 19:46:25
    | tagMorph:  $Id: rpc_intro.3rpc,v 1.1.2.9 1996/12/15 16:36:51 carrig Exp $
    | tagMorph library:  $Id: rpc_intro.3rpc,v 1.1.2.9 1996/12/15 16:36:51 carrig Exp $
    | sml-to-docbook:  1.25
    +-->
</RefEntry>
