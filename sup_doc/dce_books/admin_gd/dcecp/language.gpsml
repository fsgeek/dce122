...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" 
...\" HISTORY
...\" $Log: language.gpsml,v $
...\" Revision 1.1.4.2  1996/09/27  13:49:53  weir
...\" 	Test
...\" 	[1996/09/27  13:49:18  weir]
...\"
...\" Revision 1.1.4.1  1996/09/19  13:39:39  sherman
...\" 	{def,13575,R1.2.2}
...\" 	Miscellaneous dcecp corrections
...\" 	{def,13464,R1.2.2}
...\" 	Change value of proc _attr_show
...\" 	{def,13463,R1.2.2}
...\" 	Use of double quotes/braces in groups/lists
...\" 	[1996/09/19  13:36:39  sherman]
...\" 
...\" Revision 1.1.2.14  1995/05/25  19:01:15  rcb
...\" 	PRENTICE HALL reformat: final changes
...\" 	[1995/05/25  13:08:27  rcb]
...\" 
...\" 	more font-fixing
...\" 	[1995/03/30  19:58:14  rcb]
...\" 
...\" 	minor font correction
...\" 	[1995/03/30  19:42:21  rcb]
...\" 
...\" 	PRENTICE HALL reformat -- index entries, odds and ends
...\" 	[1995/03/27  19:48:37  rcb]
...\" 
...\" 	no change
...\" 	[1995/03/08  16:49:11  rcb]
...\" 
...\" 	no change
...\" 	[1995/03/01  14:16:52  rcb]
...\" 
...\" 	addition 1.1 edit change
...\" 	[1995/02/27  17:35:44  rcb]
...\" 
...\" 	addition 1.1 edit change
...\" 
...\" 	addition 1.1 edit change
...\" 
...\" 	additional 1.1 edit change
...\" 	[1995/02/27  17:03:18  rcb]
...\" 
...\" 	previous checkins include both incorporation of 1.1 edits and PH reformat
...\" 	[1995/02/23  18:20:37  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/02/23  17:57:03  rcb]
...\" 
...\" Revision 1.1.2.13  1994/10/28  12:40:30  wardr
...\" 	{edit R1.1}
...\" 	Added index hits
...\" 	[1994/10/28  12:40:07  wardr]
...\" 
...\" Revision 1.1.2.12  1994/10/21  17:07:37  wardr
...\" 	{edit R1.1}
...\" 	Final GA release edits
...\" 	[1994/10/21  17:07:21  wardr]
...\" 
...\" Revision 1.1.2.11  1994/10/20  16:23:04  wardr
...\" 	{edit R1.1}
...\" 	Final GA release edits
...\" 	[1994/10/20  16:22:19  wardr]
...\" 
...\" 	{edit R1.1}
...\" 	Final fixes for the GA release
...\" 
...\" Revision 1.1.2.10  1994/10/05  14:33:04  wardr
...\" 	{edit R1.1}
...\" 	moved strings before error message section
...\" 	[1994/10/05  14:32:45  wardr]
...\" 
...\" Revision 1.1.2.9  1994/10/04  17:58:27  wardr
...\" 	{enh, CR10014, R1.1}
...\" 	prepare final draft of dcecp information
...\" 	[1994/10/04  17:57:03  wardr]
...\" 
...\" Revision 1.1.2.8  1994/06/13  18:10:49  devobj
...\" 	cr10872 - fix copyright
...\" 	[1994/06/13  18:10:12  devobj]
...\" 
...\" Revision 1.1.2.7  1994/06/13  13:50:26  wardr
...\" 	{edit, R1.1}
...\" 	Fix typos
...\" 	[1994/06/13  13:50:07  wardr]
...\" 
...\" Revision 1.1.2.6  1994/06/13  13:11:02  wardr
...\" 	{enh, CR10014, R1.1}
...\" 	fix typos in examples
...\" 	[1994/06/13  13:10:17  wardr]
...\" 
...\" Revision 1.1.2.5  1994/05/18  12:14:48  wardr
...\" 	{edit R1.1}SGML fixes
...\" 	[1994/05/18  12:14:36  wardr]
...\" 
...\" Revision 1.1.2.4  1994/05/09  19:49:56  wardr
...\" 	{enh, CR10014, R1.1}
...\" 	updating draft
...\" 	[1994/05/09  19:49:03  wardr]
...\" 
...\" Revision 1.1.2.3  1994/04/18  18:31:34  wardr
...\" 	{enh, CR10014, R1.1}
...\" 	dcecp work
...\" 	[1994/04/18  18:29:59  wardr]
...\" 
...\" Revision 1.1.2.2  1994/04/14  20:42:25  wardr
...\" 	Checked out files
...\" 	[1994/04/14  20:36:18  wardr]
...\" 
...\" Revision 1.1.2.1  1994/02/24  19:46:34  rom
...\" 	{enh, 10014, R1.1}
...\" 	Add new chapters for dcecp.
...\" 	[1994/02/24  19:44:52  rom]
...\" 
...\" $EndLog$
...\" 
.H 1 "Using the DCE Control Program Command Language"
.P
.iX "DCE control program" "language"
.iX "DCE control program language" "
In Chapter 1, we provided a high-level look at some ways to use the
DCE control program to administer your DCE environment.  In this
chapter, we will discuss some syntax rules and some of the more
important commands you'll need to use in composing your \*Ldcecp\*O
administration commands and task scripts.
.P
The \*Ldcecp\*O command language consists of DCE administration commands
like \*Ldirectory create\*O and \*Lobject modify\*O, as well as Tcl
built-in commands such as \*Lif\*O and \*Lforeach\*O.  We won't
discuss DCE administration commands here.  These commands are discussed
in sections that deal with administering the particular DCE component.
Instead, we will focus on using the more generic syntax rules and
built-in commands.
.P
.iX "Tool Command Language" "its use in \*Ldcecp\*O"
The Tool Command Language (Tcl) on which \*Ldcecp\*O is based is a
general-purpose language that is also used for other applications
besides \*Ldcecp\*O.  Although there are many ways you can use Tcl for
various purposes, we will limit our discussion to those commands most
likely to be used for administering DCE environments.  Furthermore,
our command discussions don't describe every aspect of individual
commands.  Rather, they suggest why and how you might use a command in
the context of administering a DCE environment.  If you're not already
familiar with Tcl, you'll likely need to have access to the
appropriate Tcl documentation, including the Tcl reference pages, for
writing sophisticated commands and task scripts.
.H 2 "Chapter Preview"
.P
This chapter walks you through the basic \*Ldcecp\*O syntax and then looks
at some commands that you're likely to use in interactive commands and
task scripts.  The discussions will focus on
.ML
.LI
Use of variables as an easy way to pass data around in your command or
script
.LI
Command substitution as a way to channel the output from one command
to the input of another command
.LI
Grouping elements together so that \*Ldcecp\*O parses commands
correctly
.LI
Using lists to sort, find, and reuse information
.LI
Using arithmetic functions in commands and task scripts
.LI
Conditionalizing and controlling your script with \*Lif\*O statements and
loops
.LI
Executing scripts associated with character patterns by using
the \*Lcase\*O command
.LI
Synthesizing commands by using \*Leval\*O
.LI
Importing operations with \*Lsource\*O
.LI
Creating new \*Ldcecp\*O commands with \*Lproc\*O
.LI
Using error and exception information
.LI
Handling strings
.LI
Working with files
.LI
Spawning subprocesses
.LE
.H 2 "Variable Substitution"
.P
.iX "DCE control program language" "variables"
.iX "variables" "used in \*Ldcecp\*O"
Like other programming languages, \*Ldcecp\*O provides shorthand ways to
express and use values.  Variable substitution is one shorthand method
that lets you represent a value\(emsay, the name of an object in a CDS
directory\(emas a variable.  
.P
Use the \*Lset\*O command to establish a value for a variable.  For
readability, a variable name can consist of any combination of
letters, numbers, and _ (underscore) characters.  Use "" (quotes) or \\
(backslash) to include spaces in variable names (although this is not usually
recommended) or values.  All of the following examples use valid
variable names:
.oS
set a $i
set CDS_clearinghouse_name cambridge_ch
set DCE_user_1 "William Rosenberry"
.oE
.P
The following example sets variable \*Va\*O to have a value of \*L7\*O.  
The second use of the \*Lset a\*O command without a value causes
\*Ldcecp\*O to display the current value of the variable:
.oS
dcecp> \*Lset a 7\*C
7
dcecp> \*Lset a\*C
7
.oE
.P
Once you have established a value for a variable using the \*Ldcecp\*O
\*Lset\*O command, the variable can be subsequently used elsewhere in
your script or interactive command.  The DCE control program uses the $
(dollar sign) to trigger insertion of the current value into the command
word.  A simple example is
.oS
dcecp> \*Lset a 7\*C
7
dcecp> \*Lexpr $a+2\*C
9
.oE
.P
Here we first set variable \*Va\*O to \*L7\*O.  In line 2, we use the
\*Lexpr\*O command to add 2 to the value of \*Va\*O (7).  The dollar
sign triggers \*Ldcecp\*O to insert the value 7. The last line shows the
return value from the \*Lexpr\*O command.
.P
A more relevant example might be
.oS
dcecp> \*Lset a /.:/sec\*C
/.:/sec
dcecp> \*Lobject show $a\*C
{RPC_ClassVersion
 {01 00}}
{RPC_ObjectUUIDs
 {06 3b 23 00 72 e5 e0 1d 8c b4 00 00 c0 8a df 56}}
{RPC_Group
 {2f 2e 2e 2e 2f 77 61 72 64 5f 63 65 6c 2e 6f 73 66 2e 6f 72 
 67 2f 73 75 62 73 79 73 2f 64 63 65 2f 73 65 63 2f 6d 61 73 74 
 65 72 00}}
{CDS_CTS 1994-05-23-17:21:37.481+00:00I0.000/00-00-c0-8a-df-56}
{CDS_UTS 1994-05-23-17:22:36.607+00:00I0.000/00-00-c0-8a-df-56}
{CDS_Class RPC_Group}
{CDS_ClassVersion 1.0}
dcecp> 
.oE
.P
Remove (undefine) a variable by using the \*Lunset\*O
command as in the following example:
.oS
dcecp> \*Lunset a\*C
dcecp> \*Lset a\*C
Error: can't read "a": no such variable
dcecp> 
.oE
.H 2 "Command Substitution"
.P
.iX "DCE control program language" "command substitution"
.iX "command substitution" "used in \*Ldcecp\*O"
Command substitution provides a convenient way to express the return
value of one command within another command.  This is useful when you
want to use the return value of one command as input to another
command.  Use brackets to invoke command substitution.  The following
example uses the \*Lexpr\*O command, which we'll discuss shortly.
Generally, \*Lexpr\*O performs a math function, returning the computed
value expressed by its arguments, as shown:
.oS
.ne 7
dcecp> \*Lset a 4\*C
4
dcecp> \*Lset b [expr $a+2]\*C
6
dcecp> \*Lset b\*C
6
dcecp> 
.oE
.P
A more practical example might use command substitution for a command
that returns a long name or a list.  Let's recall an example we saw in
Chapter 1. In this example, the \*L[group list temps]\*O command
returns a list to the \*Lforeach\*O command that performs the
\*Laccount modify\*O operation on each element in the list.  We'll look
more closely at the \*Lforeach\*O looping command later in this
section.
.oS
dcecp> \*Lforeach i [group list users] {   \*C
> \*Laccount modify $i -change {expdate 1995-12-31}} \*C
dcecp> 
.oE
.oE
.P
Another practical use of command substitution is to set up a test
condition for an \*Lif\*O statement.  We show an example of this usage in
Section 2.9.1. 
.H 2 "Grouping Elements and Controlling Interpretation"
.P
.iX "DCE control program language" "grouping elements"
.iX "grouping \*Ldcecp\*O elements"
.zA "def,13463,R1.2.2,Add descrip of double quotes and braces"
Programming languages often use symbols such as
braces, quotes, and parentheses
to operate on selected elements as a group rather than individually.
Similarly, \*Ldcecp\*O uses "" (double quotes) and {} (braces) to group 
elements into structures.  Double quotes allow elements that
would usually be parsed separately to be grouped and treated
as a single element.  Braces are used to group elements into a
list so that \*Ldcecp\*O can correctly parse commands and other data
like return values.
.zZ "def,13463,R1.2.2,Add descrip of double quotes and braces"
.P
The \*Ldcecp\*O command elements are separated by whitespace: the space, tab,
and newline characters.  The following \*Ldcecp\*O command uses space
characters to separate its three elements:
.oS
dcecp> \*Ldirectory create /.:/subsys/comm_services\*C
dcecp>
.oE
.P
.ne 3
Use either the newline character or the ; (semicolon) to separate
commands in a script.  The following two examples, which set and then
use a variable, are equivalent:
.oS
dcecp> \*Lset a /.:/subsys/comm_services\*C
/.:/subsys/comm_services
dcecp> \*Ldirectory create $a\*C
dcecp>

dcecp> \*Lset a /.:/subsys/comm_services; directory create $a\*C
dcecp>
.oE
.P
The choice to use braces or quotes to group elements together depends
on how you want \*Ldcecp\*O to interpret special characters like $, [, and
{. While braces disable special interpretation of most of these
characters, double quotes disable special interpretation of just a
few.  The backslash character, discussed in Section 2.4.3, offers
another way to disable interpretation of special characters.  When used
together, braces, quotes, and backslashes offer lots of flexibility in
composing \*Ldcecp\*O command strings.
.H 3 "Grouping Elements with Braces"
.P
Braces group separate elements to create a new element that
consists of everything between a { (left brace) and its corresponding
} (right brace).  You can also nest braced elements.  Each of the
following example lists contain three elements:
.oS
larry moe curly 

1 {3 5 7 11 13} {17 19}

red {orange yellow {green blue} indigo} violet
.oE
.P
Braces disable command ([\|]), variable ($), and backslash
substitution.  While the most important use of braces is to ensure a
\*Ldcecp\*O command has the correct number of arguments, this also provides
a convenient way to include special characters in a list.  To see how
this works, consider the following example:
.oS
.ne 6
dcecp> \*Lset a solution\*C
solution
dcecp> \*Lputs $a\*C
solution
dcecp> \*Lputs {This is a convenient $a}\*C
This is a convenient $a
.oE
.P
While the \*Lputs\*O command is often used for writing to files, when
called with only one argument it writes the argument to \*Lstdout\*O.
In our example, the first use of \*Lputs\*O allows normal
interpretation of the variable \*Va\*O.  The second use of \*Lputs\*O
groups the separate elements into one argument by disabling special
interpretation of space characters and the dollar sign.
.H 3 "Grouping Elements with Double Quotes"
.P
Like braces, double quotes also group elements together.  But unlike
braces, double quotes cannot be nested.  Furthermore, while braces
disable almost all special characters, double quotes disable just a
few\(emspaces, tabs, newlines and semicolons\(em letting you avoid the
potentially awkward use of backslashes in a string of text elements.
The most convenient use of double quotes is to allow clean, readable
expansion of variables using the dollar sign trigger.  For
instance, in the following example we set a variable (\*Va\*O) to a value
that includes spaces:
.oS
dcecp> \*Lset a "XYZ server for /.:/corp/comm_groups"\*C
XYZ server for /.:/corp/comm_groups
dcecp> \*Lputs $a \*C
XYZ server for /.:/corp/comm_groups
dcecp> 
.oE
.P
Use of double quotes does not disable command, variable, and backslash
substitution.  Let's look at a variation of the example used in the
Section 2.4.1:
.oS
.ne 7
dcecp> \*Lset a solution\*C
solution
dcecp> \*Lputs $a\*C
solution
dcecp> \*Lputs "This is a convenient $a."\*C
This is a convenient solution.
dcecp> 
.oE
.P
In this example, the use of quotes with the second \*Lputs\*O command
gathers five elements into a single argument for \*Lputs\*O by
disabling special interpretation of the space characters.  However, the
quotes don't affect interpretation of the dollar sign.
.H 3 "Including Special Characters with Backslashes"
.P
We already know that \*Ldcecp\*O relies on certain special characters such
as spaces, braces, quotes, or dollar signs to control its
interpretation of elements.  Sometimes, you might want to include one
special character in a string, temporarily suspending its special
interpretation.  The backslash provides a form of
substitution that suppresses special interpretation of the character
immediately following the backslash.
.P
Use the backslash to insert a nonprinting space
character in a string of elements.  For instance, each of the following
\*Ldcecp\*O lists have three elements:
.oS
  a b\\ c d 
  a b \\{
.oE
.P
The elements in the first example are \*La\*O, \*Lb\*O \*Lc\*O, and \*Ld\*O.  
The elements in the second example are \*La\*O, \*Lb\*O, and \*L{\*O.
A more practical example could use the backslash to include quotes in
error messages as shown in the following code fragment:
.oS
if {[llength $a] < 2} {
   error "Unable to parse \\"$element_list\\"."
}
.oE
.P
.ne 4
The following list shows the special characters that you can include
in a string of elements by using the backslash character:
.P
.TS
center,tab(@);
lbw(1.5i) l.
\eb@Backspace
\et@Tab
\ee@Escape 
\en@Newline
\er@Carriage-return
\e{@Left brace
\e}@Right brace
\e[@Open bracket
\e]@Close bracket
\e$@Dollar sign
\e\ (space)@Space (" ")
\e;@Semi-colon
\e"@Double quote
\e\e@Backslash
\e(newline)@Nothing
\e\*Vddd\*O@Octal value
.TE
.H 2 "Documenting Scripts with Comments"
.P
.iX "DCE control program language" "comments"
.iX "comments" "in \*Ldcecp\*O scripts"
When you are writing scripts, you might want to include some
comment lines to remind yourself and others what the script is doing.
Use the # (number sign) to insert comments.  The DCE control program
suppresses interpretation between a number sign and the next newline.
You must place the number sign in a position where \*Ldcecp\*O expects
the first character of a command.  Both of the following examples are
valid: 
.oS
set a 5
# sets a to 5

set a 5 ;# sets a to 5
.oE
.P
The following example is not valid because the number sign is not
positioned where \*Ldcecp\*O expects the first character of a command:
.oS
set a 5 # sets a to 5
.oE
.P
A common use of comments is to document procedures in scripts as in
the following sample script fragment:
.oS
# 
# _dcp_cleanup_user_create  - This function undoes changes 
# after a failure in one of the user create functions as 
# though the operation never occurred.
# 

proc _dcp_cleanup_user_create {account_name args} {
.oE
.H 2 "Convenience Variables"
.iX "DCE control program language" "convenience variables"
.iX "-;convenience variables" "DCE control program language" "convenience variables"
.iX "convenience variables" "in \*Ldcecp\*O scripts"
.iX "variables" "convenience, in \*Ldcecp\*O scripts"
.P
The DCE control program remembers what you enter as well as command
output, and stores certain pieces of that information in convenience
variables for reuse in subsequent commands.  Using these variables in
your interactive commands can reduce typing and help eliminate typing
mistakes.
.P
Convenience variables apply only to \*Ldcecp\*O commands like
\*Ldirectory\*O, \*Lprincipal\*O, \*Lacl\*O, \*Laccount\*O, 
and so on.  They don't apply
to Tcl commands like \*Lfor\*O or \*Leval\*O, or UNIX commands like
\*Lmv\*O or \*Lgrep\*O.  As an example, the convenience variable
\*L_n\*O holds the name (the argument) used in the following
\*Lprincipal create\*O operation.  The \*Lprincipal show\*O operation
retrieves the name by using the \*L$_n\*O variable.
.oS
dcecp> \*Lprincipal create D_Kalivas\*C
dcecp> \*Lprincipal show $_n -all\*C 
{fullname {}}
{uid 17}
{uuid 00000011-d957-21cd-8d00-0000c08adf56}
{alias no}
{quota unlimited}
dcecp>
.oE
.P
.ne 7
While this simple explanation demonstrates the general operation of
convenience variables, it understates their usefulness.  Most of the
convenience variables are intended to aid interactive use, but some
can be used in scripts as well, adding flexibility because the
information they contain isn't hardcoded in the script.  Moreover, as
you gain experience with the DCE control program, you will likely find
these variables to be indispensible administrative tools.
.P
The DCE control program provides several convenience variables that
substitute for previously entered information or command output.  All of
the convenience variables begin with a _ (underscore) to leave
1-character variable names free for other uses. 
.P
The following sections describe the convenience variables.  Their order
of presentation generally keeps similar or related variables together.
.H 3 "Current Principal (User) Name (_u)" 
.P
.iX "convenience variables" "current principal name"
The \*L_u\*O convenience variable holds the current simple principal
name.  The DCE control program sets this variable from the login
context inherited from the parent process.  You can change its value
by performing another \*Llogin\*O operation.  Setting it using
\*Lset\*O generates an error.
.oS
dcecp> \*Lputs $_u\*C
cell_admin
dcecp> 
.oE
.P
A practical use of this variable could be in scripts that test for a
certain DCE identity before proceeding.  On finding an incorrect
identity, scripts could prompt for the necessary identity information
and perform a \*Ldce_login\*O operation. 
.P
See the cell name variable description in Section 2.6.2 for
information about composing fully qualified principal names.
.H 3 "Current Cell Name (_c)" 
.P
.iX "convenience variables" "current cell name"
The \*L_c\*O convenience variable holds the name of the cell in which
the principal is registered.  The DCE control program sets this
variable from the login context inherited from the parent process.  You
can change its value by performing another \*Llogin\*O operation.
Setting it using \*Lset\*O generates an error.
.oS
.ne 3
dcecp> \*Lputs $_c\*C
/.../my_cell.goodco.com
dcecp>
.oE
This variable is generally useful in environments where administrators
deal with multiple cells.  For example, you could use the \*L_c\*O
variable as a building block in constructing the current context's
fully qualified principal name for use in scripts.  Join the
cell name and user name variables together with a / (slash)
as shown in the following example:
.oS
dcecp> \*Lputs $_c/$_u\*C
/.../my_cell.goodco.com/cell_admin
dcecp> 
.oE
.H 3 "Current Host Name (_h)" 
.P
.iX "convenience variables" "current host name"
The \*L_h\*O convenience variable holds the DCE name of the current
host.  The DCE control program sets this variable when \*Ldcecp\*O is
invoked.  Setting it using \*Lset\*O generates an error.
.oS
dcecp> \*Lputs $_h\*C
hosts/planets
dcecp>
.oE
.P
The \*L_h\*O variable is useful for returning the name of the host to
an interactive user.  You can also use it with the \*L_c\*O variable,
as shown, to construct names such as a host principal name in a script:
.oS
dcecp> \*Lputs $_c/$_h/self\*C
/.../my_cell.goodco.com/hosts/planets/self
dcecp>
.oE
.H 3 "Most Recent Operation Argument Name (_n)" 
.P
.iX "convenience variables" "most recent argument"
The \*L_n\*O variable holds the name or names used as an argument to
the most recent control program operation.  Most \*Ldcecp\*O
objects take a name or a list of names as an argument.  Those that
do not use names as an argument include 
the miscellaneous \*Ldcecp\*O commands \*Ldcecp_initInterp\*O, 
\*Llogin\*O, \*Llogout\*O, \*Lerrtext\*O, \*Lquit\*O, \*Lresolve\*O, 
and \*Lshell\*O.
.P
The name is usually the third argument in a \*Ldcecp\*O operation, as
shown in the following \*Ldirectory\*O operation:
.oS
dcecp> \*Ldirectory create /.:/sales/printers/text_printers\*C
dcecp>
.oE
.P
Once set, you can use \*L$_n\*O in subsequent operations in place of
the name argument.  For example, you could modify a directory
attribute for the \*L/.:/sales/printers/text_printers\*O directory
created in the preceding example, as follows: 
.oS
dcecp> \*Ldirectory mod $_n -change {CDS_Convergence low}\*C
dcecp> 
.oE
.P
The \*L_n\*O variable can also hold a list of names, as when you
perform a directory service operation on more than one name.  For
instance, you could create several directories and then decide to
modify an attribute: 
.oS
dcecp> \*Ldirectory create { \*C
> \*L/.:/sales/printers/text_printers\*C
> \*L/.:/sales/printers/graphics_printers\*C
> \*L/.:/sales/printers/colorgraphics_printers }\*C
dcecp> 
.oE
.P
A subsequent directory service operation can simply use the \*L_n\*O
variable in place of the name or list of names:
.oS
dcecp> \*Ldirectory modify $_n -change {CDS_convergence high}\*C
dcecp>
.oE
.H 3 "Parent of _n (_p)" 
.P
.iX "convenience variables" "parent of last argument"
The \*L_p\*O variable holds the parent of the name stored in \*L_n\*O.
The \*L_n\*O variable holds the name or list of names used in the
argument to the most recent operation (see Section 2.6.4).  The
\*L_p\*O variable holds the name or list of names that are
hierarchically above the name in \*L_n\*O (closer to the cell root).
.P
One use of the \*L_p\*O variable is in traversing up a CDS hierarchy
of directories.  Another use is showing the \*Vaccess control
list\*O (ACL) of a parent object.  The following operations
view the ACLs of a server configuration object and of its parent
object (\*L/.:/hosts/krypton/config/srvrconf\*O):
.oS
dcecp> \*Lacl show /.:/hosts/krypton/config/srvrconf/video_clip\*C
{appl_admin cdfrwx}
{unauthenticated r}
{any_other r}
dcecp>
dcecp> \*Lputs $_p\*C
/.:/hosts/krypton/config/srvrconf
dcecp>
dcecp> \*Lacl show $_p\*C
{appl_admin criI}
{unauthenticated r}
{any_other r}
dcecp>
.oE
.H 3 "Last dcecp Object Name (_o)" 
.P
.iX "convenience variables" "most recent object name"
The \*L_o\*O variable holds the name of the \*Ldcecp\*O object used in
the most recent operation.  The following example uses the \*L_o\*O variable
to avoid retyping \*Laccount\*O:
.oS
.ne 14
dcecp> \*Laccount show j_wanders \*C
{acctvalid yes}
{client yes}
 .
 .   \*C[output omitted]\*C
 .
{home /}
 .
 .   \*C[output omitted]\*C
 .
{shell {}}
{stdtgtauth yes}
dcecp> \*L$_o modify j_wanders -home /.:/fs/corporate_services/users/j_wanders\*C
dcecp> 
.oE
.H 3 "Last Operation's Return Value (_r)" 
.P
.iX "convenience variables" "most recent return value"
The \*L_r\*O variable holds the return value of the most recent
operation.  Many \*Ldcecp\*O commands return multiple lines of output
which are in the form of a list.
.P
The following example shows one use of the \*L_r\*O convenience
variable.  The \*Ldts show\*O command returns multiple lines as a
list.  The \*Lattrlist getvalues\*O operation (see the \*Lattrlist(8dce)\*O
reference page) searches through the returned list for the string
\*Ltoofewservers\*O and returns its associated value.
.oS
dcecp> \*Ldts show -counters\*C
{creationtime 1994-09-16-07:50:13.067-04:00I-----}
{nointersections 0}
{nointersections 0}
{diffepochs 0}
{toofewservers 1}
{providertimeouts 82}
{badprotocols 0}
{badtimerep 0}
{noglobals 81}
{noresponses 0}
{abrupts 0}
{epochchanges 0}
{syserrors 0}
{syncs 1574}
{updates 0}
{enables 1}
{disables 0}
{nomemories 0}
{providerfailures 0}
{badlocalservers 0}
{badservers 0}
dcecp> \*Lattrlist getvalues $_r -type toofewservers\*C
1
dcecp> 
.oE
.H 3 "DCE Servers to Use (_s(xxx))"
.P
.iX "convenience variables" "DCE server names"
The \*L_s(\*Vxxx\*L)\*O variables hold the names of the DCE servers to
use for the next DCE operation.  The DCE control program provides four
of these variables.  Because the variables are not set by 
\*Ldcecp\*O, users must set these variables if they want to
use them.  The variables are as follows:
.VL
.LI "\*L_s(sec)\*O"
This variable holds the name of the security server you want to use
for the next registry operation.  If you set this to specify a
read-only replica and the operation (such as \*Lprincipal create\*O)
requires a master replica, \*Ldcecp\*O ignores the
variable and tries to bind to the master registry.  Registry operations
that use the \*L_s(sec)\*O variable include \*Lprincipal\*O,
\*Lgroup\*O, \*Lorganization\*O, \*Lregistry\*O, \*Laccount\*O, and
\*Lxattrschema\*O.
.P
DCE control program operations use the \*L_s(sec)\*O variable in
conjunction with the \*L_b(sec)\*O variable, which holds the name of
the most recent registry used.  A \*Lregistry\*O operation uses the
following order to select a security server:
.AL
.LI
Use the server passed as a name argument to the \*Lregistry\*O
operation.
.LI
If the operation lacks a name argument, use the server named in the
\*L_s(sec)\*O variable.
.LI
If the\*L_s(sec)\*O variable has not been set, use the server named in
the \*L_b(sec)\*O variable. 
.LI
If the\*L_b(sec)\*O variable has not been set (that is, this is the
first \*Lregistry\*O operation since \*Ldcecp\*O was
initialized), the service provides an arbitrary server that is
suitable for the operation.
.LE
.LI "\*L_s(cds)\*O"
This variable holds the name of the CDS server you want to use for the
next directory service operation.  When set, CDS operations 
attempt to use the specified server.  The operation fails if the
attempt is unsuccessful \*(Em such as when the server is unavailable
for some reason.  To overcome such a failure, you must \*Lunset\*O this
variable or make the server available.
.P
It makes sense to use the \*L_s(cds)\*O variable when all of your
application needs can be satisfied by the clearinghouse named in the
variable.  Consider not using the \*L_s(cds)\*O variable when name lookups in
CDS are likely to traverse directories in several clearinghouses.  In
this case, you'll get lookup errors because the \*L_s(cds)\*O variable
limits the lookup operation to using just the named clearinghouse.
.LI "\*L_s(dts)\*O"
This variable holds the name of the DTS server you want to use
for the next time service operation.  When set, DTS operations
attempt to use the specified server.  The operation fails if the
attempt is unsuccessful \*(Em such as when the server is unavailable
for some reason.  To overcome such a failure, you must \*Lunset\*O this
variable or make the server available.
.P
One use of this variable is to restrict DTS operations to a single DTS
server for monitoring purposes.  Normally, time service operations can
use any available DTS server.
.LI "\*L_s(aud)\*O"
This variable holds the name of the audit daemon you want to use for
the audit operation.  By default, audit operations affect the local
host's audit daemon.  You can operate on a remote host's audit daemon
by specifying its name as the value of the \*L_s(aud)\*O variable, as
follows:
.oS
dcecp> \*Lset _s(aud) /.:/hosts/planets/audit-server\*C
/.:/hosts/planets/audit-server
dcecp>
.oE
.P
.ne 5
When \*L_s(aud)\*O is set, audit operations attempts to use the
specified audit daemon.  The operation fails if the attempt is
unsuccessful \*(Em such as when the specified audit daemon is
unavailable for some reason.  To overcome such a failure, you must
\*Lunset\*O this variable or make the audit daemon available.
.LE
.P
You can specify a DCE server or audit daemon as any of the following:
.zA "def,13575,R1.2.2,Fixes to misc dcecp items"
.ML
.LI 
A DCE name.  An example of a global registry name is 
\*L/.../my_cell.goodco.com/subsys/dce/sec/oddball\*O. 
An example of a cell-relative CDS clearinghouse name is 
\*L/.:/Paris_CH\*O. 
.LI
The string binding for the host where the server resides.  String
bindings can represent security servers, DTS servers, and audit
daemons.  They cannot represent CDS servers.  An example of a string
binding is \*L{ncacn_ip_tcp 110.15.22.131}\*O.  The DCE control program
resolves the binding to the appropriate service on the host.
.LI
The name of the cell. For a remote cell, specify a global cell name, for 
example
\*L/.../my_cell.goodco.com\*O.  For the local cell you can specify the root
as \*L/.:\*O.  These operations use an arbitrary server that is
suitable for the operation.
.LE
...\" .P
...\" It makes sense to use the \*V_s(cds)\*O variable when all of your
...\" application needs can be satisfied by the clearinghouse named in the
...\" variable.  Consider not using the \*V_s(cds)\*O variable when name lookups in
...\" CDS are likely to traverse directories in several clearinghouses.  In
...\" this case, you'll get lookup errors because the \*V_s(cds)\*O variable
...\" limits the lookup operation to using just this one clearinghouse.  The
...\" following example shows how to proceed when you get a lookup error
...\" because the clearinghouse in \*V_s(cds)\*O can't satisfy a request. 
...\" .oS
...\" PSEUDOCODE FOR NOW...
...\" dcecp> \*Llookup using $_s\*C
...\" if error 
...\" dcecp> \*Lunset $_s(cds)\*C
...\" dcecp> \*Llookup without using $_s(cds)\*C
...\" dcecp> 
...\" .oE
...\" .P
...\" You can specify the \*V_s(sec)\*O variable using the \*Lset\*O command
...\" to name the security service replica you want to use.  Any of the
...\" following methods can set an \*V_s(sec)\*O variable:
...\" .VL 30
...\" .LI "\*Lset s(sec) /.:/subsys/DCE/sec/master\*O"
...\" specifying a cell-relative replica name.
...\" .LI "\*Lset s(sec) /.../subsys/DCE/sec/oddjob\*O"
...\" specifying a replica's global name.
...\" .LI "\*Lset s(sec) ncacn_ip_tcp:110.15.22.131\*O"
...\" specifying the binding to a system with the desired replica.
...\" .LI "\*Lwhat's the other method?\*O"
...\" What's this method?
...\" .LE
...\" .P
...\" The _s(sec) convenience variable is more forgiving than \*V_s(cds)\*O,
...\" treating the security server named in the variable as the
...\" \*Vdefault\*O security server.  Let's say you've performed several
...\" requests from a read-only secondary security server replica but now
...\" you make a write request.  Even though the write request fails at the
...\" read-only server, the DCE daemon automatically resends your request to
...\" the master replica which accepts write requests.
...\" ********
...\" When a request cannot be satisfied by
...\" the server named in the _s(sec) variable, the security request goes to
...\" another security server.
...\" 
...\"  Avoid using the\*V_s(cds)\*O variable when name lookups in CDS
...\" are likely to traverse directories in several clearinghouses.  In this
...\" case, you'll get lookup errors because the _s(cds) variable limits the
...\" lookup operation to using just this one clearinghouse. 
...\" 
...\"   Remember that the information in the
...\" Security Service is not distributed in the same way information is
...\" distributed in CDS.  All of the security information is replicated
...\" (copied) in each server.
...\" 
...\" While this often reduces the time it takes to locate
...\" a CDS server, it can, in some cases, produce an error.  If the CDS
...\" server named by the variable cannot complete the requested operation,
...\" \*Ldcecp\*O returns an error message.  In this case, reissue the CDS command
...\" without using the _s variable.
...\" 
...\" 
...\"   dcecp> directory list /.:/subsys/comm_services/video
...\"   <output from "directory list" command>
...\"   dcecp> directory show $_n
...\" 
...\"         <the output from "directory show">
...\" ========================================================================
...\" HERE'S A LIST OF ALL POSSIBLE _S VARIABLES AND THEIR STATUS
...\" 
...\"       s(cds) absolut_ch  (ALL cds cmds go to absolut_ch)
...\"       s(sec)  - if next cmd needs master registry, then...?
...\"   ?   s(dts)  - I think this seems straightforward
...\"   *   s(epmap) - is there one for this?
...\"   no  s(acl) - is there one for this?
...\"   *   s(keytab) - is there one for this (Spec 8.15 says it's local only)
...\"   *   s(server) - is there one for this?
...\" 
...\" _____________
...\" ? = DTS supports lcl ops only (for now) 1.1 DCED might support remote
...\"     ops, talk w/ howard later
...\" 
...\" * = Depends on how DCED shapes up in 1.1. Talk w/ howard later.
...\" 
...\" no  Acl server not stored
...\" ========================================================================
.H 3 "Last Security Server Used (_b(sec))" 
.P
.iX "convenience variables" "last security server used"
The \*L_b(sec)\*O convenience variable holds the name of the security
server used for the most recent \*Lregistry\*O operation.  The
DCE control program sets this variable based on previous registry
operations.  Consequently, users can view, but not set, this variable.
.P
One reason to read the value of this variable is to check which
registry performed the most recent operation as shown in the following
example: 
.oS
dcecp> \*Lputs $_b(sec)\*C
/.../my_cell.goodco.com/subsys/dce/sec/oddball
dcecp> 
.oE
.P
Registry operations use the value of the \*L_b(sec)\*O variable in
conjunction with the value of the \*L_s(sec)\*O variable to determine
which security server to use.  Refer to Section 2.6.8 for information
about the \*L_s(sec)\*O variable and how these values work together
for registry operations.
.H 3 "Most Recent Error Code (_e)
.P
.iX "convenience variables" "most recent error code"
The \*L_e\*O convenience variable holds the last DCE error code encountered.
If the DCE control program can determine what the error code is, this variable
is set. If an actual error code is unknown, the variable is set to \*L-1\*O 
(negative one).
.H 3 "CDS Confidence Level (_conf)
.P
.iX "convenience variables" "CDS confidence level"
The \*L_conf\*O convenience variable indicates the confidence you have in the 
local CDS daemon to fulfill requests. It alters the behavior of most commands 
that operate on a CDS object.
A confidence level can be \*Llow\*O, \*Lmedium\*O, and \*Lhigh\*O.
.zZ "def,13575,R1.2.2,Fixes to misc dcecp items"
.H 2 "Measuring and Counting with Expressions"
.iX "DCE control program language" "expressions"
.iX "DCE control program language" "mathematic functions"
.iX "mathmatical functions in \*Ldcecp\*O"
.iX "arithmetic functions in \*Ldcecp\*O"
.P  
The \*Lexpr\*O command offers flexible ways to express and use
arithmetic functions in your scripts.  Expressions are useful for
things like comparing numeric information such as the number of
elements in a list, setting thresholds for monitoring purposes,
incrementing counters that control your script's execution, and
producing statistical information.
.P  
A simple \*Ldcecp\*O expression is a combination of an operator like
\*L+\*O (add) or \*L*\*O (multiply) and some operands.  The \*Lexpr\*O
command takes one argument\(emthe expression\(emso parentheses or
braces may be needed if your expression has spaces.  Use parentheses
to control grouping in expressions.  Expressions can also be nested.
All of the following are valid expressions:
.oS
dcecp> \*Lexpr {2 + 3}\*C
5
dcecp> \*Lexpr 2+3\*C
5
dcecp> \*Lset x 24\*C
24
dcecp> \*Lexpr ($x-8)*2\*C
32
dcecp> \*Lexpr $x-(8*2)\*C
8
dcecp> \*Lexpr $x-8*2\*C
8
dcecp> 
.oE
.P  
Be careful using variables in expressions; variables like \*L$x\*O 
must be numeric strings like 24, not nonnumeric strings like 4*6. 
.P  
The DCE control program normally treats numbers as decimal integers,
but can read numbers in octal and hexadecimal formats too.
Precede a number with 0 (zero) for octal interpretation, as in 0477. Precede a
number with 0x for hexadecimal interpretation, as in 0x9FF.  You can
also represent numbers in floating-point format by using any of the forms
specified by the ANSI C standard (with the exception of the f, F, l,
and L suffixes). 
.P  
The DCE control program also supports numerous mathematical functions
in expressions such as cos, exp, log, tan, sin, and others, by
invoking the C math library functions of the same name.
.P
Here's a partial list of operators you can use with the \*Lexpr\*O
command.  The list order also denotes precedence.  This means, for
instance, that \*Lexpr\*O multiplies before adding (2+2*4 equals 10).
.P
.TS
center, tab(@);
lb l.
-@unary minus
~@bitwise NOT
!@logical NOT
*@multiply
/@divide
%@remainder
+@add
-@subtract
<<@left shift
>>@right shift 
<@Boolean less than
<=@Boolean less than or equal
>@Boolean greater than
>=@Boolean greater than or equal
==@Boolean equal
!=@not equal
&@bitwise AND
^@bitwise exclusive OR
|@bitwise OR
&&@logical AND
||@logical OR
\*Va\*L?\*Vb\*L:\*Vc@if-then-else (as in C).
.TE
.H 2 "Operating on Lists"
.P  
.iX "DCE control program language" "lists"
.iX "lists in \*Ldcecp\*O"
Lists provide convenient ways to operate on collections of things such
as sets of principals, group members, or other objects.  Lists are
collections of objects entered by you or returned from commands.
We've already seen lists in previous examples in this
chapter; they're any number of elements separated by spaces, tabs, or
newlines.  Usually, a list is enclosed in braces.  
.P
.ne 4
All of the following are examples of lists:
.oS
.ne 2
{n_long l_jones p_sawyer d_witt m_dougherty s_preska}

{{/.:/hosts} {/.:/subsys}}
.oE
.P  
The DCE control program relies on lists to group elements so they can
be correctly parsed by the \*Ldcecp\*O command interpreter.  For
example, the set command takes two arguments:
.iS
set \*VvarName value
.iE
.P  
The following \*Lset\*O command can't be correctly parsed because \*Ldcecp\*O
detects a third argument:
.oS
dcecp> \*Lset a John Hunter\*C
Error: wrong # args: should be "set varName ?newValue?"
dcecp> 
.oE
.P  
Use braces, quotes, or backslashes to create a valid list, as follows:
.oS
dcecp> \*Lset a {John Hunter}\*C
John Hunter
dcecp> \*Lset a "John Hunter"\*C
John Hunter
dcecp> \*Lset a John\\ Hunter\*C
John Hunter
dcecp>
.oE
.P
The commands that operate on lists provide convenient ways to
evaluate, select, and act on individual elements or groups of elements
in a list.  The DCE control program provides a comprehensive set of
commands that let you create, modify, search, sort, and convert to and
from lists.
.P  
For example, the following script returns the last element in a list.
The \*Lllength\*O command returns the number of elements in the list.
Our list has four elements so \*Lllength\*O returns \*L4\*O. The 
DCE control
program numbers the elements from left to right starting with \*L0\*O
(zero) so our
list with three elements has elements numbered \*L0\*O, \*L1\*O, 
\*L2\*O, and \*L3\*O. The
value of variable \*Vc\*O is set to the number of the last element in the
list (3).  Finally the \*Llindex\*O command returns element 2 (\*Lf\*O).
.oS
.ne 9
dcecp> \*Lset a {a b {c d e} f}\*C
a b {c d e} f
dcecp> \*Lset b [llength $a]\*C
4
dcecp> \*Lset c [expr $b-1]\*C
3
dcecp> \*Llindex $a $c\*C
f
dcecp> 
.oE
.P
The DCE control program provides numerous commands for working with
lists.  You can join lists together using the \*Lconcat\*O command.
Use \*Llinsert\*O to add elements to an existing list.  Extract a range
of elements by using \*Llrange\*O, replace elements in a list with
\*Llreplace\*O, and sort list elements in alphabetical (dictionary)
order by using \*Llsort\*O.  The DCE control program also includes an
\*Lattrlist\*O object (see \*Lattrlist(8dce)\*O for use in
manipulating list elements.
.P
Here's an example that lists all child directories in a tree in
alphabetic order. The \*L_r\*O variable
is a \*Ldcecp\*O convenience variable that
holds the output of the last command.  In this case, \*L_r\*O holds
the list of directories returned by the \*Ldirectory list -simple\*O
command.
.oS
dcecp> \*Ldirectory list -simple /.:\*C
hosts subsys cell-profile fs lan-profile planets_ch sec sec-v1
dcecp> \*Llsort $_r\*C
cell-profile fs hosts lan-profile planets_ch sec sec-v1 subsys
dcecp>
.oE
.H 2 "Controlling Scripts"
.P  
.iX "DCE control program language" "controlling scripts"
The DCE control program provides several commands for controlling your
script's execution.  Commands such as \*Lif\*O, \*Lwhile\*O, \*Lfor\*O,
\*Lforeach\*O, and \*Lcase\*O execute parts of scripts under various conditions.
The \*Lbreak\*O and \*Lcontinue\*O commands can stop execution of part or
all of a command script.
.H 3 "Conditionalizing with if Statements "
.P  
.iX "DCE control program language" "conditional \*Lif\*O statements"
.iX "\*Lif\*O statements in \*Ldcecp\*O"
Sometimes, you'll want part of your script to execute only under
certain conditions.  Use an \*Lif\*O statement to detect a condition
and conditionally perform some operation.  The syntax for an \*Lif\*O
statement is
.iS
if \*Vtest true_body\*L else \*Vfalse_body
.iE
.P
Let's say you're writing a script that searches through a list of
attributes for a particular attribute.  An \*Lif\*O statement could
take particular actions depending on whether an attribute exists.  The
following example script fragment returns an error message if the
account name does not exist in the \*Llist_of_group_entries\*O variable:
.oS
set list_of_group_entries [group list $group -simplename]
if { [lsearch $list_of_group_entries $account_name] == -1} {
     group add $group -member $account_name
} else {
error "Group \\"$group\\" already has an entry \\
  for \\"$account_name\\"."
}
.oE
.H 3 "Controlling Script Execution with Loops"
.P  
.iX "DCE control program language" "loops" 
.iX "loops in \*Ldcecp\*O"
Programming languages use loops to repeat operations as long as
specified conditions exist.  The DCE control program offers three kinds
of loops: \*Lforeach\*O, \*Lwhile\*O, and \*Lfor\*O.  The type of loop you
use depends on the way conditions are specified.
.H 4 "The \*Lforeach\*O Loop"
.P
.iX "DCE control program language" "loops" "\*Lforeach\*O" 
.iX "loops in \*Ldcecp\*O" "\*Lforeach\*O"
When you want to perform a given operation on each element in a list,
use the \*Lforeach\*O command.  Remember that a list is a colletion of
objects, or things enetered by you or returned from a command. 
.P
.ne 3 
The syntax is
.iS
foreach \*Vvariable_name list body 
.iE
.P  
The \*Lforeach\*O command consists of a list, a script body, and a variable
that represents each element of the list, in turn.  The command
runs the script body on the element represented by the variable and
then sets the variable to be the next element in the list.
.P
The following sample \*Lforeach\*O command could be part of a script that
manages hosts in a DCE cell.  This script fragment removes the host
principal name from the registry if a failure occurs while configuring
the host in the cell.  The \*Lforeach\*O command looks at each
principal name in the cell.  If the \*Lstring\*O commands find the
host name listed in the output from \*Lprincipal catalog\*O, the script
deletes the principal name from the registry.
.oS
foreach princ [principal catalog -simplename] {
    if {[string match $host_name [string range $princ 0 \\
        [expr [string length $host_name] - 1]]] == 1} {
        principal delete $princ
    }
}
.oE
.P
.ne 7
Keep in mind that loops return their results to the interpreter, not
to \*Lstdout\*O.  You need to take extra steps to send the results to
\*Lstdout\*O.  The next example uses a \*Lputs\*O command to send the
results of the \*Lforeach\*O loop to \*Lstdout\*O:
.oS
foreach i [group list subsys/dce/dts-servers] { 
    puts [principal show $i] 
}
.oE
.P
.ne 8
You can also \*Lappend\*O all the results together into a variable in
a script, or you can use \*Llappend\*O to append the results as
separate list elements, as follows:
.oS
foreach i [group list subsys/dce/dts-servers] {
  append result [principal show $i]
}
return $result
.oE
.H 4 "The \*Lwhile\*O Loop"
.P
.iX "DCE control program language" "loops" "\*Lwhile\*O" 
.iX "loops in \*Ldcecp\*O" "\*Lwhile\*O"
The \*Lwhile\*O loop behaves like the \*Lwhile\*O loop in C.  It takes two
arguments: an expression and a script (called the \*Vbody\*O).  When the
expression evaluates to nonzero, the \*Lwhile\*O command executes the body
and then reevaluates the expression, continuing the loop until the
expression evaluates to 0.  The syntax for a \*Lwhile\*O loop is
.iS
while \*Vexpression body
.iE
.P
The following example procedure uses a \*Lwhile\*O loop to search
through each element in a list for a pattern.  As long as the list
size contains more than zero elements (\*L$size > 0\*O), the procedure
continues looping.
.oS
.ne 15
proc _dcp_list_find {search_list pattern} {
  
  set found_items ""
  set size [llength $search_list]

  while { $size > 0 } {
    set size [expr $size - 1]
    set index [lsearch $search_list $pattern]
    if { $index == -1 } {
      return $found_items
    }
    lappend found_items [lindex $search_list $index] 
    set search_list [lreplace $search_list $index $index]
  }
}
.oE
.H 4 "The \*Lfor\*O Loop"
.P
.iX "DCE control program language" "loops" "\*Lfor\*O" 
.iX "loops in \*Ldcecp\*O" "\*Lfor\*O"
The \*Lfor\*O loop also behaves just like its C counterpart.  Although
\*Lfor\*O is more complex than its sibling \*Lwhile\*O, \*Lfor\*O
keeps all of the loop control information together, making it easier
to see what's going on.  The \*Lfor\*O command syntax is
.iS
for \*Vinitial_expression test reinit script_body 
.iE
.P
To use \*Lfor\*O, set an initial expression and then test for that
condition before executing the script body.  After executing the
script body, the \*Lfor\*O command reinitializes the initial
expression and again tests for the new value, repeating the loop
until the test becomes false.
.P  
The following example shows a \*Lfor\*O loop that performs an operation a
specified number of times and stops.  In this example, we create 50
guest principal names in the registry.
.oS
dcecp> \*Lfor {set i 0} {$i < 50} {incr i} {\*C
> \*Lprincipal create guest$i\*C          
> \*L}\*C
dcecp> 
.oE
.H 3 "Terminating Loops with continue and break"
.P  
.iX "DCE control program language" "loops" "\*Lterminating\*O" 
.iX "loops in \*Ldcecp\*O" "\*Lterminating\*O"
The \*Lcontinue\*O and \*Lbreak\*O commands terminate loops started
with the \*Lwhile\*O, \*Lfor\*O, and \*Lforeach\*O commands. 
.P  
Use the \*Lcontinue\*O command to terminate the current iteration of a
loop.  For instance, your loop can test for, and selectively ignore,
particular elements in a list while continuing to operate on the rest
of the elements.  Use the \*Lbreak\*O command to immediately terminate
loop execution. 
.P
The following example script fragment is a \*Lforeach\*O command loop
that includes \*Lcontinue\*O and \*Lbreak\*O commands.  The
\*Lforeach\*O command looks through all the DTS servers in a cell
until it finds one that is a time-provider.  (A time-provider is a
special DTS server that receives time from an external time source.)
If the first server in the list (created by the \*Ldts catalog\*O
operation) returns output from a \*Ldts show\*O operation, the
\*Lcontinue\*O command invokes the next lines in the script which
search the output for the \*L{provider yes}\*O attribute and value.  If
the \*Lprovider\*O attribute (examined by the \*Lattrlist getval\*O
operation) is \*Lyes\*O, the script sets the \*Lserver\*O variable to
be the name of that DTS server, and the \*Lbreak\*O command terminates
the entire \*Lforeach\*O loop.
.oS
.ne 12
foreach s [dts catalog] {
    if {[catch {dts show $s} dts_sh_out] != 0} {
         continue
    }
    set p [attrlist getval $dts_sh_out -type provider]
    if {[string match $p "yes"] == 1} {
        set provider "yes"
        set server $s
        break
    }
set provider "no"
}
.oE
.H 3 "Testing with Patterns Before Execution with case" 
.P  
.iX "DCE control program language" "pattern matching"
.iX "pattern matching in \*Ldcecp\*O"
Some commands return a list such as a list of objects in a directory
or a list of servers running on a host system.  You can use the
\*Lcase\*O command to test a list or string for specific patterns such
as the name of a particular object or server.  On detecting a specified
pattern, the \*Lcase\*O command then executes a script associated with the
pattern detected.  The syntax for the \*Lcase\*O command is
.iS
case \*Vstring\*L in \*Vpattern\*O {\*Vscript\*L} \*Vpattern\*O {\*Vscript\*L}
.iE
.P  
The \*Lcase\*O command looks in \*Vstring\*O for \*Vpattern\*O and executes
{\*Vscript\*O}.  The word \*Lin\*O may be omitted.
The following example illustrates how the \*Lcase\*O command works:
.oS
dcecp> \*Lset x {one ten twenty}\*C
one ten twenty
dcecp> \*Lforeach el $x {case $el in one {puts script1} two {puts script2}}\*C
script1
dcecp> 
.oE
.P  
The \*Lcase\*O command first checks in \*L$x\*O for the \*Vpattern\*O
\*Lone\*O.  On finding this pattern, the associated script echoes 
\*Lscript 1\*O on the display.  When it finds no more matches, the 
\*Lcase\*O command ends.
.P  
.ne 4
For a more practical example, say you run a \*Ldcecp\*O command that
lists all the servers on a particular system.  You could search the
list for particular server names and execute a script that appends
each name to a particular file, as follows:
.oS
.ps 11
case $x in server1 {lappend filename1} server2 {lappend filename2} 
.ps 12
.oE
.P  
If your list of patterns is lengthy and likely to break across lines,
you can prevent newlines from being interpreted as separators by
enclosing the entire list of target patterns and scripts in braces.
This has the additional benefit of preventing variable and command
substitutions in the braced list. 
.P
Patterns can include wildcard characters.  A ? (question mark) in a
search pattern matches any single character in the target
pattern.  For instance, \*L?at\*O matches \*Lbat\*O and \*Lhat\*O.  
A * (asterisk) in a pattern matches any string in the target pattern.  
For instance, \*L*at\*O matches both \*Lbat\*O and \*L"three cornered
hat"\*O (note the use of quotes to disable spaces as
separators).
.P  
You might want a way to execute some default script when no pattern
matches are found.  The \*Lcase\*O command has a special pattern called
\*Vdefault\*O whose corresponding script executes when no pattern
match is found.  You should place the default pattern as the last
position in the list:
.oS
case $x in {
  a {puts "script for case a"}
  b {puts "script for case b"}
  default {puts "run this script if no matches are found"}
}
.oE
.H 2 "Creating Commands Dynamically"
.P  
.iX "DCE control program language" "evaluating commands"
.iX "evaluating commands in \*Ldcecp\*O"
The \*Leval\*O command lets you create scripts as you go along by
chaining smaller scripts together.  This technique could be useful in a
script that records administrator responses to various questions and
then constructs a specialized script based on those responses.  The
syntax is
.iS
eval \*Varg\*O ... \*Varg\*O
.iE
.P
The following example uses variables to hold options and their values
for an \*Laccount create\*O operation.  The \*Leval\*O command ensures
that the variables expand and execute properly.
.oS
.ne 10
dcecp> \*Lset mpwd {-mypwd mxyzptlk}\*C
-mypwd mxyzptlk
dcecp> \*Lset pwd {-password change.me}\*C
-password change.me
dcecp> \*Lset org {-organization guests}\*C
-organization guests
dcecp> \*Lset grp {-group guest}\*C
-group guest
dcecp> \*Leval account create guest1 $mpwd $pwd $org $grp\*C
dcecp>
.oE
.P  
.ne 5
Be careful when using variables to construct \*Leval\*O commands.  An
\*Leval\*O command like the following can sometimes cause problems
within scripts because \*Ldcecp\*O parses it twice.  First, \*Ldcecp\*O
parses the \*Leval\*O command and its arguments.  Then it again parses
the \*Leval\*O arguments when they're executed as scripts.
.oS
dcecp> \*Leval $a $b $c \*C
dcecp>
.oE
.P  
You can avoid some parsing problems by placing braces around the
arguments as in this example:
.oS
dcecp> \*Leval {$a $b $c}\*C
dcecp>
.oE
.P  
To make certain \*Ldcecp\*O parses your \*Leval\*O command
correctly, you can invoke the \*Ldcecp\*O \*Llist\*O command to generate a
valid list structure:
.oS
dcecp> \*Leval [list $a $b $c]\*C
dcecp>
.oE
.H 2 "Reading Other Files as dcecp Scripts"
.P  
.iX "DCE control program language" "reading other files"
The \*Lsource\*O command reads the contents of other files, executing
them as \*Ldcecp\*O scripts.  This capability lets you construct higher level
scripts by plugging lower level functions together\(emlike building
blocks.  Because you reuse your scripts rather than duplicate them
with potential variations, scripts are more consistent and easy to
develop and maintain.  The command syntax is
.iS
source \*Vfilename
.iE
.P  
The return value from \*Lsource\*O is the return value from the last
command in \*Vfilename\*O.
.P  
.ne 8
As a practical example, imagine we have one script that lists entries
in CDS subtrees, another script that deletes subtrees, and another
script that moves subtrees.  One common function needed by all these
scripts might be to list every child directory under the root of the
subtree.  You could write a script that lists every child and name it
something like \*Lchildren_list.dcp\*O. (The \*L.dcp\*O extension is a
\*Ldcecp\*O convention for naming script files.) When any of your
scripts need to list all the child directories, simply use the
\*Lsource\*O command:
.iS
source children_list.dcp
.iE
.P  
Terminate a \*Lsource\*O command by using the \*Lreturn\*O command.  The
\*Lreturn\*O command provides a way for commands like \*Lsource\*O and
\*Lproc\*O to exit in a controlled manner, even when expected or
unexpected error conditions occur.  Rather than allow error conditions
to cause the whole script to exit and fail, the \*Lreturn\*O command
manages error information and allows the script to continue executing.   
We discuss the use of \*Lreturn\*O with other error-handling
techniques in Section 2.14.
.H 2 "Creating New Commands"
.P  
.iX "DCE control program language" "creating procedures"
.iX "procedures, creating in \*Ldcecp\*O"
The DCE control program provides a powerful and comprehensive set of
commands for controlling and monitoring DCE operations.  But the exact
uses to which DCE is put by end users is unpredictable.
Consequently, it's quite likely that some administrators will need
additional commands to meet very specific needs.  The \*Lproc\*O
command offers an easy way to create additional commands that look
and behave just like built-in commands such as \*Lset\*O, \*Llist\*O, and
\*Lwhile\*O.  But unlike built-in commands, which are written in C,
commands created with \*Lproc\*O are written using scripts, as follows:
.oS
dcecp> \*Lproc div {x y} {expr $x/$y}\*C
dcecp> 
.oE
.P  
The \*Lproc\*O command takes three arguments: the procedure name, a list of names
of procedure arguments, and the \*Ldcecp\*O script that forms the body
of the new procedure.  Our new procedure \*Ldiv\*O requires two
arguments.  For example:
.oS
.ne 3
dcecp> \*Ldiv 12 4\*C
3
dcecp> 
.oE
.P  
.iX "DCE control program language" "variables" "local and global"
.iX "variables" "local, in \*Ldcecp\*O"
By default, \*Lproc\*O assumes all variables are local variables.  That is,
their names and values are set only within the procedure and they expire
when the procedure completes.  The following command produces an error
because variables \*Vx\*O and \*Vy\*O have not been set within the procedure:
.oS
dcecp> \*Lset x 15\*C
15
dcecp> \*Lset y 3\*C
3
dcecp> \*Lproc div {} {expr $x/$y}\*C
dcecp> \*Ldiv\*C
Error: can't read "x": no such variable
.oE
.P  
.iX "variables" "global, in \*Ldcecp\*O"
You can import global variables (variables defined outside the
procedure) by using the \*Lglobal\*O command:
.oS
.ne 9
dcecp> \*Lset x 15\*C
dcecp> \*Lset y 3\*C
dcecp> \*Lproc div {} {\*C
> \*Lglobal x y \*C
> \*Lexpr $x/$y\*C
> \*L}\*C
dcecp> \*Ldiv\*C
5
dcecp>
.oE
.P  
Once you import a global variable, it persists for the duration of the
procedure.  Your procedure can change the value of the variable by using
\*Lunset\*O and \*Lset\*O.  The new value will be available for use
inside and outside of your procedure, as shown.
.P  
You can use the \*Lreturn\*O command to make your procedure return
immediately.  The value of the argument to \*Lreturn\*O becomes the
procedure's return value. 
.oS
.ne 7
.ps 10
.vs 12
proc find {a} {
    <some pattern matching script that looks for a specific CDS entry>
    if {a != b} {
       return 1
    }
    return 0
}
.ps 12
.vs 14
.oE
.P  
You can design procedures to take either no arguments or variable numbers of
arguments.  For instance, a procedure with no arguments could simply
perform some straightforward operation as in the following example:
.oS
proc _do_create_group {} {
     global rpcgroupname  
     rpcgroup create $rpcgroupname   
}
.oE
.P  
.iX "DCE control program language" "lists" "nested"
.iX "lists in \*Ldcecp\*O" "nested"
.zA "def,13464,R1.2.2,value of proc _attr_show should be unset"
You can also specify a default value for an argument by using a nested list
structure in the argument list.  In the following example, the first
argument, \*Vattr\*O, must be supplied.  The second argument, \*Vvalue\*O,
defaults to \*Lunset\*O if no argument is supplied.
.zZ "def,13464,R1.2.2,value of proc _attr_show should be unset"
.oS
.ne 3
proc _attr_show {attr {value "unset"}}  {
     puts "$attr is $value"
}
.oE
.P  
Procedures can call other
procedures.  The current procedure can
import variables from any calling procedure by using the \*Lupvar\*O
command, as shown:
.iX "DCE control program language" "variables" "importing"
.iX "variables" "importing, in \*Ldcecp\*O" 
.oS
upvar level otherVar1 myVar1 otherVar2 myVar2
.oE
.P  
A \*Vlevel\*O argument of \*L1\*O gets the variable context of the
parent procedure.  An argument of \*L2\*O gets the variable context of
parent's parent procedure.  You can also specify levels relative to the
global context by preceding the \*Vlevel\*O argument with \*L#\*O.  A
\*Vlevel\*O of \*L#0\*O gets global variables.  A \*Vlevel\*O of \*L#1\*O
gets variables from a procedure invoked from the global level.
.P  
The \*LotherVar\*O argument names the variable you want to import.  You
need to include the \*LmyVar\*O argument to rename the variable
for use in the current procedure.  The following example renames the
imported variable to \*Lcargs\*O:
.oS
upvar 1 local_args cargs
.oE
.P 
.iX "procedures, controlling the context of"
Procedures can also execute scripts under the context of parent
procedures by using the \*Luplevel\*O command.  This command offers a
convenient way to manage your procedure's context.  For instance,
rather than import and manipulate numerous variables from a parent
procedure, use \*Luplevel\*O to connect to them all at once.  The
syntax is
.iS
uplevel \*Vlevel arg arg arg
.iE
.P  
The \*Luplevel\*O command is similar to \*Leval\*O; it concatenates
arguments and executes them as scripts but, unlike \*Leval\*O,
\*Luplevel\*O executes the script in the context specified by
\*Vlevel\*O rather than the current context.  The \*Vlevel\*O argument
works the same in \*Luplevel\*O as it does in \*Lupvar\*O.  Use the
parent's context with a \*Vlevel\*O argument of \*L1\*O.  Use the
context of a first-level procedure with a \*Vlevel\*O argument of
\*L#1\*O.
.P  
If a \*Lproc\*O command specifies a command name that is already in effect,
the new procedure replaces the existing procedure with the same name.
Except in unusual cases, you should avoid naming new commands so that
they replace existing built-in commands. 
.P  
.ne 5
You can rename or delete Tcl commands by using the \*Lrename\*O command.
For instance, you could temporarily rename \*Llist\*O to \*Llist.old\*O
and then use \*Lproc\*O to create another command called \*Llist\*O.
When you're through using the manufactured \*Llist\*O command, you could
rename \*Llist old\*O to \*Llist\*O, restoring the original function of
\*Llist\*O as in the following:
.oS
rename list list.old
proc list {} {
     <some list operation>
}
rename list.old list
.oE
.P  
Delete a command by omitting the second argument to the \*Lrename\*O
command.  The following example deletes the \*Llist\*O command:
.oS
rename list 
.oE
.H 2 "String Manipulation"
.iX "DCE control program language" "strings"
.iX "strings in \*Ldcecp\*O"
.P
...\" [TBD]
...\" TALK TO ROBERT COREN ABOUT STR MANIP IN SCRIPTS.
...\" ?? MENTION 'split' AND 'join' TO CONVERT BETWEEN LISTS AND STRINGS
...\" concat and list combine strings to produce lists
Many DCE administrative operations return information of some sort.
For instance, the \*Lprincipal show\*O operation returns information
about a principal.  Usually this information is in the form of a list,
as in the following example:
.oS
dcecp> \*Lprincipal show R_Parsons\*C
{fullname {}}
{uid 15}
{uuid 0000000f-d6f9-21cd-8d00-0000c08adf56}
{alias no}
{quota unlimited}
{groups users}
dcecp> 
.oE
.P
.ne 7
Although it's fairly easy for an administrator to scan a list and
extract the necessary information from it, scripts operate in the
dark, feeling their way through information.  When scripts search for
specific information, they usually ignore the notion of lists,
operating instead on the collection of characters (called a
\*Lstring\*O) that makes up a list.  The DCE control program provides
a set of commands to operate on strings, letting you construct, parse,
compare, extract values from, and modify strings.
.H 3 "Constructing Strings"
.P
.iX "DCE control program language" "strings" "constructing"
.iX "strings in \*Ldcecp\*O" "constructing"
Often, scripts need to construct strings for use in other commands or
for displaying on the screen for users.  The DCE control program
provides a \*Lformat\*O command that you use to construct strings for
use by your script. 
.P
The \*Lformat\*O command substitutes variables where needed.  The
following example constructs the variable \*L_dcp_host_entries\*O
by using the \*Lformat\*O command to prepend the cell name string (the
\*Lstring\*O type is indicated by \*L%s\*O) to the string
\*L/hosts\*O.  The cell name is contained in the \*L_c\*O convenience
variable.
.oS
.ne 3
dcecp> \*Lset _dcp_host_entries [format "%s/hosts" $_c]\*C
/.../my_cell.goodco.com/hosts
dcecp> 
.oE
.P
The \*Lformat\*O command can also convert arguments between differing
forms including decimal, octal, hexadecimal, floating-point, and
scientific notation.  You can also specify to print or omit signs for
signed numbers, right or left justify output, and pad with
spaces or zeroes.  The following examples convert the integer 8 to its
octal equivalent.  The second example shifts the output nine character
spaces to the right.
.oS
dcecp> \*Lformat %1o 8\*C
10
dcecp> \*Lformat %9o 8\*C
       10
dcecp>
.oE
.H 3 "Parsing Strings"
.P
.iX "DCE control program language" "strings" "parsing"
.iX "strings in \*Ldcecp\*O" "parsing"
.iX "parsing" "strings in \*Ldcecp\*O"
The DCE control program includes a \*Lscan\*O command that parses
strings and then converts and stores relevant parts of strings in
variables.  This capability is useful, for instance, when converting
information returned by a previous command into data that can be input
to another command. 
The syntax for the \*Lscan\*O command is as follows:
.iS
scan "\*Vstring\*L"  "\*Vformat\*L"  [\*Vvarname\*L [\*Vvarname\*L]...]
.oE
.P
You can specify the \*Vstring\*O literally or by using a variable.
The \*Vformat\*O section controls parsing, ignoring blanks and tab
characters you might have included in the \*Vformat\*O section for
readability.  This section consists of one or more conversion
specifiers delimited by % (percent sign).  Conversion specifiers
define which parts of \*Vstring\*O get converted and stored, as well
as the type of conversion.  
.P
The following example parses the string contained in the variable
\*L_dcp_temp\*O for a valid floating-point number and stores it in the
variable \*L_dcp_temp2\*O:
.oS
.ne 3
if { [scan $_dcp_temp "%f" _dcp_temp2] != 1 } {
   error "Variable \\"$_dcp_temp\\" is not a \\
     valid floating-point number"
}
.oE
...\" Conversion specifiers have three fields:
...\" .oS
...\" \*C%\*V * field_width conversion_character
...\" .oE
...\" .P 
...\" The optional asterisk (*) and \*Vfield_width\*O fields can be omitted
...\" but the \*Vconversion_character\*O must be included.  To ignore
...\" characters in \*Vstring\*O, use an asterisk {*) and \*Vfield_width\*O
...\" number (and the required \*Vconversion_character\*O) to specify how
...\" many characters to ignore.  Specify the number of characters to
...\" convert by omitting the asterisk and including the \*Vfield_width\*O
...\" number and the required \*Vconversion_character\*O.  You can also
...\" specify characters to include using the \*Vconversion_character\*O
...\" [\*Vcharacters\*O] to name characters to be included or
...\" [^\*Vcharacters\*O] excluded from the input field.
...\" .P
...\" The following example says ignore the first 10 characters
...\" (\*C/.:/hosts/\*O), insert the next characters up to the slash in the
...\" variable host_name, and ignore the last [HELP HERE] characters ...
...\" .oS
...\" \*LAn example that stores "froggy" (or any other hostname between
...\" these backslashes) in the host_name variable.\*O
...\" .oS
...\" \*Cdcecp> \*Lscan /.:/hosts/froggy/event_server %*10d %[^/] %*s host_name\*O
...\" .oE
.H 3 "Other String Handling Operations"
.P
.iX "DCE control program language" "strings" "manipulating"
.iX "strings in \*Ldcecp\*O" "manipulating"
You can specify one character or a range of characters in a string
by using \*Lstring index\*O and \*Lstring range\*O.  These commands would
be useful for extracting information from a string of predictable
length.
.P
The \*Lstring index\*O command has one argument that is the position
of one character (counting from left to right beginning with 0 (zero) 
to be extracted from the string.  The \*Lstring range\*O command
includes two arguments that are the positions of the leftmost and
rightmost characters to be included in the range.  The following
example illustrates one use of the \*Lstring range\*O command:
.oS
dcecp> \*Lstring range {The quick brown fox} 4 9\*O
\*Cquick
dcecp>
.oE
...\" The syntax is 
...\" .oS
...\" \*Cstring index \*Vstring index\*O
...\" .oE
.P
You can determine whether one string is lexicographically
(alphabetically) greater than, less than, or equal to another string
by using \*Lstring compare\*O.  Generally, this operation performs a byte
comparison of ASCII codes that make up the string.
...\" \*Lstring compare\*O
...\" \*Lstring compare\*O
...\" \*Lstring compare\*O
.P
Count the number of characters in a string using the \*Lstring
length\*O command.  Here is an example:
.oS
dcecp> \*Lstring length "The quick brown fox"\*O
\*C19
dcecp>
.oE
.P
Convert characters between uppercase and lowercase by using the \*Lstring
toupper\*O and \*Lstring tolower\*O commands.  Here is an example:
.oS
dcecp> \*Lstring toupper "The quick brown fox"\*C
THE QUICK BROWN FOX
dcecp>
.oE
.P
Trim specific characters from a string by using the \*Lstring trim\*O
command.  Remove the leftmost or rightmost characters from a string
by using the \*Lstring trimleft\*O and \*Lstring trimright\*O commands.
.P
You can perform pattern-matching operations in any of several ways.
Invoke ``glob'' style pattern matching with the \*Lstring match\*O
command.  This mimics the glob pattern matching capabilities available
in \*Lcsh\*O, returning \*L1\*O for a match and \*L0\*O for no match.  More
flexible regular expression pattern matching (like that found in
\*Legrep\*O) can be performed using \*Lregexp\*O command.  You can
extend this operation to perform regular expression substitution by using
the \*Lregsub\*O command.
.P
The following example illustrates the use of the \*Lregsub\*O command.
The first argument specifies the search pattern.  The second argument
is the string to search.  The third argument specifies the replacement
pattern.  The last argument is a variable into which \*Lregsub\*O
places the new string.  The command returns \*L0\*O if no substitution
occurs and \*L1\*O if substitution does occur.
.oS
.ne 4
dcecp> \*Lregsub brown "The quick brown fox" blue color\*C
1
dcecp> \*Lputs $color\*C
The quick blue fox
.oE
.H 2 "Dealing with Errors and Exceptions"
.P  
.iX "DCE control program language" "error handling"
.iX "errors" "handling in \*Ldcecp\*O"
.iX "exceptions" "handling in \*Ldcecp\*O"
.iX "variables" "error information in \*Ldcecp\*O"
The \*Ldcecp\*O interpreter includes error facilities that return
error information when something goes wrong with a \*Ldcecp\*O script.
Error information tells users what went wrong so that they can avoid
making the same mistake in the future.  Many things can cause
\*Ldcecp\*O errors.  For instance, a command might not receive the
correct number of arguments, a command might have a typographic error
of some kind, or the object of an operation (such as a CDS directory)
might be unavailable for some reason.
.P
Here, we discuss three ways of dealing with errors and exceptions:
.ML
.LI
Using global error information variables 
.LI
Catching exceptions
.LI
Reissuing complex errors
.LE
.H 3 "Using Global Error Information Variables" 
.P  
.iX "DCE control program language" "error information"
.iX "variables" "global error information in \*Ldcecp\*O"
When \*Ldcecp\*O encounters an error it prints a descriptive message,
such as:
.oS
Error: wrong # args: should be "set varName ?newValue?"
.oE
.P  
In some cases, error messages may be
insufficient for determining exactly where a problem occurred. So 
\*Ldcecp\*O stores additional error information in a global variable called
\*LerrorInfo\*O.  Your script can access and print this information 
to help you find the error.  Generally, it traces the commands that were executing when the error
occurred.  
.P
.ne 4
The following example shows the kind of information
that can be stored in \*LerrorInfo\*O.  Reading backwards,
you can determine that the error occurred near line 4 of the
script body in the \*Lparseargs\*O procedure called from the
\*L_dcp_create_user\*O procedure of a \*Luser\*O operation.
.oS
dcecp> \*Lputs $errorInfo \*C
Unknown option "group"
    while executing
"
    invoked from within
"
    ("while" body line 4)
    invoked from within
"
    (procedure "parseargs" line 60)
    invoked from within
"
    (procedure "_dcp_create_user" line 64)
    invoked from within
"
    invoked from within
"
    invoked from within
"
    (procedure "user" line 24)
"
dcecp> 
.oE
...\" dcecp> puts $errorInfo 
...\" Unknown option "group"
...\"     while executing
...\" "error "Unknown option \"$argv($i)\"""
...\"     invoked from within
...\" "if { $_dcp_parse_left_over == 1} {
...\"         error "Unknown option \"$argv($i)\""
...\"       } elseif { $_dcp_found_one || !$_dcp_no_leftovers } {
...\"         set _dcp_parse_l ..."
...\"     invoked from within
...\" "if {[llength $_dcp_parse_option] == 0} {
...\"       if { $_dcp_parse_left_over == 1} {
...\"         error "Unknown option \"$argv($i)\""
...\"       } elseif { $_dcp_found_o ..."
...\"     ("while" body line 4)
...\"     invoked from within
...\" "while { $i < $argc } {
...\"     _dcp_parseargs_debug "i = $i, argc = $argc, argv = $argv($i)"
...\"     set _dcp_parse_option [ info locals $argv($i)* ]
...\"     if { ..."
...\"     (procedure "parseargs" line 60)
...\"     invoked from within
...\" "parseargs $arg_table local_args -no_leftovers"
...\"     (procedure "_dcp_create_user" line 64)
...\"     invoked from within
...\" "$function_call local_args"
...\"     invoked from within
...\" "return [$function_call local_args]..."
...\"     invoked from within
...\" "if { [info local function_call ] > 0 } {
...\"     return [$function_call local_args]
...\"   } else {
...\"     error "\"user\" object requires a verb to form a comman ..."
...\"     (procedure "user" line 35)
...\"     invoked from within
...\" "user create foo group bar"
...\"     ("uplevel" body line 1)
...\"     invoked from within
...\" "uplevel $args"
...\"     invoked from within
...\" "return [uplevel $args]..."
...\"     invoked from within
...\" "if $msg {
...\"             return [uplevel $args]
...\"         }"
...\"     invoked from within
...\" "if ![info exists auto_noload] {
...\"         #
...\"         # Make sure we're not trying to load the same proc twice.
...\"         #
...\"         if [info exists unknown_pending($name)] {
...\"             unset ..."
...\"     (procedure "unknown" line 5)
...\"     invoked from within
...\" "user create foo group bar"
...\" dcecp>
...\" .oE
.P  
In addition, \*Ldcecp\*O may store another kind of error information in
another global variable called \*LerrorCode\*O.  This variable
contains a list like the following that can identify other classes of
errors. 
.oS
UNIX, ENOENT, "insufficient arguments for filename"
.oE
.P  
The DCE control program sets the \*LerrorCode\*O variable to NONE if
an error produces no useful error information.
...\" Usually, Tcl errors are produced by the C code that implements the Tcl
...\" interpreter.  However, it's possible to use the Tcl error command to
...\" produce customized error messages as in:
...\" TCL CODE PRODUCING IT'S OWN ERROR MESSAGE
.H 3 "Using catch to Trap Errors and Exceptions"
.P
.iX "DCE control program language" "trapping errors in"
.iX "errors" "trapping in \*Ldcecp\*O"
.iX "exceptions" "trapping in \*Ldcecp\*O"
Occasionally, you might want to trap some kinds of errors rather than
let them terminate an active command.  The \*Lcatch\*O command lets you
trap and ignore errors so your script can continue processing.  Let's
say your script wants to rename a command if it exists.  However, it's
possible that the command name might not exist when you execute the
\*Lrename\*O command.
.oS
dcecp> \*Lrename move move.old\*C
Error: can't rename "move":  command doesn't exist
dcecp>
.oE
.P
Use \*Lcatch\*O to invoke the \*Lrename\*O command as a script.
.oS
dcecp> \*Lcatch {ren move move.old}\*C
1
dcecp>
.oE
.P
The \*Lcatch\*O command treats its argument as a script and executes it,
returning a \*L0\*O on successful execution.  If an error occurs, it is
caught by the \*Lcatch\*O command which returns a \*L1\*O. 
.P
You can add a second argument to the \*Lcatch\*O command.  This
argument is a variable that \*Lcatch\*O modifies to hold the
script's return value (on successful completion) or the error
message.  The syntax for the \*Lcatch\*O command is
.iS
catch \*Vcommand\*O \*VvarName\*O
.iE
.P
One use of \*Lcatch\*O in scripts is to invoke other
procedures.  You can read the following script fragment as follows:
``If the \*L_dcp_create_group\*O procedure returns unsuccessfully (\*L!=
0\*O) then perform the \*L_\%dcp_\%cleanup_\%user_\%create\*O 
procedure and display the error stored in the \*Lmsg\*O variable.''
.oS
.ps 11
.vs 13
if {[ catch {_dcp_create_group $group group_created} msg] != 0 } {
      _dcp_cleanup_user_create $element -principal
      error $msg
}
.ps 12
.vs 14
.oE
.P  
.ne 4
Exceptions are a special class of error generated by the \*Lbreak\*O,
\*Lcontinue\*O, and \*Lreturn\*O commands.  You use the \*Lbreak\*O and
\*Lcontinue\*O commands to terminate loops such as \*Lwhile\*O,
\*Lfor\*O, and \*Lforeach\*O, and you use the \*Lreturn\*O command to
terminate a \*Lproc\*O or \*Lsource\*O command.  
.P
Resulting exceptions can be hard to handle in procedures where loops
exist inside (as part of) a more comprehensive command.  For
instance, a user-written procedure that searches for specific object
types in CDS might invoke \*Lforeach\*O as part of a looping activity
to test for the occurrence of particular attributes.
...\" Some complex scripts include commands or procedures that, in turn,
...\" invoke other commands or other procedures to perform specific
...\" sub-operations.  We refer to a procedure that is invoked within
...\" another procedure as a nested procedure.  We refer to the calling
...\" procedure as the parent procedure.  
...\" THIS PROC USES 'IF' (NOT PROC) AS A NESTED PROCEDURE.  ERGO BAD EXAMPLE
...\" The \*Lfind\*O procedure discussed
...\" previously includes an \*Lif\*O command as an example of a nested
...\" command. 
...\" .oS
...\" proc find {a} {
...\" <some pattern matching script that looks for a specific CDS entry>
...\" if {a != b} {
...\" return 1
...\" }
...\" return 0
...\" }
...\" .oE
...\" 	--------------
...\" Using the proc command, you can create procedures or commands that
...\" perform very complex operations.  For instance, a command called
...\" find_children that searches a CDS directory for all its child
...\" directories could include 'nested' commands or procedures that perform
...\" various subtasks such as looping through directory objects looking for
...\" those with child_pointer attributes.  While use of 'nested' commands or
...\" procedures lets you develop comprehensive procedures or commands, they
...\" introduce a level of complexity that complicates error tracking and
...\" recovery.
...\" 
...\" For instance, a command called find_children
...\" that searches a CDS directory for all its child directories might, in
...\" turn call looping commands or procedures to perform various subtasks
...\" such as looping through directory objects looking for those with
...\" child_pointer attributes.  The use of nested procedures 
...\" .P
...\" Nested procedures can produce exceptions that are all caught by the
...\" parent command which aborts in the prescribed way without writing
...\" error information into the \*VerrorInfo\*O and \*VerrorCode\*O
...\" variables.
.P 
If you use the \*Lbreak\*O, \*Lcontinue\*O, or \*Lreturn\*O commands
to manage loop execution or to manage some other nested command (like
\*Lcase\*O or \*Lif\*O, for example), the parent command will not be
ready to catch the exception.  The parent command will abort and issue
an error message as usual.  However, the error is associated with the
parent command and is difficult to track to the looping command where
it actually occurred.
.P
If it's necessary to use a \*Lcontinue\*O, \*Lbreak\*O, or
\*Lreturn\*O command to terminate a command that has been called by
another command, consider using \*Lcatch\*O to invoke the nested
command which, in turn, calls the \*Lcontinue\*O, \*Lbreak\*O, or
\*Lreturn\*O command to recover from errors or exceptions.  Used this
way, the \*Lcatch\*O command keeps the exception within the looping or
nested procedure where it's easier to track down. 
.oS
foreach s [server catalog] {
    if {[catch {server show $s} srv_sh_out] != 0} {
         continue
    }
.oE
.H 3 "Reissuing Complex Errors"
.P
.iX "DCE control program language" "reissuing errors in"
.iX "errors" "reissuing in \*Ldcecp\*O"
.iX "exceptions" "reissuing in \*Ldcecp\*O"
The \*Lproc\*O command lets you create procedures or commands that
perform very precise operations.  For instance, a user-written
procedure called \*L_dcp_get_servers\*O that retrieves and filters
information about running servers could include \*Vnested\*O commands
or procedures that perform various subtasks such as looping through
server information looking for certain strings.  While use of nested
commands or procedures lets you develop comprehensive procedures or
commands, they can also produce errors that are difficult to pinpoint
if errors aren't passed along properly.
.P
.ne 4
Complex scripts can use the \*Lerror\*O command to reissue errors that
have been triggered by some previously executing part of the script.
The following script fragment simply prints out a hard coded error
message.  This use also lets you custom tailor messages to precisely
explain error conditions.
.oS
set dts_cat_out [_dcp_dts_catalog]
if {[llength $dts_cat_out] == 0} {
    error "Unable to find any DTS servers"
}
.oE
The next script fragment does more, using \*Lcatch\*O to store any
error information returned from the \*L_dcp_create_group\*O procedure
in the \*Lmsg\*O variable.  On failure (\*L!= 0\*O), the script invokes a
cleanup procedure that undoes whatever was done, and then prints out
the message stored in the \*Lmsg\*O variable.
.oS
.ps 11
.vs 13
if {[ catch {_dcp_create_group $group group_created} msg] != 0 } {
      _dcp_cleanup_user_create $element -principal
      error $msg
}
.ps 12
.vs 14
.oE
.P
This discussion has provided some fairly simple error handling
techniques.  Note, though, that error handling can be complicated,
especially in more complex situations.  We encourage you to read more
about error handling in other publications that cover more general use
of Tcl.
...\" Possibly include this section resulting from howard's comment in the
...\" cellalias task object review for ideas on extending the cellalias
...\" object.
...\" 
...\" "dcecp commands by design bon't produce any notices of
...\" progress.  This is so they are easily scriptable.  Add a
...\" -verbose option that displays output as each step is
...\" completed.  This would be most useful to display hostnames
...\" as dce_cf.db is updated as that is likely to take the
...\" longest.  It's better for the messages to be printed on
...\" stdout instead of actually being returned by the command.
...\" This way, they can be displayed as they appen rather than
...\" having to wait for the command to complete until they are
...\" begun to be displayed.  Use the puts command."
...\" 
...\" ********************************************************************** 
...\" .H 2 "Reporting Script Progress"
...\" .P
...\" DCE control program objects like \*Ldirectory\*O, \*Lendpoint\*O, and
...\" \*Lprincipal\*O, do not produce any notices of progress as they
...\" complete parts of operations.  This makes them easy to use in scripts
...\" because the script does not have to suppress, modify or display any
...\" progress messages.  But sometimes you want a script to report its
...\" progress, especially when the script has parts that take a long time
...\" to complete. 
...\" 
...\" Imagine a script that performs some operation on every host in a cell.
...\" If the script waited until the end
...\" 
...\" 	return (arg)   
...\"         puts
...\" 
.H 2 "Working with Files"
.iX "DCE control program language" "files" "working with"
.iX "files" "working with in \*Ldcecp\*O"
.P
The DCE control program has several commands for use in reading from
and writing to files.  Files are useful for things like storing the
output of \*Ldcecp\*O operations for later reference.  Here are several
useful examples of file manipulation:
.ML
.LI
You could run a \*Lserver catalog\*O operation across all of the hosts
in a cell and store the results from each host in a host-specific
file.  Later, you could compare the files to produce a report of
server configurations.
.LI
You could detect inactive accounts by running a \*Ldcecp\*O
script that shows the last time each account was logged into, storing
this information in a file for later evaluation.
.LI
.ne 3
You could also modify DCE files that aren't manipulated easily by using
the \*Ldcecp hostdata\*O object.  For example, you could write a
function that added a new attribute to the \*Lcds_attributes\*O file.
.LE
.P
DCE as provided by OSF currently supports
file operations only for UNIX systems or for systems that
support POSIX system calls.  However, some vendor DCE versions may
support file operations on other systems. 
.H 3 "Specifying Filenames"
.P
.iX "DCE control program language" "files" "specifying names of"
.iX "files" "specifying in \*Ldcecp\*O"
Specify filenames using customary UNIX rules.  For instance,
\*L/opt/dcelocal/dcecp/server_snap.dcecp\*O refers to a file named
\*Lserver_snap.dcecp\*O in a directory called
\*L/opt/dcelocal/dcecp\*O.  You can also refer to files by using relative
filenames, for example \*L~dce_admin/scripts/server_snap.dcecp\*O and
\*L~/admin/server_snap.dcecp\*O.  You can print the current working
directory by using the \*Lpwd\*O command and set the current
working directory by using the \*Lcd\*O command.  The following command
sets the current directory to be \*L~dce_admin/scripts\*O:
.oS
dcecp> \*Lcd ~dce_admin/scripts\*C
dcecp>
.oE
You can view a list of files in a directory by using the \*Lglob\*O
command.  This command returns a list of filenames that match pattern
arguments to the command.  Here is an example:
.oS
dcecp> \*Lglob *\*C 
help local_lib.dcp
dcecp> 
.oE
.P
You can view lots of other information about files by using the
\*Lfile\*O command with various options.  The \*Lfile\*O commands can
help select a file based on its age, its size, or its permissions
(whether it is executable, or readable, or writable by the current
user).
.H 3 "Reading and Writing Files"
.P
.iX "DCE control program language" "files" "reading and writing"
.iX "files" "reading and writing in \*Ldcecp\*O"
The \*Ldcecp\*O commands for reading and writing to files look and act
like their C language counterparts \(Em \*Lfopen\*O, \*Lfclose\*O,
and so on. 
.P
Open a file for reading and writing using the \*Lopen\*O command.  The
second argument to the \*Lopen\*O command (shown in the following
example as \*L+r\*O) specifies the file access mode.  You can open
files for reading, or writing, or both and you can specify whether to
replace existing files or to add to them with new information.  You can
also set the initial access position to the beginning or the end of a
file.  The default access mode is read-only (the file must already
exist).
.oS
dcecp> \*Lopen server_snap.dcecp +r\*C
file5
dcecp>
.oE
.P
The \*Lopen\*O command assigns a file identifier to each file when it
is opened.  Use the file identifier to refer to files in subsequent
commands. 
.P
Once a file is opened, you can add lines to a file by using the
\*Lputs\*O command.  Normally, \*Ldcecp\*O waits until it has
accumulated sufficient data before writing this information to a file.
If you want \*Ldcecp\*O to immediately write the information to a
file, use the \*Lflush\*O command.  Use \*Lgets\*O to read the next
line from a file or use \*Lread\*O to read a number of bytes or all of
the bytes in a file.  The following example writes a list of all
principals in a file named \*Lprins\*O:
.oS
.ne 5
dcecp> \*Lopen prins w+\*C
file8
dcecp> \*Lputs file8 [principal catalog]\*C
dcecp> \*Lclose file8\*C
dcecp>
.oE
.P
.ne 10
Sometimes, you don't want to start reading or writing at the first
line of a file.  The DCE control program provides several commands that
set the access position so you don't have to advance through every
line in the file.  These commands will produce an error if you use
them for devices like terminals or other sequential devices that don't
support random access.  Use the \*Lseek\*O command to set the access
point in a file.  Specify the offset as a number of bytes from the
origin, which can be the beginning or end of the file or the current
position.  Use a negative number to move toward the beginning of the
file, as in the following example which moves back 16 bytes from
the current access position.
.oS
dcecp> \*Lseek file5 -16 current\*C
dcecp>
.oE
You can determine the current access position by using the \*Ltell\*O
command.  Save the return value in a variable so you can go back to
that position in the file later on. 
.P
Finally, you can close a file by using the \*Lclose\*O command, as follows:
.oS
dcecp> \*Lclose file5\*C
dcecp> 
.oE
...\" Hi guys,
...\" 
...\" Right now, I'm working on the Tcl user docs for the DCE Admin Guide
...\" writing a section called "Working With Files". This section discusses
...\" using the Tcl "file" command.  Before talking about "how" to use the
...\" file command, I want talk about "why" someone would use it for dcecp
...\" administrative purposes.  For example, here's one scenario I came up
...\" with.
...\" 
...\"    Administrators could store command results in a file.  They could
...\"    run "server catalog" across several hosts and store results of each
...\"    host in a host-specific file.  Then grep or diff the files to
...\"    produce some statistical report.  Or they could take some further
...\"    operation based on the information in the files. e.g., they could
...\"    stop servers if too many are running.
...\" 
...\" 
...\" JOHN ROUSSEAU:
...\" > You could create a command that would show you the last time each account
...\" > was logged into.  This information could be stored in a file so you could
...\" > later evaluate it to find accounts that are no longer in use.  Or compare
...\" > subsequent reports to see how often accounts were used.
...\" 
...\" 
...\" This scenario is kind of vague.  Can you make it more accurate or
...\" suggest alternative or additional uses for the "file" command? I'll
...\" take email (working at home today) or a phone call at 508 251-8293.
...\" Beware  - if no one calls me, I'll call one of you at random later on
...\" today. 
...\" 
...\" Ward
...\" **********
...\" 
...\" Howard
...\" 
...\" > You could also use the command to modify DCE files that
...\" > aren't manipulated easily via hostdata in dced.  For
...\" > example, you could write a little function that added a new
...\" > attribute to the <dcelocal>/etc/cds_attributes file.
...\" 
...\" Howard
...\" 
...\" 
...\" On Fri May 20, 1994, John Rousseau wrote:
...\" 
...\" > > 
...\" > > Hi guys,
...\" > > 
...\" > > Right now, I'm working on the Tcl user docs for the DCE Admin Guide
...\" > > writing a section called "Working With Files". This section discusses
...\" > > using the Tcl "file" command.  Before talking about "how" to use the
...\" > > file command, I want talk about "why" someone would use it for dcecp
...\" > > administrative purposes.  For example, here's one scenario I came up
...\" > > with.
...\" > > 
...\" > >    Administrators could store command results in a file.  They could
...\" > >    run "server catalog" across several hosts and store results of each
...\" > >    host in a host-specific file.  Then grep or diff the files to
...\" > >    produce some statistical report.  Or they could take some further
...\" > >    operation based on the information in the files. e.g., they could
...\" > >    stop servers if too many are running.
...\" > > 
...\" > > 
...\" > > This scenario is kind of vague.  Can you make it more accurate or
...\" > > suggest alternative or additional uses for the "file" command? I'll
...\" > > take email (working at home today) or a phone call at 508 251-8293.
...\" > > Beware  - if no one calls me, I'll call one of you at random later on
...\" > > today. 
...\" > 
...\" > You could create a command that would show you the last time each account
...\" > was logged into.  This information could be stored in a file so you could
...\" > later evaluate it to find accounts that are no longer in use.  Or compare
...\" > subsequent reports to see how often accounts were used.
...\" > 
...\" > Anything to avoid random calls. :-)
...\" > 
...\" > -John
...\" > 
...\" > 
...\" > -----------------------------------------------------------
...\" > John Rousseau                    Internet: rousseau@osf.org  
...\" > Open Software Foundation           UUCP: uunet!osf!rousseau
...\" > 11 Cambridge Center                  Phone: +1 617 621 7305       
...\" > Cambridge, MA 02142                    Fax: +1 617 225 2943
...\" > -----------------------------------------------------------
.H 2 "Spawning Subprocesses"
.P
.iX "DCE control program language" "subprocesses" "creating"
.iX "subprocesses" "creating in \*Ldcecp\*O"
.iX "operating system commands" "executing from \*Ldcecp\*O"
Using subprocesses to execute commands offers several convenient solutions
to some complex scripting or special administrative needs.  Subprocesses
can provide 
.ML
.LI
Access to operating system commands
.LI
A way to establish synchronous, orderly execution
.LI
Methods for streamlining complex or sophisticated scripts
.LE
.H 3 "Running Operating System Commands from a Script"
.P
Although the DCE control program is versatile, there are times when
you may want your script to use operating system commands to
accomplish some simple (or even not-so-simple) operation.  The
\*Lexec\*O command provides a way for scripts to perform external
commands by forking a subprocess in which the command executes.
The following example uses the \*Lexec\*O command to retrieve the
local host name which is then established as a \*Vhostname\*O variable
and subsequently used in the script.
.oS
dcecp> \*Lset hostname [exec hostname]\*C
myhost
dcecp> \*Ldirectory list /.:/hosts/$hostname -simple \*C
cds-clerk cds-server dts-entity profile self
dcecp> 
.oE
.P 
The \*Lexec\*O command normally returns the results of the operation
performed in the subprocess.  However, you can use UNIX
redirection symbols (<, <<, and >) to redirect standard input or
standard output.  You can also use the | (vertical bar) to
pipe the output through filters such as \*Lnroff\*O, \*Lsort\*O, or
\*Lgrep\*O.  
.P
.ne 10
When used alone, the \*Lexec\*O command is synchronous, meaning that the
external command completes before the script continues executing.
But when a subprocess will take a long time to complete, for instance
when you synchronize directories in a CDS cell, you can use the
\*Lexec\*O command with a & (ampersand) to push a subprocess
into the background.  The following example uses the \*Vexec\*O command to
send previously collected output to a printer.  This lets your script
continue without having to wait for the \*Lprint\*O command to complete.
.oS
dcecp> \*Lexec lpr output.log &\*C
dcecp>
.oE
