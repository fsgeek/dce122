...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" 
...\" 
...\" HISTORY
...\" $Log: appl_admin.gpsml,v $
...\" Revision 1.1.6.4  1996/10/21  15:26:12  wardr
...\" 	{edit,R1.2.2}
...\" 	Update for sgml conversion
...\" 	[1996/10/21  15:25:51  wardr]
...\"
...\" Revision 1.1.6.3  1996/09/19  14:18:05  sherman
...\" 	{def,13575,R1.2.2}
...\" 	Miscellaneous dcecp fixes
...\" 	[1996/09/19  14:17:16  sherman]
...\" 
...\" Revision 1.1.6.2  1996/08/20  20:33:38  wardr
...\" 	{enh,R1.2.2}
...\" 	minor fix
...\" 	[1996/08/20  20:33:20  wardr]
...\" 
...\" Revision 1.1.6.1  1996/08/20  14:32:45  sherman
...\" 	{def,13575,R1.2.2}
...\" 	Miscellaneous dcecp fixes
...\" 	[1996/08/20  14:31:27  sherman]
...\" 
...\" Revision 1.1.4.2  1996/03/12  15:49:11  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/12  15:48:37  wardr]
...\" 
...\" Revision 1.1.4.1  1995/08/14  14:07:17  rosenb
...\" 	{edit R1.2.1}
...\" 	A test of Digital's sandbox
...\" 	[1995/08/14  14:06:33  rosenb]
...\" 
...\" Revision 1.1.2.14  1995/05/25  19:05:49  rcb
...\" 	PRENTICE HALL reformat: final changes
...\" 	[1995/05/25  13:21:36  rcb]
...\" 
...\" 	PRENTICE HALL reformat; minor changes
...\" 	[1995/05/08  17:01:14  rcb]
...\" 
...\" 	1.1 edits: minor addition
...\" 	[1995/05/01  20:01:33  rcb]
...\" 
...\" 	1.1 edit; terminology fix
...\" 	[1995/04/10  18:47:25  rcb]
...\" 
...\" 	PRENTICE HALL reformat -- index entries, odds and ends
...\" 	[1995/03/27  19:49:09  rcb]
...\" 
...\" 	prevented hyphenation of option names
...\" 	[1995/03/09  15:00:12  rcb]
...\" 
...\" 	minor editorial fix: init cap on "For" in headers
...\" 	[1995/03/06  17:05:46  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/03/06  15:41:31  rcb]
...\" 
...\" 	incorporated 1.1 edits
...\" 	[1995/03/06  14:01:47  rcb]
...\" 
...\" Revision 1.1.2.13  1994/10/28  14:57:02  wardr
...\" 	{edit R1.1}
...\" 	added index hits
...\" 	[1994/10/28  14:56:18  wardr]
...\" 
...\" Revision 1.1.2.12  1994/10/18  20:39:58  wardr
...\" 	{edit R1.1}
...\" 	Final fixes for the GA release
...\" 	[1994/10/18  20:39:35  wardr]
...\" 
...\" Revision 1.1.2.11  1994/09/23  12:29:23  wardr
...\" 	{enh, CR8545, R1.1}
...\" 	improved rpc name service description
...\" 	[1994/09/23  12:28:30  wardr]
...\" 
...\" Revision 1.1.2.10  1994/09/21  19:30:52  wardr
...\" 	{enh, CR10014, R1.1}
...\" 	prep for final draft review
...\" 	[1994/09/21  19:30:12  wardr]
...\" 
...\" Revision 1.1.2.9  1994/09/13  14:36:42  jshirley
...\" 	Shortened .zA and .zZ messages for def 10351
...\" 	[1994/09/13  14:36:06  jshirley]
...\" 
...\" Revision 1.1.2.8  1994/09/08  15:47:28  jshirley
...\" 	Fixed 10352 to 10351, the correct CR #.
...\" 	[1994/09/08  15:47:05  jshirley]
...\" 
...\" Revision 1.1.2.7  1994/09/08  15:40:01  jshirley
...\" 	{def,10351,R1.1} Restricting endpoints with RPC_RESTRICTED_PORTS.
...\" 	[1994/09/08  15:39:35  jshirley]
...\" 
...\" Revision 1.1.2.6  1994/09/08  13:51:14  wardr
...\" 	{enh, CR10014, R1.1}
...\" 	dcecp access to dced functions
...\" 	[1994/09/08  13:50:10  wardr]
...\" 
...\" Revision 1.1.2.5  1994/06/13  18:13:40  devobj
...\" 	cr10872 - fix copyright
...\" 	[1994/06/13  18:13:28  devobj]
...\" 
...\" Revision 1.1.2.4  1994/05/18  12:35:12  wardr
...\" 	{edit R1.1}SGML fixes
...\" 	[1994/05/18  12:35:03  wardr]
...\" 
...\" Revision 1.1.2.3  1994/05/12  12:36:26  wardr
...\" 	{enh,CR10014,R1.1}
...\" 	minor edits
...\" 	[1994/05/12  12:36:07  wardr]
...\" 
...\" Revision 1.1.2.2  1994/05/09  18:10:39  wardr
...\" 	{enh CR10014, R1.1}
...\" 	fix doc build problem
...\" 	[1994/05/09  18:10:08  wardr]
...\" 
...\" Revision 1.1.2.1  1994/05/05  18:33:13  wardr
...\" 	{enh, CR10014, R1.1}
...\" 	initial dced admin documentation
...\" 	[1994/05/05  18:32:26  wardr]
...\" 
...\" $EndLog$
.H 1 "DCE Application Administration"
.P
As DCE evolves, commonly needed functions are being included in the
DCE infrastructure.  As an example, DCE includes server
control capabilities that can manage server operation and help servers
exit in a controlled and efficient manner.  Application developers can
rely on these capabilities rather than implement special mechanisms to
handle them independently in every server.
.P
Moving commonly needed functions out of applications and into the DCE
infrastructure provides important benefits.  Applications can be
smaller and easier to develop and maintain.  Even more important,
because applications are not encumbered with lots of special code, they
are easier to reconfigure and reconnect with different kinds of
clients.  This adaptability is critical as organizations strive to
keep up with changing business needs. 
.P
DCE applications have always had administrative aspects.  Often,
programs include the necessary functions to manage their own
administrative needs, but this approach can be awkward and somewhat
inflexible for administrators.  Now, virtually all administrative
functions are available to programmers and administrators alike
through \*Ldcecp\*O.  This does not mean programmers no longer need to
deal with these issues.  We expect some programmers to provide scripts
written with \*Ldcecp\*O that configure client and server programs to
start and stop under specified conditions.  
.P
.ne 5
Although this approach
offers a convenient and consistent way to administer applications, it
also creates an area where programming and administrative concerns
overlap.  Our discussions in this chapter will include this area of
overlap, noting circumstances where administrative action might be
needed.
.H 2 "Controlling Server Operation"
...\" This is a test line for DEC's DCE 1.2.1 sandbox.
.P
The conventional notion of a DCE application server assumes that a
server is running, waiting for client requests to service.  While this
is an effective model for some general server operations, it does not
offer the flexibility needed by DCE applications.  
Commercial environments will likely have many kinds of servers.  Some
may need to be constantly available, while others may be needed only at
certain times of the day.  Still others may be needed on an infrequent
or unpredictable basis.  
.P
An application programmer or administrator could solve these
kinds of problems by writing a script or application that monitors server
operation, automatically starting or restarting servers when
necessary.  Such solutions frequently rely on host utilities like
startup and shutdown programs or schedulers like \*Lcron\*O.  However, this
often requires administrators to log into separate system
administration accounts on each host.  Moreover, this approach places
more burden on developers and administrators to devise independent
server control mechanisms which may not be portable, especially in
heterogeneous environments.
.P
DCE solves some of these problems by providing a server control
facility that offers a variety of ways to control DCE
application servers.  The server control facility is part of the DCE
daemon (\*Ldced\*O) so servers can rely on it wherever \*Ldced\*O
runs.  Additionally, the facility's administration functions are
accessible via \*Ldcecp\*O, so administrators can use consistent
(portable) methods to manage servers from any host where \*Ldcecp\*O
is available.  Furthermore, access to the server control facility is
authenticated, preventing unauthorized or accidental tampering of
server control information.
.P
The following sections show some common configuration needs and
describe ways to configure and unconfigure servers, how to start and
stop servers, and how to view server information.
.H 3 "Common Server Configuration Needs"
.P
Before you configure a server, you might need to perform some
preliminary steps.  If a server uses DCE authentication and
authorization, its principal name must be registered with the DCE
Security Service or run under the DCE identity of the parent process.
For details on creating server accounts, see Chapter 31.
.H 4 "Naming Server Configuration Information"
.P
Server configuration information is accessible using a name of the
form:
\*L/.../\*Vcellname\*L/hosts/\*Vhostname\*L/config/srvrconf/\*Vservername\*O.
If you have the necessary permissions, you can use the global name to
access the configuration database on a remote host (even a host in
another cell).  The following example shows configuration information
for the \*Lvideo_clip\*O server on host \*Lkrypton\*O in remote cell
\*L/.../their_cell.goodco.com\*O:
.oS
dcecp> \*Lserver show /.../their_cell.goodco.com/hosts/krypton/config/srvrconf/video_clip \*C
{uuid 2fa417e8-bb4c-11cd-831b-0000c08adf56}
{program {vclip}}
{arguments {-catalog}}
 .
 . (Output Omitted)
 .
\*Cdcecp>\*O
.oE
.P
The next example shows configuration information for the
\*Lvideo_clip\*O server on host \*Lsilver\*O in the local cell:
.oS
dcecp> \*Lserver show /.:/hosts/silver/config/srvrconf/video_clip \*C
{uuid 2fa417e8-bb4c-11cd-831b-0000c08adf56}
{program {vclip}}
{arguments {-catalog}}
 .
 . (Output Omitted)
 .
\*Cdcecp>\*O
.oE
.P
.ne 2
Use the simple name to show configuration information for the
\*Lvideo_clip\*O server on the local host:
.oS
dcecp> \*Lserver show video_clip \*C
{uuid 2fa417e8-bb4c-11cd-831b-0000c08adf56}
{program {vclip}}
{arguments {-catalog}}
 .
 . (Output Omitted)
 .
\*Cdcecp>\*O
.oE
.H 4 "Server Configuration Information"
.P
Each DCE has a database that can store
configuration information for servers on that host.  Use the DCE
control program \*Lserver\*O object to store, modify, or remove server
configuration information in the server configuration database on the
host system.  
.P
You need to specify some or all of the following information when
managing server configuration:
.VL
.LI "\*Luuid\*O"
An identifier for the particular server configuration object.
.LI "\*Lprogram\*O"
The name (including the pathname) that invokes the server program.
.LI "\*Ldirectory\*O"
The name of the program's working directory.  Once a server is running,
it might need a place to store its output or temporary files.
.LI "\*Larguments\*O"
Command-line arguments used to start the server.
.LI "\*Lentryname\*O"
The name of an RPC entry to which the server exports its binding.
.LI "\*Lkeytabs\*O"
A list of one or more UUIDs of related keytab objects (files) where
the server stores its keys.  This information is needed for servers
that use DCE authentication or authorization.
.LI "\*Lprincipals\*O"
A list of one or more principal names for the server that are
registered in the DCE Security Service.  This information is needed for
servers that use DCE authentication or authorization.
.nL
.ne 3
.LI "\*Lservices\*O"
Identifies the services offered by the server.  Each service attribute
consists of an attribute list with the following elements:
.VL
.LI "\*Lannotation\*O"
A human-readable string describing the service.
.LI "\*Lifname\*O"
The interface name of this service (specified in the interface
definition file).
.LI "\*Linterface\*O" 
The \*Vinterface identifier\*O (UUID and version number) of this service
(specified in the interface definition file).
.LI "\*Lbinding\*O" 
A list of string bindings identifying this service.
.LI "\*Lentryname\*O"
The name of an RPC entry to which the server exports its binding for
this service.
.LI "\*Lflags\*O"
A list of keywords to identify flags for this server.  Only the
\*Ldisabled\*O flag is currently supported.
.LI "\*Lobjects\*O"
A list of object UUIDs supported by this service.
.LE
.LI "\*Luid\*O"
A POSIX UID that the server is started with.
.LI "\*Lstarton\*O"
Specifies server starting conditions.  The value is a list of one or
more of the following:
.VL
.LI "\*Lauto\*O"
The server starts whenever a request for its service is received by
the DCE daemon.
.LI "\*Lexplicit\*O"
The server starts (or stops) whenever an administrator performs a
\*Lserver start\*O or \*Lserver stop\*O operation that directly names
the server.
.LI "\*Lboot\*O"
The server starts whenever the host system starts. 
.LI "\*Lfailure\*O"
The server starts whenever it has exited with a unsuccessful exit
status.
.LE
.LE
.H 4 "Permissions for Accessing Server Control Facilities"
.P
An ACL prevents unauthorized principals from
creating, reading, changing, or deleting information maintained by the
server control facilities.
.P
The server control facility maintains two kinds of server control
information.  Server configuration information (named \*Lsrvrconf\*O in
DCE) consists of the information needed to start servers.  Server
execution information (named \*Lsrvrexec\*O in DCE) consists of
information needed to control or stop servers when they are running.
.P
Server configuration information is protected by two types of ACLs.
One ACL protects the container in which the server control information
resides.  A second ACL type protects each individual server's
configuration information.  
.P
Similarly, server execution information is protected by two types of
ACLs.  One ACL protects the container in which the server execution
information resides.  A second ACL type protects each running server's
execution information. 
.P
This section shows how to manage ACLs that protect server control
information.  For detailed information about setting and using ACL
protections, see Chapter 28.
.P
.H 5 "Permissions for the Server Configuration Container"
.P
The server configuration information resides in a
\*Vcontainer\*O.  The container, a backing storage mechanism
implemented as a file on UNIX systems, is owned by root and
is also protected by an ACL.  These ACL permissions control who can
access information in the container.  Each DCE host has one server
configuration Container ACL with the following name:
.oS
\*L/.../\*Vcellname\*L/hosts/\*Vhostname\*L/config/srvrconf\*O
.oE
.P
The server configuration Container ACL has the following permissions:
.VL
.LI "\*Lc\*O (control)"
.ne 5
Modify the Container ACL 
.LI "\*Lr\*O (read)"
Read configuration information in the container
.LI "\*Li\*O (insert)"
Create new configuration information
.LI "\*LI\*O\ (Insert)"
Create new configuration information for a server that runs as a
privileged user (for example, as root on a POSIX system).  Such
operations also require the \*Li\*O permission.
.LE
.P
Use the \*Ldcecp acl\*O object to view or modify ACLs.  For example,
use the following operation to view the ACL for the server
configuration container object on host \*Lsilver\*O:
.oS
dcecp> \*Lacl show /.:/hosts/silver/config/srvrconf\*C
{user appl_admin criI}
{unauthenticated r}
{any_other r}
\*Cdcecp>\*O
.oE
.P
Because \*L/.:/hosts/silver/config/srvrconf\*O is a container, it also
has an Initial Container ACL and an Initial Object ACL.  You can
operate on these initial ACLs by using the \*L-ic\*O and \*L-io\*O
options to \*Lacl\*O operations.  Note, however, that because you 
cannot currently 
create child containers under \*L/.:/hosts/\*Vhostname\*L/config/srvrconf\*O,
the Initial Container ACL has no effect.
.P
.H 5 "Permissions for Accessing Server Configuration Information"
.P
Each server's configuration information is protected by its own ACL.
These ACLs can prevent unauthorized principals from creating, reading,
changing, or deleting server configuration information, and from
starting, stopping, enabling, and disabling servers.
.P
Each ACL is named for the server configuration information it protects
and has a name like the following:
.oS
\*L/.../\*Vcellname\*L/hosts/\*Vhostname\*L/config/srvrconf/\*Vserver_name\*O
.oE
This ACL has the following permissions:
.VL
.LI "\*Lc\*O (control)"
.ne 5
Modify the ACL
.LI "\*Ld\*O (delete)"
Delete the server configuration information
.LI "\*Lf\*O (flag)"
Start the server with custom flags
.LI "\*Lr\*O (read)"
Read the server configuration information
.LI "\*Lw\*O (write)"
Modify the server configuration information 
.LI "\*Lx\*O (execute)"
Start the server
.LE
.P
Use the \*Lacl\*O object to view or modify ACLs.  For example, use the
following operation to view the ACL for the \*Lvideo_clip\*O server on
host \*Lsilver\*O:
.oS
.ne 4
dcecp> \*Lacl show /.:/hosts/silver/config/srvrconf/video_clip\*C
{user appl_admin cdfrwx}
{unauthenticated r}
{any_other r}
\*Cdcecp>\*O
.oE
.P
This ACL takes its default values from the container's Initial Object
ACL.  You can operate on the Initial Object ACL by using the \*L-io\*O
option to \*Lacl\*O operations.  The following example shows the
Initial Object ACL for the \*Lvideo_clip\*O server:
.oS
dcecp> \*Lacl show /.:/hosts/silver/config/srvrconf/video_clip -io \*C
{unauthenticated r}
{any_other r}
\*Cdcecp>\*O
.oE
.P
.H 5 "Permissions for the Server Execution Container"
.P 
When servers are started, the DCE daemon copies server configuration
information into the server execution database.  The \*Ldced\*O process
also adds more information about the running server such as a UUID, the
server's communication endpoints and its process name and ID.  The
execution information controls the running server; for instance,
the process ID is used to stop a server.  When a server exits,
the DCE daemon removes its server execution information. 
.P
.ne 5
The server execution information resides in a \*Vcontainer\*O.  The
container, a backing storage mechanism implemented as a file on UNIX
systems, is owned by root and its access through \*Ldced\*O is
protected by an ACL.  These ACL permissions control who can access
information in the container.  Each DCE host has one server execution
Container ACL with the following name:
.oS
\*L/.../\*Vcellname\*L/hosts/\*Vhostname\*L/config/srvrexec\*O
.oE
.P
The server execution Container ACL has the following permissions:
.VL
.LI "\*Lc\*O (control)"
Modify the Container ACL.
.LI "\*Lr\*O (read)"
Read execution information in the container.
.LI "\*Li\*O (insert)"
Create new execution information.
.LI "\*LI\*O\ (Insert)"
Create new execution information for a server that runs as a
privileged user (for example, as root).  Such operations also require
the \*Li\*O permission.
.LE
.P
Use the \*Lacl\*O object to view or modify ACLs.  For example, use this
operation to view the ACL for the server execution container object 
on host \*Lsilver\*O:
.oS
dcecp> \*Lacl show /.:/hosts/silver/config/srvrexec\*C
{user appl_admin criI}
{unauthenticated r}
{any_other r}
\*Cdcecp>\*O
.oE
.P
Because \*L/.:/hosts/silver/config/srvrexec\*O is a container, it also
has an Initial Container ACL and an Initial Object ACL.  You can
operate on these initial ACLs by using the \*L-ic\*O and \*L-io\*O
options to \*Lacl\*O operations.  Note that the Initial Container ACL
has no effect because currently, child containers do not exist 
under \*L/.:/hosts/\*Vhostname\*L/config/srvrexec\*O.
.H 5 "Permissions for Accessing Server Execution Information"
.P
Each server's configuration information is protected by its own ACL.
These ACLs can prevent unauthorized principals from creating, changing,
reading, or deleting server configuration information, and from
starting, stopping, enabling, and disabling servers.
.P
.ne 4
Each ACL is named for the server execution information it protects
and has a name like the following:
.oS
\*L/.../\*Vcellname\*L/hosts/\*Vhostname\*L/config/srvrexec/\*Vserver_name\*O
.oE
This ACL has the following permissions:
.VL
.LI "\*Lc\*O (control)"
Modify the ACL
.LI "\*Lr\*O (read)"
Read the server execution information
.LI "\*Lw\*O (write)"
Modify the server execution information
.LI "\*Ls\*O (stop)"
Stop the server
.LE
.P
As an example, use the following operation
to view the ACL for the server execution information for the
\*Lvideo_clip\*O server on host \*Lsilver\*O:
.oS
dcecp> \*Lacl show /.:/hosts/silver/config/srvrexec/video_clip\*C
{user appl_admin crws}
{unauthenticated r}
{any_other r}
\*Cdcecp>\*O
.oE
.P
This ACL takes its default values from the container's Initial Object
ACL.  You can operate on the Initial Object ACL by using the \*L-io\*O
option to \*Lacl\*O operations.  The following example shows the
Initial Object ACL for the \*Lvideo_clip\*O server:
.oS
dcecp> \*Lacl show /.:/hosts/silver/config/srvrexec/video_clip -io \*C
{unauthenticated r}
{any_other r}
\*Cdcecp>\*O
.oE
.H 3 "Configuring Servers"
.P
Use the \*Lserver create\*O operation to make an application server
accessible to the server control facility.  Configuring a server means
creating the information needed to start and control the server.
Typically this includes a server's starting command line and
arguments, along with other information needed to start DCE
applications.
.P
.ne 6
Some servers need to be available whenever a host system is running.
For instance, you might want a server that provides information on host
activity to start at the host boot time and run until the host shuts
down.  Other kinds of services might be needed or only for brief
periods.  The server control facility has an administrative interface
that lets you specify some conditions for starting and stopping
servers:
.ML
...\"  .LI
...\"   \*LTimed server control\*O \*(em You can set servers to
...\"   start at boot time or at any absolute or relative time you specify.
...\"   Similarly, you can set servers to stop at host shutdown,
...\"   or at any absolute or relative time.  You can also set a server to be
...\"   restarted automatically if it exits unexpectedly.  
.LI
\*LExplicit\*O: You can set a server so that
you can explicitly start it whenever you want. 
.LI
\*LBoot\*O: You can set a server to start at
boot time. 
.LI
\*LAutomatic\*O: You can set a server to start on
demand; that is, it starts whenever a client request for its services is
received at the host system.
.LI
\*LFailure\*O: You can set a server to start automatically if it
exits unexpectedly.
.LE
.P
The following example creates an entry for a fictitious video clip
server named \*Lvideo_clip\*O on the local host.  For a remote host or
a host in another cell, use the cell-relative or the global name.  The
program name \*Lvclip\*O invokes the server that is located in the
\*L/usr/local/bin\*O working directory.  The server has a catalog mode
that was set by specifying \*L-catalog\*O as the argument.  The server
uses the DCE Security Service, so the server has a principal name
\*LVclip_Srv_1\*O.  The \%\*L-entryname\*O option specifies the entry
name in the Cell Directory Service (CDS)
where the server stores its binding information.  The
\%\*L-starton\*O option sets the server to start when \*Ldced\*O
receives an explicit \*Lserver start\*O operation that names the
\*Lvideo_clip\*O server.  The \*Lfailure\*O attribute further specifies to
restart the server if it exits with a status that is not successful.
The \%\*L-services\*O option has annotation information to help
administrators identify servers when this information is returned with
\*Lserver show\*O operations.  The \*Linterface\*O attribute is needed
because the DCE daemon copies this information into the host endpoint
map when the server starts. 
.oS
dcecp> \*Lserver create /.:/hosts/silver/config/srvrconf/video_clip \\
\*C>\*L -program {/usr/local/bin/vclip} \\
\*C>\*L -directory {/tmp} -arguments {-catalog} \\
\*C>\*L -principal {Vclip_Srv_1} \\
\*C>\*L -entryname {/.:/subsys/applications/video_clip_1} \\
\*C>\*L -starton {explicit failure} \\
\*C>\*L -services {{annotation {Video Clip Catalog and Server}} \\
\*C>\*L {interface {d860322b-d499-11cd-9dfb-0000c08adf56 1.0}}}
\*Cdcecp>\*O
.oE
.P
.ne 3
.zA "def,13575,R1.2.2,Replaced boot failure with boot"
The next example configures the same server to start whenever the host
system boots.  The only difference from the preceding example is that
the \%\*L-starton\*O option has a value of \*Lboot\*O.
.oS
.ne 8
dcecp> \*Lserver create /.:/hosts/silver/config/srvrconf/video_clip \\
\*C>\*L -program {/usr/local/bin/vclip} \\
\*C>\*L -directory {/tmp} -arguments {-catalog} \\
\*C>\*L -principal {Vclip_Srv_1} \\
\*C>\*L -entryname {/.:/subsys/applications/video_clip_1} \\
\*C>\*L -starton {boot} \\
\*C>\*L -services {{annotation {Video Clip Catalog and Server}} \\
\*C>\*L {interface {d860322b-d499-11cd-9dfb-0000c08adf56 1.0}}}
\*Cdcecp>\*O
.oE
.zZ "def,13575,R1.2.2,Replaced boot failure with boot"
.P
The final configuration example sets the \*Lvideo_clip\*O server to
start whenever a client request for its services is received at the
host system.  The \%\*L-starton\*O option value is \*Lauto\*O. 
Section 10.1.4 discusses the steps for disabling and enabling services.
.zA "def,13575,R1.2.2,Replaced boot failure with auto"
.oS
dcecp> \*Lserver create /.:/hosts/silver/config/srvrconf/video_clip \\
\*C>\*L -program {/usr/local/bin/vclip} \\
\*C>\*L -directory {/tmp} -arguments {-catalog} \\
\*C>\*L -principal {Vclip_Srv_1} \\
\*C>\*L -entryname {/.:/subsys/applications/video_clip_1} \\
\*C>\*L -starton {auto} \\
\*C>\*L -services {{annotation {Video Clip Catalog and Server}} \\
\*C>\*L {interface {d860322b-d499-11cd-9dfb-0000c08adf56 1.0}}}
\*Cdcecp>\*O
.oE
.zZ "def,13575,R1.2.2,Replaced boot failure with auto"
.H 3 "Listing and Retrieving Server Configuration Information"
.P
When you want to see a list of the names of servers configured on a
particular host, use a \*Lserver catalog\*O operation, as shown.  
This operation
doesn't show every server available on a host, just those that have
configuration information stored in the server configuration database.
.oS
dcecp> \*Lserver catalog /.:/hosts/silver\*C
/.../my_cell.goodco.com/hosts/silver/config/srvrconf/video_clip
\*Cdcecp>\*O
.oE
.P
List the names of all the configured servers in a DCE cell by using a
\*Lforeach\*O command to repeat the \*Lserver catalog\*O operation for
each host in a cell:
.oS
foreach h [directory list /.:/hosts]{
   echo [server catalog $h]
}
.oE
.P
If you're unsure of the configuration information established for a
server, you can view it using a \*Lserver show\*O operation,
as shown.  Use the
\%\*L-executing\*O option to view information about a running server. 
.oS
dcecp> \*Lserver show /.:/hosts/silver/config/srvrconf/video_clip \*C
{uuid d860322b-d499-11cd-9dfb-0000c08adf56 1.0} 
{program {/usr/local/bin/vclip}}
{arguments {-catalog}}
{prerequisites {}}
{keytabs {683cf29a-e456-11cd-8f04-0000c08adf56}}
{services {{annotation "Video Clip Catalog and Server"}} 
{principals {Vclip_Srv_1}}
{starton {explicit failure}}
{uid 1441}
{gid 1000}
{dir {/tmp}}
\*Cdcecp>\*O
.oE
.H 3 "Unconfiguring Servers"
.P
You can remove server configuration information from a host's
configuration database by using a \*Lserver delete\*O operation.  You
would perform this operation, for instance, when a server moves to a
different host.  A \*Lserver delete\*O operation does not stop a
server that is currently running.
.P
The following example removes the \*Lvideo_clip\*O server's
configuration information from the configuration database on host
\*Lsilver\*O:
.oS
dcecp> \*Lserver delete /.:/hosts/silver/config/srvrconf/video_clip \*C
\*Cdcecp>\*O
.oE
.H 3 "Starting and Stopping Servers"
.P
Once a server has been appropriately configured, you can use a
\*Lserver start\*O or \*Lserver stop\*O operation to start or stop the
server remotely.  For example, the following \*Lserver start\*O
operation starts the server \*Lvideo_clip\*O on host
\*Lsilver\*O in the local cell:
.oS
dcecp> \*Lserver start /.:/hosts/silver/config/srvrconf/video_clip \*O
eb814e2a-0099-11ca-8678-02608c2ea96e
\*Cdcecp>\*O
.oE
.P
The next example 
stops the server \*Lvideo_clip\*O on the local host
\*Lsilver\*O in the local cell:
.oS
dcecp> \*Lserver stop video_clip \*C
dcecp>\*O
.oE
.H 3 "Disabling and Enabling Services"
.zA "def,13575,R1.2.2,Removed last paragraph and example from section"
.P
You can prevent clients from using a service offered by a
server\(emeven when the server is running\(emby setting its services
to disabled.  When set to disabled, server endpoint information is not
returned to requesting clients, thereby preventing clients from finding
servers.  Instead, clients receive a server status of \*Lendpoint not
registered.\*O  Clients that previously acquired the server endpoint
can still communicate with the server, however.
.P
When a server provides multiple interfaces, you can disable any one or
more of its interfaces by specifying their interface identifiers.  The
following example disables one service of the \*Lvideo_clip\*O server:
.oS
dcecp> \*Lserver disable /.:/hosts/silver/config/srvrexec/video_clip \\
\*C>\*L -interface {d860322b-d499-11cd-9dfb-0000c08adf56 1.0}
\*Cdcecp>\*O
.oE
The next example enables the \*Lvidsrv\*O service of the
\*Lvideo_clip\*O server after it has been disabled.  This operation
allows clients to acquire a server's endpoint.
.oS
dcecp> \*Lserver enable /.:/hosts/silver/config/srvrexec/video_clip \\
\*C>\*L -interface {d860322b-d499-11cd-9dfb-0000c08adf56 1.0}
\*Cdcecp>\*O
.oE
.zZ "def,13575,R1.2.2,Removed last paragraph and example from section"
.H 3 "Extending Server Configurations"
.P
Some servers may require configuration information that is not
supported by the set of attributes provided with your DCE software.
You can add arbitrary information to your server configuration
information by creating additional \*Vextended registry attributes\*O
ERAs with the \*Lxattrschema\*O object. 
.P
.zA "def,13575,R1.2.2,Added srvrconf/objfamily"
For example, say you have a server that needs an attribute that
specifies an object family.  You create such an attribute by using the
\*Lxattrschema\*O object.  The following example creates an ERA called
\*Lsrvrconf/objfamily\*O.  The operation specifies the permissions needed to
query, update, test, and delete the ERA, and it specifies the ACL
manager that supports the permissions.
.zZ "def,13575,R1.2.2,Added srvrconf/objfamily"
.zA "def,13575,R1.2.2,Added ending curly braces"
.oS
dcecp> \*Lxattrschema create \\
\*C>\*L /.:/hosts/silver/config/xattrschema/srvrconf/objfamily \\
\*C>\*L -attribute {{annotation {object family}} {encoding uuid} \\
\*C>\*L {aclmgr {srvrconf r w r d}}}
\*Cdcecp>\*O
.oE
.zZ "def,13575,R1.2.2,Added ending curly braces"
.P
.ne 3
Once you have created a new attribute, use a \*Lserver modify\*O
operation, as explained in Section 10.1.8, to insert the necessary data.  
More information about ERAs is provided in Chapter 32.
.P
You can review the attributes associated with an ERA by using an
\*Lxattrschema show\*O operation as shown in the following example:
.oS
.ne 14
dcecp> \*Lxattrschema show /.:/hosts/silver/config/xattrschema/srvrconf/objfamily\*C
{aclmgr {srvrconf {{query r} {update w} {test r} {delete d}}}}
{annotation {object family}}
{applydefs no}
{encoding uuid}
{intercell reject}
{multivalued yes}
{reserved no}
{scope {}}
{trigbind {}}
{trigtype none}
{unique no}
{uuid 1bef2222-e687-11cd-b74a-0000c08adf56}
\*Cdcecp>\*O
.oE
.P
ERAs in server configuration information are protected by two levels
of ACLs.  One ACL type protects the container in which the ERA resides.
The second ACL type protects the individual ERA. 
.P
The ERA Container ACL is named as follows:
.oS
\*L/.../\*Vcellname\*L/hosts/\*Vhostname\*L/config/xattrschema\*O
.oE
.P
The ERA Container ACL has the following permissions:
.VL
.LI "\*Lc\*O (control)"
Modify the Container ACL 
.LI "\*Lr\*O (read)"
Read the ERA in the container
.LI "\*Li\*O (insert)"
Create new ERA information
.LI "\*LI\*O\ (Insert)"
Although the \*LI\*O permission is present, it does not apply to
ERA items.  The permission applies to server control facilities, which
are explained in Section 10.1.1.3.
.LE
.P
Use the \*Ldcecp acl\*O object to view or modify the Container ACL.
For example, the following operation views the ERA Container ACL on
host \*Lsilver\*O:
.oS
.ne 4
dcecp> \*Lacl show /.:/hosts/silver/config/xattrschema\*C
{user appl_admin criI}
{unauthenticated r}
{any_other r}
\*Cdcecp>\*O
.oE
.P
.ne 3
.zA "def,13575,R1.2.2,Removed srvrconf from ERA_name"
The ACL for an individual ERA is named as follows:
.oS
\*L/.../\*Vcellname\*L/hosts/\*Vhostname\*L/config/xattrschema/\*VERA_name\*O
.oE
.zZ "def,13575,R1.2.2,Removed srvrconf from ERA_name"
.P
.ne 7
.zA "def,13575,R1.2.2,Added srvrconf to objfamily"
ACLs on individual ERAs can prevent unauthorized principals from
creating, reading, changing, or deleting ERA information.  The
following example shows permissions established for the
\*Lsrvrconf/objfamily\*O ERA.  In this example, the \*Lc\*O permission has no
effect because it was not assigned when the ERA was created with the
\*Lxattrschema create\*O operation.  All users can query and test the
ERA.  Only the user named \*Lappl_admin\*O can also update and delete
the ERA.
.zZ "def,13575,R1.2.2,Added srvrconf to objfamily"
.oS
dcecp> \*Lacl show /.:/hosts/silver/config/xattrschema/srvrconf/objfamily\*C
{user appl_admin crwd}
{unauthenticated cr}
{any_other cr}
\*Cdcecp>\*O
.oE
.P
This ACL takes its default values from the container's Initial Object
ACL.  You can operate on the Initial Object ACL by using the \*L-io\*O
option to \*Lacl\*O operations.  The following example shows the
Initial Object ACL for the \*Lxattrschema\*O container on host
\*Lsilver\*O:
.oS
dcecp> \*Lacl show /.:/hosts/silver/config/xattrschema -io \*C
{unauthenticated cr}
{any_other cr}
\*Cdcecp>\*O
.oE
.H 3 "Changing Server Configurations"
.P
Sometimes you might want to change a server's configuration
information.  For instance, you want to change the \*L-starton\*O
attribute from \*Lboot\*O to \*Lexplicit\*O so that you can control
the server manually. 
.P
.ne 4
To change the normal server configuration attributes, you must first
delete all of the existing attributes and then create new ones.  Avoid
losing the current information by first using a \*Lserver show\*O
operation to display it on your screen. 
.P
.ne 5
The steps are illustrated in the following example which uses a
\*Lserver show\*O operation to capture the current server
configuration information.  The \*Lserver delete\*O operation removes
the configuration information, and a \*Lserver create\*O operation
inserts the new \*L\-starton\*O attribute along with the remaining
server configuration information.
.oS
.ne 20
dcecp> \*Lserver show /.:/hosts/silver/config/srvrconf/video_clip \*C
{uuid d860322b-d499-11cd-9dfb-0000c08adf56 1.0} 
{program {/usr/local/bin/vclip}}
{arguments {-catalog}}
{prerequisites {}}
{keytabs {683cf29a-e456-11cd-8f04-0000c08adf56}}
{services {{annotation "Video Clip Catalog and Server"}} 
{principals {Vclip_Srv_1}}
{starton {boot}}
{uid 1441}
{gid 1000}
{dir {/tmp}}
dcecp> \*Lserver delete /.:/hosts/silver/config/srvrconf/video_clip \*C
dcecp> \*Lserver create /.:/hosts/silver/config/srvrconf/video_clip \\ 
\*C>\*L -program /usr/local/bin/vclip \\
\*C>\*L -directory /tmp \\
\*C>\*L -arguments {-catalog} \\
\*C>\*L -principal Vclip_Srv_1 \\
\*C>\*L -entryname /.:/subsys/applications/video_clip_1 \\
\*C>\*L -starton {explicit} \\
\*C>\*L -services {{annotation "Video Clip Catalog and Server"}}
\*Cdcecp>\*O
.oE
.P
.zA "def,13575,R1.2.2,Added srvrconf/objfamily"
You can directly change ERA information by using a
\*Lserver modify\*O operation.  The following example changes a server's
ERA called \*Lsrvrconf/objfamily\*O to contain new values.  This operation assumes 
the ERA has already been created using an \*Lxattrschema create\*O operation
described in Section 10.1.17.
.oS
dcecp> \*Lserver modify /.:/hosts/silver/config/srvrconf/video_clip \\
\*C>\*L -change {srvrconf/objfamily {c09dcc40-e4f4-11cd-bd59-0000c08adf56}}
\*Cdcecp>\*O
.oE
.zZ "def,13575,R1.2.2,Added srvrconf/objfamily"
.H 3 "Checking Whether Servers Are Running"
.P
You can check whether a particular server is running by performing a
\*Lserver ping\*O operation.  This might be a convenient test when some
client users report they can't communicate with a server.  The
\*Lserver ping\*O operation communicates with the named server to test
its presence, returning a \*L1\*O is a server is listening and a
\*L0\*O if it is not listening.  
The argument to the server ping operation is the \*Lentryname\*O of the server,
not the name of the \*Lsrvrconf\*O object.
The following example tests whether
the \*Lvideo_clip\*O server is running:
.oS
dcecp> \*Lserver ping /.:/subsys/applications/video_clip_1 \*C
1
\*Cdcecp>\*O
.oE
.H 2 "Managing Client/Server Binding Information"
.P
In a DCE environment, clients and their servers frequently reside on
different hosts in a network, so clients need a way to find servers. 
.P
Clients need three pieces of information to communicate with a server:
.ML
.LI
The host name (or network address) of the host where the server is
running
.LI
The name of the network transport the server is using
.LI
The communication port (endpoint) the server is using for client
communications
.LE
.P
Of course, an application programmer could simply hardcode a server's
location information (also called \*Vbinding information\*O) into the client
side of the application where it is immediately available for use.
However, this approach requires that a programmer have advance
knowledge of precise network details such as host names and available
port numbers.  Furthermore, servers with hardcoded binding
information do not easily adapt to configuration changes.  If you move
a server to a different host, you need to recompile all of the clients
with the server's new host name.  So DCE provides more flexible ways
for clients to obtain server bindings.
.P
.ne 4
The standard way for clients to find servers is by using CDS
and the server host's endpoint map.  Figure
10-1 provides a high-level example of this method, showing how a fictitious
dictionary client application on host \*Llarry\*O finds a dictionary server
on host \*Lcurly\*O.
.P
.FG "Server Binding Information"
...\" 	***  XFIG REDUCED BY 60%  ***
.pI ../rpc/rpc/figures/srv_admin_1.ps 0 0 1
.sp .5
.AL
.LI
When the dictionary server starts up, DCE host software assigns the
server a communications port (endpoint), which clients will use
to communicate with this server.  Here, the endpoint is TCP/IP port 1015.
The DCE host software also places the server identification
information along with the current endpoint in the host's endpoint
map.
.LI
The dictionary server then advertises its availability to clients by
placing (\*Eexporting\*O) its host name (usually it's the host
address) and the transport it uses to a server entry in CDS.
.LI
.ne 3
When the dictionary client makes a call to a remote procedure provided
by the server, the DCE software on the client queries the CDS server
to find the dictionary server's host name and the transport. 
.LI
.ne 2
The client system's host software then queries the endpoint map on
host \*Lcurly\*O to find the dictionary server's endpoint (port 1015).
.LI
Equipped with all the necessary binding information, the host services
on host \*Llarry\*O transmit the remote procedure call directly to port
1015 on host \*Lcurly\*O. 
.LE
.P
Although we've omitted some details in this high-level example, the
figure still shows the major binding activities performed by
clients and servers.  That is, servers place their binding information
in CDS and in the host endpoint map where clients look for it.  There
are other ways for clients to find servers and there are variations on
the mechanism we've described.  But these alternatives are generally
controlled by the applications themselves rather than through
conventional DCE administration facilities like \*Ldcecp\*O. 
.P
This section discussed one basic client/server binding mechanism.  The
following sections examine the roles played by the endpoint map and by CDS.  We'll also discuss
specific administration tasks for managing binding information in
endpoint maps and in CDS.
.H 2 "Using the Endpoint Map for Easy Application Development and Administration"
.P
Remote clients can find a server by using the server host's
endpoint map to determine the server's communication endpoint.  But
how do remote clients know where to find the endpoint map itself?
They know because the endpoint map is always accessible at a
\*Ewell-known\*O endpoint (that is, it is always the same endpoint) on
each host so clients can easily find it.
.P
When hosts support multiple transports, the endpoint map \*Elistens\*O
on one port for each transport.  In the IP address family (both TCP and
UDP), the endpoint map process listens on port 135. In the Domain
Domain Sockets (DDS) address family, it listens on port 12. In the
DECnet NSP address family, it listens on port 69. A complete list of
the protocol sequences and well-known endpoints used by the endpoint
mapper service can be found in the header file
\*L/opt/dcelocal/share/include/dce/ep.idl\*O.  
.P
.ne 2
Note that not all hosts
support all transports.  DCE software tries to ensure that at
least one transport is shared between a client and a server.
.P
While well-known endpoints provide convenient access to some critical
servers, for most servers they are impractical.  That's because some
address families have a limited number of endpoints and well-known
endpoints can be assigned only by a central administrative authority.
So most servers use \*Edynamic endpoints\*O.  When a server starts up,
the RPC runtime library gets an available endpoint from the operating
system and registers it in the host endpoint map.
.P
Because a server can be assigned a different endpoint each time it
starts, the endpoint information is stored in the endpoint map rather
than CDS, which is a repository for more stable information; namely,
the server's host address and the transports it uses.  As long as the
server stays on the same machine, host and transport information need
not be updated, which tends to reduce bottlenecks at CDS.
.P
This scheme makes application development and administration easier
because it reduces the need to manage endpoints.  Servers needn't
worry about passing dynamic endpoints to clients.  Furthermore, unless
a server moves to a new host, or removes or adds a transport, it
doesn't even have to update the information in CDS.
.H 3 "Automatic Endpoint Map Administration"
.iX "endpoint maps" "about"
.P
Each server that uses the endpoint map stores a set of information in
the endpoint map when it starts up.  The information includes 
Universal Unique Identifiers (UUIDs) for objects and interfaces offered by
the server, an annotation string, and other fields.
.P
The endpoint map resides on disk in
\*Vdcelocal\*L/var/dced/Ep.db\*O and
\*Vdcelocal\*L/var/dced/Srvrexec.db\*O.  After a system reboot,
DCE-based servers restart and reregister with the endpoint mapper
service, so the database files need to be deleted before the DCE
daemon starts.  This happens automatically on most systems.
.P
.iX "endpoints" "purging obsolete"
DCE-based servers normally need to register with the endpoint mapper
service on startup and unregister on termination.  If any servers exit
without unregistering, the endpoint map may contain stale entries.
.P
.ne 7
DCE provides server control facilities that help servers
unregister and avoid leaving stale entries in the endpoint map.
Servers that don't use these facilities (older servers, for example)
are more likely to leave stale entries if they exit unexpectedly.  So
periodically, the DCE daemon (\*Ldced\*O) purges stale entries by
scanning the endpoint map, ``pinging'' each server that is registered,
and deleting entries for servers that do not respond.
.P
The background process of removing stale entries is not intended
to be highly responsive.  It is not intended to replace the
need for servers to unregister themselves from the endpoint map
when they no longer service RPCs.  Rather, this processing is
intended only to clean up after a server failure.
.P
While the behavior of the pinging/purging mechanism is
implementation dependent, in a typical implementation 
the database is scanned (that is, servers are pinged 
and stale entries removed) only infrequently; for example, 
a few times an hour.  Once a ping to a 
server fails, the server is pinged several times over 
a shorter interval; for example, every 5 
minutes.  If the server continues to not respond, 
the \*Ldced\*O process determines that its entry is ``stale'' and removes it 
from the database.  Ultimately, the rate at which stale server
entries are detected and purged depends on the number of
stale entries in the database; the more stale entries, the longer
it takes to detect and purge the stale entries.
.H 3 "Restricting Endpoints"
.P
You can restrict the assignment of endpoints (ports) for DCE servers and
clients to a specific set.  This is useful if your environment has
applications other than DCE that are designed to use certain endpoints, and you
do not want to be concerned about DCE servers or clients monopolizing
them.
.P
The facility is activated by setting the \*LRPC_RESTRICTED_PORTS\*O
environment variable with the list of endpoints to which dynamic
assignment should be restricted before starting a client or server
application. \*LRPC_RESTRICTED_PORTS\*O governs only the dynamic
assignment of server ports by the RPC runtime.  It does not affect
well-known endpoints.
.P
.ne 3
The following example restricts servers to using TCP/IP
endpoints ranging from 5000 to 5110, and 5500 to 5521. It restricts
UDP/IP endpoints to the range of 6500 to 7000.
.oS
.ne 2
% \*Lset RPC_RESTRICTED_PORTS \\
         ncacn_ip_tcp[5000-5110,5500-5521]:ncadg_ip_udp[6500-7000]\*C
%
.oE
.P
To use \*LRPC_RESTRICTED_PORTS\*O for DCE servers such as CDS, set the
environment variable each time before starting your cell.
.P
Note that this facility does not add any security to RPC and is not intended
as a security feature.  It merely facilitates configuring a network ``firewall''
to allow incoming calls to DCE servers.
...\" .H 3 "Server Endpoint Location Facilities"
...\" 
...\" When servers start up, they request to use a network communication
...\" endpoint on one or more network transports available on the host
...\" system.  An endpoint can be a TCP/IP port or a datagram socket or some
...\" other kind of endpoint depending on which network transports are
...\" available on the host.  Servers then monitor their assigned endpoints
...\" waiting for client requests.
...\" 
...\" Let's step back and look at the bigger picture for a minute.  Clients
...\" need three pieces of information to communicate (bind) with a server;
...\" they need the server's host address, network protocol, and the
...\" endpoint.  A client finds the server's host address and network
...\" protocol by looking in the CDS.  When servers
...\" start, they generally store their names along with their host address
...\" and network protocol in CDS where clients can easily find it.  This
...\" information is suited for CDS because it doesn't often change.  But
...\" endpoints can be different each time a server starts so servers store
...\" this more volatile endpoint information in a host-resident endpoint
...\" map.  The endpoint map correlates each server name and identification
...\" information with its assigned endpoint. 
...\" 
...\" [THESE TWO PARAS NEED STREAMLINING]
...\" A client queries CDS to determine which host the server is on and
...\" which network protocol to use but it still doesn't know which endpoint
...\" the server is using.  So the client sends a remote procedure call to
...\" the endpoint map on the server's host requesting the server's
...\" endpoint.  The endpoint map is always accessible at a \*Lwell-known\*O
...\" endpoint (this means it's always the exact same endpoint) on each host
...\" so clients can easily find it.  The endpoint map returns the endpoint
...\" information to the client.  Now, having all the information it needs,
...\" the client makes its request directly to the endpoint being monitored
...\" by the server.
...\"  
...\"    Because clients don't necessarily know which endpoint a particular
...\"    server is using, the DCE host facilities include an endpoint map that
...\"    correlates each server name and identification information with its
...\"    assigned endpoint. 
...\" 
...\"    Running servers wait for client requests by monitoring an
...\"    assigned network communication \*Lendpoint\*O on the host.  An endpoint
...\"    can be a TCP/IP port or a datagram socket or some other kind of
...\"    endpoint depending on which network transports are available on the
...\"    host. 
...\" 
...\"    When servers start up, they request to use one or more network
...\"    transports available on the host system.  The host system then
...\"    assigns one of the available endpoints for each transport
...\"    requested.  When a host assigns a random endpoint
...\" 
...\"    Clients communicate with servers by sending remote procedure calls to
...\"    a particular \*Vendpoint\*O on the host where 
.H 3 "Viewing Information in the Endpoint Map"
.P
For the most part, the endpoint map on each host takes care of itself,
purging stale entries when necessary and removing the endpoint
information each time the host reboots.  So there's really no
administration needed for the endpoint map.
.P
However, when client/server communication problems arise, the
information stored in the endpoint map might be useful to
administrators, particularly for determining whether servers are
supplying the correct endpoint information to clients.  In this case,
you can use the \*Lendpoint\*O object to view endpoint map
information.  Besides its use in troubleshooting, you can also use the
\*Lendpoint\*O object for other specialized server
operations such as adding new object UUIDs to existing mappings.
.P
Endpoints are not protected by ACLs.  This means anyone who can run
\*Ldcecp\*O can use an \*Lendpoint show\*O operation on their host to
view endpoint information on any other host in the cell.  Other
endpoint operations, such as creating or deleting endpoints, can be
performed only by users who are logged into the local host.  No other
special privileges, such as system administrator or root privileges,
are needed for local access to endpoint information.
...\" Endpoints themselves don't have ACLs to control access to the endpoint
...\" information.  Instead, permissions for operating on endpoints are
...\" set within the ACL for the server whose endpoint you want to operate
...\" on.  IS THERE MORE? HOW ABOUT AN EXAMPLE THAT LOOKS AT A SERVER'S ACL?
.P
.ne 4
You can view information stored in a host's endpoint map database
by using an \*Lendpoint show\*O operation.  The following example shows
the endpoint map information for the \*Lvideo_clip\*O server on a remote
host \*Lmegazoid\*O.  Omit the \*Vhostname\*O argument to operate on the local
endpoint map.
.oS
.ne 6
dcecp> \*Lendpoint show /.:/hosts/megazoid \\
\*C>\*L -interface {2fa417e8-bb4c-11cd-831b-0000c08adf56 1.0} \*C
{{object 99ff4fb8-c042-11cd-91cd-0000c08adf56} 
 {interface {2fa417e8-bb4c-11cd-831b-0000c08adf56 1.0}} 
 {binding {ncacn_ip_tcp 130.105.1.227 1028}} 
 {annotation {Text Development Utilities}}} 
\*Cdcecp>\*O
.oE
.P
You can view all of the endpoints in an endpoint map by not using 
any options with the \*Lendpoint show\*O operation.
.H 2 "Managing Server Entries, Groups, and Profiles in CDS"
.P
An endpoint map acts as a directory of servers on a host.  Similarly,
CDS acts as a directory of servers in the cell.  In the first part of
this chapter, we gave a high-level look at how applications can use
CDS to store relatively stable binding information such as a server's
name, its host address, and the transports over which the server is
available.  In this section, we'll show how to use CDS facilities for
organizing your servers and other distributed objects in meaningful
ways.
.P
Many of the operations discussed in the following sections operate on
CDS directories that are protected by ACLs against unauthorized access.
For detailed information about ACLs and
CDS see Chapter 16.
.H 3 "Using Unique Server Entry Names to Identify Individual Servers and Objects"
...\" .H 3 "Organizing Servers in CDS"
.P
We know that servers store their binding information in CDS where
clients can find it.  But so far, we've been treating CDS like a
black box.  If a DCE cell consisted of just a few servers or objects
and a handful of users, CDS could be as simple as a data file
accessible to both servers and clients.  Finding unique names for
objects would probably not pose a big problem.  And you could
probably even devise some effective scheme for protecting objects
from unauthorized use.  But DCE cells can include many hundreds or
even thousands of objects.  Large cells will likely contain many
similar or even identical servers that need convenient and effective
ways to offer their services to clients.  
.P
DCE CDS answers this need by providing a
hierarchical (tree-structured) name system that servers use to store
binding information.  CDS acts much like a hierarchical file system of
directories that stores names and other information instead of files.
You can build on its hierarchical structure, imposing directory names
that can correspond to your company's organizational structure.
.P
Servers have CDS names like
\*L/.:/admin/finance/payroll/check_writer\*O.  When this \*Lcheck_writer\*O
server exports its server entry name to CDS, CDS stores it in a
directory named \*L/.:/admin/finance/payroll\*O.  Consequently, clients
won't confuse this \*Lcheck_writer\*O with another \*Lcheck_writer\*O named
\*L/.:/admin/finance/accts_payable/check_writer\*O.  Thus, unique
server entry names fill a critical administration need, providing a
way to access and control individual servers.
.P
Part 4 of this book provides more information about CDS and the
structure and uses of CDS names.  For our current purposes, it's enough
to know how and why CDS directory names help make potentially
identical server entries unique.
.P
While servers themselves often manage exporting and removing their
names and binding information from CDS, sometimes administrators
need to manually add, change, or remove binding information.  For
instance, when a server host machine crashes unexpectedly and stays
offline for a long time, its resident servers cannot 
remove their entry names and binding information from CDS.  Clients
can waste time looking for these phantom servers.  The DCE control 
program provides the \*Lrpcentry\*O object that you can use to manage
server entry names and their binding information in CDS.  
.P 
Before we get to the actual management tasks, let's examine a server
entry to see exactly what it is we'll be managing.  Figure 10-2 shows
possible information in a server entry.
.P
.FG "Possible Information in a Server Entry"
...\" Old DEC-file name .P! pictures/rpc-nsi-server-entry.ps 3.25i
...\" tree_name .pI ../rpc/figures/6_nsi_usage_02.ps 0 0 1
.pI ../rpc/rpc/figures/6_nsi_usage_02.ps 0 0 1
.sp .5
.P
The top part of Figure 10-2 contains bindings.  Each binding consists of
an interface identifier and a binding.  
The interface identifier identifies an interface
offered by the server, and its binding information indicates the host
address and network transport to use to access that interface.  The
following example of a binding (shown in \*Ldcecp\*O syntax) indicates
the server is on the host with internet address 120.101.13.157 and is
available using the User Datagram Protocol (UDP):
.oS
{nacdg_ip_udg 120.101.13.157}
.oE
.P
.ne 4
When an interface identifier is available over several
transports, the server entry contains bindings (one binding for each
transport).  Servers can offer more than one interface.  Multiple
interfaces can be available through a single endpoint.  That is,
different interfaces can have the same bindings.
.P
The lower part of the figure contains object UUIDs.  Object UUIDs offer
additional information to clients; they identify specific objects or
resources managed by the server.  For instance, one print server offers
printers on floor 2 while another print server offers printers on
floor 1.  In this case, object UUIDs let clients select printers on
the appropriate floor.  In other words, object UUIDs help clients
distinguish from among otherwise identical services.
.P
Although application servers can manage their own server entries in
CDS, you may find it more convenient (and more straightforward) to
manually add, remove, or change information in a server entry.
There are four methods for managing server entries in CDS:
.ML
.LI
Server entry names can be hardcoded into an application.  You can change
server entry information in the source code, but you need to recompile
and rerun the application before the entry names take effect.
.LI
Server entry names can be stored as the \*Lentryname\*O attribute of
the server's configuration information (using the \*Lserver\*O object)
where it's accessible to the application.  This is more convenient
than recompiling but, more importantly, this method places the
server's entry name in a standard (platform independent) place where
administrators can see it too.  You might need to restart an
application to use this method, however.
.LI
Server entry names can be passed to an application through environment
variables or arguments.  While these are effective methods and they are
more convenient than recompiling, they are not platform-independent.
This means you might need different approaches on different operating
systems.
.LI
Server entry names can be directly managed in CDS by using the DCE
control program's \*Lrpcentry\*O object.  This manual method does not
require recompiling or restarting applications. 
.LE
.P
The next sections discuss how to use the \*Lrpcentry\*O object to
manually manage server entries in CDS.
.H 4 "Creating a Server Entry in CDS"
.P
Often, servers will create their own entries in CDS either when they
initialize or when they are configured after installation.  But
sometimes, you might want to create a server entry manually.  When you
create a server entry, it is empty; it doesn't contain any interface
or binding information.  
.P
One reason to create an empty server entry is to establish ownership of
the entry.  Server entries are owned by the creator.  If a server
creates an entry, the server can also delete the entry later.  You
can preempt such a circumstance by creating the entry yourself.  Later,
the server exports its bindings to the existing server entry (provided
that the ACL allows this).
.P
Use an \*Lrpcentry create\*O operation to create an empty server entry
as  in the following, which creates one named
\*L/.:/subsys/applications/bbs_server\*O.  The CDS directory
\*L/.:/subsys/applications\*O must already exist for this operation to
succeed.
.oS
dcecp> \*Lrpcentry create /.:/subsys/applications/bbs_server\*C
\*Cdcecp>\*O
.oE
.H 4 "Deleting a Server Entry from CDS"
.P
Because server entries generally contain stable server binding
information, they tend to stay around rather than be deleted.  Even
when a server goes away for a short time, say, overnight, it might not
be practical to remove its entry.  But when a server goes away for a
long time, you can avoid the client expense of trying to use the
phantom server by removing the server's entry from CDS.
.P
Use an \*Lrpcentry delete\*O operation to remove a server entry from
CDS as shown in the following example:
.oS
dcecp> \*Lrpcentry delete /.:/subsys/applications/bbs_server\*C
\*Cdcecp>\*O
.oE
.H 4 "Exporting Binding Information to a Server Entry in CDS"
.P
Servers usually export their own binding information to CDS when they
initialize or when they are configured after installation.  But
sometimes, binding information may have been removed for some reason
or by accident and you want to restore it.  Or another transport has
been added and you want to export the binding for the new transport.
.P
You can manually export server binding information to a server entry
by using an \*Lrpcentry export\*O operation.  If the entry does not
already exist, the \*Lrpcentry export\*O operation creates it provided
the directory already exists and you have the necessary permissions. 
.P
The following example illustrates exporting a server's binding
information to a server entry named
\*L/.:/subsys/applications/bbs_server\*O.  The object UUID identifies
the data file resource used by \*Lbbs_server\*O.
.oS
dcecp> \*Lrpcentry export /.:/subsys/applications/bbs_server \\    
\*C>\*L -interface {458ffcbe-98c1-11cd-bd93-0000c08adf56 1.0} \\
\*C>\*L -binding {ncacn_ip_tcp 130.105.1.227} \\
\*C>\*L -object {76030c42-98d5-11cd-88bc-0000c08adf56}
\*Cdcecp>\*O
.oE
.H 4 "Importing Binding Information from a Server Entry in CDS"
.P
Application client programs can automatically import server binding
information from CDS and use it in their quest to find and communicate
with a server.  But occasionally, an administrator might want to
import a binding.  For instance, a client might lack access to CDS but
it could still communicate with the server if you supplied it with a
valid binding. 
.P
Use an \*Lrpcentry import\*O operation to return a server's binding
information, as follows: 
...\" For instance a script that locates servers and related information
...\" could roam parts of the CDS namespace recording host addresses where
...\" particular interfaces reside.
.oS
dcecp> \*Lrpcentry import /.:/subsys/applications/bbs_server \\
\*C>\*L -interface {458ffcbe-98c1-11cd-bd93-0000c08adf56 1.0}\*C
{ncacn_ip_tcp 130.105.1.227}
\*Cdcecp>\*O
.oE
.H 4 "Viewing Information in a Server Entry"
.P
When clients are having difficulty communicating with servers, you might
want to see what binding information is contained in a server entry as a
troubleshooting step.  Or say you are adding object UUIDs to server
entries and you wonder whether a server entry has been overlooked.  You
can use an \*Lrpcentry show\*O operation to view the information in a
server entry as illustrated in the following example.  The returned
information includes the interface identifier, two bindings over which
the server can be reached, and an object UUID of a resource maintained by
the server.
.oS
dcecp> \*Lrpcentry show /.:/subsys/applications/bbs_server\*C
{458ffcbe-98c1-11cd-bd93-0000c08adf56 1.0
  {ncadg_ip_udp 130.105.1.227}
  {ncacn_ip_tcp 130.105.1.227}}
{76030c42-98d5-11cd-88bc-0000c08adf56}
\*Cdcecp>\*O
.oE
.H 4 "Removing Binding Information from a Server Entry in CDS"
.P
Occasionally, you might want to remove binding information from a server
entry.  If a server host crashes, its servers cannot remove their server
entries from CDS.  To prevent clients from trying to communicate with
these phantom servers, you should unexport the bindings from CDS
manually.  Unlike the \*Lendpoint delete\*O operation, this operation
does not remove the entry name from CDS.
.P
Use an \*Lrpcentry unexport\*O operation to remove server binding
information as shown in the following example.  Notice that the object
UUID is not removed from the server entry unless you specify it as an
option to the \*Lunexport\*O operation.
.oS
dcecp> \*Lrpcentry unexport /.:/subsys/applications/bbs_server \\
\*C>\*L -interface {458ffcbe-98c1-11cd-bd93-0000c08adf56 1.0}\*C
\*Cdcecp>\*O
dcecp> \*Lrpcentry show /.:/subsys/applications/bbs_server\*C
{76030c42-98d5-11cd-88bc-0000c08adf56}
\*Cdcecp>\*O
.oE
.H 3 "Using Group Entries to Help Balance Server Workloads"
.P
When a client queries CDS for a server binding, the request includes
the name of the entry to look in for the binding.  When only one
server offers the client's requested service, CDS will return the same
binding for every client request for this service.  While this model
works fine for limited client requests, it can cause service
bottlenecks when many client requests converge on one server.
Applications can avoid bottlenecks by providing multiple servers to
service large numbers of client requests.  Server entry names alone
don't provide a convenient way to distribute client requests evenly
among multiple servers because you'd have to explicitly direct each
client to a particular server.  So CDS provides \*Vgroup entries\*O as
a convenient mechanism for distributing the client load across
multiple servers.
.P
A CDS group entry gathers related servers together under a common
group name.  Group entries contain members that are generally pointers
to server entries, but members can point to other group entries, too.
When a client requests a binding from a group entry, CDS returns, at
random, one of the pointers contained in the group entry.  If the entry
picked at random is another group entry, CDS doesn't return that.  Instead 
CDS goes to that group and picks another random member, continuing
until a server entry is returned.  This model requires that any group
member can service the client request.  Figure 10-3 shows how a group
entry contains members that point to other groups and to server
entries. 
.P
.ne 4.5i
.FG "Possible Mappings of a Group"
...\" DEC-file name .P! pictures/rpc-nsi-group-mappings.ps 5.5i
...\" tree_name .pI ../rpc/figures/6_nsi_usage_03.ps 0 0 1
.pI ../rpc/rpc/figures/6_nsi_usage_03.ps 0 0 1
.sp .5
.P
Now, let's see how group entries help balance a workload.  Consider an
organization with 12 identical laser printers equally spread among
three departments.  The following group entry examples show how each
group entry name returns any one of the four printers assigned to its
own department:
.oS
.ne 5
\*LGroup entry name:\*O /.:/admin/finance/accts_payable_printers
  /.:/admin/finance/accts_payable/laser_10
  /.:/admin/finance/accts_payable/laser_11
  /.:/admin/finance/accts_payable/laser_12
  /.:/admin/finance/accts_payable/laser_13

.ne 5
\*LGroup entry name:\*O /.:/admin/finance/accts_receivable_printers
  /.:/admin/finance/accts_receivable/laser_10
  /.:/admin/finance/accts_receivable/laser_11
  /.:/admin/finance/accts_receivable/laser_12
  /.:/admin/finance/accts_receivable/laser_13

.ne 5
\*LGroup entry name:\*O /.:/admin/finance/payroll_printers
 /.:/admin/finance/payroll/laser_10
 /.:/admin/finance/payroll/laser_11
 /.:/admin/finance/payroll/laser_12
 /.:/admin/finance/payroll/laser_13
.oE
.P
You could temporarily make one department's printers available to
another group by adding its group name to the group entry of the other
group as shown in the next group entry example:
.P
.oS
\*LGroup entry name:\*O /.:/admin/finance/accts_payable_printers
  /.:/admin/finance/accts_payable/laser_10
  /.:/admin/finance/accts_payable/laser_11
  /.:/admin/finance/accts_payable/laser_12
  /.:/admin/finance/accts_payable/laser_13
  /.:/admin/finance/accts_receivable_printers
.oE
.P
The configuration in the preceding example means the clients in
accounts payable can use the printers in accounts receivable 20% of
the time.  You could offer a higher percentage of use by adding server
entry names rather than the group name.  The next group entry example
shows a situation where the clients in accounts payable can use the
printers in accounts receivable 50% of the time.  However, don't
try to increase the percentage of use by including a group name
multiple times because you'll get an error.
.P
.oS
\*LGroup entry name:\*O /.:/admin/finance/accts_payable_printers
  /.:/admin/finance/accts_payable/laser_10
  /.:/admin/finance/accts_payable/laser_11
  /.:/admin/finance/accts_payable/laser_12
  /.:/admin/finance/accts_payable/laser_13
  /.:/admin/finance/accts_receivable/laser_10
  /.:/admin/finance/accts_receivable/laser_11
  /.:/admin/finance/accts_receivable/laser_12
  /.:/admin/finance/accts_receivable/laser_13
.oE
.P
Although application servers can manage their own group entries in CDS,
you may find it more convenient (and more straightforward) to manually
add, remove, or change server information in a group entry.  Like
managing server entries, there are several methods for managing group
entries in CDS:
.ML
.LI
Group entry names can be hardcoded into an application.  You can change
group entry information in the source code, but you need to recompile
and rerun the application before the entry names take effect.
.LI
Group entry names can be passed to an application through environment
variables or arguments.  These are more convenient methods than
recompiling, but you might need to restart an application to use either
method.
.LI
Group entry names can be directly managed in CDS by using the DCE
control program's \*Lrpcgroup\*O object.  This manual method does not
require recompiling or restarting applications. 
.LE
.P
The next sections discuss how to use the \*Lrpcgroup\*O object to
manually manage group entries in CDS.
.H 4 "Creating a New Group Entry in CDS"
.P
You can create an empty group entry in CDS by using an \*Lrpcgroup
create\*O operation.  While group creation is frequently performed by
applications that first use a group entry, creating an entry yourself
establishes you as the owner of the entry.  As the owner, you have
ultimate control over who can export and manage information in the
entry. 
.P
To create an empty group entry in CDS, use an \*Lrpcgroup create\*O
operation as in the following example:
.oS
dcecp> \*Lrpcgroup create /.:/subsys/applications/admin_bbs_servers\*C
\*Cdcecp>\*O
.oE
.H 4 "Adding a Member to a Group Entry in CDS"
.P
You can use an \*Lrpcgroup add\*O operation to add a member to a group
entry.  If the group entry does not exist, the operation creates the
group entry and adds the member.  The member can be a server
entry or another group entry.  Note that no operations check whether
the members you add actually exist.  This lets you configure the
namespace even before servers are up and running. 
.P
To add a member to the \*L/.:/subsys/applications/admin_bbs_servers\*O
group entry in CDS, use an \*Lrpcgroup add\*O operation as in the
following example:
.oS
dcecp> \*Lrpcgroup add /.:/subsys/applications/admin_bbs_servers \\
\*C>\*L -member /.:/subsys/applications/bbs_server4
\*Cdcecp>\*O
.oE
.H 4 "Viewing the Members of a Group Entry"
.P
You can list the members of a group entry by using an \*Lrpcgroup
list\*O operation.  This is useful for troubleshooting or for just
seeing how servers are distributed in group entries.
.P
To list the members of a group entry in CDS, use an \*Lrpcgroup list\*O
operation, as shown in the following example, which lists the members of the
group \*L/.:/subsys/applications/admin_bbs_servers\*O:
.oS
dcecp> \*Lrpcgroup list /.:/subsys/applications/admin_bbs_servers \*C
/.../my_cell.goodco.com/subsys/applications/bbs_server3
/.../my_cell.goodco.com/subsys/applications/bbs_server4
\*Cdcecp>\*O
.oE
...\" \*LCACHING AND THE -noupdate OPTION\*O
...\" .P
...\" You can get faster performance if you rely on previously cached data
...\" to satisfy this request.  However, cached data might be stale in a cell
...\" where lots of changes are going on.
...\" .P
...\" By default rpc(entry/group/profile) commands always get fresh data
...\" from CDS because they set the rpc_ns_mgmt_exp_age to 0 before
...\" executing.  While this doesn't flush the cache, the command sees only
...\" expired data and goes to CDS so it's always updating the cache.
...\" .P
...\" You can use data in the local cache (if it's there) and avoid updating
...\" (getting fresh data from CDS) by using the -noupdate option.  This sets
...\" the exp_age to some random relative time between 8 and 12 hours.  This
...\" method may be faster that relying on CDS.
.nL
.ne 10
.H 4 "Importing Binding Information from a Group Entry in CDS"
.P
Application client programs can automatically import server binding
information from CDS and use it in their quest to find and communicate
with a server.  But occasionally, an administrator might want to
import a binding.  In the case where a client lacks access to CDS, it
could still communicate with the server if you supplied the client
with a valid binding.
.P
You can use an \*Lrpcgroup import\*O operation to return a server's
binding information.  You must specify an interface by using the
\%\*L-interface\*O option as shown in the following example:
.oS
dcecp> \*Lrpcgroup import /.:/subsys/applications/admin_bbs_servers \\
\*C>\*L -interface {458ffcbe-98c1-11cd-88bc-0000c08adf56 1.0}\*C
{ncacn_ip_tcp 130.105.1.227}
dcecp>
.oE
.P
You can use other options such as \*L-version\*O and \*L-object\*O to
further specify a binding.  Use the \%\*L-max\*O option to limit the
number of bindings returned.
.H 4 "Removing Members from a Group Entry in CDS"
.P
Over time, organizational changes can require you to redeploy servers
in your DCE cell.  You might, for instance, want to move server entries
from one group entry into another. 
.P
Use an \*Lrpcgroup remove\*O operation to remove one or more members
from a group.  The following example removes \*Lbbs_server3\*O from the group
\*L/.:/subsys/applications/admin_bbs_servers\*O:
.oS
dcecp> \*Lrpcgroup remove /.:/subsys/applications/admin_bbs_servers \\
\*C>\*L -member /.../my_cell.goodco.com/subsys/applications/bbs_server3\*C
dcecp> \*Lrpcgroup list /.:/subsys/applications/admin_bbs_servers \*C
/.../my_cell.goodco.com/subsys/applications/bbs_server4
/.../my_cell.goodco.com/subsys/applications/bbs_server5
/.../my_cell.goodco.com/subsys/applications/bbs_server6
\*Cdcecp>\*O
.oE
.H 4 "Deleting a Group Entry from CDS"
.P
Organization changes or server redeployments can make some groups
obsolete.  When you want to remove a group entry from CDS, use an
\*Lrpcgroup delete\*O operation.  The following example illustrates
removing an obsolete group entry called
\*L/.:/subsys/admin/temporaries/wp_services\*O from CDS:
.oS
dcecp> \*Lrpcgroup delete /.:/subsys/admin/temporaries/wp_services\*C
\*Cdcecp>\*O
.oE
.H 3 "Using Profiles to Direct Client Searches for Servers"
.P
Group entries offer clients a random choice from among multiple
available services.  Although a group entry can help in load balancing
and resource allocation, its random nature resists fine tuning.
Furthermore, it doesn't offer a way to 
prioritize servers for use by particular clients.
.P
Profiles offer a complimentary way to organize servers because you can
prioritize the search order of the profile members. (These were called
\*Velements\*O in previous DCE versions.)  Members identify servers by
providing the following information:
.ML
.LI
Interface identifier
.P
This field is the key to the profile.
The 
...\" .gL "interface identifier"
.iX "interface" "RPC identifier"
.iX "RPC" "interface" "identifier" 
interface identifier
consists of the interface UUID and the interface version numbers.
.LI
Member name
.P
The entry name of one of the following kinds of directory service entries:
.ML
.LI
A server entry for a server offering the requested RPC interface 
.LI
A group corresponding to the requested RPC interface
.LI
A profile 
.LE 
.LI
.ne 7
Priority value
.P
The priority value (0 is the highest priority; 7 is the lowest
priority) is designated by the creator of a profile member to help
determine the search order to select among like-priority members at
random.
...\" The default is 0. 
.LI
Annotation string
.P
The annotation string enables you to identify the
purpose of the profile member.  The annotation can be any textual information;
for example, an interface name associated with the interface identifier or a
description of a service or resource associated with a group. 
.P
Unlike the interface identifier field, the annotation string is not a
search key.
.LE 
.P
Profiles are flexible; they contain members that can point to server
entries, groups, and to other profiles.  Profiles can also contain a
special member called a \*Vdefault profile member\*O.  This optional
member should point to a default profile, usually a
comprehensive backup profile that can serve the needs of most users in
an organization.  Figure 10-4 shows some possible mappings of a
profile.
...\" "DEFAULT PROFILE" NEEDS BETTER DESCRIPTION...
...\"<Figure XX <APP_GD, FIG 15-4>>
.P
.ne 6.5i
.FG "Possible Mappings of a Profile"
...\" DEC-file name .P! pictures/rpc-nsi-profile-mappings.ps 7.0i
...\" tree_name .pI ../rpc/figures/6_nsi_usage_04.ps 0 0 1
.pI ../rpc/rpc/figures/6_nsi_usage_04.ps 0 0 1
.sp .5
.P
To get an idea of how profiles can work, let's build on our printer
example from the preceding discussion on group entries.  The following
profile entry example shows one way to use profiles to prioritize
resources based on proximity to clients.  
.P
.ne 4
In the figure, three users
have personalized printer profiles that return server entries for
printers nearest to them first.  For example, user \*LJohn\*O is closest to
\*Llaser_20\*,O so the profile priority \*L1\*O returns that 
binding first.  \*LJohn\*O is furthest from \*Llaser_23\*O, 
so the profile priority \*L4\*O returns that binding
last.
.oS
.ps 10
.vs 12
\*LProfile entry name:\*C /.:/admin/finance/accts_receivable_printers/johns_profile
  /.:/admin/finance/accts_receivable/laser_20  1
  /.:/admin/finance/accts_receivable/laser_21  2  
  /.:/admin/finance/accts_receivable/laser_22  3 
  /.:/admin/finance/accts_receivable/laser_23  4

\*LProfile entry name:\*C /.:/admin/finance/accts_receivable_printers/pats_profile
  /.:/admin/finance/accts_receivable/laser_20  3
  /.:/admin/finance/accts_receivable/laser_21  4  
  /.:/admin/finance/accts_receivable/laser_22  2 
  /.:/admin/finance/accts_receivable/laser_23  1

\*LProfile entry name:\*C /.:/admin/finance/accts_receivable_printers/wills_profile
  /.:/admin/finance/accts_receivable/laser_20  2
  /.:/admin/finance/accts_receivable/laser_21  1  
  /.:/admin/finance/accts_receivable/laser_22  3 
  /.:/admin/finance/accts_receivable/laser_23  4
.ps 12
.vs 14
.oE
.P
To conclude this example, let's say that your department's server is
being overused by another department.  You could further limit its use
by lowering the server's priority value in the foreign department's
profile that points to your server. 
.P
Just as application servers can manage their own profile entries in CDS,
they can also manage their own profile entries.  However, you may find it
more convenient (and more straightforward) to manually add, remove, or
change server information in a profile entry.  Like managing server
entries and group entries, there are several methods for managing
profile entries in CDS:
.ML
.LI
Profile entry names can be hardcoded into an application.  You can change
profile entry information in the source code, but you need to recompile
and rerun the application before the entry names take effect.
.LI
Profile entry names can be passed to an application through environment
variables or arguments.  These methods are more convenient than
recompiling, but you might need to restart an application to use either
method.
.LI
.ne 3
Profile entry names can be directly managed in CDS by using the DCE
control program's \*Lrpcprofile\*O object.  This manual method does not
require recompiling or restarting applications. 
.LE
.P
The next sections discuss how to use the \*Lrpcprofile\*O object to
manually manage profile entries in CDS.
.H 4 "Creating a New Profile"
.P
You can create an empty profile entry in CDS by using a \*Lrpcprofile
create\*O operation.  While profile creation is frequently performed by
applications that first use a profile entry, creating an entry yourself
establishes you as the owner of the entry.  As the owner, you have
ultimate control over who can export and manage information in the
entry. 
.P
To create an empty profile entry in CDS, use an \*Lrpcprofile create\*O
operation as in the following example:
.oS
dcecp> \*Lrpcprofile create /.:/subsys/applications/admin_group_profile\*C
\*Cdcecp>\*O
.oE
.H 4 "Adding a Profile Member"
.P
You can use an \*Lrpcprofile add\*O operation to add a member to a profile
entry.  If the profile entry does not exist, the operation creates the
profile entry and adds the member.  The member can be a server
entry or another profile entry.  
.P
To add a member to the
\*L/.:/subsys/applications/wards_profile\*O profile entry in
CDS, use an \*Lrpcprofile add\*O operation as in the following example
which adds the server entry
\*L/.:/subsys/applications/bbs_server3\*O with a priority of \*L2\*O: 
.oS
dcecp> \*Lrpcprofile add /.:/subsys/applications/wards_profile \\
\*C>\*L -member /.:/subsys/applications/bbs_server3 \\
\*C>\*L -interface {458ffcbe-98c1-11cd-88bc-0000c08adf56 1.0} \\
\*C>\*L -priority 2
\*Cdcecp>\*O
.oE
...\" Alternatively, you can add the default profile member by using the
...\" \%\*L-default\*O option.  The default profile is a general profile to be
...\" used when other profile members cannot satisfy the client request. 
.H 4 "Viewing the Members of a Profile Entry"
.P
You can simply list the members of a profile entry by using an \*Lrpcprofile
list\*O operation.  This is useful for troubleshooting or for just
seeing how servers are distributed in profile entries.
.P
To list the members of a profile entry in CDS, use an \*Lrpcprofile list\*O
operation as in the following example which lists the members of the
profile \*L/.:/subsys/applications/admin_group_profile\*O:
.oS
dcecp> \*Lrpcprofile list /.:/subsys/applications/wards_profile \*C
/.../my_cell.goodco.com/subsys/applications/admin_bbs_servers
/.../my_cell.goodco.com/subsys/applications/bbs_server
\*Cdcecp>\*O
.oE
.P
You can view the complete information stored with a profile entry
by using an \*Lrpcprofile show\*O operation.  This shows the priority
and the interface UUIDs associated with a member.  The following
example shows all of the information contained in the profile named
\*L/.:/cell-profile\*O:
.oS
.ps 9
.vs 12
dcecp> \*Lrpcprofile show /.:/cell-profile\*C
{{d46113d0-a848-11cb-b863-08001e046aa5 2.0} /.../cell.co.com/sec 0 rs_bind}
{{0d7c1e50-113a-11ca-b71f-08001e01dc6c 1.0} /.../cell.co.com/sec-v1 0 secidmap}
{{8f73de50-768c-11ca-bffc-08001e039431 1.0} /.../cell.co.com/sec 0 krb5rpc}
{{b1e338f8-9533-11c9-a34a-08001e019c1e 1.0} /.../cell.co.com/sec 0 rpriv}
{{b1e338f8-9533-11c9-a34a-08001e019c1e 1.1} /.../cell.co.com/sec 0 rpriv}
{{6f264242-b9f8-11c9-ad31-08002b0dc035 1.0} /.../cell.co.com/lan-profile 0 LAN}
{{4d37f2dd-ed43-0000-02c0-37cf2e000001 4.0} /.../cell.co.com/fs 0 fs}
\*Cdcecp>\*O
.ps 12
.vs 14
.oE
.H 4 "Importing Binding Information from a Profile Entry in CDS"
.P
Application client programs can automatically import server binding
information from CDS and use it in their quest to find and communicate
with a server.  But occasionally, an administrator might want to
import a binding.  In the case where a client lacks access to CDS, it
could still communicate with the server if you supplied the client
with a valid binding.
.P
.ne 3
You can use an \*Lrpcprofile import\*O operation to return a server's
binding information.  You must specify an interface by using the
\%\*L-interface\*O option as shown in the following example:
.oS
dcecp> \*Lrpcprofile import /.:/subsys/applications/wards_profile \\
\*C>\*L -interface {458ffcbe-98c1-11cd-88bc-0000c08adf56 1.0}\*C
{ncacn_ip_tcp 130.105.1.202}
{ncacn_ip_tcp 130.105.1.227}
\*Cdcecp>\*O
.oE
.P
You can use other options such as \*L-version\*O and \*L-object\*O to
further specify a binding.  Use the \%\*L-max\*O option to limit the
number of bindings returned, as shown in the following example:
.oS
dcecp> \*Lrpcprofile import /.:/subsys/applications/wards_profile \\
\*C>\*L -interface {458ffcbe-98c1-11cd-88bc-0000c08adf56 1.0} \\
\*C>\*L -max 1\*C
{ncacn_ip_tcp 130.105.1.202}
\*Cdcecp>\*O
.oE
.H 4 "Removing Members from a Profile Entry in CDS"
.P
Over time, organizational changes can require you to redeploy servers
in your DCE cell.  You might, for instance, want to move server entries
from one profile entry into another. 
.P
Use an \*Lrpcprofile remove\*O operation to remove one or more members
from a profile.  In the following example, the \*Lrpcprofile remove\*O
operation removes member \*L/.:/subsys/applications/admin_bbs_servers\*O 
from the profile \*L/.:/subsys/applications/wards_profile\*O:
.oS
dcecp> \*Lrpcprofile remove /.:/subsys/applications/wards_profile \\
\*C>\*L -member /.:/subsys/applications/admin_bbs_servers \\
\*C>\*L -interface {458ffcbe-98c1-11cd-88bc-0000c08adf56 1.0}
\*Cdcecp>\*O
.oE
.H 4 "Deleting a Profile Entry from CDS"
.P
Organization changes or server redeployments can make some profiles
obsolete.  When you want to remove a profile entry from CDS, use an
\*Lrpcprofile delete\*O operation.  The following example illustrates
removing an obsolete profile entry called
\*L/.:/subsys/admin/temporaries/74232_profile\*O from CDS:
.oS
dcecp> \*Lrpcprofile delete /.:/subsys/admin/temporaries/74232_profile
\*Cdcecp>\*O
.oE
.H 2 "Client Administration"
.P
So far, this chapter has focused on server administration issues.
We've seen how to control some server operations, and how to store
server binding information in CDS and in the host endpoint map where
clients can find it.  This section discusses the administration needs
of application clients.  Although client administration is very 
simple\(em there are just two related operations\(emit's an essential step
in getting clients and servers working together.
.P
We know that CDS is a hierarchical system of directories that stores
server binding information in the form of server entries.  We also
know that CDS offers group entries and profile entries as a way to
direct clients to appropriate servers.  But how do clients know where
to begin looking for a server?  
.P
As we discussed earlier in this chapter, servers register interfaces and
their bindings in CDS.  Each interface-binding combination is
registered under a server entry name.  When a client makes a remote
procedure call, it passes a server entry name (or a group or profile
entry name) to CDS along with the UUID of an interface that offers the
remote procedure.  CDS uses the server entry name (or group or profile
entry name) as a starting point in the search for a binding that
contains an interface UUID and version matching that passed by the
client.  This method presumes the client has previously acquired the
server entry name (or group or profile name) used by the server.
.P
.ne 3
Getting clients to use an appropriate server entry name is a 2-step
process:
.AL
.LI
Determine what entry name a client should use.
.LI
Pass the name to the client program.
.LE
.P
Note that a client uses whatever name you supply.  The client program
cannot distinguish whether the name is a server entry name or group
entry name or profile entry name.  To the client, all of these names
look and behave the same. 
.H 3 "Determining the Entry Name"
.P
You need to know the entry name exported by a server so you can
provide it to client programs when you configure them.  Here, we're
just calling this name an entry name, but it can be a server entry
name or group entry name or profile entry name.  Your application
documentation should help you decide which kind of entry to use.
.P
If you are installing and configuring the server and client parts of
an application, make a note of the server's entry name when you
configure the server. 
.P
If you are not installing or configuring the server (for instance, the
server was previously installed), you might need to do some detective
work to determine the name to use.  There are several places you can
look. 
.P
If a server uses the server control facility described earlier in this
chapter, you can probably use a \*Lserver show\*O operation to
reveal its entry name.  Of course, this means you need to know the
server's object name on the host where the server resides.  You can see
all of the server object names on a host by using a \*Lserver catalog\*O
operation.  The following example lists all the server objects
configured on host \*Lsilver\*O.  The \*Lserver show\*O operation reveals the
entry name used by the \*Linfo_server\*O program.
.oS
dcecp> \*Lserver catalog /.:/hosts/silver\*C
/.../my_cell.goodco.com/hosts/silver/config/srvrconf/video_clip
/.../my_cell.goodco.com/hosts/silver/config/srvrconf/info_server
dcecp> \*Lserver show /.:/hosts/silver/config/srvrconf/info_server \*C
{uuid 6d5e7184-71b7-11cd-a205-08000925634b}
{program {/usr/local/bin/infosrv}}
{arguments {-brief}}
{prerequisites {}}
{keytabs {}}
{entryname {/.:/subsys/applications/info_server_1}}
{services {}}
{principals {}}
{starton {explicit failure}}
{uid 1423}
{gid 1000}
{dir {/tmp}}
\*Cdcecp>\*O
.oE
.P
If a server starts from a boot program or script of some kind, look in
the program or script for the name or names (sometimes servers use
multiple names when they export multiple interfaces).  The name might
be supplied as an argument to the command that starts the server, as in
the following example:
.P
.oS
\*Cinfosrv /.:/finance/operations/infoserv\*O
.oE
.P
When the server side does not easily reveal its entry name, try to
determine what entry other client programs are using.  Client programs
frequently start from a boot program or script of some kind, and entry
names are generally provided as arguments to the command to start the
client.  These commands often follow the same model shown in the
previous example of the server startup command.
.H 3 "Providing the Entry Name to Clients"
.P
Sometimes, very simple clients can have the server entry name encoded
within them so you don't have to pass any entry name.  But more often,
you need to supply an entry name to a client program when it starts.
This approach is more flexible than hardcoding an entry name because
it offers an easy way to use a different entry name should the need
arise.  
.P
.ne 6
The client configuration documentation should include instructions on
how to pass the name to the client.  One method uses a script or batch
file that contains the command to start the client along with
arguments that include the appropriate server entry name.  The
following example shows a server entry name passed as a command
argument in a shell script that starts the client:
.oS
# Shell Script to start the InfoClient application
infoclient /.:/finance/operations/InfoServ_profile \*O
.oE
.P
Alternatively, the server entry name can be stored in an environment
variable (called \*LRPC_DEFAULT_ENTRY\*O on UNIX systems).  The following
example shows a shell script that defines this variable and then
invokes the client:
.oS
#! /bin/sh
# Shell Script to start the InfoClient application
export RPC_DEFAULT_ENTRY=/.:/finance/operations/InfoServ_profile 
infoclient \*O
.oE
...\" *********************************************************************
...\" .P
...\" ITS POSSIBLE FOR SOME APPLICATIONS TO REGISTER MULTIPLE SERVER ENTRY
...\" NAMES (WITH DIFFERENT INTERFACES IN EACH ENTRY).  AUTOMATIC CLIENTS
...\" MUST RELY ON THE RPC_DEFAULT_ENTRY WHICH LIMITS THEM TO A SINGLE
...\" INTERFACE.
...\" 
...\" .P
...\" AUTOMATIC BINDING JUST USES THE RPC_DEFAULT_ENTRY ENVIRONMENT
...\" VARIABLE.  THIS IMPLIES THAT CLIENTS CAN ONLY USE ONE INTERFACE. 
...\" 
...\" 
...\" THE END ...
...\" .H 3 "Determining the Name of a CDS Object"
...\" 
...\" Imagine that a host administrator approaches you and asks you to lower
...\" the priority of the XYZ server because it's using too many system
...\" resources.  How do you determine the name of the profile to use? Its
...\" not easy... CDS doesn't support attribute-based searching and server's
...\" don't always provide an easy or consistent way to retrieve this
...\" information.  Sometimes it may be in a configuration file - often
...\" you'll have to ask a developer or better-yet, work with developers to
...\" establish naming conventions that 
...\" 
...\" John,
...\" 
...\" Another area we'll have to coordinate on is 
...\" 
...\" > On clients, administrators need to know the default entry.
...\" > client apps can set this on startup but it can be changed by other
...\" > client apps when they start.  How do administrators find out what an
...\" > apps default entry is?
...\" 
...\" 
...\" Environment variables (RPC-DEFAULT_ENTRY)
...\" 
...\" 
...\" 3. Cells and Naming issues - ACLs on directories, and entries...
...\" 
...\" *********************************************************************
...\" say your organization resides on several floors of a building
...\" Each floor has several printers designed  have a bunch
...\" 
...\" 
...\" When a client queries CDS for a server binding, the request includes
...\" the name of the entry to look in for the binding.  When only one
...\" server offers the client's requested service, CDS will return the same
...\" binding for every client request for this service.  While this model
...\" works fine for limited client requests, it can cause service bottlenecks
...\" when many client requests coverge on one server.  Some applications
...\" avoid bottlenecks by providing multiple servers to service large
...\" numbers of client requests.  Server entry names alone don't provide a
...\" convenient way to distribute client requests evenly among multiple
...\" servers because you'd have to explicitly direct each client to a
...\" particular server.  So CDS provides \*Lgroup entries\*O as a convenient
...\" mechanism for distributing the client load on servers. 
...\" 
...\" A CDS group entry gathers related servers together under a common
...\" group name.  Group entries contain members which are generally pointers
...\" to server entries but members can point to other group entries, too.
...\" When a client requests a binding from a group entry, CDS returns, at
...\" random, one of the pointers contained in the group entry.  If the entry
...\" picked at random is another group entry, CDS doesn't return that.  Instead 
...\" CDS goes to that group and picks another random member, continuing
...\" until a server entry is returned.  This model requires that any group
...\" member can service the client request.  Figure XX shows how a group
...\" entry contains members that point to other groups and to server
...\" entries. 
...\" 
...\" <FIGURE> <GRP ENTRY POINTING TO SERVER ENTRIES AND GRP ENTRIES>
...\" 
...\" While application servers usually manage their own group entries
...\" in CDS, sometimes you might want to manually add, remove, or change
...\" server information in a group entry.  For example, consider an
...\" organization with twelve identical laser printers equally spread among
...\" three departments.  Figure XX shows how each group entry name returns
...\" any one of the four printers assigned to its own department.
...\" 
...\" /.:/admin/finance/accts_payable_printers
...\"   /.:/admin/finance/accts_payable/laser
...\" 
...\" 
...\" The directory structure also provides a convenient way to protect the
...\" \*L/.:/admin/finance/payroll/check_writer\*O from unauthorized use.
...\" You can use ACLs to precisely regulate
...\" access to that directory.  For instance, you can prevent unauthorized
...\" clients from finding out about a server's existence by setting ACLs on
...\" the CDS directory that deny read access to all but ...
...\" 
...\" 
...\" The DCE CDS allows administrators to impose a
...\" logical directory structure that can correspond to a company's (or
...\" department's) organizational structure.  The use of particular
...\" directories to store server binding information has two benefits: 
...\" 
...\" 
...\" CHARACTERISTICS: distinguish server
...\" instances (charging and access control reasons) (ERGO cell
...\" directrories) Protect 
...\" 
...\" While we won't embark on a big discussion about cells, 
...\" 
...\" For example your company or organization is divided up into 
...\" 
...\" A hospital maintains its own DCE cell.  Each organization within the
...\" hospital has its own directory structure within CDS which we show in
...\" Figure XX.  As you can see 
...\" 
...\" /.:
...\" admin           finance         medstaff        engineering
...\"  policies        accts_payable   podiatry        
...\"  fund_raising    accts_rcvbl     phrenology
...\"  records         payroll         
...\"                          
...\" 
...\" board admin
...\" finance
...\" medstaff
...\" engineering
...\" 
...\" 
...\" 
...\" Servers need an easy way to name
...\" themselves uniquely.  To avoid bottlenecks at application servers,
...\" clients must be able to engage a systematic search for an appropriate
...\" server. 
...\" 
...\" CDS acts much like a file system that stores names and other
...\" information instead of files.  It has a hierarchical structure that
...\" you can build that let's you store server and object information in
...\" CDS \*Ldirectories\*O which can correspond to your organizational
...\" structure.  You can also use DCE's ACL
...\" capabilities to regulate which entities (servers, objects, or persons)
...\" can read information from and write information into CDS directories. 
...\" 
...\" 
...\" SERVER ENTRIES: interface.  A server offers various remote procedures
...\" by advertising an \*Linterface\*O in CDS.  An interface is a
...\" collection of one or more related remote procedures which servers can
...\" find out about and 
...\" 
...\" For instance a math interface could offer five remote procedures.  One
...\" could add
...\" 
...\" The binding information structure that servers export to CDS is
...\" called a server entry.  We've already seen some of what's in a server
...\" entry but examine one more closely.
...\" 
...\" We mentioned how CDS is compartmentalized with sections reserved
...\" for use by various entities within an organization.   
...\" 
...\" Figure xxx shows
...\" how CDS divides a cell into 
...\" 
...\" OBJECTS:
...\"  rpcentry (done)
...\"  rpcgroup
...\"  rpcprofile
...\" 
...\" 
...\" *****
...\" OLD STUFF
...\" 
...\" 
...\" 
...\" 	DCE services offer programmers and administrators convenient ways to
...\" 	automate distributed application operations.  For instance the DCE 
...\" 	application development tools automatically generate code that clients
...\" 	use to communicate with servers.  Application servers can use CDS by
...\" 	just invoking a few prefabricated functions that store server location
...\" 	(binding) information in CDS where clients can find it. 
...\" 
...\" 	Despite these convenient methods for automating client server
...\" 	activities, the name service must be configured so that servers and
...\" 	clients can use it is a logical and consistent manner.  In fact lots of
...\" 	the administration in the CDS part of this admin guide 
...\" 
...\" 
...\" You can think of CDS like a big bulletin board that is divided up into
...\" various sections each of which is restricted for use by particular
...\" members of your organization.  That is, members of one group in your
...\" organization can post their information only in their own designated
...\" parts of the bulletin board.  You need to ensure that the bulletin
...\" board works for your company; that is, it is available and accessible
...\" to everyone who needs to use it.  But it's up to the members
...\" themselves to decide what to post.  In actuality, you use CDS
...\" administration functions to create specific directories for use by
...\" servers and clients, and to make sure the directories are accessible
...\" to them.  These tasks are described in Part IV of the DCE admin gd core
...\" book (CDS).  
...\" 
...\" When servers start, they
...\" typically export their binding information to various kinds of
...\" entries in CDS such as server entries, groups, or profiles.  Each kind
...\" of entry has a special function that helps direct client requests to
...\" an appropriate server.  Client systems 
...\" 
...\" 
...\" 1. Purpose and use of server entries, groups, or profiles, and how
...\"    they work together
...\" 
...\" 2. Why administrators will manually administer rather than
...\"    applications (the norm).
...\" 
...\" 
...\" ANSWER:
...\" HIGH LEVEL - introduces the overall need for manual administration. 
...\" LOW-LEVEL examples introduce each section??
...\" 
...\" 
...\" 
...\" Rich,
...\" 
...\" Figure 15-7 in the Application Development Guide shows two identical
...\" servers on one host.  Although this is possible, there are
...\" architectural reasons to avoid this.  An exiting server could remove
...\" its entry from CDS leaving the other server with no entries in CDS and
...\" therefore unavailable to clients seeking it.  The only reason for this
...\" configuration is to handle more client requests.  The recommended way
...\" to handle more client requests is to increase the number of threads
...\" in the server. 
...\" 
...\" 
...\" > RICH - Why would an administrator (and not the developer) add,
...\" > remove, and change rpc objects (rpcentries, rpcgroups, and
...\" > rpcprofiles)?
...\" 
...\" > To do this, the administrator needs to know the "name" of the object.
...\" > How does he find this out.
...\" 
...\" > On clients, administrators need to know the default entry.
...\" > client apps can set this on startup but it can be changed by other
...\" > client apps when they start.  How do administrators find out what an
...\" > apps default entry is?
...\" 
...\" 
...\" TASKS 
...\"  create entry, group, profile
...\"  modify entry, group, profile
...\"  remove modify entry, group, profile
...\" 
...\" Here's a quick look at server entries, groups, and profiles, and the
...\" special functions of each type. 
...\" 
...\" .VL
...\" .LI "rpcentry"
...\" Points directly to a server of a particular remote procedure.  If the
...\" remote procedure identified in the entry matches the procedure sought
...\" by the client, CDS returns its binding information to the client.
...\" 
...\" .LI "rpcgroup"
...\" Contains pointers to rpcentries and to other groups. 
...\" .LI "rpcprofile"
...\" 
...\" OBJECTS:
...\"  rpcentry
...\" 
...\" **************************************************
...\" 
...\" THEME: DCE's built-in services help streamline applications.
...\" 
...\" 
...\" DCE services offer programmers and administrators convenient ways to
...\" automate distributed application operations.  Built-in services like
...\" the CDS and the DCE Security Service 
...\" 
...\" 
...\" 
...\" For instance the DCE 
...\" application development tools automatically generate code that clients
...\" use to communicate with servers.  Application servers can use CDS by
...\" just invoking a few prefabricated functions that store server location
...\" (binding) information in CDS where clients can find it. 
...\" 
...\" Despite these convenient methods for automating client server
...\" activities, the name service must be configured so that servers and
...\" clients can use it is a logical and consistent manner.  In fact lots of
...\" the administration in the CDS part of this admin guide 
...\" 
...\" There are several ways for servers to obtain their CDS entry name
...\"   hard-coded in the app
...\"   passed to the app via argv (explicitly, via script, via srvrconf)
...\"   manually entered in CDS by via administration operations
...\" 
...\" <FIGURE - Client finds server via CDS and EP map>
...\" 
...\" **********************************************************************
...\" Junk from 3/17
...\" 
...\" DCE consists of a set of services and facilities that supports the
...\" development, execution, and maintenance of distributed applications.
...\" Some of these services directly support client/server interoperation.
...\" For instance, Remote Procedure Call (RPC) provides communications
...\" between clients and servers, converting data between formats of
...\" different platforms whenever it's necessary.  But clients need to find
...\" the servers so the DCE Directory Service provides location-independent
...\" naming.  Servers advertise their presence in CDS where clients can find
...\" them. 
...\" 
...\" Other services help establish boundaries for individual distributed
...\" computing environments called cells.  For instance CDS, or the Cell
...\" Directory Service, stores names and addresses of host computers and
...\" servers in a cell.  People and programs can look in CDS for the
...\" location of a host or server in a cell.  The DCE Security Service
...\" stores the names and passwords of all hosts, servers, and people in a
...\" cell.  People and servers prove their identities to the security
...\" service in return for credentials which people and servers then use to
...\" prove their identities to each other. 
...\" 
...\" A DCE cell is primarily a collection of networked
...\" host computers, DCE services, distributed applications,
...\" and people in a single distributed computing environment.  
...\" 
...\" It's often convenient to think of a DCE cell as a collection of
...\" networked computers, DCE services, DCE applications, and users.
...\" Many aspects of DCE cells require administration.  The DCE DS must be
...\" managed so that servers can successfully advertise their presence to
...\" clients.  The DCE SS must be managed to store and provide
...\" authentication and authorization information about each principal in a
...\" cell.  The time service must be managed (albeit only a little) so that
...\" all hosts share a common notion of time.  While these services are
...\" generally available to all hosts and principals in a cell, the
...\" services themselves might reside on only a few hosts in a cell.  
...\" 
...\" Although it's often convenient to think of a DCE administration as
...\" managing cell as a collection of
...\" networked computers, DCE services, DCE applications, and users.
...\" But each host computer also needs to maintain a certain set to participate as a member of a cell.
...\" 
...\" 
...\" 
...\" 
...\" **********************
...\" STUFF FROM 3/23 (Server control musings....)
...\"
...\"  ??? what year are we talking here ???  3/23/??  
...\"
...\"  ??? (Question asked in July 1996.) ???
...\" 
...\" 
...\" The simplest distributed application might only use remote procedure
...\" call.  But while remote procedure call alone can take care of
...\" rudimentary client server communication needs, it cannot directly help
...\" clients find appropriate servers or accurately identify who is making
...\" a request.  So DCE provides other facilities like the CDS which lets servers advertise their location to clients,
...\" and like the DCE Security Service which helps protect clients,
...\" servers, and their data from unauthorized use.
...\" 
...\" DCE provides many different kinds of services that are needed by
...\" industrial-strength distributed applications.  The simplest
...\" distributed application might only use remote procedure call.  But
...\" while remote procedure call alone can take care of rudimentary client
...\" server communication needs, it cannot directly help clients find
...\" appropriate servers or accurately identify who is making a request.  So
...\" DCE provides other facilities like the CDS
...\" which lets servers advertise their location to clients, and like the
...\" DCE Security Service which helps protect clients, servers, and their
...\" data from unauthorized use.
