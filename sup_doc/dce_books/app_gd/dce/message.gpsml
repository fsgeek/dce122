...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" HISTORY
...\" $Log: message.gpsml,v $
...\" Revision 1.1.4.1  1996/03/21  19:17:46  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/21  19:17:22  wardr]
...\"
...\" Revision 1.1.2.13  1995/06/07  14:36:11  rcb
...\" 	PRENTICE HALL reformat; final edits and changes
...\" 	[1995/06/05  19:52:20  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/04/04  18:37:17  rcb]
...\" 
...\" 	incorporated 1.1 edits
...\" 	[1995/03/30  21:09:36  rcb]
...\" 
...\" Revision 1.1.2.12  1994/11/08  20:26:44  neilson
...\" 	Added index entries.
...\" 	[1994/11/08  20:26:27  neilson]
...\" 
...\" Revision 1.1.2.11  1994/11/03  23:31:00  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:38:14  neilson]
...\" 	Substituted macros for book names in cross refs.
...\" 	Revision 1.1.2.10  1994/10/20  21:07:12  jshirley
...\" 	Move figure title to before figure.
...\" 	[1994/10/20  20:52:48  jshirley]
...\" 	Revision 1.1.2.9  1994/10/19  20:02:53  weir
...\" 	Review comments
...\" 	[1994/10/19  20:02:28  weir]
...\" 	Revision 1.1.2.8  1994/09/19  20:17:04  weir
...\" 	Revised figures
...\" 	[1994/09/19  20:16:25  weir]
...\" 	Revision 1.1.2.7  1994/09/16  18:41:19  weir
...\" 	Updates
...\" 	[1994/09/16  18:40:40  weir]
...\" 	Revision 1.1.2.6  1994/06/13  18:39:35  devobj
...\" 	cr10872 - fix copyright
...\" 	[1994/06/13  18:37:38  devobj]
...\" 	Revision 1.1.2.5  1994/06/12  18:07:50  weir
...\" 	Beta Update
...\" 	[1994/06/12  18:07:23  weir]
...\" 	Revision 1.1.2.4  1994/05/18  18:41:27  weir
...\" 	Beta update
...\" 	[1994/05/18  18:40:54  weir]
...\" 	Revision 1.1.2.3  1994/05/16  21:08:43  weir
...\" 	Beta update
...\" 	[1994/05/16  21:08:14  weir]
...\" 	Revision 1.1.2.2  1994/05/16  14:43:32  weir
...\" 	Initial submission
...\" 	[1994/05/16  14:43:11  weir]
...\" 	Revision 1.1.2.1  1994/03/11  23:03:16  rom
...\" 	{enh, 10129, R1.1}
...\" 	Initial split of App Dev Guide into three books and creation of
...\" 	Intro and Style Guide.
...\" 	[1994/03/11  23:00:47  rom]
...\" 
...\" $EndLog$
...\"
...\" ----------------------------------------------------------------------
.H 1 "DCE Application Messaging"
...\" ----------------------------------------------------------------------
...\" SEE CONNIE COMMENT IN ORANGE OBLONG RE FORMAT
.P
Message generation by distributed programs can be divided into two broad kinds:
.iX "application" "messaging"
.ML
.LI
``Normal'' (often user-prompted, client-generated) messages
.LI
``Server event'' messages, containing information about server activity,
either normal or extraordinary
.LE
.P
Similarly, DCE makes available to applications two messaging APIs:
.ML
.LI
The DCE messaging interface
.iX "messaging" "interface"
.LI
The DCE serviceability interface
.iX "serviceability" "interface"
.LE
.P
The DCE serviceability interface is designed specifically to route messages
of the second type; it is described in Chapter 4.  Messages in the
first category are output using the DCE general-purpose application messaging
routines, which are the subjects of this chapter.
.P
Although the two interfaces, broadly speaking, do the same general thing (that
is,
write messages), their functionality was designed to serve different needs,
both of which occur in most distributed applications.  Nevertheless, either
interface can be used more or less exclusively of the other, if desired.
...\" ----------------------------------------------------------------------
.H 2 "DCE and Messages"
...\" ----------------------------------------------------------------------
.P
A \*Vmessage\*O is a readable character string conveying information about some
aspect of a program's state or activity to a human audience.  Messages may be
purely informational or they may be intended to be responded to (that is, be
``interactive'').  Prompts, error displays, warnings, logs, announcements and
program responses are all various kinds of message.
.iX "announcements"
.iX "logs"
.iX "warnings"
.iX "error displays"
.iX "prompts"
.iX "program responses"
.P
DCE applications can simply use the standard output routines (such as \*Lprintf(\|)\*O,
\*Lsprintf(\|)\*O, and so on) for messaging.  However, DCE provides two message interfaces
that automatically and transparently take care of many of the special problems that
distributed application messaging can give rise to.  These interfaces are used by the
DCE components themselves to implement their messaging.
.P
Both of the DCE message facilities use XPG4 message catalog files 
(see the \*VX/Open Portability Guide\*O) 
to hold message text.  The message catalogs are generated by a DCE
.iX "message" "catalog"
utility (called \*Lsams\*O) during the application development process, and must
.iX "sams utility for message catalog generation"
be installed in the correct platform-dependent location in order for the DCE
messaging library routines to be able to find them (and, consequently, the
messages) at runtime.
.P
The main purpose of message catalogs is to allow programs' message text to be
stored and organized (separately from the programs themselves) in a culture- or
nationality-specific way.  This enables programs to switch their I/O styles
and contents to the form appropriate to the geographical location (\*Vlocale\*O)
they are running in, simply by using the appropriate catalog.  Thus, it is essential
to compose catalogs in such a way that each one contains message text appropriate
only to a single (same) locale.
.P
Questions such as the proper use of locales, proper language style for messages,
where catalogs should be installed, and so on, all fall under the broad topic of
\*Vinternationalization\*O, and are not discussed in this chapter.  The other important
aspect of internationalization, namely character and code set compatibility, is
discussed in detail in Chapter 15. 
...\" ----------------------------------------------------------------------
...\" Codeset Server/Client Compatibility
...\" ----------------------------------------------------------------------
...\" [the following is excerpted from ../codeset_conversion:]
...\" Q: How is codeset conversion/internationalization going to be implemented 
...\"    in DCE 1.1? Specifically, How much will a programmer have to do and
...\"    how much will IDL or the RPC runtime do? Who will do codeset conversion?
...\" In most cases, application programmers don't have to know which code set(s)
...\" they are working in.  Any code set conversion is done transparently by the
...\" RPC runtime.
...\" Almost all of the work is done by either the compiler or the runtime
...\" support library in cases where the default representations and
...\" conversion policies are selected.  The programmer writes an .idl file
...\" and an .acf file, and the compiler generates code to do the conversions
...\" automatically.
...\" On the server side, its supported code sets need to be registered either
...\" with the NSI by a new management runtime call, or to some administration
...\" file by an administrator.  In other words, the server programmer adds code-
...\" set information to the namespace to advertise on server codeset and converter
...\" support.  
...\" On the client side, the preferred conversion model is chosen by the application
...\" programmer, and the RPC runtime is made aware of the model by a new management
...\" runtime call.  The client programmer calls import with a new compatibility evalu-
...\" ation feature to determine whether a client and server can communicate (based on
...\" codeset). 
...\" Then you make the RPC. The conversion happens automatically.
...\" There are options available so you can write your own converters and compatibility
...\" evaluation routines, and we provide defaults.  Thus, even though the RPC runtime will
...\" provide several conversion models, application developers are free to write their own
...\" conversion models and methods when they need to satisfy their own requirements; the
...\" RPC runtime provides a framework to support this kind of extension.  DCE RFC41.0 ex-
...\" plains these mechanisms.
...\" ----------------------------------------------------------------------
.H 2 "DCE Messaging Interface Usage"
...\" ----------------------------------------------------------------------
...\" 	
.P
Use of the DCE messaging API is very straightforward.  In the application code
itself, all that is usually required is simply to call one of the output routines,
passing it the ID of the message to be output.  The messages themselves must
first be defined in a text file which must then be processed by the DCE \*Lsams\*O
(symbols and message strings) utility, which generates the message catalog
file along with other C source files that contain code necessary to facilitate the
additional layer of functionality that DCE has added to the XPG4 message catalog
mechanism.
...\" ----------------------------------------------------------------------
.H 3 "A Simple DCE Messaging Example"
...\" ----------------------------------------------------------------------
.P
The following subsections 
describe all the steps and code necessary to compile an
application that uses the DCE messaging 
API to print the familiar ``Hello World'' message.
...\" ----------------------------------------------------------------------
.H 4 "Defining the Message"
...\" ----------------------------------------------------------------------
.P
For our example, we will define a \*Lsams\*O
file with the minimum contents necessary
to print the one brief message we want to display. 
(Additional information on the
use of \*Lsams\*O can be found in the \*Lsams(1dce)\*O reference page,
which contains comprehensive descriptions of all
aspects of the utility.)
.P
Each line in a \*Lsams\*O file consists of a simple \*Vheader\*O and \*Vvalue\*O
combination.  The \*Vheader\*O indicates the meaning of the value being specified,
and \*Vvalue\*O is the value itself.  A \*Lsams\*O file for messaging use is normally made
up of three parts (although only two parts are needed for the short example in this
chapter).  The first part consists of a minimum of one line that specifies the
name of the 
\*Vcomponent\*O (that is, the application) that is to use the messages
that will be generated from the file.
.P
.ne 8
Each invocation of \*Lsams\*O to process a separate 
\*L.sams\*O input file produces
a complete set of output files that can be used by the DCE messaging routines to
print or log messages as required.  These ``sets'' of output files are organized by
DCE \*Vcomponent\*O. (In DCE itself, these components are identical to the DCE components:
RPC, DTS, and so on; for applications, the categorization of components is determined
by the developer.) Each set of output files will have names in which the component
name (also determined by the developer) appears.
.P
The component name that you specify at the top of a \*Lsams\*O file must consist of a
three-character (no more, no less) string.  For the ``Hello World'' program we will
use the component name \*Lhel\*O:
.oS
# Part I of simple sams message file...
component           hel
.oE
.P
The \*Lhel\*O string will be used to identify all the files and data structures
that \*Lsams\*O will generate from the file.
.P
The second (and final) part of a \*Lsams\*O file for DCE messaging consists of a series of
records that specify the messages themselves.  Each record is delimited by the \*Lstart\*O
and \*Lend\*O keywords.  Within each record, a series of keywords identifies the various
information that each message consists of or has associated with it.
.P
Our file will contain only one message, the text of 
which is to be ``Hello World''. The
record that specifies it is as follows:
.oS
start
code          hello_msg
text          "Hello World"
action        "None required"
explanation   "Greeting message for sample messaging program"
end
.oE
.P
The keywords specified have the following meanings:
.VL 1.25i
.LI "\*Lcode\*O"
Identifies the message.
.LI "\*Ltext\*O"
Specifies the text of the message itself.
.LI "\*Lexplanation\*O"
Describes the meaning of the message.  The text following this keyword
is used to generate the documentation of the component's messages.
.LI "\*Laction\*O"
.ne 3
Describes any action(s) that should be taken in response to the message.
The text following this keyword is used to generate the documentation of
the component's messages.
.LE
...\" ----------------------------------------------------------------------
.H 4 "Processing the \*L.sams\*O File"
...\" ----------------------------------------------------------------------
.P
The entire \*Lsams\*O file for the \*Lhello\*O program is as follows:
...\" sams input file for hello.c:
.oS
# Part I
component     hel

# Part II
start
code          hello_msg
text          "Hello World"
action        "None required"
explanation   "Greeting message for sample messaging program"
end
.oE
.P
We create the file with these contents and name it \*Lhel.sams\*O.
.P
A \*Lsams\*O file containing DCE messaging API message definitions (in other words, a
sams file not containing definitions for DCE serviceability API messages) should
be compiled by invoking \*Lsams\*O as follows:
.iS
sams -o thmc \*Vsams_filename\*O
.iE
.P
where:
.VL 1i
.LI "\*L-o\*O"
Introduces output flags as follows:
.VL .5i
.LI "\*Lt\*O"
Specifies that a file containing source code to generate an in-memory message table
be output by \*Lsams\*O.
.LI "\*Lh\*O"
Specifies that a header file defining codes for the message numbers be output by
\*Lsams\*O.
.LI "\*Lm\*O"
Specifies that a \*L.msg\*O file be output by \*Lsams\*O.
.LI "\*Lc\*O"
Specifies that \*Lsams\*O call \*Lgencat\*O (with the \*L.msg\*O file as input) to
produce a message catalog.
.LE
.LE
.P
Running the command as shown will result in four files being output:
.VL 1.5i
.LI "\*Ldcehel.cat\*O"
XPG4 message catalog file created by \*Lgencat\*O. If you wish to use the
message catalog, you must install it yourself.
.LI "\*Ldcehel.msg\*O"
Message input file for \*Lgencat\*O.
.LI "\*Ldcehelmsg.c\*O"
Code defining the in-memory table of message texts.  By using this table
you can avoid depending on extracting message texts from the message catalog.
.LI "\*Ldcehelmsg.h\*O"
Header file containing definitions for \*Ldcehelmsg.c\*O.
.LE
.P
The header file should be included in 
the program source code.  The \*Ldcehelmsg.c\*O
module should be compiled and linked with the program object module.  The message catalog
should be installed in the correct platform-dependent location.
.P
All that remains now is to create a simple C program that calls a DCE messaging
routine to output the ``Hello World'' message.
...\" ----------------------------------------------------------------------
.H 4 "Program Source"
...\" ----------------------------------------------------------------------
.P
The complete source code for \*Lhello.c\*O is as follows:
.oS
#include <dce/dce_svc.h>
#include "dcehelmsg.h"

int
main(
    int     argc,
    char    *argv[])
{

    dce_printf(hello_msg);

}
.oE
.P
.ne 9
To build the application, you simply
.ML
.LI
Process the \*Lhel.sams\*O file with the \*Lsams\*O command.
.LI
Build and link \*Lhello\*O from the following modules:
.ML
.LI
\*Ldcehelmsg.c\*O
.LI
\*Lhello.c\*O
.LE
.LE
.P
When executed, the program will print the following:
.oS
Hello World
.oE
.P
This is the text of the \*Lhello_msg\*O message as defined in the
\*Lhel.sams\*O file.
...\" ----------------------------------------------------------------------
.H 4 "DCE Messaging and Message Catalogs"
...\" ----------------------------------------------------------------------
.P
The reader may be wondering why, in the previous example, it was not necessary
to explicitly open the message catalog before making the call to retrieve and
.iX "message" "catalog"
print the message itself.  The answer is that \*Ldce_printf(\|)\*O takes care
of this step implicitly.  It is able to find the message catalog because the
catalog's name is generated from the \*Lcomponent\*O field in the first part
of the \*Lsams\*O file.  Of course, for this to work, the message catalog must be
installed in the correct system-defined location before the application is run.
.P
An application may even dispense with the use of installed message catalogs
altogether, and use ``in-memory'' message tables instead.  The necessary code
to declare the \*Lsams\*O file messages as arrays in program memory is contained in
the \*Ldce\*Vcmp\*Lmsg.c\*O file generated with the \*Lsams -o t\*O option.
To initialize the table before using it the application must also call the
\*Ldce_msg_define_msg_table(\|)\*O routine, described in Section 3.3.3.
The message
routines will, when called, attempt to use the application's message catalog;
but if it cannot be found, the in-memory table will be used instead.
...\" ----------------------------------------------------------------------
.H 3 "The DCE Message Interface and sams Input and Output Files"
...\" ----------------------------------------------------------------------
.P
Figure 3-1 shows the relationship of the various files, both source
and \*Lsams\*O output, that go to make up DCE application code that uses the
DCE messaging API. 
.P
The two parallelogram-shaped objects represent the files
that must be created by the developer (you).
.P
Rectangular objects with solid
lines represent files that are generated by \*Lsams\*O; the two ovals represent
executable utilities: one is \*Lsams\*O, the other \*Lgencat\*O (which is
implicitly run by \*Lsams\*O when message catalogs are generated).
.P
The large
rectangular object in dashed lines represents \*Llibdce\*O, which contains the
DCE message API library.
.P
This illustration makes no attempt to show how a DCE application that 
uses DCE messaging should be compiled and linked, nor how it runs.  
It is merely a static map of the
general place of DCE application messaging in DCE development.
...\" ------------------------------------
...\" ----------------------------------------------------------------------
...\" Figure: Showing regular use of sams.
...\" ----------------------------------------------------------------------
...\" ------------------------------------
...\" pix/sams_reg_use.pic
.P
.ne 5i
.FG "sams and DCE Messages"
...\" ----------------------------------------------------------------------
.sp
.PS
.in 1i
scale = 100
line ->  from 352, 436 \
	to 456, 388 
"\fR\s8\s8\fR"  at 456, 244
"\fR\s8(doc)\s8\fR"  at 512, 380
"\fB\s8dcehelmsg.idx\s8\fR"  at 504, 396
line   from 552, 372 \
	to 552, 404 \
	to 456, 404 \
	to 456, 372 \
	to 552, 372 
"\fB\s8dcehelmsg.sml\s8\fR"  at 504, 444
"\fR\s8)\s8\fR"  at 360, 260
"\fB\s8sams\s8\fR"  at 344, 260
"\fR\s8(executed by\s8\fR"  at 344, 272
"\fB\s8gencat\s8\fR"  at 344, 284
line  dashed from 192, 212 \
	to 288, 204 
"\fB\s8libdce\s8\fR"  at 112, 164
"\fB\s8dce_printf(hello_msg);\s8\fR"  at 128, 212
"\fB\s8dcehelmsg.h\s8\fR"  at 96, 468
"\fB\s8dcehelmsg.c\s8\fR"  at 96, 428
"\fB\s8sams\s8\fR"  at 312, 452
"\fB\s8dcehel.msg\s8\fR"  at 344, 348
"\fB\s8dcehel.cat\s8\fR"  at 344, 212
"\fB\s8dcehelmsg.man\s8\fR"  at 504, 492
"\fB\s8hel.sams\s8\fR"  at 304, 580
line   from 96, 412 \
	to 96, 284 
line   from 96, 444 \
	to 96, 452 
line   from 144, 452 \
	to 144, 484 \
	to 48, 484 \
	to 48, 452 \
	to 144, 452 
line   from 144, 412 \
	to 144, 444 \
	to 48, 444 \
	to 48, 412 \
	to 144, 412 
line ->  from 360, 444 \
	to 456, 436 
line ->  from 360, 452 \
	to 456, 484 
line ->  from 256, 452 \
	to 144, 428 
line ->  from 256, 452 \
	to 144, 468 
line   from 552, 468 \
	to 552, 500 \
	to 456, 500 \
	to 456, 468 \
	to 552, 468 
line   from 552, 420 \
	to 552, 452 \
	to 456, 452 \
	to 456, 420 \
	to 552, 420 
"\fR\s8(doc)\s8\fR"  at 506, 476
"\fR\s8(doc)\s8\fR"  at 508, 428
line ->  from 320, 428 \
	to 336, 372 
"\fR\s8\s8\fR"  at 114, 244
ellipse wid 104 ht 48 at 310, 448
"\fR\s8\s8\fR"  at 96, 4
ellipse wid 104 ht 48 at 340, 274
line   from 288, 220 \
	to 392, 220 \
	to 392, 188 \
	to 288, 188 \
	to 288, 220 
"\fR\s8(message catalog)\s8\fR"  at 344, 196
line   from 288, 364 \
	to 392, 364 \
	to 392, 332 \
	to 288, 332 \
	to 288, 364 
line ->  from 344, 332 \
	to 344, 300 
line ->  from 344, 252 \
	to 344, 220 
line  dotted from 280, 372 \
	to 400, 372 \
	to 400, 180 \
	to 280, 180 \
	to 280, 372 
line   from 0, 284 \
	to 208, 284 \
	to 224, 252 \
	to 16, 252 \
	to 0, 284 
"\fR\s8(DCE library)\s8\fR"  at 110, 150
line  dashed from 96, 484 \
	to 96, 484 
line -> dashed from 112, 260 \
	to 120, 220 
line  dashed 0.1 * scale from 16, 252 \
	to 16, 116 \
	to 224, 116 \
	to 224, 252 
"\fR\s8\s8\fR"  at 304, 564
line   from 232, 596 \
	to 248, 564 \
	to 376, 564 \
	to 360, 596 \
	to 232, 596 
line ->  from 312, 564 \
	to 312, 476 
"\fB\s8hello.c\s8\fR"  at 112, 268
.in
.PE
.P
.ne 20
The \*Lsams\*O output filenames are made up of the following pieces:
.oS
\*Vtech_name\ \*L+ \*Vcomp_name\ \*L+\ \*Vpart_name\ \*L+\ \*Vextension\*O
.oE
.P
where:
.VL 1i
.LI "\*Vtech_name\*O"
Is the technology name (optionally specified at the top of the \*Lhel.sams\*O file);
by default \*Ldce\*O.
.LI "\*Vcomp_name\*O"
Is the component name (specified at the top of the \*Lhel.sams\*O file); in
this case, \*Lhel\*O.
.LI "\*Vpart_name\*O"
Is a substring identifying the particular file; for example, \*Lsvc\*O or
\*Lmsg\*O, and so on.  This piece of the name is omitted from the message
catalog filenames (in our example, \*Ldcehel.msg\*O and \*Ldcehel.cat\*O).
.LI "\*Vextension\*O"
Is the file extension (preceded by a \*L.\*O (dot) character).
.LE
.P
The files
\*Ldcehelmsg.man\*O (generated by \*Lsams -p d hel.sams\*O) and
...\" \*Ldcehelmsg.idx\*O (generated by \*Lsams ???? hel.sams\*O)
\*Ldcehelmsg.sml\*O (generated by \*Lsams -p p hel.sams\*O), 
which are shown in Figure 3-1, were not generated
by the following command:
.iS
sams -o thmc hel.sams
.iE
.P
They could have been generated by executing this command:
.iS
sams -o dp hel.sams
.iE
.P
These are automatically generated documentation files (their nature and
purpose were previously described) that have nothing to do 
with the operation of the interface itself.
...\" DCE 1.2 WRITER: PLEASE CHECK THE ABOVE INFORMATION FOR ACCURACY
.P
A definitive description of \*Lsams\*O and the contents of 
\*Lsams\*O files can be found in the \*Lsams(1dce)\*O reference page.
...\" ----------------------------------------------------------------------
.H 2 "DCE Messaging Routines"
...\" ----------------------------------------------------------------------
.P
There are several different DCE messaging routines.  It is possible for an application
to accomplish all of its messaging tasks with only one or two of these routines
(\*Ldce_printf(\|)\*O and \*Ldce_error_inq_text(\|)\*O); additional routines
allow applications to perform manipulations on message tables, open and close
message catalogs explicitly, retrieve messages without printing them, and so on.
The complete list of routines is as follows:
.ML
.LI
Message output routines
.iX "message" "output routines"
.P
These routines retrieve and output a specified message.  If necessary,
the message catalog is opened.
.ML
.LI
\*Ldce_printf(\|)\*O
.LI
\*Ldce_fprintf(\|)\*O
.LI
\*Ldce_sprintf(\|)\*O
.LI
\*Ldce_pgm_printf(\|)\*O
.LI
\*Ldce_pgm_sprintf(\|)\*O
.LI
\*Ldce_pgm_fprintf(\|)\*O
.LE
.LI
Message retrieval routines
.iX "message" "retrieval routines"
.P
These routines retrieve a specified message.  If necessary, the message
catalog is opened.
.ML
.LI
\*Ldce_msg_get_msg(\|)\*O
.LI
\*Ldce_msg_get(\|)\*O
.LI
\*Ldce_msg_get_default_msg(\|)\*O
.LI
\*Ldce_error_inq_text(\|)\*O
.LE
.LI
Message table routines
.iX "message" "table routines"
.P
Miscellaneous routines for manipulating in-memory message tables.
.ML
.LI
\*Ldce_msg_define_msg_table(\|)\*O
.LI
\*Ldce_msg_translate_table(\|)\*O
.LE
.LI
.ne 12
DCE XPG4 routines
.iX "DCE" "XPG4 routines"
.P
DCE versions of the XPG messaging routines \*Lcatopen(\|)\*O, \*Lcatgets(\|)\*O,
and \*Lcatclose(\|)\*O.
.ML
.LI
\*Ldce_msg_cat_open(\|)\*O
.LI
\*Ldce_msg_cat_get_msg(\|)\*O
.LI
\*Ldce_msg_get_cat_msg(\|)\*O
.LI
\*Ldce_msg_cat_close(\|)\*O
.LE
.LE
.sp 2
.P
Generally speaking, routines that retrieve or print messages will first try to
get a message from the message catalog file (the routines deduce the correct
message catalog from the message ID that is passed to them).  Routines will look
for the catalog in the current locale's system-specific location for
correctly installed message catalogs.
.P
If the message catalog cannot be found, and an in-memory message table has
been defined, the message will be retrieved from there.
.P
The only exception to this message-finding algorithm occurs with
\*Ldce_msg_get_default_msg(\|)\*O, which always attempts to retrieve the
in-memory message only.
.P
The following sections describe each of the DCE messaging routines in detail.
Complete reference pages for the routines can be found in the \*(Dr.
...\" ----------------------------------------------------------------------
.H 3 "Message Output Routines"
...\" ----------------------------------------------------------------------
.P
The six message output routines in this group essentially reproduce the
functionality of \*Lprintf(\|)\*O, \*Lfprintf(\|)\*O, and \*Lsprintf(\|)\*O,
with the difference being 
that they operate on a specified message rather than on
a string variable.  The routines can be called without any special preparation
(but see the descriptions of the three \*Ldce_pgm_\*O routines).
.VL 1i
.LI "\*Ldce_fprintf(\|)\*O"
.ne 6
.nL
Retrieves the message text associated with the specified message ID, and prints
the message and its arguments on the specified stream.  The message is printed
\*Vwithout\*O a concluding newline; if a newline is desired at the end of the
message, then it should be coded (as \*L\\n\*O) in the message definition in
the \*Lsams\*O file.
.P
The routine determines the correct message catalog and, if neccessary, opens it.
If the message catalog is inaccessible, and the message exists in an in-memory
table, then this message (the default message) is printed.  If for any
reason the message cannot be retrieved, an error message is printed.
.LI "\*Ldce_printf(\|)\*O"
.nL
Performs a \*Ldce_fprintf(\|)\*O of the specified message to standard output.
.LI "\*Ldce_sprintf(\|)\*O"
.nL
Retrieves the message text associated with the specified message ID, and writes
the message and its arguments into an allocated string (which should be freed by
the caller).  The routine determines the correct message catalog and, if neccessary,
opens it.  If the message catalog is inaccessible, and the message exists in an
in-memory table, then this message (the default message) is printed.  If for
any reason the message cannot be retrieved, an error message is printed.
.P
For example, assume that the following message is defined in an application's
\*Lsams\*O file:
.oS
.ps 10
.vs 12
start
code          arg_msg
text          "This message has exactly %d not %d argument(s)"
action        "None required"
explanation   "Test message with format arguments"
end
.ps 12
.vs 14
.oE
.P
.ne 12
The following code fragment shows how \*Ldce_sprintf(\|)\*O might be called to
write the message (with some argument values) into a string:
.oS
unsigned char     *my_msg;

my_msg = dce_sprintf(arg_msg, 2, 8);

/* Process my_msg as appropriate...    */

free(my_msg);
.oE
.P
Of course, \*Ldce_printf(\|)\*O could also be called to print the message and
arguments:
.oS
dce_printf(arg_msg, 2, 8);
.oE
.LI "\*Ldce_pgm_printf(\|)\*O"
.nL
Equivalent to \*Ldce_printf(\|)\*O, except that it prefixes the program name to
the message (in the standard style of DCE error messages), 
whereas \*Ldce_printf(\|)\*O
does not.  This allows clients (which do 
not usually use the serviceability interface)
to produce error (or other) messages that
automatically include the originating
application's name.  The message is printed with a concluding newline.
.P
Note that the client should call \*Ldce_svc_set_progname(\|)\*O first to set the
desired application name.  Otherwise, the default program name will be
.oS
PID#\*Vnnnn\*O
.oE
.P
where \*Vnnnn\*O is the process ID of the application making the call.
.LI "\*Ldce_pgm_sprintf(\|)\*O"
.nL
Equivalent to \*Ldce_sprintf(\|)\*O, except that it prefixes the program name to the
string (in the standard style of DCE error messages), whereas \*Ldce_sprintf(\|)\*O
does not.  Note that the client must call \*Ldce_svc_set_progname(\|)\*O first to set
the desired application name.
.P
.ne 5
Otherwise, the default name is
.oS
PID#\*Vnnnn\*O
.oE
.P
where \*Vnnnn\*O is the process ID of the application making the call.
.LI "\*Ldce_pgm_fprintf(\|)\*O"
.nL
Equivalent to \*Ldce_fprintf(\|)\*O, except that it prefixes the program name to the
string (in the standard style of DCE error messages), whereas \*Ldce_fprintf(\|)\*O
does not.  The message is printed with a concluding newline.
.P
Note that the client must call \*Ldce_svc_set_progname(\|)\*O first to set the
desired application name.  Otherwise, the default name is
.oS
PID#\*Vnnnn\*O
.oE
.P
where \*Vnnnn\*O is the process ID of the application making the call.
.LI "\*Ldce_error_inq_text(\|)\*O"
.nL
Opens a message catalog, extracts a message identified by a message ID, and
places the message in the space pointed to by the \*Vtext\*O parameter.  If the message
catalog is inaccessible, and there is a default message in memory, the default message
is copied into the space passed.  If neither the catalog nor the default message is
available, a status code is placed in the status output parameter and the message is
returned as a hexadecimal number; the routine always returns a printable message.
.P
This routine existed in prior releases of DCE and has been modified for 
DCE Version 1.1 to use the default message arrays.  Programs prior to Version
1.1 that use the routine do not need to be modified.
.P
.ne 9
For example, assume that the following message is defined in an application's
\*Lsams\*O file:
.oS
start
code          error_msg
text          "Error: %s"
action        ""
explanation   "DCE error status message"
end
.oE
.P
The following code fragment 
shows how \*Ldce_\%error_inq_text(\|)\*O could be used to
retrieve the error status received from a DCE routine:
.oS
.ps 10
.vs 12
dce_error_string_t  error_string;
unsigned32          status;
int                 error_inq_status;
uuid_t              type_uuid, obj_uuid;

             \*V<.\ .\ .>\*C

rpc_object_set_type(&obj_uuid, &type_uuid, &status);
if (status != rpc_s_ok)
{
  dce_error_inq_text(status, error_string, &error_inq_status);
  dce_printf(error_msg, error_string);
}
.ps 12
.vs 14
.oE
.LE
...\" ----------------------------------------------------------------------
.H 3 "Message Retrieval Routines"
...\" ----------------------------------------------------------------------
.P
The following three routines retrieve messages, but do not print them.
.VL 1i
.LI "\*Ldce_msg_get_msg(\|)\*O"
.nL
Retrieves a message (identified by a global message ID) from a message catalog,
and returns a pointer to a \*Lmalloc(\|)\*O'd space containing the message.  The
routine determines the correct message catalog and opens it.  If the message
catalog is inaccessible, and the message exists in an in-memory table, then this
message (the default message) is returned in the allocated space.  If neither
the catalog nor the default message is available, an error status code is placed
in the status output parameter.
.P
.ne 4
The following code fragment shows how \*Ldce_msg_get_msg(\|)\*O might be called
to retrieve the ``Hello World'' message defined in the example program earlier
in this chapter:
.oS
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include "dcehelmsg.h"

unsigned char       *my_msg;
unsigned32          status;

             \*V<.\ .\ .>\*C

my_msg = dce_msg_get_msg(hello_msg, &status);
printf("Message is: %s\en", my_msg);
free(my_msg);
.oE
.LI "\*Ldce_msg_get(\|)\*O"
.nL
This is a convenience form of \*Ldce_msg_get_msg(\|)\*O. 
If it fails, it does not pass back or return a status code, 
but instead fails with an assertion error, that is,
aborts the calling process.
.P
The following code fragment shows how the routine might be called to retrieve the
``Hello World'' message defined in the example program earlier in this chapter:
.oS
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include "dcehelmsg.h"

unsigned char       *my_msg;

             \*V<.\ .\ .>\*C

my_msg = dce_msg_get(hello_msg);
printf("Message is: %s\en", my_msg);
free(my_msg);
.oE
.LI "\*Ldce_msg_get_default_msg(\|)\*O"
.ne 6
.nL
Retrieves a message (identified by a global message ID) from an 
in-memory message table 
and returns a pointer to static space containing the message retrieved.  If
the default message is not available, an error status code 
is placed in the status output parameter.
.P
The following code fragment shows how \*Ldce_\%msg_\%get_default_msg(\|)\*O 
might be called to retrieve the in-memory copy of the ``Hello World'' 
message defined in the example program earlier in this chapter:
.ps 11
.vs 13
.oS
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include "dcehelmsg.h"

unsigned char       *my_msg;
unsigned32          status;

             \*V<.\ .\ .>\*C

my_msg = dce_msg_get_default_msg(hello_msg, &status);
printf("Message is: %s\en", my_msg);
.oE
.ps 12
.vs 14
.P
Note that, in order for this
call to be successful, \*Ldce_msg_define_msg_table(\|)\*O
must first have been called to set the table up in memory.  
For an example of how this is done, see the following section.
.LE
...\" ----------------------------------------------------------------------
.H 3 "Message Table Routines"
...\" ----------------------------------------------------------------------
.P
The two routines in this group are intended to be used to perform manipulations
on the in-memory message table.
.P
The in-memory table is implemented with code generated by \*Lsams\*O and contained
in the \*Ldce\*Vcmp\*Lmsg.c\*O module (where \*Vcmp\*O is the component name of the
application, as specified in the \*Lcomponent\*O field in part I of the
\*Lsams\*O file).
This file must then be compiled and linked with the application, and
\*Ldce_msg_define_msg_table(\|)\*O is called at runtime to set up the table.
.P
.ne 5
Note that,
even if an in-memory table is defined, the DCE messaging routines still
will always attempt first to extract the specified message from 
the message catalog,
and only if unsuccessful will they revert to the in-memory 
table.  The exception to
this rule is \*Ldce_msg_get_default_msg(\|)\*O, 
which always attempts to retrieve
the in-memory message only.
.VL 1i
.LI "\*Ldce_msg_define_msg_table(\|)\*O"
.nL
Installs a default in-memory message table accessible to DCE messaging routines.
This routine is intended to be used by programs that load all messages from a
catalog into memory in order to avoid file access overhead on message retrieval.
.P
The following code fragment shows how \*Ldce_\%msg_define_msg_table(\|)\*O 
might be
called to set up an in-memory message table consisting of the contents of the
messages defined in \*Lhel.sams\*O earlier in this chapter:
.oS
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include "dcehelmsg.h"

unsigned32          status;

             \*V<.\ .\ .>\*C

dce_msg_define_msg_table(hel_msg_table,
 sizeof(hel_msg_table) / sizeof(hel_msg_table[0]),
                         &status);
.oE
.LI "\*Ldce_msg_translate_table(\|)\*O"
.nL
Makes a new copy of the specified in-memory message table 
(that is, updates the table
with the contents of a message table, which has changed because of a change in
locale).
.P
Note that this routine will fail if the message catalog is not installed or if
\*LLANG\*O is not properly set, since the update depends on accessing the contents
of the message catalog (unlike the initial table setup, which is done from the code
in the \*Ldce\*Vcmp\*Lmsg.c\*O file).
.P
.ne 6
The following code fragment shows how \*Ldce_\%msg_translate_table(\|)\*O might be
called to translate the in-memory table that was set up by the call to
\*Ldce_\%msg_define_msg_table(\|)\*O in the previous example:
.oS
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include <locale.h>
#include "dcehelmsg.h"

char                *loc_return;
unsigned32          status;

             \*V<.\ .\ .>\*C

loc_return = setlocale(LC_MESSAGES, "C");
dce_msg_translate_table(hel_msg_table,
 sizeof(hel_msg_table) / sizeof(hel_msg_table[0]),
                        &status);
.oE
.LE
...\" ----------------------------------------------------------------------
.H 3 "DCE XPG4 Routines"
...\" ----------------------------------------------------------------------
.P
The four routines in this group provide DCE versions of functionality of the
XPG messaging routines \*Lcatopen(\|)\*O, \*Lcatgets(\|)\*O, and \*Lcatclose(\|)\*O.
.VL 1i
.LI "\*Ldce_msg_cat_open(\|)\*O"
.nL
(DCE abstraction over \*Lcatopen(\|)\*O) Opens a message catalog identified by a
message ID. The routine returns a handle to the open catalog from which messages
will be extracted.  This routine is intended for use by applications (such as user
interface programs) that display many messages from a particular catalog.
.P
The routine will fail if the message catalog is not installed or if \*LLANG\*O
is not properly set.
.P
The following code fragment shows how 
\*Ldce_\%msg_\%cat_open(\|)\*O might be called
to open the message catalog containing the ``Hello World'' message defined for
the example application earlier in this chapter:
.oS
.ps 11
.vs 13
.ne 10
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include "dcehelmsg.h"

dce_msg_cat_handle_t    hel_msg_handle;
unsigned32              status;

             \*V<.\ .\ .>\*C

hel_msg_handle = dce_msg_cat_open(hello_msg, &status);
.ps 12
.vs 14
.oE
.P
.LI "\*Ldce_msg_cat_get_msg(\|)\*O"
.nL
(DCE abstraction over \*Lcatgets(\|)\*O)  Retrieves 
a message from an open catalog.
If the message is not available, returns NULL.
.P
The routine will fail if the message catalog is not installed or if
\*LLANG\*O is not properly set.
.P
The following code fragment shows how 
\*Ldce_\%msg_\%cat_get_msg(\|)\*O might be called
to retrieve the ``Hello World'' message.  Note that the message catalog must first
be opened.
.oS
.ps 10
.vs 12
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include "dcehelmsg.h"

dce_msg_cat_handle_t    hel_msg_handle;
unsigned32              status;
unsigned_char_t         *msg;

             \*V<.\ .\ .>\*C

hel_msg_handle = dce_msg_cat_open(hello_msg, &status);
msg = (unsigned_char_t *)dce_msg_cat_get_msg(hel_msg_handle,
                                             hello_msg,
                                             &status);
printf("Message from dce_msg_cat_get_msg == %s\en", msg);
.ps 12
.vs 14
.oE
.P
.LI "\*Ldce_msg_get_cat_msg(\|)\*O"
.nL
Convenience form of previous routine.  Opens a message catalog, extracts a message
identified by a global message ID, and returns a pointer to \*Lmalloc(\|)\*O'd space
containing the message.  If the message catalog is inaccessible, returns an error.
.P
.ne 2
The routine will fail if the message catalog is not installed or if
\*LLANG\*O is not properly set.
.P
The following code fragment shows how \*Ldce_\%msg_\%get_cat_msg(\|)\*O might be
called to retrieve the ``Hello World'' message:
.oS
.ps 11
.vs 13
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include "dcehelmsg.h"

unsigned32              status;
unsigned_char_t         *msg;

             \*V<.\ .\ .>\*C

msg = dce_msg_get_cat_msg(hello_msg, &status);
printf("Message from dce_msg_get_cat_msg == %s\en", msg);
.ps 12
.vs 14
.oE
.P
.LI "\*Ldce_msg_cat_close(\|)\*O"
.nL
(DCE abstraction over \*Lcatclose(\|)\*O)  Closes 
the catalog specified by \*Vhandle\*O.
.P
The following code fragment shows how 
\*Ldce_\%msg_cat_close(\|)\*O might be called
to close the message catalog containing the ``Hello World'' message:
.oS
#include <dce/dce.h>
#include <dce/dce_msg.h>
#include "dcehelmsg.h"

dce_msg_cat_handle_t    hel_msg_handle;
unsigned32              status;

             \*V<.\ .\ .>\*C

dce_msg_cat_close(hel_msg_handle, &status);
.oE
...\" ----------------------------------------------------------------------
