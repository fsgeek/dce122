...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" 
...\" 
...\" HISTORY
...\" $Log: dced.gpsml,v $
...\" Revision 1.1.7.1  1996/10/16  15:41:54  weir
...\" 	CR 9830: added greet_dced example, first pass
...\" 	[1996/10/16  15:41:23  weir]
...\"
...\" Revision 1.1.4.1  1996/03/21  19:17:44  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/21  19:17:19  wardr]
...\" 
...\" Revision 1.1.2.13  1995/06/07  14:35:50  rcb
...\" 	PRENTICE HALL reformat; final edits and changes
...\" 	[1995/06/05  19:52:11  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/04/04  17:16:01  rcb]
...\" 
...\" 	incorporated 1.1 edits
...\" 	[1995/03/30  19:50:59  rcb]
...\" 
...\" 	incorporated 1.1 edits (actually no change, all done by steto
...\" 	[1995/03/30  17:29:13  rcb]
...\" 
...\" Revision 1.1.2.12  1994/11/09  20:51:31  neilson
...\" 	Added index entries.
...\" 	[1994/11/09  20:51:08  neilson]
...\" 
...\" Revision 1.1.2.11  1994/11/09  18:26:05  steto
...\" 	{edt, R1.1, Inc'd production edits for PH version.}
...\" 	[1994/11/09  18:25:13  steto]
...\" 
...\" Revision 1.1.2.10  1994/10/20  21:50:14  jshirley
...\" 	Paging repairs.
...\" 	[1994/10/20  21:50:01  jshirley]
...\" 
...\" Revision 1.1.2.9  1994/10/19  22:07:31  jshirley
...\" 	Final updates.
...\" 	[1994/10/19  22:06:56  jshirley]
...\" 
...\" Revision 1.1.2.8  1994/10/06  19:32:41  jshirley
...\" 	{def,9830,R1.1}New dced functionality.
...\" 	[1994/10/06  19:32:04  jshirley]
...\" 
...\" Revision 1.1.2.7  1994/06/13  18:39:32  devobj
...\" 	cr10872 - fix copyright
...\" 	[1994/06/13  18:37:34  devobj]
...\" 
...\" Revision 1.1.2.6  1994/05/18  15:14:48  weir
...\" 	Checked out to fix SML error, but it's apparently already fixed.
...\" 	[1994/05/18  15:14:11  weir]
...\" 
...\" Revision 1.1.2.5  1994/05/18  02:17:45  jshirley
...\" 	Added Ping Wang's review comments and made many other modifications to
...\" 	fill out sections and examples.
...\" 	[1994/05/18  02:17:13  jshirley]
...\" 
...\" Revision 1.1.2.4  1994/05/11  22:18:41  jshirley
...\" 	Merged with changes from 1.1.2.3
...\" 	[1994/05/11  22:18:35  jshirley]
...\" 
...\" 	Incorporated John Bowe's comments from first draft.
...\" 	[1994/05/11  22:16:51  jshirley]
...\" 
...\" 	Incorporated rsalz comments from first draft.
...\" 	[1994/05/04  22:32:25  jshirley]
...\" 
...\" 	Modified figures.
...\" 	[1994/05/04  17:22:22  jshirley]
...\" 
...\" Revision 1.1.2.3  1994/05/04  17:22:54  jshirley
...\" 	Modified figures.
...\" 	[1994/05/04  17:22:22  jshirley]
...\" 
...\" Revision 1.1.2.2  1994/03/24  17:59:19  jshirley
...\" 	First check-in of real information for the file.
...\" 	[1994/03/24  17:50:32  jshirley]
...\" 
...\" Revision 1.1.2.1  1994/03/11  23:03:12  rom
...\" 	{enh, 10129, R1.1}
...\" 	Initial split of App Dev Guide into three books and creation of
...\" 	Intro and Style Guide.
...\" 	[1994/03/11  23:00:46  rom]
...\" 
...\" $EndLog$
...\" 
...\" 
...\" ----------------------------------------------------------------------
.H 1 "DCE Host Services"
...\" ----------------------------------------------------------------------
...\" 
.P    
.iX "DCE" "host services"
Every DCE host must maintain certain kinds of data about itself and the
servers it provides.   For example, each host stores configuration data
about its DCE
environment, and it also stores data about servers registered and
running on the host. 
In addition, each host needs some services to not only manage this data
but also to administer the host and DCE servers.  For example, 
a service that can start and stop specific servers has obvious value.
The DCE host services consist of the following:
.ML
.LI
Endpoint Mapper
.P
The endpoint mapper service enables a client to find servers on a 
.iX "endpoint" "mapper service"
.iX "dced services" "endpoint mapper"
par\%ticular host and the services and objects provided by those services.
This service maintains on each host an endpoint map
that contains a  mapping of port addresses (endpoints) to servers, 
the services servers provide, and the objects servers manage.  
.LI
Hostdata Management
.P
The hostdata management service stores and con\%trols access to such
.iX "hostdata management service"
.iX "dced services" "hostdata management"
data as the host's cell name, the host name, and the cell alias names, 
among other things.
.LI
.ne 5
Server Management
.P
The server management service can start and stop specified servers on a host,
.iX "server" "management service"
.iX "dced services" "server management"
enable or disable specific services provided by a server, 
and manage configuration and execution data about these servers.
.LI
Security Validation
.P
The security validation service maintains a login context for the host's
.iX "security" "validation service"
.iX "dced services" "security validation"
identity of itself, maintains the host principal's keys,
and ensures applications (especially login programs) 
that the DCE security daemon (\*Lsecd\*O) is genuine.
.LI
Key Table Management
.P
A server uses private keys for its security instead of human-entered
passwords.  The key table management service can be used to manage the
.iX "key table management service"
.iX "dced services" "key table management"
keys stored in key tables on a server's host.
.LE
.P
.ne 5
Of course, in a distributed environment, these data and services must
be easily yet securely accessible from other hosts.
The DCE host daemon (\*Ldced\*O) is a continuously running program on each
.iX "DCE" "host daemon (dced)"
.iX "dced, DCE host daemon"
host that provides access to the host services either locally on
that host or remotely from another host.
...\" 
...\" 
...\" ----------------------------------------------------------------------
.H 2 "Types of Applications"
...\" ----------------------------------------------------------------------
...\" 
.P
Although applications may need some aspect of these host services 
(control over which services are enabled for a particular server, 
for example), typical servers do not have to do any special coding for them.  
This reduces the size and complexity of server code and keeps the
details of administration out of applications.  It also removes the
burden of server administration so you can concentrate on
the application's business functionality.
.P
System administrators will appreciate this development model 
too because it is unlikely that many servers implementing their 
own administrative mechanisms will all behave in the same manner.
Administrators commonly use the DCE control program, \*Ldcecp\*O,
to access the host services (via \*Ldced\*O) of any host in their 
distributed environment
(provided the user has the appropriate permissions).  
The DCE control program also uses a script language for more sophisticated
administration.  See the
...\"Admin.  Guide Core
\*(Ac
for more on using \*Ldcecp\*O to access the host services.
.P
Although \*Ldcecp\*O commands offer an administrator a great deal of
control over DCE hosts and servers, a set of APIs are also
supplied for application developers who need to access the DCE
host services from an application rather than from scripts or the operating
system's command line.
.P
Typical business applications do not use the APIs of these services,
but a \*Emanagement application\*O might.
A management application is a client or server that manages other
servers or some aspect of the distributed environment.
(The \*Ldced\*O program is itself a management application that is built into DCE.)
Some other types of applications that might use these API include
.ML
.LI
Applications that control other servers for load balancing or server redundancy.
.LI
An application that uses a graphical user interface (GUI) instead of
the command-line interface provided by \*Ldcecp\*O.
.LI
An application that needs to monitor a server's current state.  For
example, an application may need to make sure a particular server or one of
its services is available.
.LE
...\" 
...\" 
...\" ----------------------------------------------------------------------
.H 2 "Issues of Distributed Applications"
...\" ----------------------------------------------------------------------
...\" 
.iX "distributed applications"
.P
The most important aspect of \*Ldced\*O is that it gives system
administrators the ability to remotely manage services, servers, endpoints,
.iX "remote" "management" "of services"
.iX "remote" "management" "of servers"
.iX "remote" "management" "of endpoints"
.iX "remote" "management" "of objects"
and even objects on any host in DCE.
This eliminates the frustrating and tedious task of logging into many
different hosts to manage them.  This also allows for scalability because 
it is impractical to manage a large system by logging into all its hosts.
.P
The features of \*Ldced\*O are greatly enhanced when used remotely.
Of course, an administrator can use \*Ldced\*O to locally manage a 
host's services, but \*Ldced\*O's real power is in remotely managing 
system and application server configurations, key tables, server startup, 
login configurations, and cell information.
.P
.ne 6
Security becomes a major issue when it comes to remote services.  
With the power of \*Ldced\*O's services and \*Ldcecp\*O, 
it is important that only authorized principals can use them.  
The \*Ldced\*O program controls access to its various objects by using ACLs.
Server keys are security-sensitive data that must be seldom transmitted over
the network.  All key table data is encrypted when it is transmitted for 
secure remote key table management.
.P
Finally, the remote capabilities of \*Ldced\*O give you real-time
status of processes and services in DCE.
...\" 
...\" 
...\" 
...\" ----------------------------------------------------------------------
.H 2 "Managing a Host's Endpoint Map"
...\" ----------------------------------------------------------------------
...\" 
.P
Each DCE host has an endpoint map that contains a mapping of servers
to endpoints.  Each endpoint map server entry is associated with an
array of services (interfaces) provided by the server, and each
service is associated with an array of objects supported by the service.
.P
When a typical server calls the \*Ldce_server_register(\|)\*O routine,
the RPC runtime generates the endpoints on which the server will
listen for calls and then uses \*Ldced\*O's endpoint mapper service of the 
.iX "endpoint" "mapper service"
.iX "dced services" "endpoint mapper"
local host to register the endpoints.
Later, when a typical client makes a remote procedure call,
its RPC runtime uses the server host's endpoint mapper service 
to find the server.
When the typical server shuts down, it calls the
\*Ldce_server_unregister(\|)\*O routine to remove its endpoints from
the endpoint map so that clients do not later try to bind to it.
.P
Applications can also use the lower-level \*Lrpc_ep_register(\|)\*O
and associated RPC routines.
Since the endpoint map is essential for RPCs to work,
endpoints are fully described in Chapter 12
and the endpoint map structure is described with respect to routing of
RPCs in Chapter 16.
.P
The endpoint map is for the most part maintained automatically by \*Ldced\*O.  
For example, it periodically removes ``stale'' endpoints so that the
RPC runtime will not try to complete a binding for a client to a
server that is no longer running.
However, administrative applications may find it necessary to peruse
a remote endpoint map
and even remove specific endpoints from a local host's endpoint map.
.P
.ne 5
To read the elements of a remote endpoint map, applications use a loop with
the set of routines 
\*Lrpc_mgmt_ep_elt_inq_begin(\|)\*O,
\*Lrpc_\%mgmt_\%ep_\%elt_\%inq_\%next(\|)\*O,
and \*Lrpc_mgmt_ep_elt_inq_done(\|)\*O.
The inquiry can return all elements until the list is exausted, 
or the inquiry can be restricted to return elements for the following:
.ML
.LI
Elements matching an interface identifier (UUID and version number) 
.LI
Elements matching an object UUID
.LI
Elements matching both an interface identifier and object UUID 
.LE
.P
Administrators can manage the endpoint map by using \*Ldcecp\*O with
the \*Lendpoint\*O object.
.P
You can use the \*Ldced_server_disable_if(\|)\*O routine to mark as
disabled all the endpoints for a specific interface.  
This will prevent any new RPCs with partial bindings from binding to
the server for this interface,
but not prevent clients from using the interface if they already have
a full binding with these endpoints.
You can use the \*Ldced_server_enable_if(\|)\*O routine to
reenable previously disabled interfaces.
In an extreme situation, you could permanently remove endpoints
directly from the local endpoint map by calling the
\*Lrpc_mgmt_ep_unregister(\|)\*O routine.
This function cannot be done remotely for security reasons.
...\" 
...\" 
...\" 
...\" ----------------------------------------------------------------------
.H 2 "Binding to dced's Services"
...\" ----------------------------------------------------------------------
...\" 
.iX "dced services" "binding to the services"
.P
When you write a program that uses a host service, 
you begin by creating a \*Ldced\*O binding to the service on a particular host.
Bindings are relationships between clients and servers that allow them
to communicate.
A \*Ldced\*O binding is a specific kind of binding that not only gives your
application a binding to the \*Ldced\*O server
but also associates the binding with a specific host service on
that server.\*F
.FS  
.na
Applications must establish a binding to each host service used.
However, the endpoint mapper service uses a different binding
mechanism and API from the other host services.
This is due to the fact that the endpoint mapper service already existed
within the very large RPC API in earlier versions of DCE, 
prior to the development of \*Ldced\*O.
.ad
.FE
.P
.ne 5
In general, an application follows these basic steps to use a host service:
.AL
.LI
Establish a binding to the service on the desired host. 
For example, your application can establish a binding to the host
data management service on another host.
.LI
Obtain one or more \*Ldced\*O entries for that service.  
For example, your application can obtain the \*Lhostdata\*O entry that identifies
the host's cell name, among other things.
This step is valid for the following services:
.ML
.LI
hostdata management
.LI
server management
.LI
key table management
.LE
.P
Depending on the service and function desired, 
this step may or may not be necessary.  
For example, the security validation service does not store data, 
so \*Ldced\*O maintains no entries for this service.
.LI
.ne 6
Access (read or write) the actual data for the entries obtained
or peform other functions appropriate for the service.  
For example, if your application reads the hostdata management service's 
cell name entry, the API accesses \*Ldced\*O which may actually read
the data from a file.  For another example, 
if your application established a binding to the security validation service, 
it could validate the security daemon.
.LI
Release the resources obtained in step 2.
.LI
Free the binding established in step 1.
.LE
.P
Applications bind to a host service by using the 
\*Ldced_binding_create(\|)\*O or 
\*Ldced_binding_from_rpc_binding(\|)\*O routine.  
The first routine establishes a \*Ldced\*O binding to a service on a host 
specified in a service name, 
and the second routine establishes a \*Ldced\*O binding to a service on a
host for which the application already has a binding.  
Both of the routines return a \*Ldced\*O binding handle of type
\*Ldced_binding_handle_t\*O, which is used as an input parameter to
all other \*Ldced\*O API routines.
.P
...\"
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Host Service Naming in Applications"
...\" ----------------------------------------------------------------------
...\" 
.iX "host service naming"
.P
Applications include a host service name as input to the \*Ldced\*O binding routine
\*Ldced_binding_create(\|)\*O.
A host service name is a string that may include a host name, or a
cell and host name.  
The following key words in the host service name refer to a specific DCE host
service:
.P
.VL 1i
.LI "\*Lhostdata\*O"
Refers to configuration data of the hostdata
management service.
.LI "\*Lsrvrconf\*O"
Refers to the static server configuration portion of
the server management service.  
This refers to the managment of a DCE-installed server.
.LI "\*Lsrvrexec\*O"
Refers to the dynamic server execution portion of
the server management service.  
This refers to the management of a running DCE-installed server.
.LI "\*Lsecval\*O"
Refers to the security validation service.
.LI "\*Lkeytab\*O"
Refers to the private key data of the key table
management service.
.LE
.P
The following examples show service names and the
locations of the hosts in the namespace:
.VL 1i
.LI "\*Vservice\*O"
The host is local, the same as the application's.
.LI "\*Vservice\*L@hosts/\*Vhost\*O"
.nL
The host is in the local namespace.  
.LI "\*L/.:/hosts/\*Vhost\*L/config/\*Vservice\*O"
.nL
The complete specification for \*Vservice\*L@hosts/\*Vhost\*O where the 
host is in the local namespace.
.LI "\*L/.../\*Vcell\*L/hosts/\*Vhost\*L/config/\*Vservice\*O"
.nL
The host is in the global namespace.
.LE
.P
Since the \*Ldced_binding_from_rpc_binding(\|)\*O routine already
knows which host to bind to from an RPC binding input parameter, 
it uses one of the global variables defined for each service 
(instead of a string) to specify which \*Ldced\*O service to use.
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "The dced Program Maintains Entry Lists"
...\" ----------------------------------------------------------------------
...\" 
.P
One \*Ldced\*O service's data is very different from another's
(for example, server configuration data versus key table data), but you
manipulate the data in a similar way.
This is because it is a simpler and more efficient design to
implement a few API routines that can handle more than one kind of data
rather than many routines that do essentially the same thing but on a different
service's data.  An added benefit is a flexible API that can handle
your own application's data and new kinds of DCE data in the future.
.iX "dced services" "entry lists for services"
.P
To separate the actual data from the API implementation,  
a \*Ldced\*O service maintains a list of all data items in an 
\*Eentry list\*O.  
Entry lists contain \*Eentries\*O that describe the name and location
of each item of data, but they do not contain the actual data.
With this mechanism, \*Ldced\*O can obtain and manipulate data very
efficiently, without concern for the implementation and location of
the actual data.  It also supports well the model that administrators
commonly need when accessing data: 
scan a list, select an item, and use the data.
.P
The \*Ldced\*O program maintains entry lists for the 
\*Lhostdata\*O, \*Lsrvrconf\*O, \*Lsrvrexec\*O, and \*Lkeytab\*O services.
The \*Lsecval\*O service does not need an entry list because it does not 
maintain any data, but functions are performed to set its state.
.P
There is a special relationship between \*Lsrvrconf\*O and
\*Lsrvrexec\*O entries.
In order for \*Ldced\*O to control the start of a server,  the server must 
have a \*Lsrvrconf\*O entry associated with server configuration data.  
When \*Ldced\*O starts a server, it generates from the \*Lsrvrconf\*O
entry and data a \*Lsrvrexec\*O entry and associates the new entry with the
running server's state.
.P
Figure 2-1 shows the entry lists maintained by \*Ldced\*O.
.P
.ne 5.25i
.FG "The dced Entry Lists"
.pI ../dce/figures/dced_entry_lists.ps 4.5i 3.4i
.sp .5
.P
Although an entry can be associated with many different kinds of data items, 
all entries have the same structure, shown in Figure 2-2.
.P
.ne 1i
.FG "Structure of an Entry"
.pI ../dce/figures/entry_list_data.ps .4i 2.5i
.sp .5
.P
Each entry is a \*Ldced_entry_t\*O data structure.
Each member of this data structure is described as follows:
.P
.VL 1.25i
.LI "\*Lid\*O"
.ne 4
An entry UUID is necessary to uniquely identify the data item.  Some data items
have well-known UUIDs (the same UUID for the particular item on all hosts).
The data type is \*Luuid_t\*O.
.LI "\*Lname\*O"
.ne 5
Each data item is identified with a name, to which applications refer.
The name need only be unique within an entry list 
because the entry UUID guarantees the entry's uniqueness.  
Some item names are well-known and defined in header files.
The data type is \*Ldced_string_t\*O.
.LI "\*Ldescription\*O"
This is a human-readable description of the data item.
Its data type is \*Ldced_string_t\*O.
.LI "\*Lstorage_tag\*O"
The storage tag locates the actual data. 
Each service \*Eknows\*O how to interpret this tag to find the data.
For example, some data is stored in a file, 
the name of which is contained in the storage tag.  
Other data is stored in memory and the storage tag contains a pointer to the
memory location.  The data type is \*Ldced_string_t\*O.
.LE
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Reading All of a Host Service's Data"
...\" ----------------------------------------------------------------------
...\" 
.P
.iX "dced services" "host service data"
Suppose you want to display host service data in an application that has a
graphical user interface.  The \*Ldcecp\*O commands may not be adequate
to display data for this application.
The following example shows how to obtain the entire set of data for each
host service:
.oS
.ps 9
.vs 11
dced_binding_handle_t   dced_bh;
dced_string_t           host_service;
void                    *data_list;
unsigned32              count;
dced_service_type_t     service_type;
error_status_t          status;
 .
 .
 .
while(user_selects(&host_service, &service_type)){   /*application specific*/
    dced_binding_create(host_service, 
    		    dced_c_binding_syntax_default,
    	            &dced_bh, 
    		    &status);
    if(status == error_status_ok) {
        dced_object_read_all(dced_bh, &count, &data_list, &status);
        if(status == error_status_ok) {
            display(service_type, count, data_list); /*application specific*/
            dced_objects_release(dced_bh, count, data_list, &status);
        } 
        dced_binding_free( dced_bh, &status);
    } 
} 
.ps 12
.vs 14
.oE
.P
.VL 1i
.LI "\*Luser_selects(\|)\*O"
.ne 5
.nL
This is an example of an application-specific routine that constructs the
complete service name from host and service name information.  
Data is stored and retrievable for the \*Lhostdata\*O, \*Lsrvrconf\*O,
\*LsrvrexecD\*O, 
and \*Lkeytab\*O services.  No data is stored for the \*Lsecval\*O service.
.LI "\*Ldced_binding_create(\|)\*O"
.nL
Output from the \*Ldced_binding_create\*O routine includes a \*Ldced\*O binding
handle whose data type is \*Ldced_binding_handle_t\*O.  
If an application already has an RPC binding handle to a server on the
host desired, it can use the \*Ldced_\%binding_\%from_\%rpc_binding(\|)\*O
routine to bind to \*Ldced\*O and one of its host services on that host.
(Applications also use these routines to bind to the \*Lsecval\*O service 
to perform other functions.)
.LI "\*Ldced_object_read_all(\|)\*O"
.nL
Applications use the \*Ldced_object_read_all(\|)\*O 
routine to read data for all the objects in an entry list.  
The output includes the address of an allocated buffer of data 
and a count of the number of objects the buffer contains.
The data type in the buffer depends on the service used. 
.LI "\*Ldisplay(\|)\*O"
This is an application-specific routine that displays the data.
Before the data is displayed, it must be interpreted depending on the service.
The \*Lhostdata\*O data is an array of \*Lsec_attr_t\*O data structures, 
the \*Lsrvrconf\*O and \*Lsrvrexec\*O data are arrays of 
\*Lserver_t\*O structures, and the \*Lkeytab\*O data is an array of
\*Ldced_key_list_t\*O structures.
The following code fragments show the data type for each service:
.LE
.oS
.ne 30
.ps 9
.vs 11
void display(
dced_service_type_t service_type, /* dced service type */
int                 count,        /* count of the number of data items */
void                *data)        /* obtained from dced_object_read{_all}(\|) */
{
    sec_attr_t               *host_data;
    server_t		     *servers;
    dced_key_list_t          *keytab_data;
    .
    .
    .
    switch(service_type) {
    case dced_e_service_type_hostdata:
        host_data = (sec_attr_t *)data;
        . . .
    case dced_e_service_type_srvrconf:
        servers = (server_t *)data;
        . . .
    case dced_e_service_type_srvrexec:
        servers = (server_t *)data;
        . . .
    case dced_e_service_type_keytab:
        keytab_data = (dced_key_list_t *)data;
        . . .
    default:
        /* No other dced service types have data to read. */
        break;
    }
    return;
}
.ps 12
.vs 14
.oE
.P
.VL 1i
.LI "\*Ldced_objects_release(\|)\*O"
.nL
Each call to the \*Ldced_object_read_all(\|)\*O routine requires a
corresponding call to \*Ldced_\%objects_release(\|)\*O to release the
resources allocated.
.LI "\*Ldced_binding_free(\|)\*O".
.nL
Each call to the \*Ldced_binding_create(\|)\*O routine requires a corresponding
call to \*Ldced_\%binding_free(\|)\*O to release the resources for the binding
allocated.
.LE
...\" 
...\" 
...\" 
...\" ----------------------------------------------------------------------
.H 3 "Managing Individual dced Entries"
...\" ----------------------------------------------------------------------
...\" 
.iX "dced services" "entry lists for services"
.P
Figure 2-3 shows examples of individual \*Ldced\*O entries and the
locations of associated data.  
The data item name or its UUID is used to find an entry, 
and then the storage tag is used to find the data.
.P
.ne 6i
.FG "Accessing Hostdata"
.pI ../dce/figures/read_entry_data.ps 0 0 1
.sp .5
.P
The data for each \*Lhostdata\*O item is stored in a file on disk.  
The \*Ldced\*O program uses the UUID to find the entry in the \*Lhostdata\*O entry list.
The entry's storage tag is then used to find the data.  
For \*Lhostdata\*O, the tag contains a filename in OSF's reference
implementation.
The data returned for one entry is an array of strings in a \*Lsec_attr_t\*O
structure.
.P
The server management data is stored in memory.
The \*Ldced\*O program uses UUIDs (maintained in the entry lists by
\*Ldced\*O) 
to find an entry.  The location of the data in memory is indicated by
the storage tag. 
The data returned for one entry is a structure of server data (\*Lserver_t\*O).
All data for the \*Lsrvrconf\*O and \*Lsrvrexec\*O entries are accessed
from memory for fast retrieval, but the \*Lsrvrconf\*O data is also
stored on disk for use when a host needs to reboot.
.P
Each \*Lkeytab\*O entry stores its data in a file on disk.
However, like the server management entries, the \*Lkeytab\*O entries
use server names and corresponding UUIDs (maintained by \*Ldced\*O)
to identify each entry.  
The storage tag contains the name of the key table file.  
The data returned for one entry is a list of keys
of type \*Ldced_key_list_t\*O.
.P
The following example shows how to obtain and manage individual entries
for the \*Lhostdata\*O, \*Lsrvrconf\*O, \*Lsrvrexec\*O, or \*Lkeytab\*O
services:
.oS
.ps 9
.vs 11
handle_t                rpc_bh;
dced_binding_handle_t   dced_bh;
dced_entry_list_t       entries;
unsigned32              i;
dced_service_type_t     service_type;
void                    *data;
error_status_t          status;
 .
 .
 .
dced_binding_from_rpc_binding(service_type, rpc_bh, &dced_bh, &status);
if(status != error_status_ok) 
    return;
dced_list_get(dced_bh, &entries, &status);
if(status == error_status_ok) {
    for(i=0; i<entries.count; i++) {
        if( select_entry(entries.list[i].name) ) {/* application specific */
            dced_object_read(dced_bh, &(entries.list[i].id), &data, &status);
            if(status == error_status_ok) {
                display(service_type, 1, &data);  /* application specific */
                dced_objects_release(dced_bh, 1, data, &status);
            }
        }
    }
    dced_list_release(dced_bh, &entries, &status);
}
dced_binding_free(dced_bh, &status);
.ps 12
.vs 14
.oE
.P
.ne 17
Each routine is described as follows:
.P
.VL 1i
.LI "\*Ldced_binding_from_rpc_binding(\|)\*O"
.nL
The \*Ldced_binding_from_rpc_binding(\|)\*O routine returns a \*Ldced\*O
binding handle whose data type is \*Ldced_binding_handle_t\*O.  
This binding handle is used in all subsequent
\*Ldced\*O API routines to access the service.
The host is determined from the RPC binding handle, \*Vrpc_bh\*O, 
and the \*Vservice_type\*O is selected from the following list:
.ML
.LI
\*Ldced_e_service_type_hostdata
.LI
dced_e_service_type_srvrconf
.LI
dced_e_service_type_srvrexec
.LI
dced_e_service_type_keytab\*O
.LE
.LI "\*Ldced_list_get(\|)\*O"
.nL
Applications use the \*Ldced_list_get(\|)\*O routine to get a
service's entire list of names.
Using the \*Ldced_list_get(\|)\*O routine gives your application great
flexibility when manipulating entries in an entry list.
If you prefer, your application can use the 
\*Ldced_entry_cursor_initialize(\|)\*O,
\*Ldced_entry_get_next(\|)\*O, 
and \*Ldced_\%entry_\%cursor_\%release(\|)\*O
set of routines to obtain individual entries, one at a time.
.LI "\*Lselect_entry(\|)\*O"
.nL
This is an application-specific routine that selects which entry 
to use based on the entry name.
.LI "\*Ldced_object_read(\|)\*O"
.nL
The default attribute for \*Ldced_object_read(\|)\*O is to return an 
array of strings.  The \*Lhostdata\*O and \*Lkeytab\*O services have other 
``read'' routines that allow you to specify binary data.
.LI "\*Ldisplay(\|)\*O"
This is an example of an application-specific routine that simply
displays the server configuration data read.
Depending on the service, a different data structure is used.
For the \*Lhostdata\*O service, a \*Lsec_attr_t\*O is used.
For the \*Lsrvrconf\*O and \*Lsrvrexec\*O services \*Lserver_t\*O
structures are used.  For the \*Lkeytab\*O service, a
\*Ldced_key_list_t\*O structure is used.
.LI "\*Ldced_objects_release(\|)\*O"
.ne 4
.nL
After your application is finished with the data read with the 
\*Ldced_object_read(\|)\*O routine, free the buffer of allocated data by
using the \*Ldced_objects_release(\|)\*O routine.
.LI "\*Ldced_list_release(\|)\*O"
.nL
Each call to the \*Ldced_list_get(\|)\*O routine requires a corresponding call
to \*Ldced_list_release(\|)\*O to release the resources allocated for the 
entry list.
.LI "\*Ldced_binding_free(\|)\*O".
.nL
Each call to the \*Ldced_binding_from_rpc_binding(\|)\*O routine requires a
corresponding call to \*Ldced_binding_free(\|)\*O to release the resources
of the allocated binding.
.LE
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 2 "Managing Hostdata on a Remote Host"
...\" ----------------------------------------------------------------------
...\" 
.iX "dced services" "remote host service data"
.P
Administrators typically use the \*Ldcecp hostdata\*O object to
remotely manage the data of the \*Lhostdata\*O service.  
However, application developers can use the \*Ldced\*O API for their
own management applications or if \*Ldcecp\*O does not handle a task in the
desired way, such as for a browser of hostdata that uses a graphical
user interface.
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Kinds of Hostdata Stored"
...\" ----------------------------------------------------------------------
...\" 
.P
Each \*Lhostdata\*O item is stored in a file, and \*Ldced\*O has a UUID
associated with each. 
The standard data items include the following well-known names:
.VL 1.5i
.LI "\*Lcell_name\*O"
The name of the cell to which your host belongs is stored.
.LI "\*Lcell_aliases\*O"
When the cell name changes, the old names are designated as cell aliases.
.LI "\*Ldce_cf.db\*O"
The DCE configuration data file is stored.
.LI "\*Lhost_name\*O"
The host name is stored.
.LI "\*Lpe_site\*O"
The location of the security server is stored.
.LI "\*Lpost_processors\*O"
The \*Lpost_processors\*O file contains UUID-program pairs for which the UUIDs
represent other \*Lhostdata\*O items. 
If changes occur to an associated \*Lhostdata\*O item, the system runs the program.
.LI "\*Lsvc_routing\*O"
The default routing file for serviceability messages is stored.
.LE
.P
Depending on your DCE provider, additional items may exist.
In addition to the well-known \*Lhostdata\*O items, applications can also add
their own. 
The well-known \*Lhostdata\*O items have well-known UUIDs defined in the file
\*L/usr/include/dce/dced_data.h\*O, but you can use the
\*Ldced_inq_uuid(\|)\*O routine to obtain any UUID associated with any
name known to \*Ldced\*O.
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Adding New Hostdata"
...\" ----------------------------------------------------------------------
...\" 
.P
In addition to modifying existing hostdata, you can add your own data by
using the hostdata API.  
For example, suppose you want to add a printer to a host 
and make the configuration file part of that host's \*Ldced\*O data.
The following example shows how to do this:
.oS
.ps 9
.vs 11
dced_binding_handle_t    dced_bh;
error_status_t           status;
dced_entry_t             entry;
dced_attr_list_t         data;
int                      num_attr, str_size;
sec_attr_enc_str_array_t *attr_array;
 .
 .
 .
dced_binding_create(dced_c_service_hostdata, 
    	        dced_c_binding_syntax_default,
    	        &dced_bh, 
    		&status);
/*Create Entry Data */
uuid_create(&(entry.id), &status);
entry.name = (dced_string_t)("NEWERprinter");
entry.description = (dced_string_t)("Configuration for a new printer.");
entry.storage_tag = (dced_string_t)("/etc/NEWprinter");

.ne 15 
/* Create the Attributes, one for this example */
data.count = 1;
num_attr = 1;
data.list  = (sec_attr_t *)malloc( data.count * sizeof(sec_attr_t) );
(data.list)->attr_id = dced_g_uuid_fileattr;
(data.list)->attr_value.attr_encoding = sec_attr_enc_printstring_array;
str_size = sizeof(sec_attr_enc_str_array_t) + 
                      num_attr * sizeof(sec_attr_enc_printstring_p_t);
attr_array = (sec_attr_enc_str_array_t *)malloc(str_size);
(data.list)->attr_value.tagged_union.string_array = attr_array;
attr_array->num_strings = num_attr;
attr_array->strings[0] = (dced_string_t)("New printer configuration data");

dced_hostdata_create(dced_bh, &entry, &data, &status);
dced_binding_free( dced_bh, &status);
.ps 12
.vs 14
.oE
.P 
The description of this example is as follows:
.VL 1i
.LI "\*Ldced_binding_create(\|)\*O"
.nL
This routine creates a \*Ldced\*O binding to a \*Ldced\*O service.
The binding handle created is used in all subsequent calls to appropriate 
\*Ldced\*O API routines.  By using the \*Ldced_c_server_hostdata\*O value
for the first parameter, we are using the \*Lhostdata\*O service on the
local host.
.LI "Create Entry Data"
.nL
Prior to creating a \*Lhostdata\*O entry, we have to set its values.  These
include the name and UUID that \*Ldced\*O will use to identify the new data,
a description of the entry, and a filename with the full pathname of where
the actual data will reside.
.LI "Create the Attributes"
.nL
The data stored is of type \*Lsec_attr_t\*O.  
This data type is a very flexible one that can store many different
kinds of data. 
In this example, we set the file to have one attribute, 
printable string information.  This example has only one string of data.  
You can also establish binary data for the file.
.LI "\*Ldced_hostdata_create(\|)\*O"
.nL
This routine takes the binding handle, entry, and new data as input; it
creates the file with the new data and returns a status code.
.P
If the printer configuration file already exists on the host, 
but you want to now make it accessible to \*Ldced\*O, 
use the \*Ldce_entry_add(\|)\*O routine instead of
\*Ldced_hostdata_create(\|)\*O.
.P
.ne 5
.LI "\*Ldced_binding_free(\|)\*O"
.nL
Each call to the \*Ldced_binding_create(\|)\*O routine requires a
corresponding call to \*Ldced_binding_free(\|)\*O to release the binding
resources allocated.
.LE
.P
Use the \*Ldced_hostdata_delete(\|)\*O routine to delete application-specific
\*Lhostdata\*O items and their entries.   
For example, the printer installed in the example is
easily removed with this routine.   
If you are only taking the printer out of service for a short time,
use the \*Ldced_entry_remove(\|)\*O routine to remove the \*Ldced\*O
entry but not the data file itself.  When the printer is later ready again, 
use the \*Ldced_entry_add(\|)\*O routine to reinstall it.
.P
Do not delete the well-known \*Lhostdata\*O items or remove their entries.
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Modifying Hostdata"
...\" ----------------------------------------------------------------------
...\" 
.P
Changing hostdata cannot only change the way the host works
but it also affects other files and processes on the host.   
Therefore, care should be taken when changing hostdata.  
Deleting the well-known \*Lhostdata\*O entries can cause even more serious
operational problems for the host.
.P
The current as well as earlier versions of DCE provide configuration routines 
that use a \*Ldce_cf.db\*O file for data.   
When hostdata changes, \*Ldced\*O also makes the appropriate changes 
to this file so that the \*Ldce_cf*\*O routines continue to work correctly.
This is one reason the \*Lhostdata\*O items are established as well-known
names with well-known UUIDs so that \*Ldced\*O knows which values to monitor.
.P
Management applications use the \*Ldced_hostdata_read(\|)\*O routine
to obtain the data for an entry referred to by an entry UUID. 
To modify an entry's actual data, applications use the
\*Ldced_hostdata_write(\|)\*O routine.   
This routine replaces the old data with the new data for the
\*Lhostdata\*O entry represented by the entry UUID.  
The \*Lhostdata\*O entry must already exist because this routine will
not create it.  Use the \*Ldced_hostdata_create(\|)\*O routine to
create new \*Lhostdata\*O entries.
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Running Programs Automatically When Hostdata Changes"
...\" ----------------------------------------------------------------------
...\" 
.P
The following example shows how to use the \*Lpost_processors\*O feature of
the well-known hostdata to cause \*Ldced\*O to automatically run a
program if another \*Lhostdata\*O entry changes.  
In this example, the \*Lpost_processors\*O file is
read, and data is added for the \*LNEWERprinter\*O \*Lhostdata\*O entry
created in an earlier example.  The data is placed in a
\*Ldced_attr_list_t\*O structure and written back to the
\*Lpost_processors\*O \*Lhostdata\*O entry.
.oS
.ps 9
.vs 11
dced_binding_handle_t dced_bh;
uuid_t                entry_uuid;
sec_attr_t            *data_ptr;
error_status_t        status;
int                   i, num_strings, str_size;
sec_attr_enc_str_array_t *attr_array;
unsigned_char_t       *string_uuid, temp_string[200];
dced_attr_list_t      attr_list;

dced_binding_create(dced_c_service_hostdata, 
    	        dced_c_binding_syntax_default,
    	        &dced_bh, 
    		&status);
dced_hostdata_read(dced_bh, 
                   &dced_g_uuid_hostdata_post_proc, 
                   &dced_g_uuid_fileattr, 
                   &data_ptr, 
                   &status);

/* Create New Array and Copy Old Data into it */
num_strings = data_ptr->attr_value.tagged_union.string_array->num_strings + 1;
str_size = sizeof(sec_attr_enc_str_array_t) + 
                      num_strings * sizeof(sec_attr_enc_printstring_p_t);
attr_array = (sec_attr_enc_str_array_t *)malloc(str_size);
attr_array->num_strings = num_strings;
for(i=0; i<(num_strings-1); i++) {
    attr_array->strings[i] =  
        data_ptr->attr_value.tagged_union.string_array->strings[i];
}

dced_inq_id(dced_bh, "NEWERprinter", &entry_uuid, &status);

uuid_to_string(&entry_uuid, &string_uuid, &status);
sprintf(temp_string, "%s %s", string_uuid, "/path/and/program/to/run");
attr_array->strings[num_strings-1] = (dced_string_t)(temp_string);
data_ptr->attr_value.tagged_union.string_array = attr_array;

.ne 7
attr_list.count = 1;
attr_list.list = (sec_attr_t *)malloc(attr_list.count * sizeof(sec_attr_t));
attr_list.list = data_ptr;
dced_hostdata_write(dced_bh, 
                    &dced_g_uuid_hostdata_post_proc,
                    &attr_list, 
                    &status); 

dced_objects_release(dced_bh, 1, (void*)(data_ptr), &status);
dced_binding_free(dced_bh, &status);
.ps 12
.vs 14
.oE
.P 
The description of this example is as follows:
.VL 1i
.LI "\*Ldced_binding_create(\|)\*O"
.nL
This routine creates a \*Ldced\*O binding to the \*Lhostdata\*O service on a specified host.
The binding handle created is used in all subsequent calls to appropriate 
\*Ldced\*O API routines.
The \*Ldced_c_service_hostdata\*O argument is a constant string that is
the well-known name of the \*Lhostdata\*O service.  When this string is used
by itself, it refers to the service on the local host. 
.LI "\*Ldced_hostdata_read(\|)\*O"
.nL
This routine reads the \*Lhostdata\*O item referred to by the entry UUID. 
In this example, the global variable \*Ldced_g_uuid_hostdata_post_proc\*O 
represents the UUID for the well-known \*Lpost_processors\*O file.
The second parameter specifies an attribute for the data.  
Attributes describe how the data is to be interpreted.
In this example, we know the data to be read is plain text, so we use
the global variable \*Ldced_g_uuid_fileattr\*O to specify 
plain text rather than binary data (\*Ldced_g_uuid_binfileattr\*O).
.LI "Create a New Array\*O"
.nL
The next few lines copy the existing array of print strings into a
new array that has additional space allocated for the new data.
.LI "\*Ldced_inq_id(\|)\*O"
.nL
This routine acquires the UUID \*Ldced\*O that maintains for a known entry
name.  In this example, we need the UUID for the \*LNEWERprinter\*O
\*Lhostdata\*O entry so that it can be included in the data stored back in the
\*Lpost_processors\*O file.
.LI "\*Luuid_to_string(\|)\*O"
.ne 8
.nL
This routine returns the string representation of a UUID.
Each line in the \*Lpost_processors\*O file contains a string UUID and a
program name for \*Ldced\*O to run if the \*Lhostdata\*O entry referred to by
the UUID changes.
The next few lines create a new string containing the string UUID and a
program name,  adds the new string to the new array, and reassigns the
new array to the old data pointer.
.LI "\*Ldced_hostdata_write(\|)\*O"
.nL
Since hostdata could have more than one attribute associated
with each entry, the data must be inserted in an attribute list data
structure before the \*Ldced_hostdata_write(\|)\*O routine is called.
In the case of the well-known \*Lpost_processors\*O \*Lhostdata\*O object, 
the attribute is for a plain text file.
The \*Ldced_hostdata_write(\|)\*O routine replaces the old data with
the new data for the \*Lhostdata\*O entry represented by the entry UUID.  
.LI "\*Ldced_objects_release(\|)\*O"
.nL
Each call to the \*Ldced_hostdata_read(\|)\*O routine requires a corresponding
call to \*Ldced_objects_release(\|)\*O to release the resources allocated.
.LI "\*Ldced_binding_free(\|)\*O"
.nL
Each call to the \*Ldced_binding_create(\|)\*O routine requires a
corresponding call to \*Ldced_binding_free(\|)\*O to release the
resources allocated.
.LE
.P
The \*Lpost_processors\*O data for this \*Ldced\*O now contains an additional
string with a UUID and program name.  If the \*Lhostdata\*O item
represented by the UUID for \*LNEWERprinter\*O is changed, 
\*Ldced\*O automatically runs the program.
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 2 "Controlling Servers Remotely"
...\" ----------------------------------------------------------------------
...\" 
.iX "server" "controlling remotely"
.iX "remote" "control of servers"
.iX "dced services" "remote control of servers"
.P
Both applications developers and system administrators may want
servers to have certain support services and control functionality.
For example, servers may need mechanisms to store operational data, 
and they may need to start or stop in various ways.
The \*Ldced\*O program provides these support and control mechanisms
for servers.
.P
.ne 8
Servers are typically configured by an administrator using the
\*Ldcecp server\*O object in a script after the server is installed on the host.
In addition to configuring the server,
this script would commonly include other tasks like create an account
and assign a principal name for the server, 
modify the ACLs and key table files (keytabs)
to control access to the server and its resources, 
and export the server binding information to the Cell Directory Service (CDS) 
so that clients can find a server that will start dynamically later.
.P
After a server is configured, 
whether it runs as a persistent daemon or an on-demand (dynamic) process, 
administrators would again use \*Ldcecp\*O if they need to control or modify 
its behavior.
Although server management is typically an administrator's task,
you may want a management application to perform these tasks, 
including the following:
.ML
.LI
Configure a server to describe how it can be invoked
.LI
Start a server based on configuration data
.LI 
Stop a running server 
.LI
Disable a specific service provided by a running server
.LI
Enable a specific service for a running server
.LI
Modify a server's configuration
.LI
Delete a server's configuration, effectively removing the server from
\*Ldced\*O's control
.LE
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Two States of Server Management: Configuration and Execution"
...\" ----------------------------------------------------------------------
...\" 
.P
If all servers ran as persistent processes, \*Ldced\*O could maintain
data about each server in a single (albeit complex) data structure.
However, due to the fact that some servers may run on demand,
it is a more flexible design to have two sets of data: 
one that describes the default configuration to start the server,  
and one that describes the executing (running) server.
Earlier in this chapter when we described \*Ldced\*O service naming,
we defined \*Lsrvrconf\*O and \*Lsrvrexec\*O objects to name the two
portions of the server management service.
.P
.ne 3
Table 2-1 lists the routines that applications can use to control
servers. 
It also shows the valid object names to use when establishing a 
\*Ldced\*O binding prior to using the routine.
.P
.ne 15
.TB "API Routines for Remote Server Management"
.TS
center,allbox,tab(@);
lB | lB.
API Routine@Service Name for Binding
_
dced_server_create(\|)@srvrconf
dced_server_start(\|)@srvrconf
dced_server_disable_if(\|)@srvrexec
dced_server_enable_if(\|)@srvrexec
dced_server_stop(\|)@srvrexec
dced_object_read(\|)@srvrexec \*Oor\*L srvrconf
dced_object_read_all(\|)@srvrexec \*Oor\*L srvrconf
dced_server_modify_attributes(\|)@srvrconf
dced_server_delete(\|)@srvrconf
.TE
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Configuring Servers"
...\" ----------------------------------------------------------------------
...\" 
.P
Although administrators commonly use \*Ldcecp\*O to configure servers
remotely, management applications can use \*Ldced\*O API routines to 
configure a new server remotely by creating server configuration data, 
.iX "configuring a new server remotely"
.iX "dced services" "configuring a new server remotely"
changing a remote server's configuration, 
and deleting a server's configuration data.
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 4 "Configuring a New DCE Server"
...\" ----------------------------------------------------------------------
...\" 
.P
Management applications use the \*Ldced_server_create(\|)\*O routine to
add a new server to a host.  After a server is configured, it can be remotely
controlled by modifying its configuration attributes, 
starting and stopping it, 
enabling or disabling the RPC interfaces it supports, 
and deleting its configuration.
.P
Configuring the server involves describing the server for DCE by
allocating and filling in a \*Lserver_t\*O data structure, as shown in
the following example.  Note that not all \*Lserver_t\*O fields are
assigned values in this example.
.oS
.ps 9
.vs 12
int                   i;
dced_binding_handle_t dced_bh;
server_t              conf, exec;
dced_string_t         server_name;
uuid_t                srvrconf_id, srvrexec_id;
dced_attr_list_t      attr_list;
error_status_t        status;
static service_t      nil_service;
 .
 .
 .
dced_binding_create("srvrconf@hosts/somehost", 
                    dced_c_binding_syntax_default, 
                    &dced_bh, 
                    &status);
dced_inq_id(dced_bh, server_name, &srvrconf_id, &status);
if(status == error_status_ok) {
    puts("Configuration already exists for this server.");
    dced_binding_free(dced_bh, &status);
    return;
}
/* ___________setup a server_t structure ________________*/
uuid_create(&(conf.id), &status);
conf.name           = server_name;
conf.entryname      = (dced_string_t)"/.:/greeter";
conf.services.count = 1;

.ne 12
/* ___service_t structures represent each interface supported ___*/
conf.services.list = 
    (service_t *)malloc(conf.services.count * sizeof(service_t));
for(i=0; i<conf.services.count; i++) {
    rpc_if_inq_id(greetif_v1_0_c_ifspec, 
                  &(conf.services.list[i].ifspec),
                  &status);
    conf.services.list[i] = nil_service;
    conf.services.list[i].ifname     = (dced_string_t)"greet";
    conf.services.list[i].annotation = (dced_string_t)"The greet application";  
    conf.services.list[i].flags      = 0;  
}

/* ______________server_fixedattr_t structure _______________*/
conf.fixed.startupflags = 
    server_c_startup_explicit | server_c_startup_on_failure;
conf.fixed.flags = 0;
conf.fixed.program = (dced_string_t)"/server/path/and/program/name";

dced_server_create(dced_bh, &conf, &status);
dced_binding_free(dced_bh, &status);
.ps 12
.vs 14
.oE
.P
.VL 1i
.LI "\*Ldced_binding_create(\|)\*O"
.nL
To configure a server, the application must first create a
\*Ldced\*O binding to the \*Lsrvrconf\*O portion of the 
server management service
on a specified host.  The binding handle created is used in all subsequent 
calls to appropriate dced API routines.  
.LI "\*Ldced_inq_id(\|)\*O"
.nL
This routine returns the UUID that \*Ldced\*O associates with the name input.
Each configured server has an associated UUID used by 
\*Ldced\*O to identify it.  In this example, we won't try to create a
configuration for a server that already exists.
.LI "Set Up a \*Lserver_t\*O Structure for the Server"
.nL
The \*Lserver_t\*O structure contains all the information DCE uses to
specify a server.
.LI "Set Up \*Lservice_t\*O Structures for Each Interface"
.nL
Each service that the server supports is represented by a
\*Lservice_t\*O data structure that contains the interface
specification, among other things.
In this example the client stub for the interface was compiled with
the program so that the interface specification
(\*Lgreetif_v1_0_c_ifspec\*O) could be obtained
without building the structure from scratch.
.LI "Set Up a \*Lserver_fixedattr_t\*O Structure"
.ne 5
.nL
Other fixed attributes required for all servers describe how the
server can start, the program name and pathname for the server so that
\*Ldced\*O knows which program to start, and the program's arguments,
among other things.
.LI "\*Ldced_server_create(\|)\*O"
.ne 4
.nL
This routine uses the filled-in \*Lserver_t\*O structure to create a
\*Lsrvrconf\*O entry for \*Ldced\*O.  The data is stored in memory for
quick access whenever the server is started.
.LI "\*Ldced_binding_free(\|)\*O"
.nL
Each call to the  \*Ldced_binding_create(\|)\*O routine requires a
corresponding call to \*Ldced_binding_free(\|)\*O to release the binding
resources allocated.
.LE
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 4 "Modifying a Server's Configuration Attributes"
...\" ----------------------------------------------------------------------
...\" 
.P
The data for configuring servers includes arrays of attributes.
For flexibility, \*Ldced\*O is implemented using the extensible and 
dynamic data structures developed for the DCE security registry attributes.  
This extended registry attribute (ERA) schema gives vendors the flexibility to
modify the attributes appropriate for configuring servers on various systems.
The use and modification of these data structures are described in 
Chapter 28.
.P
Applications commonly use \*Ldced_server_modify_attributes(\|)\*O
after the \*Ldced_server_create(\|)\*O routine to change
the default configuration attributes (the \*Lattributes\*O field of
a \*Lserver_t\*O structure) for a remote server. 
A \*Ldced_attr_list_t\*O data structure is input that contains an
array of \*Lsec_attr_t\*O data structures and a count of the number in
the array.
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 4 "Deleting a DCE Server"
...\" ----------------------------------------------------------------------
...\" 
.P
Management applications use \*Ldced_server_delete(\|)\*O to delete
a server's configuration data and entry in its hosts \*Ldced\*O.
Although this does not delete the actual server program from the host, 
it removes it from DCE control.
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Starting and Stopping Servers"
...\" ----------------------------------------------------------------------
...\" 
.iX "starting and stopping servers"
.iX "dced services" "starting and stopping servers"
.P
A server typically runs as persistent process or is started on demand 
when a client makes a remote procedure call to it.  
Management applications can start remote servers by using the
\*Ldced_server_start(\|)\*O routine.   
This is a \*Lsrvrconf\*O routine that takes as input server configuration
data in the form of an attribute list.  
.P
Once a server has started, it tends to remain running until an administrator 
or management application stops it, but some applications may stop themselves
if, for example, they do not detect activity within a specified time.
To stop remote servers, applications can use the \*Ldced_server_stop(\|)\*O
routine.
.P
The following example shows how an application starts or stops a server:
.oS
.ps 9
.vs 12
dced_binding_handle_t dced_bh, conf_bh, exec_bh;
server_t              conf, exec;
dced_string_t         server_name;
uuid_t                srvrconf_id, srvrexec_id;
error_status_t        status;
 .
 .
 .
/* Toggle the Starting or Stopping of a Server */
dced_binding_create("srvrconf@hosts/somehost",
                    dced_c_binding_syntax_default, 
                    &conf_bh, 
                    &status);
dced_binding_create("srvrexec@hosts/somehost", 
                    dced_c_binding_syntax_default, 
                    &exec_bh, 
                    &status);
dced_inq_id(exec_bh, server_name, &srvrexec_id, &status);
if(status != error_status_ok) {
    puts("Server is NOT running.");
    dced_inq_id(conf_bh, server_name, &srvrconf_id, &status);
    dced_server_start(conf_bh, &srvrconf_id, NULL, &srvrexec_id, &status);
}
else {
    puts("Server is RUNNING.");
    dced_server_stop(exec_bh, &srvrexec_id, srvrexec_stop_rpc, &status);
}
dced_binding_free(conf_bh, &status);
dced_binding_free(exec_bh, &status);
.ps 12
.vs 14
.oE
.P
.VL 1i
.LI "\*Ldced_binding_create(\|)\*O"
.nL
These routines create \*Ldced\*O bindings to the \*Lsrvrconf\*O and
\*Lsrvrexec\*O portions of the server management service on a specified host.
The binding handles created are used in all subsequent calls to appropriate 
\*Ldced\*O API routines.
.LI "\*Ldced_inq_id(\|)\*O"
.nL
This routine returns the UUID that \*Ldced\*O associates with the name input.
Each name used to identify an object of each service has a UUID.
If \*Ldced\*O maintains a UUID for a \*Lsrvrexec\*O object, the server
is running.
However, it is possible that the server is in an in-between state as
it is starting up or shutting down.  For a more robust check as to whether the
server is running, use the \*Ldced_object_read(\|)\*O routine
to read the \*Lserver_t\*O structure for the \*Lsrvrexec\*O object.  
If the \*Vexec_data.tagged_union.running_data.instance\*O UUID is the same as
the \*Lsrvrconf\*O UUID (\*Vsrvrconf_id\*O), the server is running.
.LI "\*Ldced_server_start(\|)\*O"
.nL
This routine starts the server via \*Ldced\*O.  The \*Lsrvrconf\*O
binding handle and UUID are input.
For special server configurations, you can start a server with a
specific list of attributes, but a value of NULL in the third
parameter uses the attributes of the server configuration data.
You can input a \*Lsrvrexec\*O UUID for \*Ldced\*O to use, or allow it
to generate one for you.
.LI "\*Ldced_server_stop(\|)\*O"
.nL
This routine stops a running server identified by its \*Lsrvrexec\*O
UUID.  The cleanest stop method is to cause \*Ldced\*O to use the 
\*Lrpc_mgmt_server_stop_listening(\|)\*O routine so that all
outstanding remote procedure calls complete before the server stops.
.LI "\*Ldced_binding_free(\|)\*O"
.nL
Each call to the  \*Ldced_binding_create(\|)\*O routine requires a
corresponding call to \*Ldced_binding_free(\|)\*O to release the  binding
resources allocated.
.LE
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 3 "Enabling and Disabling Services of a Server"
...\" ----------------------------------------------------------------------
...\" 
.iX "enabling services of a server"
.iX "disabling services of a server"
.iX "dced services" "enabling and disabling"
.P
Most servers have all their services enabled to process all requests.
However, a server may need to enable or disable services to synchronize them, 
for example. 
For another example, an administrator (or management application) may need to
disable or enable services to perform orderly startup or shutdown of a server.
.P
.ne 4
Each service provided by a server is implemented as a set of procedures.  
DCE uses an interface definition to define a service and its procedures,
and application code refers to the interface when controlling the service.
.P
When a server starts, it initializes itself by registering with the RPC runtime
and the \*Ldced\*O process on its host by using the
\*Ldce_server_register(\|)\*O routine. 
This enables all services (interfaces) that the server can support.  
The server can then disable and reenable services (in whatever order 
it requires) by using the \*Ldce_server_disable_if(\|)\*O 
and \*Ldce_server_enable_if(\|)\*O routines.
.P
To control the services of remote servers, management applications use 
the \*Ldced_server_disable_if(\|)\*O and \*Ldced_server_enable_if(\|)\*O routines.  These routines work on the \*Lsrvrexec\*O object.
When a service (interface) is disabled, a client that already knows about 
the service (through a binding handle to this interface and server) 
will no longer work because the interface is unregistered with the RPC runtime.
If you wish to have clients that already know about the server and 
service work, but wish to prohibit any new clients from finding the server and 
service, you can use \*Lrpc_mgmt_ep_unregister(\|)\*O to remove from the
endpoint map the server address information with respect to the service.
This routine does not affect the RPC runtime.
.P
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 2 "Validating the Security Server"
...\" ----------------------------------------------------------------------
...\" 
.P
.iX "security" "validation service"
.iX "dced services" "security validation"
The security validation service (\*Lsecval\*O) has the following major
functions:
.ML
.LI
It maintains a login context for the host's self-identity which includes 
periodic changes to the host's key (password).
.LI
It validates and certifies to applications, usually login programs,
that the DCE security daemon (\*Lsecd\*O) is legitimate.
.LE
.P
Clients (including remote clients, local servers, host logins, and 
administrators) all need the security validation service to make sure that 
the \*Lsecd\*O) process being used by the host is legitimate.
The security validation service establishes the link in a trust 
chain between applications and \*Lsecd\*O 
so that applications can trust the DCE security mechanism.
.P  
.ne 6
An application can trust its host's security validation service 
because they are on the same host, but an application has no way to
``convince itself'' that \*Lsecd\*O, presumably on another host, is genuine.  
However, if the application trusts another principal
(in this case, the security validation service),  
which in turn trusts \*Lsecd\*O, 
then the trust chain now extends from the application to \*Lsecd\*O.
.P
Typically, a login program accesses the security validation service
when it uses the DCE Security Service's login API, described in Chapter 29.
Administrators access the \*Lsecval\*O service by using 
the \*Ldcecp\*O \*Lsecval\*O object.
However, suppose you are writing a security monitoring application to
watch for and respond to security attacks.  
After the application binds to the \*Lsecval\*O service, 
it can call the \*Ldced_secval_validate(\|)\*O 
routine to verify that the \*Lsecd\*O process is legitimate.
.P
Applications can also use the 
\*Ldced_secval_start(\|)\*O and
\*Ldced_secval_stop(\|)\*O routines to start and stop the 
security validation service on a given host.
.P
For example, during configuration of a host, the \*Ldced\*O program can start
with or without the security validation service.  
Later when security is configured, a management application can start
\*Lsecval\*O by using the \*Ldced_secval_start(\|)\*O routine.
For another example, suppose our security monitoring application mentioned
earlier suspects an attack.  
The application can call \*Ldced_secval_stop(\|)\*O to stop
the security validation service without stopping the entire \*Ldced\*O.
This makes the login environment more restrictive.
.P
.P
.P
.ne 5
...\"
...\"
...\"
...\" ----------------------------------------------------------------------
.H 2 "Managing Server Key Tables"
...\" ----------------------------------------------------------------------
...\" 
.P
.iX "key table management service"
.iX "dced services" "key table management"
Keys for servers are analogous to passwords for human users.  
Keys also play a major role in authenticated remote procedure calls.
Keys have some similarities with passwords.
For example, server keys and user passwords have to follow the same 
change policy (or a more stringent one) for a given host or cell.
This means that, just as a user has to periodically come up
with a new password, a server has to periodically generate a new key. 
It is easy to see that a human user protects a password by memorizing it.
But a server ``memorizes'' a key by storing it in a 
file called a \*Ekey table\*O.  
.P
.ne 8
It is more complex for a server to change keys than
it is for a human user to change a password. 
For example, a human user needs to only remember the latest password, 
but a server may need to maintain a history of its keys by using version
numbers so that currently active clients do not have difficulty completing a
remote procedure call. 
When a client prepares to make authenticated remote procedure calls, 
it obtains a ticket to talk with the server.
(The security registry of the authentication service encrypts this ticket 
by using the server's key, and later the server decrypts the ticket when it
receives the remote procedure call.)
.P
Timing can become an issue when a client makes a remote procedure call
because tickets have a limited lifetime before they expire,
and servers must also change their keys on a regular basis.
Assuming the client posesses a valid ticket, suppose that, by the time the 
client makes the call, the server has generated a new key. 
If a server maintains versions of its keys, 
the client can still complete the call.
Authentication is described in detail in Chapter 23.
.P
A key table usually contains keys stored by one server, 
and it must be located on the same host as that server.  
However, a key table can hold keys for a set of related servers, 
as long as all the servers reside on the same host.
Servers usually maintain their own keys, and
Chapter 30 describes the API they use.
Administrators can remotely manage key tables and the keys in the
tables by using the \*Ldcecp\*O \*Lkeytab\*O object.
This section describes the API routines that management applications
can use to manage the key tables and keys of other servers on the network.
.P
Suppose you discover that a server or an entire host's security has been
compromised.   Applications can use the \*Ldced_keytab_change_key(\|)\*O 
routine to change a key table's key.
The following example shows how to reset the key for all key tables
on a specified host:
.P
.oS
.ps 9
.vs 12
.ne 5
dced_binding_handle_t   dced_bh;
dced_entry_list_t       entries;
unsigned32              i;
error_status_t          status;
dced_key_t              key;

.ne 4
dced_binding_create("keytab@hosts/somehost", 
                     dced_c_binding_syntax_default,
                     &dced_bh, 
                     &status);

.ne 6
dced_binding_set_auth_info(dced_bh,
                           rpc_c_protect_level_default,
                           rpc_c_authn_default,
                           NULL,
                           rpc_c_authz_dce,
                           &status);

dced_list_get(dced_bh, &entries, &status);

for(i=0; i<entries.count; i++) {
    generate_new_key(&key); /* application specific */
    dced_keytab_change_key(dced_bh, &entries.list[i].id, &key, &status);
}
dced_list_release(dced_bh, &entries, &status);
dced_binding_free( dced_bh, &status);
.ps 12
.vs 14
.oE
.P
.VL 1i
.LI "\*Ldced_binding_create(\|)\*O"
.nL
This routine creates a \*Ldced\*O binding to a \*Ldced\*O service on a specified
host.
The binding handle created is used in all subsequent calls to appropriate 
\*Ldced\*O API routines.
The \*Lkeytab\*O portion of the first argument represents the
well-known name of the keytab service.  
When this string is used by itself, it refers to the service on the
local host. 
.LI "\*Ldced_binding_set_auth_info(\|)\*O"
.nL
Accessing keytab data requires authenticated remote procedure calls.
The \*Ldced_binding_set_auth_info(\|)\*O routine sets
authentication for the \*Ldced\*O binding handle, \*Vdced_bh\*O.
.LI "\*Ldced_list_get(\|)\*O"
.nL
Applications use the \*Ldced_list_get(\|)\*O routine to get a
service's entire list of names.
.LI "\*Lgenerate_new_key(\|)\*O"
.ne 5
.nL
This application-specific routine generates the new key and fills in
a \*Ldced_key_t\*O data structure.  This routine could use the
\*Lsec_key_mgmt_gen_rand_key(\|)\*O routine to randomly generate a new key.
.LI "\*Ldced_keytab_change_key(\|)\*O"
.nL
The \*Ldced_keytab_change_key(\|)\*O routine tries to change
the principal's key in the security service's registry first.
If that is succesful, it changes the key in the key table.
.LI "\*Ldced_list_release(\|)\*O"
.nL
Each call to the \*Ldced_list_get(\|)\*O routine requires a
corresponding call to \*Ldced_list_release(\|)\*O to release the
resources allocated for the entry list.
.LI "\*Ldced_binding_free(\|)\*O"
.nL
Each call to the \*Ldced_binding_create(\|)\*O routine requires a
corresponding call to \*Ldced_binding_free(\|)\*O to release the
resources allocated for a \*Ldced\*O binding handle.
.LE
.P
For more detailed key table management, applications can peruse a key
table's list of keys by using the 
\*Ldced_keytab_initialize_cursor(\|)\*O,
\*Ldced_keytab_get_next_key(\|)\*O, and
\*Ldced_keytab_release_cursor(\|)\*O routines.
Reading key table data remotely presents a greater security risk
because data is sent over the network.  For remote access, these
routines actually get all the keys during one remote procedure call 
to be more efficient and to minimize the time keys are being sent over
the network.
.P
Earlier in this section we described how to change the key of a key table
with the \*Ldced_keytab_change_key(\|)\*O routine.  
The key table management service also provides the routines
\*Ldced_keytab_add_key(\|)\*O and
\*Ldced_keytab_remove_key(\|)\*O
to control key modification in even greater detail.
.P
Finally, you can create a new key table by using \*Ldced_keytab_create(\|)\*O, 
or you can delete an existing key table by using \*Ldced_keytab_delete(\|)\*O.
...\" 
...\" 
.zA "enh,CR9830,R1.2.2,add dced example"
...\" 
...\" ----------------------------------------------------------------------
.H 2 "Sample dced Application"
...\" ----------------------------------------------------------------------
...\" 
.P
The following sections contain the complete source code, Makefile, and \*Ldcecp\*O
installation and cleanup scripts for a simple DCE application that uses
some of the \*Ldced\*O server management facilities.
...\" 
...\" 
...\" What it does
...\" How to use it (briefly)
...\" 
...\" 
...\" ----------------------------------------------------------------------
.H 3 "Running the Program"
...\" ----------------------------------------------------------------------
...\" 
...\" .P
...\" 
...\" 
...\" 
...\" To run \*Lgreet_dced\*O, do the following.
...\" 
...\" 
...\" .AL
...\" .LI
...\" \*Lmake\*O
...\" 
...\" .LI
...\" Change the \*Luid\*O and \*Lgid\*O values in \*Lgreet_dced.install\*O
...\" as desired. If you do change them, make sure that you chown the \*Lkeytab\*O
...\" file to the same \*Luid\*O in Step 4 below.
...\" 
...\" .LI
...\" As \*Lcell_admin\*O, do:
...\" 
...\" .iS
...\"     dcecp greet_dced.install
...\" .iE
...\" .P
...\" This creates a server principal and account with the password ``secret'',
...\" creates a CDS directory and changes permissions on it (so that the server
...\" principal has rights to create its server entry), creates a \*Lkeytab\*O entry
...\" and creates a \*Lsrvrconf\*O entry. It handles errors, so if something fails
...\" (e.g. if the user already exists) it still goes on to complete.
...\" 
...\" .LI
...\" As root, do:
...\" 
...\" .iS
...\"     chown nick greet_dced.ktab
...\" .iE
...\" .P
...\" because the \*Lchown\*O command in \*Lgreet_dced.install\*O will fail\(emit is
...\" present there only as a reminder. If you use a different \*Luid\*O in the script,
...\" change it here as well.
...\" 
...\" .LI
...\" As \*Lcell_admin\*O, do:
...\" .iS
...\"     dcecp -c server start greeter_dced.nick
...\" .iE
...\" 
...\" .LI
...\" Wait a few moments and check \*L/tmp/srv.out\*O to make sure the server has
...\" started.
...\" 
...\" 
...\" .LI
...\" Start the client as follows
...\" 
...\" .iS
...\"     ./greet_dced_client /.:/subsys/my_company/greet_dced/greeter_dced.nick_entry
...\" .iE
...\" 
...\" .LE
...\" 
...\" 
...\" .P
...\" After you are done, you can get rid of everything as follows:
...\" 
...\" 
...\" .AL
...\" .LI
...\" As cell_admin, stop the server:
...\" 
...\" 	dcecp -c server stop greeter_dced.nick -method soft
...\" 
...\" .LI
...\" As cell_admin, run the delete script:
...\" 
...\" 	dcecp greet_dced.delete
...\" .LE
...\" 
...\" 
...\" 
...\" 
...\" Limitations:
...\" 
...\" .ML
...\" .LI
...\" The server does not catch signals, so when it is stopped it does not
...\" clean up anything.
...\" 
...\" .LI
...\" The dce_server_sec_begin() routine logs in using the server
...\" principal and keytab specified in the srvrconf file. It also starts a
...\" thread to manage the server's key. However, it does NOT start a thread
...\" to refresh the server's login context. That still needs to be done by
...\" the application writer, using the same method that was used in DCE
...\" 1.0.x:
...\" 
...\" 
...\" .DS
...\" \*C        \*Ocreate a thread to run the following:\*C
...\" 
...\"         \*Oloop\*C
...\"                 \*Ofind out when the login context expires\*C
...\"                 \*Odo a pthread_delay_np for (expiration time - current time - 10 minutes)\*C
...\"                 \*Lsec_login_refresh_identity(\|)\*O;\*C
...\"                 \*Lsec_key_mgmt_get_key(\|)\*O;\*C
...\"                 \*Lsec_login_validate_identity(\|)\*O;\*C
...\"                 \*Lsec_key_mgmt_free_key(\|)\*O;\*C
...\"         \*Oend loop\*O
...\" .DE
...\" 
...\" 
...\" 
...\" 
...\" ----------------------------------------------------------------------
.nL
.ne 12
.H 3 "greet_dced.idl"
...\" ----------------------------------------------------------------------
...\" 
.P
Following are the contents of the \*Lgreet_dced.idl\*O file.
...\" 
...\" 
.nL
.ps 9
.vs 12
.oS
/*
 * greet_dced.idl
 *
 * The "greet_dced" interface.
 */

[uuid(3d6ead56-06e3-11ca-8dd1-826901beabcd),
version(1.0)]

interface greet_dcedif
{
    const long int REPLY_SIZE = 100;

    void greet_dced(
        [in]            handle_t h,
        [in, string]    char client_greeting[],
        [out, string]   char server_reply[REPLY_SIZE]
    );
}
.oE
.ps 12
.vs 14
...\" 
...\" 
...\" 
...\" ----------------------------------------------------------------------
.nL
.ne 12
.H 3 "greet_dced_server.c"
...\" ----------------------------------------------------------------------
...\" 
.P
Following are the contents of the \*Lgreet_dced_server.c\*O file, which contains
the \*Lgreet_dced\*O server setup and cleanup routines. This is where the server's
interaction with \*Ldced\*O takes place.
...\" 
...\" 
...\" 
.nL
.ps 9
.vs 12
.oS
/* greet_dced_server_dce.c
 * Main program (initialization) for "greet_dced" server.
 * NEW SERVER for DCE 1.1.
 */

#include <stdio.h>
#include <dce/dced.h>
#include "greet_dced.h"
#include "util.h"

char invocation_instructions[] = "Usage:\en\e
1. Invoke the dcecp program: dcecp\en\e
   dcecp>\en\e
2. Start the server:\en\e
   dcecp> server start greeter_dced\en\e
3. If dced cannot find a matching server object, create server configuration:\en\e
   dcecp> source greet_dced.install\en\e
   dcecp> server start greeter_dced\en\e
4. exit dcecp.\en\e
   dcecp> exit";

FILE * out = NULL;

boolean32 rpc_mgmt_authorize (rpc_binding_handle_t client_bn,
			      unsigned32 op_no,
			      unsigned32 *st);

int main(
    int  argc, 
    char *argv[]
)
{
    server_t                    *server_conf;
    dce_server_register_data_t  register_data[1];
    dce_server_handle_t         server_handle;
    error_status_t              status;   

    /* if we are a daemon stderr is missing */
    out = fopen ("/tmp/srv.out" , "w");

    /* otherwise just use
    out = stderr;
    */

    fprintf(out, "Server start\en");    fflush(out);

    /********** Get the server's configuration from the local dced ***********/
    fprintf(out, "dce_server_inq_server() call\en");    fflush(out);
    dce_server_inq_server(&server_conf, &status);
    fprintf(out, "dce_server_inq_server() return\en");    fflush(out);
    if(status != error_status_ok) {  /*  Describe startup via dcecp and dced */
        fprintf(out, "%s\en", invocation_instructions);	fflush(out);
        ERROR_CHECK(status, "Cannot get server configuration structure");     
    }

    /********** login and manage key                ****************/
    fprintf(out, "dce_server_sec_begin() call\en");    fflush(out);
    dce_server_sec_begin(dce_server_c_login|dce_server_c_manage_key, &status);
    fprintf(out, "dce_server_sec_begin() return\en");    fflush(out);
    if ( status != error_status_ok) {
        fprintf(out, "Failed in dce_server_sec_begin()\en");    fflush(out);
        ERROR_CHECK(status, "Cannot sec_begin");     
    }

    /********** Only the protocol sequences we want ****************/
    fprintf(out, "dce_server_use_protseq() call\en");    fflush(out);
    dce_server_use_protseq( NULL , (idl_char *)"ncadg_ip_udp", &status);
    fprintf(out, "dce_server_use_protseq() return\en");    fflush(out);
    if ( status != error_status_ok) {
        fprintf(out, "Failed to specify protocol sequence\en");    fflush(out);
        ERROR_CHECK(status, "Cannot specify protocol sequence");     
    }

    /************* Fill in rest of registration data structures **************/
    register_data[0].ifhandle = greet_dcedif_v1_0_s_ifspec;
    register_data[0].epv = NULL;       /* use the default entry point vector */
    register_data[0].num_types = 0;
    register_data[0].types = NULL;

    /************************** Register the Server **************************/
    fprintf(out, "dce_server_register() call\en");    fflush(out);
    dce_server_register(    
        dce_server_c_ns_export,        /* flag says register server with CDS */
        server_conf,
        register_data,
        &server_handle,
        &status
    );
    fprintf(out, "dce_server_register() return\en");    fflush(out);
    if ( status != error_status_ok) {
        fprintf(out, "Failed dce_server_register. Error %d\en", status);    fflush(out);
	ERROR_CHECK(status, "Can't register server with DCE");
    }

    /******************* Listen for remote procedure calls *******************/
    fprintf(out, "Listening...\en");    fflush(out);
    rpc_server_listen(rpc_c_listen_max_calls_default, &status);
    fprintf(out, "Returned from listening...\en");    fflush(out);
    if ( status != rpc_s_ok) {
        fprintf(out, "Failed rpc_server_listen\en");    fflush(out);
	ERROR_CHECK(status, "Can't start listening for calls");
    }

    /************************ Unregister from DCE ****************************/
    fprintf(out, "dce_server_unregister call\en");    fflush(out);
    dce_server_unregister(&server_handle, &status);
    fprintf(out, "dce_server_unregister return\en");    fflush(out);
    if ( status != error_status_ok) {
        fprintf(out, "Failed dce_server_unregister\en");    fflush(out);
	ERROR_CHECK(status, "Can't unregister server from DCE");       
    }

    fprintf(out, "dce_server_sec_done call\en");    fflush(out);
    dce_server_sec_done(&status);
    fprintf(out, "dce_server_sec_done return\en");    fflush(out);
    if ( status != error_status_ok) {
        fprintf(out, "Failed dce_server_sec_done\en");    fflush(out);
	ERROR_CHECK(status, "Can't do sec_done");       
    }

}
.oE
.ps 12
.vs 14
...\" 
...\" ----------------------------------------------------------------------
.nL
.ne 12
.H 3 "greet_dced_manager.c"
...\" ----------------------------------------------------------------------
...\" 
.P
Following are the contents of the \*Lgreet_dced_manager.c\*O file, which contains
the implementation of the \*Lgreet_dced\*O interface.
...\" 
...\" 
.nL
.ps 9
.vs 12
.oS
/* 
 * greet_dced_manager.c
 *
 * Implementation of "greet_dced" interface.
 */

#include <stdio.h>
#include "greet_dced.h"

void 
greet_dced(
    handle_t h, 
    idl_char *client_greeting, 
    idl_char *server_reply
)
{
    printf("The client says: %s\en", client_greeting);

    strcpy(server_reply, "Hi, client!");
}
.oE
.ps 12
.vs 14
...\" 
...\" ----------------------------------------------------------------------
.nL
.ne 12
.H 3 "greet_dced_client.c"
...\" ----------------------------------------------------------------------
...\" 
.P
Following are the contents of the \*Lgreet_dced_client.c\*O file.
...\" 
.nL
.ps 9
.vs 12
.oS
/* 
 * greet_dced_client.c
 *
 * Client of "greet_dced" interface.
 */

#include <stdio.h>
#include <dce/nbase.h>
#include <dce/rpc.h>

#include "greet_dced.h"
#include "util.h"

int
main(
    int argc,
    char *argv[]
)
{
    rpc_ns_handle_t import_context;
    handle_t binding_h;
    error_status_t status;
    idl_char reply[REPLY_SIZE];

    if (argc < 2) {
        fprintf(stderr, "usage: greet_dced_client <CDS pathname>\en");
        exit(1);
    }

    /*
     * Start importing servers using the name specified
     * on the command line.
     */
    rpc_ns_binding_import_begin(
        rpc_c_ns_syntax_default, (unsigned_char_p_t) argv[1], 
            greet_dcedif_v1_0_c_ifspec, NULL, &import_context, &status);
    ERROR_CHECK(status, "Can't begin import");

    /*
     * Import the first server (we could interate here,
     * but we'll just take the first one).
     */
    rpc_ns_binding_import_next(import_context, &binding_h, &status);
    ERROR_CHECK(status, "Can't import");

    /*
     * Make the remote call.
     */
    greet_dced(binding_h, (idl_char *) "hello, server", reply);

    printf("The Greet Server said: %s\en", reply);
}
.oE
.ps 12
.vs 14
...\" 
...\" ----------------------------------------------------------------------
.nL
.ne 12
.H 3 "util.c"
...\" ----------------------------------------------------------------------
...\" 
.P
Following are the contents of the \*Lutil.c\*O file, which contains the
error message handling routines for the \*Lgreet_dced\*O server and client.
...\" 
...\" 
.nL
.ps 9
.vs 12
.oS
/*
 * util.c
 *
 * Utility routine(s) shared by "greet_dced" client and server programs.
 */

#include <stdio.h>
#include <dce/nbase.h>
#include <dce/dce_error.h>

void
error_exit(
    error_status_t status,
    char *text
)
{
    unsigned char error_text[100];
    int dummy;

    dce_error_inq_text(status, error_text, &dummy);
    fprintf(stderr, "Error: %s - %s\en", text, error_text);
    exit(1);
}
.oE
.ps 12
.vs 14
...\" 
...\" ----------------------------------------------------------------------
.nL
.ne 12
.H 3 "util.h"
...\" ----------------------------------------------------------------------
...\" 
.P
Following are the contents of the \*Lutil.h\*O file, which contains declarations
used in the \*Lutil.c\*O file.
...\" 
...\" 
.nL
.ps 9
.vs 12
.oS
/*
 * util.h
 *
 * Declarations of utility routine(s) shared by "greet_dced" client
 * and server programs.
 */

#define ERROR_CHECK(status, text) if (status != error_status_ok) error_exit(status, text)

void
error_exit(
    error_status_t status,
    char *text
);
.oE
.ps 12
.vs 14
...\" 
...\" ----------------------------------------------------------------------
.nL
.ne 12
.H 3 "greet_dced.install"
...\" ----------------------------------------------------------------------
...\" 
.P
Following are the contents of the \*Lgreet_dced.install\*O file, which is
the \*Ldcecp\*O install script for the \*Lgreet_dced\*O server.
...\" 
...\" 
...\" 
.nL
.ps 9
.vs 12
.oS
set dir /users/nick/src/dce/greet_dced/greet_dced.nick
set cds_dir /.:/subsys/my_company/greet_dced

# Unix and group id of the server process owner
# has to own the keytab file as well
set uid 1265
set gid 1000

# add a PGO for the server
set cmd "user create greet_dced_server -group servers -o osf -password secret -mypwd -dce-"
if {[catch $cmd msg] != 0} {
	echo "user create:" $msg
}

# create a directory in CDS and give access to the server
# this will fail if any directory in the chain is not already there
set cmd "directory create $cds_dir" 
if {[catch $cmd msg] != 0} {
	echo "directory create: " $msg
}

set cmd "acl modify $cds_dir -add {user greet_dced_server rwdit}"
if {[catch $cmd msg] != 0} {
	echo "acl modify: " $msg
}

# create a keytab for the server
set cmd "keytab create greet_dced.nick.ktab \e
	-storage $dir/greet_dced.ktab \e
	-data {greet_dced_server plain 1 secret}"
if {[catch $cmd msg] != 0} {
	echo "keytab create: " $msg
}

# dced create the keytab file with root as its owner
# so we have to chown it, but
# this may require root permission, so it's likely to fail.
set cmd "exec chown $uid $dir/greet_dced.ktab"
if {[catch $cmd msg] != 0} {
	echo "chown: " $msg
}

# create the srvrconf object
set cmd "server create greeter_dced.nick \e
	-program $dir/greet_dced_server \e
	-entryname $cds_dir/greeter_dced.nick_entry \e
	-keytabs [attrlist getvalues [keytab show greet_dced.nick.ktab] -type uuid]\e
	-principals {greet_dced_server} \e
	-starton explicit \e
	-directory $dir/exec_dir \e
	-services { {ifname greet_dced} {interface {3d6ead56-06e3-11ca-8dd1-826901beabcd 1.0}}} \e
	-uid $uid -gid $gid"
if {[catch  $cmd msg] != 0} {
	echo "server create: " $msg
}
.oE
.ps 12
.vs 14
...\" 
...\" ----------------------------------------------------------------------
.nL
.ne 12
.H 3 "greet_dced.delete"
...\" ----------------------------------------------------------------------
...\" 
.P
Following are the contents of \*Lgreet_dced.delete\*O, which contains the \*Ldcecp\*O
cleanup script for the \*Lgreet_dced\*O server.
...\" 
...\" 
...\" 
.nL
.ps 9
.vs 12
.oS
set dir /users/nick/src/dce/greet_dced/greet_dced.nick
set cds_dir /.:/subsys/my_company/greet_dced

catch "server delete greeter_dced.nick"
catch "keytab delete greet_dced.nick.ktab"
catch "directory delete $cds_dir -tree"
catch "user delete greet_dced_server"
.oE
.ps 12
.vs 14
...\" 
...\" ----------------------------------------------------------------------
.nL
.ne 12
.H 3 "Makefile"
...\" ----------------------------------------------------------------------
...\" 
.P
Following are the contents of the \*Lgreet_dced\*O Makefile.
...\" 
...\" 
...\" 
.nL
.ps 9
.vs 12
.oS
##############################################################################
#                                                                            #
# Makefile: A generic makefile suitable for building the greet_dced          #
#           application.                                                     #
#                                                                            #
#                               -77 cols-                                    #
##############################################################################

DCEROOT		= /opt/dcelocal
CC		= /bin/c89
IDL		= idl
LIBDIRS		= -L${DCEROOT}/usr/lib
LIBS		= -ldce -lc_r
LIBALL		= ${LIBDIRS} ${LIBS}
INCDIRS		= -I. -I${DCEROOT}/share/include
CFLAGS		= -g ${INCDIRS} -D_SHARED_LIBRARIES -D__hppa -Dhp9000s800 \e
		-Dhp9000s700 -D__hp9000s800 -D__hp9000s700 -DHPUX -D__hpux \e
		-Dunix +DA1.1 -D_HPUX_SOURCE
IDLFLAGS	= -v ${INCDIRS} -cc_cmd "${CC} ${CFLAGS} -c"

all:	greet_dced_client greet_dced_server

greet_dced.h greet_dced_cstub.o greet_dced_sstub.o: greet_dced.idl
	${IDL} ${IDLFLAGS} greet_dced.idl

greet_dced_client:	greet_dced.h greet_dced_client.o util.o greet_dced_cstub.o
	${CC} -o greet_dced_client greet_dced_client.o greet_dced_cstub.o \e
		util.o ${LIBALL}

greet_dced_server:	greet_dced.h greet_dced_server.o greet_dced_manager.o util.o \e
		greet_dced_sstub.o
	${CC} -o greet_dced_server greet_dced_server.o greet_dced_manager.o \e
		greet_dced_sstub.o util.o ${LIBALL}

greet_dced_client.c greet_dced_server.c util.c: util.h
greet_dced_manager.c greet_dced_client.c greet_dced_server.c: greet_dced.h

clobber:
	rm -f greet_dced.h greet_dced_client greet_dced_client.o greet_dced_cstub.o \e
		greet_dced_manager.o greet_dced_server greet_dced_server.o \e
		greet_dced_server_dce.o greet_dced_sstub.o server_struct.o \e
		greet_dced_server_dce util.o
.oE
.ps 12
.vs 14
...\" 
.zZ "enh,CR9830,R1.2.2,add dced example"
...\" ----------------------------------------------------------------------
