...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" HISTORY
...\" $Log: service.gpsml,v $
...\" Revision 1.1.7.1  1996/05/10  21:07:29  wardr
...\" 	{enh,R1.2.2}
...\" 	Removed Change Bars
...\" 	[1996/05/10  21:07:12  wardr]
...\"
...\" Revision 1.1.4.3  1996/03/21  19:17:48  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/21  19:17:24  wardr]
...\" 
...\" Revision 1.1.4.2  1996/03/11  21:12:31  weir
...\" 	CR 13047: clarified DCE_SVC_LOG behavior
...\" 	[1996/03/11  21:12:06  weir]
...\" 
...\" Revision 1.1.4.1  1996/03/11  20:56:23  weir
...\" 	Removed incorrect backslash in an example
...\" 	[1996/03/11  20:55:13  weir]
...\" 
...\" Revision 1.1.2.16  1995/06/07  14:36:23  rcb
...\" 	PRENTICE HALL reformat; final edits and changes
...\" 	[1995/06/05  19:52:26  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/04/10  15:56:13  rcb]
...\" 
...\" 	incorporated 1.1 edits
...\" 	[1995/04/05  17:07:56  rcb]
...\" 
...\" Revision 1.1.2.15  1994/11/08  20:53:00  neilson
...\" 	Added index entries.
...\" 	[1994/11/08  20:52:43  neilson]
...\" 
...\" Revision 1.1.2.14  1994/11/03  23:31:13  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:38:16  neilson]
...\" 	Substituted macros for book names in cross refs.
...\" 	Revision 1.1.2.13  1994/10/20  21:07:14  jshirley
...\" 	Move figure title to before figure.
...\" 	[1994/10/20  21:06:47  jshirley]
...\" 	Revision 1.1.2.12  1994/10/19  20:02:55  weir
...\" 	Review comments
...\" 	[1994/10/19  20:02:31  weir]
...\" 	Revision 1.1.2.11  1994/09/19  20:17:07  weir
...\" 	Revised figures
...\" 	[1994/09/19  20:16:27  weir]
...\" 	Revision 1.1.2.10  1994/09/16  19:50:46  weir
...\" 	Corrections
...\" 	[1994/09/16  19:50:19  weir]
...\" 	Revision 1.1.2.9  1994/09/16  18:41:21  weir
...\" 	Updates
...\" 	[1994/09/16  18:40:43  weir]
...\" 	Revision 1.1.2.8  1994/06/13  18:39:37  devobj
...\" 	cr10872 - fix copyright
...\" 	[1994/06/13  18:37:42  devobj]
...\" 	Revision 1.1.2.7  1994/06/12  18:07:51  weir
...\" 	Beta Update
...\" 	[1994/06/12  18:07:25  weir]
...\" 	Revision 1.1.2.6  1994/05/18  19:58:01  weir
...\" 	More comments
...\" 	[1994/05/18  19:57:38  weir]
...\" 	Revision 1.1.2.5  1994/05/18  18:41:30  weir
...\" 	Beta update
...\" 	[1994/05/18  18:40:57  weir]
...\" 	Revision 1.1.2.4  1994/05/16  21:08:46  weir
...\" 	Beta update
...\" 	[1994/05/16  21:08:19  weir]
...\" 	Revision 1.1.2.3  1994/05/12  20:51:01  weir
...\" 	Beta review comments
...\" 	[1994/05/12  20:50:38  weir]
...\" 	Revision 1.1.2.2  1994/05/12  18:26:04  weir
...\" 	First submission
...\" 	[1994/05/12  18:25:40  weir]
...\" 	Revision 1.1.2.1  1994/03/11  23:03:21  rom
...\" 	{enh, 10129, R1.1}
...\" 	Initial split of App Dev Guide into three books and creation of
...\" 	Intro and Style Guide.
...\" 	[1994/03/11  23:00:50  rom]
...\" 
...\" $EndLog$
...\"
...\" ----------------------------------------------------------------------
.H 1 "Using the DCE Serviceability Application Interface"
...\" ----------------------------------------------------------------------
.iX "API" "serviceability"
.P
DCE serviceability was originally developed simply as a way of standardizing
server messages.  The goal of its design was to make sure that all situations
.iX "server" "messages"
requiring human intervention that can be encountered by a server are documented
and identified (both by the server when reporting them, and by the documentation
when explaining them) in a standard coordinated way so that system 
administrators can easily determine the proper corrective action to 
take in response.  Both the
server message text and the relevant documentation are derived from 
the same source (that is, a \*L.sams\*O input file), which 
minimizes the possibility of any discrepancies appearing between the two.
.P
The serviceability component is used by the DCE components (RPC, DTS, Security,
and so on) for their server messaging, and it is made available as an API for use
by DCE application programmers who wish to standardize their applications' server
messaging. (The DCE components are required to use the serviceability routines,
but applications are not.)
...\" ----------------------------------------------------------------------
.H 2 "Overview"
...\" ----------------------------------------------------------------------
.P
Serviceability uses XPG4 message catalogs to hold message text, but it adds an
additional layer to the XPG4 functionality.  The message catalogs and other required
.iX "message" "catalog"
data (and documentation) files are generated by a utility called \*Lsams\*O (``symbols
and message strings'').  Its input is a text file that establishes some organizational
.iX "sams utility for message catalog generation"
information about the program that is to use the messages, followed by a series of
specifications of the messages themselves.
.P
Each message specification contains, along with the message text itself, a detailed
explanation of the situation in which the message will be displayed, together with
a description of the action required, where applicable, to correct the situation.  Part
of the output of \*Lsams\*O thus consists of ``automatic'' documentation of all the
messages writable via the serviceability API. This output was used 
as the basis of the contents of the \*(Tg for the DCE component server
messages.
.P
Messages also have one or more \*Vattributes\*O specified in the \*Lsams\*O input file.
The attributes fall into three broad categories: those that indicate message \*Vseverity\*O,
those that specify message \*Vrouting\*O, and those that specify some \*Vaction\*O (usually
some form of program exit) that should be taken immediately after the message is written.
The effect of the presence of a severity attribute is to cause the message text to contain
a severity-identifying string when displayed or written.  The effect of the presence of a
routing attribute is to cause the message to be routed by default to one of a couple of
standard destinations (more flexible routing is available dynamically).  The effect of
the presence of an action attribute is to cause the program to terminate execution in
one of three ways as soon as the message has been written or displayed, or to cause a
special short form of the message to be generated.
.P
The serviceability API can also be used by DCE applications.  
The advantage in using
it consists mainly in the following:
.ML
.LI
It allows all application messaging to be routed uniformly, on the basis of
the severity of the message
...\" Type of message [NOT SURE WHAT THIS MEANT NOW]
and the functional part of the program originating the message.
.LI
It allows application messages to be made self-documenting.
.LE
.P
.ne 3
Serviceability also contains facilities for debug messaging, which can be
compiled in or out of executables and which can be activated and routed
by component at nine different levels.
...\" ----------------------------------------------------------------------
.H 3 "How Programs Use Serviceability"
...\" ----------------------------------------------------------------------
.P
The DCE serviceability mechanism uses XPG4 message catalogs to hold message text.
Additional files contain the messages' associated documentation and other extra
information used by the mechanism.  All of these files, including the message
catalog, are generated in a single step by running the DCE \*Lsams\*O utility.
The input to \*Lsams\*O is a single \*Lsams\*O file 
that is written by the developer,
and which contains all the necessary information (text, documentation, additional
information) for each message.  The message catalogs and associated information
generated by \*Lsams\*O are then accessed whenever \*Ldce_svc_printf(\|)\*O or
one of the other serviceability routines is called to print or log a message. 
.P
Thus, the result of converting a program to use serviceability will essentially
be that all \*Lprintf(\|)\*O, \*Lfprintf(\|)\*O, and other such routines
will be replaced by
calls to \*Ldce_svc_printf(\|)\*O or one of the related serviceability routines.
For example, a line of code such as the first one that follows would be
replaced by the second:
.oS
fprintf(stderr, "File %s not found\en", filename);

dce_svc_printf(DCE_SVC(\*Vcmp\*C_svc_handle, ""), \*Vcmp\*C_s_server, \\
  svc_c_sev_error, \*Vcmp\*C_s_file_not_found, \*Vfilename\*C);
.oE
.P
where the constants \*Vcmp\*L_s_server\*O and \*Vcmp\*L_s_file_not_found\*O were
generated by \*Lsams\*O, and identify the server ``subcomponent'' of the
application and the message to be written, respectively.   The 
\*Vcmp\*L_svc_handle\*O constant
is the application's handle to its serviceability message 
tables and other necessary data; 
\*Vcmp\*L_s_server\*O is actually an index to a subtable within this dynamically
generated area, and \*Vcmp\*L_s_file_not_found\*O is the index of the 
message text within the subtable.
.P
.ne 6
By convention, \*Vcmp\*O is a three-character code identifying the application
as a whole; serviceability uses it to group all of an application's message and table data
together.  Specifying \*Lsvc_c_sev_error\*O gives the message the severity of ``error;''
the significance of severity in serviceability will be explained in the
following sections. \*LDCE_SVC(\|)\*O
is a macro that helps simplify the coding of \*Ldce_svc_printf(\|)\*O calls; 
as will be seen,
another macro mechanism can be used to make the calls much simpler still.
...\" .P
...\" Suppose the \*Lfprintf(\|)\*O call quoted above appeared in an application you wanted
...\" to convert to serviceability.  The steps you would have to follow in order to replace the
...\" \*Lfprintf(\|)\*O with \*Ldce_svc_printf(\|)\*O call are:
...\" .AL
...\" .LI
...\" Create a \*L.sams\*O file in which you specify the text and identifier of each
...\" message you want your application to be able to display or write.
...\" .LI
...\" Invoke the \*Lsams\*O utility to process the \*L.sams\*O file.
...\" .LI
...\" Code the call to \*Ldce_svc_printf(\|)\*O in your application.  You must also
...\" insert calls to several routines to initialize the serviceability interface
...\" and specify various other runtime parameters, including such things as message
...\" routing, generation of debugging messages (if present), and so on.
...\" .LI
...\" Compile and link your application with the files output by \*Lsams\*O in Step
...\" 2 above.
...\" .LE
...\" ----------------------------------------------------------------------
.H 3 "Simple Serviceability Interface Tutorial"
...\" ----------------------------------------------------------------------
.P
In this section, we'll see how to go about creating a simple C program that
uses the serviceability interface to print the familiar ``Hello World''
message.
.P
All that is necessary to do this is to replace the first call that
follows with something like the second:
.oS
printf("Hello World\en");

dce_svc_printf(\*Vhello_world_message\*C);
.oE
.P
However, making the \*Ldce_svc_printf(\|)\*O call requires the following
preliminary steps:
.AL
.LI
Defining the message in a \*Lsams\*O file.
.LI
Processing the \*Lsams\*O file to obtain a set of files that contain code
used by the serviceability routines.
.LI
Coding some serviceability initialization calls into the C program itself.
.LI
Coding the \*Ldce_svc_printf(\|)\*O call.
.LE
.P
The next several sections describe each of these steps.
...\" ----------------------------------------------------------------------
.H 4 "Defining the Message"
...\" ----------------------------------------------------------------------
.P
In order to print any message through the serviceability interface, we must
first define the message in a \*Lsams\*O file and process the file with the
\*Lsams\*O utility.  For the \*Lhello_svc\*O program, we will define a
\*Lsams\*O
file with the ``bare minimum'' contents necessary.  Additional information on
the use of \*Lsams\*O can be found in the \*Lsams(1dce)\*O reference page.
.P
Each line in a \*Lsams\*O file consists of a simple \*Vheader\*O and \*Vvalue\*O
combination.  The \*Vheader\*O indicates the meaning of the 
value being specified,
and \*Vvalue\*O is the value itself.  A \*Lsams\*O file for serviceability use is made up
of three parts.  The first part consists of a minimum of one line 
that specifies the name of the \*Vcomponent\*O 
(that is, the application) that is to use the messages that
will be generated from the file.
.P
The component name that you specify at the top of a \*Lsams\*O file must consist of a
three-character (no more, no less) string.  For the ``Hello World'' program,
we will use the component name \*Lhel\*O:
.oS
# Part I of simple sams file ...
component           hel
.oE
.P
The \*Lhel\*O string will be used to identify all the files and data structures
that \*Lsams\*O will generate from the file.
.P
The second part of the \*Lsams\*O file contains some additional serviceability-specific
information about the message data structures that will be generated. (This information
is necessary if the \*Lsams\*O file is intended for serviceability use because \*Lsams\*O is
also used to generate message files for general, nonserviceability use.)
.P
This part of the file specifies the names of the serviceability \*Vtable\*O and the
serviceability \*Vhandle\*O.  It also contains a list of the component's
\*Vsubcomponents\*O.  A subcomponent consists of a distinct functional module
of executing code.  For example, most distributed applications would have a basic
server subcomponent, a reference monitor subcomponent that would handle authorization
decisions, and one or more subcomponents that would contain the application's
particular functionality.
.P
.ne 6
The serviceability interface finds a component's messages in one or more subtables,
each one associated with a subcomponent.  When the message is displayed or written,
the associated subcomponent name is written in a field of the message.  This allows
messages to be distinguished during routing or other processing on the basis of the
subcomponent with which they are associated.
.P
Following is what the second part of our simplified sample \*Lsams\*O file looks
like.  We call the serviceability table \*Lhel_svc_table\*O, and we call the serviceability
handle \*Lhel_svc_handle\*O.  Although we have used the three-letter component code
\*Lhel\*O in these names, we were under no obligation to do so; we could have named
the table and the handle anything we wanted. (We will need to know both of these names
when we make the call in the application to initialize the interface in
preparation for displaying messages.)
.P
A component must have at least one subcomponent specified in its \*Lsams\*O file.
Subcomponents are specified in this part simply by supplying their \*Vtable index\*O,
their \*Vname\*O, and their \*Vdescriptive id\*O in a series of separate lines, one
per subcomponent and each one beginning with the \*Lsub-component\*O keyword, between
a set of \*Lstart\*O and \*Lend\*O keywords:
.oS
# Part II
serviceability table hel_svc_table handle hel_svc_handle
start
subcomponent   hel_s_main      "main"  hel_i_svc_main
...\"        tag        table_ix        subcomp full_descr_id
end
.oE
.P
In our example,
.VL 1.5i
.LI "\*Lhel_s_main\*O"
is the table index name for the subcomponent.  Serviceability routines need this name
in order to locate and print any of the subcomponent's messages.
.LI "\*Lmain\*O"
is the name of the subcomponent, specified in quotes.
.LI "\*Lhel_i_svc_main\*O"
is a name that will be used (later on in the file) to identify a message that describes
the subcomponent.
.LE
.P
(Note that \*Lsams\*O assigns values to all of these indexes automatically.)
.P
The third (and final) part of the \*Lsams\*O file consists of a series of records that specify
the messages themselves.  Each record is delimited by the \*Lstart\*O and \*Lend\*O
keywords.  Within each record, a series of keywords identifies the various information
that each message consists of or has associated with it.
.P
.ne 4
Our file will contain only one message, the text of which is to be ``Hello World''. The
record that specifies it is as follows:
.oS
# Part III
start
code                hel_s_hello
subcomponent       hel_s_main
attributes          "svc_c_sev_notice | svc_c_route_stderr"
text                "Hello World"
explanation         "A short informational greeting"
action              "None required."
end
.oE
.P
The keywords specified have the following meanings:
.VL 1.5i
.LI "\*Lstart\*O"
Marks the beginning of a message definition.  This keyword can optionally be followed
by various values.
.ML
.LI
A \*Vnumber\*O following the keyword specifies that the ID that is generated by
\*Lsams\*O for the message should be based on (\*Vnumber\*O multiplied by 100).
This allows the ID numbers of messages that belong to the same subcomponent of
an application to be in the same numerical subseries (\*Lcollection\*O), even
if additional messages for subcomponents have to be added later on.  If each
subcomponent's first message is \*Lstart\*Oed with a \*Lcollection\*O number
that allows for enough extra ID space in the previous subcomponent to accommodate
a reasonable number of future additional definitions, then each subcomponent's ID
series will be able to maintain its unbroken series.
.P
As mentioned, the default size of a \*Lcollection\*O number is 100.  Thus, the
following \*Lcollection\*O specification is interpreted as ``200'':
.oS
start               2
.oE
.P
.ne 6
To change the default \*Lcollection\*O size, specify
.oS
collection size \*Vdddd\*O
.oE
.P
(where \*Vdddd\*O is the \*Lcollection\*O size you desire) in a separate line in
Part 1 of the \*Lsams\*O file.
.LE
.LI "\*Lcode\*O"
Identifies the message.
.LI "\*Lsub-component\*O"
Identifies the subcomponent that will use the message. (This must also
have been defined in Part II of the \*Lsams\*O file.)
.LI "\*Lattributes\*O"
Specifies various things about the message: what kind of message
it is, how it is to be routed, and so on.  Multiple attributes are
specified by ORing their values together.  In the example shown,
the message has the \*Vseverity\*O attribute \*Lsvc_c_sev_notice\*O,
and the \*Vrouting\*O attribute \*Lsvc_c_route_stderr\*O; the latter
forces the message to be routed to \*Lstderr\*O whenever it is written
by a serviceability routine.
.LI "\*Ltext\*O"
Specifies the text of the message itself.
.LI "\*Lexplanation\*O"
Describes the meaning of the message.  The text following this keyword
is used to generate the documentation of the component's messages.
.LI "\*Laction\*O"
Describes any action(s) that should be taken in response to the message.
The text following this keyword is used to generate the documentation of
the component's messages.
.LE
.P
Not all the possible keywords are illustrated in our example, and, of those
illustrated, only \*Lcode\*O and \*Ltext\*O are required in all circumstances.
In the example, \*Lexplanation\*O and \*Laction\*O have been specified because
it is simpler at this point to do so than to leave them out, and 
\*Lattributes\*O
and \*Lsub-component\*O have been specified for reasons that will be made clear
later on.
.P
This final part of the \*Lsams\*O file also contains 
a series of one or more records
that specify messages identifying each of the subcomponents themselves.  Since
our application has only one subcomponent, it contains only one such 
subcomponent-identifying message:
.oS
.ne 7
# Part IIIa
# Messages for serviceability table

start               !intable undocumented
code                hel_i_svc_main
text                "hello_svc main"
end
.oE
.P
The keywords have the same meanings as they did in the ``Hello World'' message.  A
couple of flags have been specified after the \*Lstart\*O keyword.  The first will
cause the message to \*Vnot\*O be generated in the message table, and the second
means that the message does not need any \*Lexplanation\*O or \*Laction\*O
text associated with it.  By specifying \*Lundocumented\*O (with \*Lintable\*O, to
cause the message to actually be generated even though it was to be undocumented)
for the ``Hello'' message, we could have eliminated the \*Lexplanation\*O and
\*Laction\*O keywords there also.
...\" ----------------------------------------------------------------------
.H 4 "Processing the \*Lsams\*O File"
...\" ----------------------------------------------------------------------
.P
The entire \*Lsams\*O file for the \*Lhello_svc\*O program is as follows:
.oS
# Part I
component           hel
table               hel_msg_table

# Part II
serviceability  table hel_svc_table handle hel_svc_handle
start
subcomponent   hel_s_main      "main"  hel_i_svc_main
end

.ne 9
# Part III
start
code                hel_s_hello
subcomponent       hel_s_main
attributes          "svc_c_sev_notice | svc_c_route_stderr"
text                "Hello World"
explanation         "?"
action              "None required."
end

.ne 5
# Part IIIa
start               !intable undocumented
code                hel_i_svc_main
text                "hello_svc main"
end
.oE
.P
We create the file with these contents and name it \*Lhel.sams\*O.  It
can be processed with the simple command that follows:
.iS
sams hel.sams
.iE
.P
Running the command as shown will result in ten files being created:
.VL 1.5i
.LI "\*Ldcehel.cat\*O"
XPG4 message catalog file created by \*Lgencat\*O.  If you wish to use the
message catalog, you must install it yourself.  Its proper location is
platform dependent.
.LI "\*Ldcehel.msg\*O"
Message input file for \*Lgencat\*O.
.LI "\*Ldcehelmac.h\*O"
Defines \*Vconvenience macros\*O for use with the serviceability interface
to write serviceability messages.
.LI "\*Ldcehelmsg.c\*O"
Code defining the in-memory table of message texts.  By using this table,
you can avoid depending on extracting message texts from the message catalog.
.LI "\*Ldcehelmsg.h\*O"
Header file containing definitions for \*Ldcehelmsg.c\*O.
.LI "\*Ldcehelmsg.sml\*O"
Code for a \*(Tg subsection documenting the messages.
.LI "\*Ldcehelmsg.man\*O"
Code for a reference page subsection documenting the messages.
.LI "\*Ldcehelmsg.idx\*O"
.ne 2
Code for building an index for the \*(Tg subsection.
...\" It maps names/numbers and text/numbers.
.LI "\*Ldcehelsvc.c\*O"
.ne 4
Code defining the serviceability table.  
(This is a separate table containing the
serviceability subcomponent identifying messages specified at the end of the
\*Lsams\*O file.)
.LI "\*Ldcehelsvc.h\*O"
Header file containing definitions for \*Ldcehelsvc.c\*O.
.LE
.P
Of these files, only the following are needed for the \*Lhello_svc\*O program:
.VL 1.5i
.LI "\*Ldcehelmac.h\*O"
Contains convenience macro code.
.LI "\*Ldcehelmsg.c\*O"
Contains in-memory message table code.
.LI "\*Ldcehelmsg.h\*O"
Contains definitions for in-memory message table code.
.LI "\*Ldcehelsvc.c\*O"
Contains serviceability message table code.
.LI "\*Ldcehelsvc.h\*O"
Contains definitions for serviceability message table code.
.LE
.P
The three header files should be included into the program source code.  The
\*Ldcehelmsg.c\*O and \*Ldcehelsvc.c\*O modules should be compiled and linked
with the program object module.
.P
All that remains now is to create a simple C program that calls the necessary
serviceability routines to output the ``Hello World'' message.
...\" ----------------------------------------------------------------------
.H 4 "Coding the Serviceability Calls"
...\" ----------------------------------------------------------------------
.P
The bare minimum required to initialize the serviceability interface
and use it to display our message is
.ML
.LI
Call \*Ldce_svc_register(\|)\*O to get a serviceability handle that we can
pass to serviceability message routines.
.LI
Call \*Ldce_msg_define_msg_table(\|)\*O to set up the in-memory message table.
.LI
Call \*Ldce_svc_printf(\|)\*O to print the message.
.LE
.P
To call \*Ldce_svc_register(\|)\*O, you must declare the serviceability handle
that you defined in \*Lhel.sams\*O:
.oS
#include "dcehelsvc.h"

             \*V<.\ .\ .>\*C

dce_svc_handle_t  hel_svc_handle;
unsigned32        status;

             \*V<.\ .\ .>\*C

hel_svc_handle = dce_svc_register(hel_svc_table, \\
  (idl_char*)"hel", &status);
if (status != svc_s_ok)
{
    printf("dce_svc_register failed\en");
    exit(1);
}
.oE
.P
This call is the only initialization we need if we have installed our message
catalog and are willing to depend on the message(s) being extracted from there.
...\" Note that if the application does use the catalog, it does not access the
...\" message catalogs directly; it does not call \*Lcatopen(\|)\*O, \*Lcatgets(\|)\*O,
...\" or \*Lcatclose(\|)\*O.
However, if we wish to have the messages available in program memory (and thus
not depend on the catalog's being correctly installed), then we have to call
\*Ldce_msg_define_msg_table(\|)\*O to initialize the in-memory table, as
follows:
.oS
#include <dce/dce_msg.h>
#include "dcehelmsg.h"

             \*V<.\ .\ .>\*C

dce_msg_define_msg_table(hel_msg_table,
     sizeof(hel_msg_table) / sizeof(hel_msg_table[0]),
                         &status);
if (status != svc_s_ok)
{
    printf("dce_svc_define_msg_table failed\en");
    exit(1);
}
.oE
.P
Now we can call \*Ldce_svc_printf(\|)\*O to print the message, as follows:
.oS
.ne 5
#include "dcehelmac.h"

             \*V<.\ .\ .>\*C

dce_svc_printf(HEL_S_HELLO_MSG);
.oE
.P
Note the argument \*LHEL_S_HELLO_MSG\*O, which we did not define in the \*Lhel.sams\*O
file. \*LHEL_S_HELLO_MSG\*O is, in fact,
a macro that was generated by \*Lsams\*O from
our definition for the \*Lhel_s_hello\*O message, as you can see from
the following code:
.oS
start
code                hel_s_hello
subcomponent       hel_s_main
attributes          "svc_c_sev_notice | svc_c_route_stderr"
text                "Hello World"
explanation         "?"
action              "None required."
end
.oE
.P
The macro automatically generates the long argument list that must be passed to
\*Ldce_svc_printf(\|)\*O to get it to print the message.  The code for this
convenience macro is contained in \*Ldcehelmac.h\*O.
.P
A convenience macro is generated for every message in a \*Lsams\*O file that has both
\*Lsub-component\*O and \*Lattributes\*O specified.  The macro's name is formed
from the uppercase version of its \*Lcode\*O value (as specified in the
\*Lsams\*O file), with the string \*L_MSG\*O appended.
.P
The complete source code for \*Lhello_svc.c\*O is as follows:
.oS
.ne 13
#include <dce/dce.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <dce/utctypes.h>
#include <pthread.h>
#include <dce/dce_msg.h>

#include "hel_svc.h"
#include <dce/dcesvcmsg.h>
#include "dcehelmsg.h"
#include "dcehelsvc.h"
#include "dcehelmac.h"

int main( int  argc,
          char *argv[] )
{

    dce_svc_handle_t    hel_svc_handle;
    unsigned32          status;

    hel_svc_handle = dce_svc_register(hel_svc_table, \\
      (idl_char*)"hel", &status);
    if (status != svc_s_ok)
    {
            printf("dce_svc_register failed\en");
            exit(1);
    }

    dce_msg_define_msg_table(hel_msg_table,
          sizeof(hel_msg_table) / sizeof(hel_msg_table[0]),
                             &status);
    if (status != svc_s_ok)
            printf("dce_svc_define_msg_table failed \\
                        -- will use catalogs\en");

    dce_svc_printf(HEL_S_HELLO_MSG);

}
.oE
...\" mention dce_svc_unregister() here.
...\" ----------------------------------------------------------------------
.H 4 "Building and Running the Program"
...\" ----------------------------------------------------------------------
.P
To build the application, you simply perform these steps:
.AL
.LI
Process the \*Lhel.sams\*O file with the \*Lsams\*O command
.LI
.ne 7
Build and link \*Lhello_svc\*O from the the following modules:
.ML
.LI
\*Ldcehelmsg.c\*O
.LI
\*Ldcehelsvc.c\*O
.LI
\*Lhello_svc.c\*O
.LE
.LE
...\" ----------------------------------------------------------------------
.H 4 "Fields of a Serviceability Message"
...\" ----------------------------------------------------------------------
.P
When executed, the program will print a message similar to the following:
.oS
.ps 8
.vs 10
1994-04-05-20:13:34.500+00:00I----- PID#9467 NOTICE hel main hello_svc.c 47 0xa444e208
Hello World
.ps 12
.vs 14
.oE
.P
This message is made up of the following fields:
.iS
.ps 10
\*Vtime\ inaccuracy\ process_ID\ severity\ component\ subcomponent\ src_file\ src_line\ thread_ID text
.ps 12
.iE
.P
Where the field names have the following meanings:
.VL 1.25i
.LI "\*Vtime\*O"
The time that the message was written, in ISO format:
.iS
\*VCCYY-MM-DD-hh:mm:ss.fff[+|-]II:ii
.iE
.P
Where the digit groups represent:
.VL .5i
.LI "\*VCCYY\*O"
Century and year
.LI "\*VMM\*O"
Month
.LI "\*VDD\*O"
Day
.LI "\*Vhh\*O"
Hour
.LI "\*Vmm\*O"
Minutes
.LI "\*Vss\*O"
Seconds
.LI "\*Vfff\*O"
Fractions of second
.LI "\*VII:ii\*O"
Time inaccuracy expressed in hours and minutes
.LE
.P
The final groups represent a time differential factor (expressed
in hours and minutes), followed by an inaccuracy component.  For further
information on time format, see Chapter 19.
.LI "\*Vprocess_ID\*O"
The process ID of the program that wrote the message (\*LPID#9467\*O in
the example).  If \*Ldce_svc_set_progname(\|)\*O had been called to establish
the application's program name, that name would appear in this field instead
of the process ID.  See Section 4.3.1 for further information.
.LI "\*Vseverity\*O"
The severity level of the message (\*LNOTICE\*O in the example).
.LI "\*Vcomponent\*O"
The component name of the program that wrote the message (\*Lhel\*O in
the example).
.LI "\*Vsubcomponent\*O"
The subcomponent that wrote the message (\*Lmain\*O in the example; note
that this program has only one subcomponent).
.LI "\*Vsrc_file\*O"
The name of the C source file in which the \*Ldce_svc_printf(\|)\*O call
was executed.
.LI "\*Vsrc_line\*O"
The line number, in the source file, at which the \*Ldce_svc_printf(\|)\*O
call is located.
.LI "\*Vthread_ID\*O"
The thread ID of the thread that wrote the message, expressed as a hexadecimal
number (\*L0xa444e208\*O in the example).
.LI "\*Vtext\*O"
The text of the message (\*LHello World\*O in the example).
.LE
...\" Working Architecture...
...\" ----------------------------------------------------------------------
.H 3 "Serviceability Input and Output Files"
...\" ----------------------------------------------------------------------
.P
...\" COPY FROM PREVIOUS CHAPTER?
Figure 4-1 shows the relationship of the various files, both source
and \*Lsams\*O output, that go to make up the \*Lhello_svc\*O application.
.P
The two parallelogram-shaped objects represent the files that 
must be created by the developer (you).
.P
Rectangular objects with solid lines represent files that are
generated by \*Lsams\*O; the two ovals represent programs: one is \*Lsams\*O,
the other \*Lgencat\*O (which is implicitly run by \*Lsams\*O when message
catalogs are generated).
.P
The large rectangular object in dashed lines represents
\*Llibdce\*O, which contains the serviceability library.
.P
The diagram makes no attempt to show how \*Lhello_svc.c\*O itself is compiled
and linked, nor how it runs.  It is just a static map of the general place
of serviceability in DCE development.
.P
...\" pix/sams_svc_use.pic
.FG "Serviceability and DCE Applications"
.sp .5
...\" ----------------------------------------------------------------------
.PS
.in +.5i
scale = 100
"\fB\s8dcehelmsg.idx\s8\fR"  at 504, 396
"\fB\s8dcehelmsg.sml\s8\fR"  at 504, 444
"\fB\s8dcehelmsg.man\s8\fR"  at 504, 492
"\fB\s8dcehel.cat\s8\fR"  at 344, 212
"\fB\s8sams)\s8\fR"  at 344, 268
"\fB\s8gencat\s8\fR"  at 342, 288
"\fR\s8(executed by\s8\fR"  at 344, 276
"\fB\s8dcehel.msg\s8\fR"  at 344, 348
"\fB\s8sams\s8\fR"  at 310, 452
"\fB\s8hel.sams\s8\fR"  at 304, 580
"\fB\s8libdce\s8\fR"  at 110, 166
"\fB\s8dce_svc_printf(HEL_S_HELLO_MSG);\s8\fR"  at 120, 212
"\fB\s8hello_svc.c\s8\fR"  at 112, 268
"\fB\s8dcehelmsg.h\s8\fR"  at 96, 348
"\fB\s8dcehelmsg.c\s8\fR"  at 96, 388
"\fB\s8dcehelsvc.c\s8\fR"  at 96, 428
"\fB\s8dcehelsvc.h\s8\fR"  at 96, 468
"\fB\s8dcehelmac.h\s8\fR"  at 96, 508
line ->  from 312, 564 \
	to 312, 476 
line   from 232, 596 \
	to 248, 564 \
	to 376, 564 \
	to 360, 596 \
	to 232, 596 
"\fR\s8\s8\fR"  at 304, 564
line  dashed 0.1 * scale from 16, 252 \
	to 16, 116 \
	to 224, 116 \
	to 224, 252 
line  dashed from 200, 204 \
	to 288, 196 
line   from 96, 484 \
	to 96, 492 
line   from 96, 444 \
	to 96, 452 
line   from 96, 404 \
	to 96, 412 
line   from 96, 364 \
	to 96, 372 
line   from 96, 284 \
	to 96, 332 
line -> dashed from 112, 260 \
	to 120, 220 
line  dashed from 96, 484 \
	to 96, 484 
"\fR\s8(DCE library)\s8\fR"  at 110, 150
line   from 0, 284 \
	to 208, 284 \
	to 224, 252 \
	to 16, 252 \
	to 0, 284 
line  dotted from 280, 372 \
	to 400, 372 \
	to 400, 180 \
	to 280, 180 \
	to 280, 372 
line ->  from 344, 252 \
	to 344, 220 
line ->  from 344, 332 \
	to 344, 300 
line   from 288, 364 \
	to 392, 364 \
	to 392, 332 \
	to 288, 332 \
	to 288, 364 
"\fR\s8(message catalog)\s8\fR"  at 344, 196
line   from 288, 220 \
	to 392, 220 \
	to 392, 188 \
	to 288, 188 \
	to 288, 220 
ellipse wid 104 ht 48 at 340, 274
"\fR\s8\s8\fR"  at 96, 4
ellipse wid 104 ht 48 at 310, 448
"\fR\s8\s8\fR"  at 114, 244
line ->  from 320, 428 \
	to 336, 372 
"\fR\s8(doc)\s8\fR"  at 508, 428
"\fR\s8(doc)\s8\fR"  at 506, 476
line   from 552, 420 \
	to 552, 452 \
	to 456, 452 \
	to 456, 420 \
	to 552, 420 
line   from 552, 468 \
	to 552, 500 \
	to 456, 500 \
	to 456, 468 \
	to 552, 468 
line   from 144, 332 \
	to 144, 364 \
	to 48, 364 \
	to 48, 332 \
	to 144, 332 
line   from 144, 372 \
	to 144, 404 \
	to 48, 404 \
	to 48, 372 \
	to 144, 372 
line   from 144, 412 \
	to 144, 444 \
	to 48, 444 \
	to 48, 412 \
	to 144, 412 
line   from 144, 452 \
	to 144, 484 \
	to 48, 484 \
	to 48, 452 \
	to 144, 452 
line   from 144, 492 \
	to 144, 524 \
	to 48, 524 \
	to 48, 492 \
	to 144, 492 
line ->  from 256, 452 \
	to 144, 508 
line ->  from 256, 452 \
	to 144, 468 
line ->  from 256, 452 \
	to 144, 428 
line ->  from 256, 452 \
	to 144, 388 
line ->  from 256, 452 \
	to 144, 348 
line ->  from 360, 452 \
	to 456, 484 
line ->  from 360, 444 \
	to 456, 436 
line   from 552, 372 \
	to 552, 404 \
	to 456, 404 \
	to 456, 372 \
	to 552, 372 
line ->  from 352, 436 \
	to 456, 388 
"\fR\s8(doc)\s8\fR"  at 512, 380
.in
.PE
.P
.ne 4
The \*Lsams\*O output filenames are constructed as follows:
.iS
\*Vtech_name\*L.\*Vcomp_name\*L.\*Vpart_name\*L.\*Vextension
.iE
.P
where:
.VL 1i
.LI "\*Vtech_name\*O"
Is the technology name (optionally specified at the top 
of the \*Lhel.sams\*O file); by default it is \*Ldce\*O.
.LI "\*Vcomp_name\*O"
Is the component name (specified at the top of the \*Lhel.sams\*O file); in
this case, \*Lhel\*O.
.LI "\*Vpart_name\*O"
Is a substring identifying the particular file; for example, \*Lsvc\*O or
\*Lmsg\*O, and so on.  This piece of the name is omitted from the message
catalog filenames (in our example, \*Ldcehel.msg\*O and \*Ldcehel.cat\*O).
.LI "\*Vextension\*O"
Is the file extension (preceded by a \*L.\*O (dot) character).
.LE
.P
Because we executed the simplest form of the \*Lsams\*O command (that is,
without specifying any output flags), the full repertory of \*Lsams\*O
output files was created, even though the following files were not needed
for our application:
.ML
.LI
\*Ldcehel.msg\*O and \*Ldcehel.cat\*O
.P
The file \*Ldcehel.msg\*O is input to \*Lgencat\*O when it is invoked by
\*Lsams\*O to create \*Ldcehel.cat\*O, the message catalog. (Although our
example application used in-memory tables, the serviceability routines always
attempt to use the message catalog first.)
.LI
\*Ldcehelmsg.man\*O and \*Ldcehelmsg.sgm\*O
.P
These are automatically generated documentation files (their nature and
purpose were previously described) that have nothing to do with 
the operation of the interface itself.
.LE
.P
The many additional features of serviceability will be described in 
the following sections.  A definitive description of \*Lsams\*O and 
the contents of \*Lsams\*O files
can be found on the \*Lsams(1dce)\*O reference page.
...\" ----------------------------------------------------------------------
.H 2 "Integrating Serviceability into a Server"
...\" ----------------------------------------------------------------------
.P
The purpose of the preceding tutorial was simply to give a brief taste of what
it feels like to use the interface.  The main task involved in using serviceability
does not, however, lie in mastering the mechanics of the interface, but rather
in understanding the purpose of handling server messages in this way, and then
applying this understanding in order to develop an effective and serviceable
messaging strategy for one's own application.
...\" ----------------------------------------------------------------------
.H 3 "Serviceability Strategy"
...\" ----------------------------------------------------------------------
.P
The serviceability mechanism is designed to be used mainly for server informational
and error messaging\(emthat is, for messages that are of interest to those who
are concerned with server maintenance and administration (in the broadest sense of
these terms).  The essential idea of the mechanism is that all server events that
are significant for maintaining or restoring normal operation should be reported in
messages that are made to be self-documenting so that (provided all significant
events have been correctly identified and reported) users and administrators will by
definition always be able to learn what action they should take whenever anything
out of the ordinary occurs.  User-prompted, interactive, client-generated messaging
should be handled through the DCE messaging interface, which is described in
Chapter 3.
.P
It follows that serviceability is not just an interface; it is partly a state of
mind.  The first thing that a developer who wishes to use serviceability should do
is examine his or her server code with a view to identifying all the \*Vevent points\*O
that should be covered by serviceability calls.  Once these have 
been determined, the
\*Lsams\*O file (containing the message definitions) should be written; the last step will
be to insert the messaging calls into the code.
...\" ----------------------------------------------------------------------
.H 3 "Components and Subcomponents"
...\" ----------------------------------------------------------------------
.P
The very first step in incorporating serviceability into a server is to analyze
it into functionally discrete modules (called \*Vsubcomponents\*O), each of which
will usually be associated with a separate set of messages.
.P
The program itself is regarded as the component.  The main significance of subcomponents
is that each one uses a separate part of the message table generated by \*Lsams\*O, and
every message is identified both by component and by subcomponent; message routing and
the level of debug messaging can be specified separately by subcomponent.
...\" Refer to example program?
...\" ----------------------------------------------------------------------
.H 3 "Identifying Event Points"
.iX "event points"
.iX "serviceability" "event points"
...\" ----------------------------------------------------------------------
...\" Following taken from "Code Point Criteria" in Section 4 of the RFC, also the
...\"  definitions in Section 5.
.P
Once you have established the subcomponent organization of the server application,
you can begin the work of identifying all the points in the server code at which
events occur or can occur that require serviceability messaging.
.P
Following is a list of the events and kinds of events that should be reported
through the serviceability interface:
.ML
.LI
Server startup
.P
Servers should report when they are started, when they have completed
their initialization, and when they are ready to perform work.  
They should also indicate when they are going offline.
...\" ...John's note: what severity do we suggest?
.LI
Server exit
.P
All fatal exits should be reported as fatal errors, using the 
\*Lsvc_c_sev_fatal\*O
severity attribute in a call to \*Ldce_svc_printf(\|)\*O.
In other words, \*Lexit(\|)\*O or
\*Labort(\|)\*O should not be called directly; this ensures 
that all such fatal errors
will be logged.  For an explanation of severity level attributes, 
see Section 4.3.1.
.LI
.ne 7
Other fatal errors
.P
Errors that make it impossible to proceed should be detected as close
as possible to the point where the actual failure occurred.  
This class of error includes such ``impossible'' conditions as failure 
to successfully allocate memory, failure to
open a configuration file for reading, failure to open a log file for writing, 
and so on.
.LI
Impaired efficiency
.P
Conditions that may indicate system-level malfunction or poor
performance should be reported as warnings.  
An example of such a situation (from one
of the DCE components) would be the RPC runtime detecting that it is having to make an
excessive number of retransmits.
.LI
Significant ``routine'' activity
.P
Routine administrative actions should be reported as
informational (\*Lsvc_c_sev_notice\*O) messages.  
Such activity includes creation, modification and deletion of tickets, 
threads, files, sockets, RPC endpoints, or other
objects; message transfer, including name lookup, 
binding, and forwarding; directory
maintenance (including caching, advertising, 
skulking, and replication); and database
maintenance (including replication or synchronization).
...\" .LI
...\" It should be possible to determine that the system is operating reliably even if it
...\" is idle.  Periodic \*Lping\*O messages are too expensive.  We suggest a value-added
...\" program that collects and displays the statistics collected from the remote management
...\" interface (see below).
...\" .LI
...\" It is \*Vnot\*O necessary for run-time programming errors to be detected and caught,
...\" as this could add unacceptable size and performance penalties.  For example, internal
...\" subroutines need not validate their input parameters.
...\" Many routines in DCE are only
...\" called by other subroutines, and none of their input parameters is an arbitrary text
...\" string that would be entered by a user.  These routines are not required to validate
...\" their input.  DCE engineers might use the \*Ldce_assert(\|)\*O macro 
...\" to test for common obvious errors (such as an illegal null pointer); using
...\" assertions means that these checks can easily be removed from production code.
...\" Routines that are not part of the exposed API fall into this category and need not
...\" have their input validated.
.LI
Data input syntax errors
.P
Routines that process data that could have been entered from 
a keyboard should fail gracefully (and not core dump, for example) 
if the data is syntactically incorrect.
Serviceability can be used to report this kind of failure.
.LE
.P
Once you have identified the points in your code that should be reported with
serviceability messaging, the next step is to define the messages themselves
(in the \*Lsams\*O file) and code the serviceability calls.  The serviceability features
of \*Lsams\*O files were described previously; the following sections
describe the various parts of the serviceability interface itself.
...\" Following added at Rich's suggestion, but I think I need to add some
...\"  more explanation.  See RFC 24.2...
.P
Using the serviceability interface to report errors ensures that the error codes
used will be unique within DCE.
...\" ----------------------------------------------------------------------
.H 2 "Application Use of Serviceability"
...\" ----------------------------------------------------------------------
.P
The following subsections describe in detail the various elements of the
serviceability API and what you can do with them.
.P
Complete reference pages for all the serviceability routines can be found
in the \*(Dr.
...\"\*VOSF DCE Application Dev.  Reference\*O.
...\" ----------------------------------------------------------------------
.H 3 "Basic Server Calls"
...\" ----------------------------------------------------------------------
.P
The ``basic'' serviceability routines are the following:
.ML
.LI
\*LDCE_SVC_DEFINE_HANDLE(\|)\*O
.iX "serviceability API" "\*LDCE_SVC_DEFINE_HANDLE(\|)\*O"
.P
This is a macro that can be used instead of \*Ldce_svc_register(\|)\*O to
register a table (it does this by means of a global variable created at
compile time).  It could have been used in the \*Lhello_svc.c\*O code as
follows, 
with exactly the same results as from using \*Ldce_svc_register(\|)\*O: 
.oS
.ps 11
.vs 13
DCE_SVC_DEFINE_HANDLE(hel_svc_handle, hel_svc_table, "hel");
/*                        handle            |          |      */
/*                                      table          |      */
/*                                            component name  */
.ps 12
.vs 14
.oE
.P
Note that either \*LDCE_SVC_DEFINE_HANDLE(\|)\*O or \*Ldce_svc_register(\|)\*O
\*Vmust\*O be called before the interface can be used.
.LI
\*Ldce_svc_register(\|)\*O
.iX "serviceability API" "\*Ldce_svc_register(\|)\*O"
.P
This is the function call for registering a serviceability message table.
Either it or \*LDCE_SVC_DEFINE_HANDLE(\|)\*O must be called before any
routines can be called to display or log messages.  An example of its use
can be seen in the illustrated \*Lhello_svc.c\*O code.
.LI
\*Ldce_svc_unregister(\|)\*O
.iX "serviceability API" "\*Ldce_svc_unregister(\|)\*O"
.P
This is the function call for destroying a serviceability handle.  Calling it
closes any open message routes and frees all allocated resources associated
with the handle.  However, it is not usually necessary to call this routine
since the normal process exit will perform the required cleanup.
.P
The routine could have been called at the end of the \*Lhello_svc.c\*O
application as follows:
.oS
dce_svc_unregister(hel_svc_handle, &status);
.oE
.P
where \*Lhel_svc_handle\*O is the serviceability handle that was originally
returned by the call to \*Ldce_svc_register(\|)\*O, or filled in by the
\*LDCE_SVC_DEFINE_HANDLE(\|)\*O call.
.LI
\*Ldce_svc_set_progname(\|)\*O
.iX "serviceability API" "\*Ldce_svc_set_progname(\|)\*O"
.P
This function sets the application's \*Vprogram name\*O, which is included
in all messages.  In this way, multiple programs can write messages to the same
file and the messages will remain distinguishable.
.P
For example, this routine could have been called in the \*Lhello_svc.c\*O
code, as follows:
.oS
dce_svc_set_progname("hello_program", &status);
.oE
.P
The message printed by the program would, as a result, have looked like
the following:
.oS
.ps 10
.vs 12
1994-04-05-20:13:34.500+00:00I----- hello_program NOTICE hel main \&.\&.\&.
Hello World
.ps 12
.vs 14
.oE
.P
instead of looking like this:
.oS
.ps 10
.vs 12
1994-04-05-20:13:34.500+00:00I----- PID#9467 NOTICE hel main \&.\&.\&.
Hello World
.ps 12
.vs 14
.oE
.P
where the default process ID information has been replaced by the string
\*Lhello_program\*O in the first example.  The second example shows what
the message looks like if the routine is not called.  The \*LPID#\*Vnnnn\*O
value is the value returned by \*Lgetpid(\|)\*O.
.P
This call is \*Voptional\*O.
.LI
.ne 8
\*Ldce_svc_printf(\|)\*O
.iX "serviceability API" "\*Ldce_svc_printf(\|)\*O"
.P
This is the normal call for writing or displaying serviceability messages.
It cannot be called with a literal text argument; instead, the message text
and other necessary information must be pre-specified in a file that 
is processed by the \*Lsams\*O utility, which in turn outputs sets of 
tables from which the messages are extracted for output.  
The tutorial in Section 4.1.2 provides a brief example of how this is done.
.P
There are two main ways in which to call the routine.  If a message has been
defined in the \*Lsams\*O file with both \*Lsub-component\*O and \*Lattributes\*O
specified, then the \*Lsams\*O output will include a convenience macro for
the message that can be passed as the single argument to \*Ldce_svc_printf(\|)\*O,
for example:
.oS
dce_svc_printf(HEL_S_HELLO_MSG);
.oE
.P
The convenience macro's name will be generated from the uppercase version of the
message's \*Lcode\*O value (as specified in the \*Lsams\*O file), with the string \*L_MSG\*O
appended.
.P
If a convenience macro is not generated, or if you want to override some of
the message's attributes at the time of output, then you must call the routine
in its long form.  For the \*Lhel_s_hello\*O message, such a form of the call
might look as follows:
.oS
dce_svc_printf(DCE_SVC(hel_svc_handle, ""), hel_s_main,\\
  svc_c_sev_error | svc_c_route_stderr, hel_s_hello);
.oE
.P
\*LDCE_SVC(\|)\*O is a macro that \*Vmust\*O be passed as the first argument
to \*Ldce_svc_printf(\|)\*O if a convenience macro is not being used.  It takes
two arguments:
.ML
.LI
The caller's serviceability handle
.LI
A format string for the message that is to be output
.LE
.P
The format string is for use with messages that have been coded with argument
specifiers.  The \*Lhel_s_hello\*O message had no argument specifiers, so an
empty string is passed here to \*LDCE_SVC\*O.  For an example of printing a message
with arguments, see the end of this subsection.
.P
.ne 3
The remaining arguments passed to \*Ldce_svc_printf(\|)\*O 
are as follows:
.ML
.LI
Subcomponent table index
.P
This symbol was declared in the \*Lsub-component\*O list coded in Part II of the
\*Lsams\*O file; its value is used to index into the subtable of messages in which the
desired message is located.
.LI
Message attribute(s)
.P
This argument consists of one or more attributes to be applied to the message
that is to be printed.  Note that you \*Vmust\*O specify at least a severity 
here (for a list of message severity values, see Section 4.3.3).
Multiple attributes are ORed together, as shown in the example.
.P
There are four categories of message attributes:
.VL 1.25i
.LI "routing"
The available routing attribute constants are
.ML
.LI
\*Lsvc_c_route_stderr\*O
.LI
\*Lsvc_c_route_nolog\*O
.LE
.P
However, most routing is done either by passing specially formatted
strings to \*Ldce_svc_routing(\|)\*O or by environment variable
values.  See Section 4.3.4 for more detailed information.
.LI "severity"
The available severity attribute constants are
.ML
.LI
\*Lsvc_c_sev_fatal\*O
.LI
\*Lsvc_c_sev_error\*O
.LI
\*Lsvc_c_sev_warning\*O
.LI
\*Lsvc_c_sev_notice\*O
.LI
\*Lsvc_c_sev_notice_verbose\*O
.LE
.P
For more detailed information, see Section 4.3.3.
.LI "action"
.ne 10
The available message action attribute constants are
.ML
.LI
\*Lsvc_c_action_abort\*O
.LI
\*Lsvc_c_action_exit_bad\*O
.LI
.ne 3
\*Lsvc_c_action_exit_ok\*O
.LI
\*Lsvc_c_action_brief\*O
.LE
.P
For more detailed information, see Section 4.3.7.
.LI "debug level"
Nine different debug levels can be specified.  For more detailed information,
see Section 4.3.12.
.LE
.LI
message ID
.P
This argument consists of the message's \*Lcode\*O, as declared in the
\*Lsams\*O file.
.LE
.P
As an example of how to use format specifiers in messages, 
consider the following
\*Lsams\*O file fragment, in which we 
define a second message for the \*Lhello_svc.c\*O
application:
.oS
.ps 10
.vs 12
start
code                hel_s_testmessage
text                "This message has exactly %d not %d argument(s)"
explanation         "This message is to show how to pass arguments"
action              "None required."
end
.ps 12
.vs 14
.oE
.P
The message could be printed by a call like the following:
.oS
.ps 10
.vs 12
dce_svc_printf(DCE_SVC(hel_svc_handle, "%d%d"), hel_s_main,\\
               svc_c_sev_notice | svc_c_route_stderr,\\
               hel_s_testmessage, 2, 7);
.ps 12
.vs 14
.oE
.P
Note the format specifiers passed in the format string to \*LDCE_SVC\*O, and
the argument values passed at the end of the argument list.  This call would
cause the following message to be printed:
.oS
.ps 8
.vs 10
1994-04-06-20:06:33.113+00:00I----- hello NOTICE hel main hello_svc.c \*Vline_nr\*C 0xa444e208
This message has exactly 2 not 7 argument(s)
.ps 12
.vs 14
.oE
.LE
...\" ----------------------------------------------------------------------
.H 3 "Extended Format Notation for Message Text"
...\" ----------------------------------------------------------------------
.P
A slightly extended notation allows you to define message texts in the 
\*Lsams\*O
.iX "message" "text format notation"
file that will (if desired) have format specifiers in their application code
forms (that is, in the \*L.c\*O and \*L.msg\*O files output by \*Lsams\*O), but
which will be replaced by some specified string constant in the message texts
that are generated for documentation use (that is, in the \*L.sml\*O and \*L.man\*O
files).
.P
The notation consists in surrounding the format specifier and alternative
constant with < and > (angle bracket) characters, and separating the two 
with a | (vertical bar).  (You can use a preceding \e (backslash) to
escape these symbols.)  For example, the following message text field:
.oS
text          Can't open input file %s for reading
.oE
.P
would become something like the following:
.oS
text          Can't open input file <%s|filename> for reading
.oE
.P
This message text definition, when processed by \*Lsams\*O, would generate
a format string with \*L%s\*O in the \*L.c\*O and message files, but this
format specifier would be replaced by the string \*Vfilename\*O
in the \*L.sml\*O and \*L.man\*O file versions.
...\" One of the goals was to have the exact same text used for both
...\" documentation and code(messaging):  the SAMS input should go right to
...\" typesetting untouched by human hands:  changes that show through in the
...\" manual should be made to the sams input, not to one of the sams output
...\" files.
...\" To explain the problem a bit more, the application program needs to see
...\"         Can't open input file %s for reading
...\"         Processed %d lines
...\"         Yes, a<%d
...\" In a book you'd probably want to see something like
...\"         Can't open input file \fBfilename\fP for reading
...\"         Processed \fBcount\fP lines
...\"         Yes, a<\fB%d\fP
...\" I will extend the input syntax (for SAMS "text" fields) like this:
...\"         Can't open input file <%s|filename> for reading
...\"         Processed <%d|count> lines.
...\"         Yes, a\<<%d|number>.
...\" [For example, see src/admin/dced/idl/dhd.sams.]
...\" ----------------------------------------------------------------------
.H 3 "Specifying Message Severity"
.iX "message" "severity"
...\" ----------------------------------------------------------------------
.P
Production (that is, nondebug) serviceability messages are categorized
by their \*Vseverity level\*O, which implies various important things about
the kind of situation that causes the message to be printed.  Every message's
severity is stated in the text of the message itself (for example, \*LNOTICE\*O
in the examples given previously shows that the messages are
``informational notices''), and the serviceability routines can route and
process messages differently on the basis of their severity levels.
.P
Severity levels are attached to messages either when the messages are defined
(in the \*Lsams\*O file) or when the messages are written (by 
specifying an argument to the routine writing the message).  
These severity levels can then be used at runtime as the basis on which 
to route the messages (the way this is done will be explained in the 
next section).
.P
.ne 4
Thus, each severity level is represented by
a \*Vconstant\*O by which it is specified in program code, and a \*Vname\*O
by which it is referred to in routing files and environment variables.  Each
level's name and constant is shown, together with an explanation, in 
Table 4-1.
...\" See also "Code Point Criteria", Section 4 in the RFC, for detailed
...\"  descriptions of what each of these levels means and implies.  See
...\"  also the definitions in Section 5.
.P
.ne 4i
.TB "Serviceability Message Severities"
.ps 11
.vs 13
.na
.TS
center tab(@) allbox;
lb | lb | lb
lb | lb | l.
Name@Specifier@Meaning
_
FATAL@svc_c_sev_fatal@T{
A fatal error has occurred; the program is about
to exit.
T}
ERROR@svc_c_sev_error@T{
An error has occurred.
T}
WARNING@svc_c_sec_warning@T{
An error has been detected; the program is
continuing execution.
T}
NOTICE@svc_c_sev_notice@T{
A nonerror event has occurred; this message is an
informational notice of it.
T}
NOTICE_VERBOSE@svc_c_sev_notice_verbose@T{
A nonerror event has occurred; this
message is a verbose informational notice of it.
T}
.TE
.ad
.ps 12
.vs 14
.sp .5
.P
Detailed explanations of the levels are as follows:
.VL 1i
...\" .LI "\*Lsvc_c_sev_exit\*O"
...\" Normal exit: Program has successfully completed processing and is about to exit.
.LI "\*LFATAL\*O"
Fatal error exit: An unrecoverable error (such as database corruption) has occurred
which will probably require manual intervention to be corrected.  The program usually
terminates immediately after such an error.
.LI "\*LERROR\*O"
Error detected: An unexpected event that is nonterminal (such as a timeout), or is
correctible by human intervention, has occurred.  The program will continue operation,
although some functions or services may no longer be available.  This severity level
may also be used to indicate that a particular request or action could not be completed.
.LI "\*LWARNING\*O"
.ne 8
Correctible error: An error occurred that was automatically 
corrected (for example, a configuration file was not found, and 
default values were used instead).  This severity level may also 
be used to indicate a condition that \*Vmay\*O be an error if the 
effects are undesirable (for example, removing all files as a side 
effect of removing a nonempty directory), or to indicate a condition 
which, if not corrected, will eventually result in an error (for 
example, a printer's running low on paper).
...\" .LI "\*Lsvc_c_sev_alarm\*O"
...\" Alarming condition: An event in the security domain has occurred; for example, an
...\" incorrect value was detected.
.LI "\*LNOTICE\*O"
Informational notice: A significant routine major event has occurred; for example,
a server has started.
.LI "\*LNOTICE_VERBOSE\*O"
.nL
Verbose information notice: A significant routine event has occurred; for example,
a directory entry was removed.
...\" .LI "\*Lsvc_c_debug1\*O\ through"
...\" .LI "\*Lsvc_c_debug9\*O"
...\" Debug level 1 through Debug level 9: Messages in the nine Debug levels will not
...\" normally appear in production code.
...\" They are used to capture the current \*L#ifdef DEBUG\*O messages
...\" found in the DCE sources.
...\" (There is also a \*Lsvc_c_debug_off\*O level, which means that no logging should be
...\" done for the so-specified subcomponent.)
.LE
.P
Note that debug messages are identified as such by their own set of levels;
see Section 4.3.12 for more information.
...\" ----------------------------------------------------------------------
.H 3 "How to Route Messages"
...\" ----------------------------------------------------------------------
.P
Serviceability messages can be written to any of the normal output destinations.
Routing for serviceability messages can be specified in any of three different
.iX "message" "routing"
ways (in ascending order of precedence):
...\" Following list is in decreasing order of precedence...
.AL
.LI
By the contents of a routing file
.LI
By the contents of a routing environment variable
.LI
By calling the \*Ldce_svc_routing(\|)\*O routine (often as part of processing
an application's command-line arguments)
.LE
.P
Additional routing (that is, in addition to whatever routing has been
specified by the means described) of a message to standard error 
can be performed in either of the following two ways:
.ML
.LI
By specifying the routing as one of the message's \*Lattributes\*O (in the
\*Lsams\*O
file definition of the message)
.LI
By specifying the attribute in the call to \*Ldce_svc_printf(\|)\*O (or other
serviceability output routine) to generate the message
.LE
.P
.ne 5
\*VRouting\*O a message actually consists of specifying two things:
.ML
.LI 
How the
message should be processed (the form it should be put in)
.LI
Where the
message should be sent (its destination)
.LE
.P
The two specifications are sometimes
closely interrelated, and sometimes specifying a certain destination implies
that the message must be put into a certain form.  This fact allows certain
combinations of processing and destination to be abbreviated.
.P
.ne 2
In the following sections, each of the ways to route serviceability messages
is described.
.P
.ne 2
Note that debug messages are routed by a similar, but slightly different,
technique.  For a full description, see Section 4.3.12.
...\" ----------------------------------------------------------------------
.H 4 "Using a Routing File"
...\" ----------------------------------------------------------------------
.P
If a file called \*Vdce-local-path\*L/svc/routing\*O
exists, the contents of the file (if in the proper format) will be used 
to determine the routing of messages written via serviceability routines.
.P
The value of \*Vdce-local-path\*O is usually \*L/opt/dcelocal\*O;
...\" depends on the values of two \*Lmake\*O
...\" variables when DCE is built:
...\" N.B. These are defined in  src/config/dce_com_env
...\" .VL 1i
...\" .LI "\*LDCEROOT\*O"
...\" its default value is: \*L/opt\*O
...\" .LI "\*LDCELOCAL\*O"
...\" its default value is: \*L$DCEROOT/dcelocal\*O
...\" .LE
the default location of the serviceability routing file is usually
\*L/opt/dcelocal/svc/routing\*O.
However, a different location for the file can be specified by setting the
value of the environment variable \*LDCE_SVC_ROUTING_FILE\*O to the complete
desired pathname.
.P
The contents of the routing file consists of formatted strings specifying
the routing desired for the various kinds of messages (based on message
severity).  Each string consists of three fields as follows:
.iS
\*Vsev\*L:\*Vout_form\*L:\*Vdest\*O[\*L;\*Vout_form\*L:\*Vdest\*O .\ .\ .\ ] [\*LGOESTO:\*O{\*Vsev\*O | \*Vcomp\*O}]
.iE
.P
where:
.VL 1i
.LI "\*Vsev\*O"
Specifies the severity level of the message, and must be one of the following:
.ML
.LI
.ne 9
\*LFATAL\*O
...\" Fatal error, about to exit
.LI
\*LERROR\*O
...\" Normal exit
.LI
\*LWARNING\*O
...\" Error detected, program proceeding
.LI
\*LNOTICE\*O
...\" Informational notice
.LI
\*LNOTICE_VERBOSE\*O
...\" Verbose informational notice
.LE
.P
The meanings of these severity levels are explained in detail in 
Section 4.3.3.
.LI "\*Vout_form\*O
(output form) Specifies how the messages of a given severity level should be
processed, and must be one of the following:
.VL 1.25i
.LI "\*LBINFILE\*O"
Write these messages as binary log entries.
.LI "\*LTEXTFILE\*O"
Write these messages as human-readable text.
.LI "\*LFILE\*O"
Equivalent to \*LTEXTFILE\*O.
.LI "\*LDISCARD\*O"
Do not record messages of this severity level.
.LI "\*LSTDOUT\*O"
Write these messages as human-readable text to standard output.
.LI "\*LSTDERR\*O"
Write these messages as human-readable text to standard error.
.LE
.P
Files written as \*LBINFILE\*Os can be read and manipulated with a 
set of log file functions, or with the \*Lsvcdumplog\*O command.  
For further information, see Section 4.3.6.
.P
The \*Vout_form\*O specifier may be followed by a two-number specifier of the form:
.iS
\*L.\*Vgens\*L.\*Vcount\*O
.iE
.P
where:
.VL .75i
.LI "\*Vgens\*O"
Is an integer that specifies the number of files (that is, generations) that
should be kept.
.LI "\*Vcount\*O"
Is an integer specifying how many entries (that is, messages) should be
written to each file.
.LE
.P
.ne 10
The multiple files are named by appending a dot to the simple specified
name, followed by the current generation number.  When the number of entries
in a file reaches the maximum specified by \*Vcount\*O, the file is closed,
the generation number is incremented, and the next file is opened.  When the
maximum generation number files have been created and filled, the generation
number is reset to 1, and a new file with that number is created and written
to (thus overwriting the already-existing file with the same name), and so
on, as long as messages are being written.  Thus the files wrap around to their
beginning, and the total number of log files never exceeds \*Vgens\*O, although
messages continue to be written as long as the program continues writing them.
.LI "\*Vdest\*O
(destination) Specifies where the message should be sent, and is a pathname.
The field can be left blank if the \*Vout_form\*O specified is \*LDISCARD\*O,
\*LSTDOUT\*O, or \*LSTDERR\*O.  The field can also contain a \*L%ld\*O
string in the filename which, when the file is written, will be replaced
by the process ID of the program that wrote the message(s).  Filenames may
\*Vnot\*O contain colons, semicolons, or periods.
.LE
.P
Multiple routings for the same severity level can be specified by simply
adding the additional desired routings as semicolon-separated strings in
the following format:
.iS
\*Vout_form\*L:\*Vdest\*O
.iE
.P
.ne 18
For example, consider the following: 
.oS
FATAL:TEXTFILE:/dev/console
WARNING:DISCARD:--
NOTICE:BINFILE.50.100:/tmp/log%ld;STDERR:-
.oE
.P
These strings specify that
.ML
.LI
Fatal error messages should be sent to the console.
.LI
Warnings should be discarded.
.LI
Notices should be written both to standard error and as binary entries in files
located in the \*L/tmp\*O directory.  No more than 50 
files should be written, and
there should be no more than 100 messages written to each file.  
The files will have names of the form
.iS
\*L/tmp/log\*Vprocess_id\*L.\*Vnn\*O
.iE
.P
where \*Vprocess_id\*O is the process ID of the 
program originating the messages,
and \*Vnn\*O is the generation number of the file.
.LE
.P
The \*LGOESTO\*O specifier allows messages for the severity whose routing
specification it appears in to be routed to the same destination (and in the
same output form) as those for the other, specified, severity level (or
component name).
...\" The effect of this routing specifier is that messages for the 
...\" component (or level) in question ``go to'' the named component 
...\" or message. 
For example, the following specification:
.oS
WARNING:STDERR:;GOESTO:FATAL
FATAL:STDERR:;FILE:/tmp/foo
.oE
.P
means that \*LWARNING\*O messages should show up in three places: twice to
\*Lstderr\*O, and then once to the file \*L/tmp/foo\*O.
.P
Note that a \*LGOESTO\*O specification should be the last element in a
multidestination route specification.
...\" ----------------------------------------------------------------------
.H 4 "Routing by Environment Variable"
...\" ----------------------------------------------------------------------
.P
Serviceability message routing can also be specified by the contents of
certain environment variables.  If environment variables are used, the routes
they specify will override any conflicting routings specified by a routing file.
.P
.ne 12
The routings are specified (on the basis of severity 
level) by putting the desired
routing instructions in the following environment variables:
.ML
.LI
\*LSVC_FATAL\*O
.LI
\*LSVC_ERROR\*O
.LI
\*LSVC_WARNING\*O
.LI
\*LSVC_NOTICE\*O
.LI
\*LSVC_NOTICE_VERBOSE\*O
.LE
.P
Each variable should contain a single string in the following format:
.iS
\*Vout_form\*L:\*Vdest\*O;[\*Vout_form\*L:\*Vdest\*O .\ .\ .\ ] [\*LGOESTO:\*O{\*Vsev\*O | \*Vcomp\*O}]
.iE
.P
where \*Vout_form\*O and \*Vdest\*O have the same meanings and
form as described in Section 4.3.4.1.  Multiple routings
can be specified with semicolon-separated additional strings specifying the
additional routes, as shown.
...\" Likewise with debug routing, where the
...\" variable is called \*LSVC_\*VCMP\*L_DBG\*O.]
...\" ----------------------------------------------------------------------
.H 4 "Calling \*Ldce_svc_routing(\|)\*O to Set Routing"
...\" ----------------------------------------------------------------------
.P
Message routing can be set up by the application itself, by calling the
routine \*Ldce_svc_routing(\|)\*O and passing to it a string formatted
in the same way as a line of text from a routing file.  The routine must
be called separately for each severity level.  When routing is specified
this way, the routings so specified will override any conflicting routings
specified by environment variable or routing file (as described in the
preceding sections).  This is especially useful for setting routes from
command-line arguments.
.P
For example, to set routing in this way for the \*Lhello_svc.c\*O application
described previously, use the following code:
.oS
.ne 16
.ps 11
.vs 13
unsigned_char_t *my_route = "NOTICE:STDOUT:-;TEXTFILE:/tmp/my_log";
unsigned_char_t *error_route = "ERROR:TEXTFILE:/tmp/errors_%ld";

dce_svc_routing(my_route, &status);
if (status != svc_s_ok)
{
    printf("dce_svc_routing failed\en");
    exit(1);
}

dce_svc_routing(error_route, &status);
if (status != svc_s_ok)
{
    printf("dce_svc_routing failed\en");
    exit(1);
}
.ps 12
.vs 14
.oE
...\" .P
...\" Note that \*Ldce_svc_routing(\|)\*O should be called \*Vbefore\*O
...\"  \*Ldce_svc_register(\|)\*O is called.
...\" ...THIS MAY NOT BE NECESSARILY TRUE. CHECK IT.
...\" ----------------------------------------------------------------------
.H 4 "Additional Routing by Attribute"
...\" ----------------------------------------------------------------------
.P
Limited additional routing for messages can be specified by attribute, either
in the message definition itself in the \*Lsams\*O file 
or as part of the argument
list to \*Ldce_svc_printf(\|)\*O. 
Two routing attribute specifiers are available:
.VL 2i
.LI "\*Lsvc_c_route_stderr\*O"
Route the message to standard error.
.LI "\*Lsvc_c_route_nolog\*O"
Discard the message.
.LE
.sp
.P
Note also the \*Lsvc_c_action_brief\*O attribute, which is described in
Section 4.3.7.
...\" ----------------------------------------------------------------------
.H 3 "Table of Message Processing Specifiers"
...\" ----------------------------------------------------------------------
.P
As was seen, message processing can be specified either by text strings
(read from an environment variable or routing file, or passed to a routine) or,
to a limited degree, by attribute in the message definition or when the message
is output.  Table 4-2 shows all the available types of serviceability
message processing; the \*Vname\*O by which it is specified in strings, and the
\*Vattribute\*O (where it exists) by which it is specified in 
message definitions and calls are both given, along with the meaning 
of each.
.ne 3.25i
.TB "Serviceability Message Processing Specifiers"
.TS
center tab(@) allbox;
lb | lb | lb
lb | lb | l.
Name@Attribute@Meaning
_
BINFILE@@Write binary log entry.
TEXTFILE@@Write human-readable text.
FILE@@Equivalent to \*LTEXTFILE\*O.
DISCARD@svc_c_route_nolog@Do not record.
STDOUT@@T{
Write human-readable text to standard output.
T}
STDERR@svc_c_route_stderr@T{
Write human-readable text to standard error.
T}
GOESTO@@T{
Route messages in same way as named level or component.
T}
.TE
...\" ----------------------------------------------------------------------
.H 3 "Logging and Log Reading"
...\" ----------------------------------------------------------------------
.P
The serviceability interface includes a set of functions for reading
.iX "serviceability" "interface logs"
and manipulating log files written as \*LBINFILE\*Os (see Section 
4.3.4.1).
...\" Note that the binary logs don't contain the actual message texts,
...\" but rather the message IDs and the argument values, if any.  So you have
...\" to have access to the message catalog in one way or another in order to
...\" print these logs out fully.  I suspect that the routines will default to
...\" a local message catalog, but I haven't tried this yet...
...\" N.B.: See dce/utils/svc/dumplog.c for a sample program that dumps
...\"       the contents of a log.
.VL 2.25i
.LI "\*Ldce_svc_log_open(\|)\*O"
Opens a log file for reading.
.LI "\*Ldce_svc_log_get(\|)\*O"
Reads the next entry from a log file.  It returns the contents thereof in the
form of a filled-in \*Lprolog\*O structure to which it returns a pointer
(see below for a description of the structure fields).
...\" .LI "\*Ldce_svc_log_get_arg(\|)\*O"
...\" Reads the next message argument.
...\" .LI "\*Ldce_svc_log_rewind_arg(\|)\*O"
...\" Returns message argument processing back to the first argument in the
...\" message.
.LI "\*Ldce_svc_log_rewind(\|)\*O"
Returns log processing back to the first message in the log file.
...\" .LI "\*Ldce_svc_log_tell(\|)\*O"
...\" Gives the file location of the current record.
...\" .LI "\*Ldce_svc_log_seek(\|)\*O"
...\" Repositions processing to the specified record (whose position was learned
...\" by calling \*Ldce_svc_log_tell(\|)\*O).
.LI "\*Ldce_svc_log_close(\|)\*O"
Closes the open log file.
.LE
.P
The contents of the log \*Lprolog\*O structure (defined in \*Ldce/svclog.h\*O)
are as follows:
...\" Note that this structure is apparently not identical to the one passed
...\"  to the filter routine...
.VL 2.25i
...\" from dce/svclog.h:
...\"     typedef struct dce_svc_log_prolog_s_t {
.LI "\*Lint\ \*Vversion\*O"
Version number of the interface that generated the message.
.LI "\*Lutc_t\ \*Vt\*O"
Pointer to an opaque binary timestamp containing the time at
which the message was written.  The opaque timestamp can be
converted to a \*Ltm\*O structure by calling one of the DCE DTS
\*Lutc_\*Vxxx\*L(\|)\*O routines.
.LI "\*Lunsigned32\ \*Vattributes\*O"
Message attributes, ORed together (a bit flag).
.LI "\*Lunsigned32\ \*Vmessage_index\*O"
Index number of message in message table (for example, \*Lhel_s_hello\*O
in the example at the beginning of this chapter).
.LI "\*Lpthread_t\ \*Vthread_id\*O"
ID of application thread that caused the message to be written.
.LI "\*Lchar\ \*V*argtypes\*O"
The format-specifier string for the message.
.LI "\*Lint\ \*Vargtypes_size\*O"
The number of format specifiers for the message.
.LI "\*Lchar\ \*V*fac_name\*O"
The component or subcomponent (``facility'') name string.
...\" .LI "\*Lint\ \*Vfac_name_size\*O"
.LI "\*Lchar\ \*V*message_text\*O"
Message text string.
...\" .LI "\*Lint\ \*Vmessage_text_size\*O"
...\" Length of message text string.
.LI "\*Lchar\ \*V*progname\*O"
Program name string, set by the application's call to
\*Ldce_\%svc_\%set_\%progname(\|)\*O.
.LI "\*Lchar\ \*V*file\*O"
Filename string identifying file from which entry was read.
.LI "\*Lint\ \*Vline\*O"
Line number in \*Vfile\*O from where the message was printed.
.LI "\*Lint\ \*Vfile_size\*O"
Length of filename string.
...\" .LI "\*Lint\ \*Vprogname_size\*O"
...\" Length of program name string.
.LE
...\"     } *dce_svc_log_prolog_t;
...\" EXAMPLES HAVE TO BE INCLUDED...
...\" ----------------------------------------------------------------------
.H 3 "Message Action Attributes"
.iX "message" "action attributes"
...\" ----------------------------------------------------------------------
...\" note that these are purely attribute, and not level-associated per se
.P
Routing and severity attributes affect what happens to the messages they are
applied to, and nothing else.  However, there is an additional set of attributes
that, when applied to a message, mainly affect \*Vwhat happens to the program\*O
.iX "action after a message"
after the message is sent:
.VL 2.25i
.LI "\*Lsvc_c_action_abort\*O"
Causes the program to abort (with core dump) as soon as the message is output.
.LI "\*Lsvc_c_action_exit_bad\*O"
Causes the program to exit (with failure status) as soon as the message is
output.
.LI "\*Lsvc_c_action_exit_ok\*O"
Causes the program to exit (with successful status) as soon as the message is
output.
.LI "\*Lsvc_c_action_brief\*O"
Suppresses the standard \*Vprolog\*O
of the message.  The prolog of a serviceability
includes all the nonmessage information that is output before the message text
itself.  The prologs of all messages can be suppressed by setting the 
\*LSVC_BRIEF\*O environment variable; see the next section.
...\" [?Does this mean the prolog
...\" that the filter routine would receive (so that the filter routine in effect
...\" isn't called), or does ot mean that the logfile output is somehow abbreviated,
...\" or what?]
...\" svc_c_action_brief ONLY means that the prolog isn't printed.  All the
...\" other stuff still happens.  In the prolog the "line" field is the line
...\" number in the source file where the call was made.  It and file are like
...\" the C macros __LINE__ and __FILE__.  Note that in some systems they may
...\" be 0 and "", respectively.  (controlled by a DCE build param, DCE_SVC_WANT__FILE__)
.LE
...\" ----------------------------------------------------------------------
.H 3 "Suppressing the Serviceability Message Prolog"
.iX "message" "prolog suppression"
...\" ----------------------------------------------------------------------
.P
You can suppress the prolog (nonmessage text) part of all serviceability
messages generated by an application by setting the value of the \*LSVC_BRIEF\*O
environment variable to 1.
.P
The prolog of a serviceability consists of all the nonmessage information that
is output before the message text itself.  For example, examine
the following message:
.oS
.ps 8
.vs 10
1994-04-05-20:13:34.500+00:00I----- PID#9467 NOTICE hel main hello_svc.c \*Vline_nr\*C 0xa444e208
Hello World
.ps 12
.vs 14
.oE
.P
.ne 3
In this example, 
the first line is the message prolog, and the second line is the message text.
If the message were generated with the \*LSVC_BRIEF\*O environment variable
set to 1, the message would appear as follows:
.oS
.ps 8
.vs 10
Hello World
.ps 12
.vs 14
.oE
.P
Prologs of separate messages can be suppressed selectively through the use of
the \*Lsvc_c_action_brief\*O attribute; see the previous section.
...\" ----------------------------------------------------------------------
.H 3 "Serviceability Use of the __FILE__ Macro"
.iX "serviceability" "and the __FILE__ macro"
...\" ----------------------------------------------------------------------
.P
Whenever a serviceability message is generated, information identifying the
source file and line at which the invoked routine was called is included in
the message information.  This information appears in the text-form nonerror
messages, and it is also written into the binary form serviceability
logs (when binary logs are specified).  The information also appears
in the text form of messages announcing error situations.  For example:
.oS
.ps 8
.vs 10
1994-07-20-11:11:09.906-04:00I----- sample_server FATAL smp server \\
  sample_server.c 2851 0xa44b0c18
server_renew_identity(\|): login context has not been certified (dce / sec)
.ps 12
.vs 14
.oE
.P
(The preprocessor variable \*LDCE_SVC_WANT__FILE__\*O (in \*Ldce/dce_svc.h\*O)
will be defined or undefined depending on whether or not the serviceability
component has been set up on your system to include the filename and line
number information in serviceability messages.)
.P
The serviceability routines receive the source file information from
\*LDCE_SVC__FILE__\*O, which, by default, is defined to be the C preprocessor
macro \*L__FILE__\*O.  However, if you desire to avoid these macro expansions
in your application code, you can redefine the symbol to be some kind
of variable.  For example:
.oS
#define DCE_SVC__FILE__ myfile
#include <dce/dce.h>
static char myfile[] = __FILE__;
.oE
...\" ----------------------------------------------------------------------
.H 3 "Forcing Use of the In-Memory Message Table"
...\" ----------------------------------------------------------------------
.P
As described elsewhere in this chapter, the \*Ldce_msg_define_msg_table(\|)\*O
routine can be called by an application to initialize an in-memory copy of
its message table, thus freeing the application from depending on its message
catalog's being properly installed for its serviceability messages to be
properly generated.
.P
However, the serviceability routines will still, by default, attempt first to
retrieve a specified message from the message catalog, even if an in-memory
table has been initialized; only if the message catalog cannot be found will
the in-memory table be used.
.P
You can change the default behavior of the serviceability routines by setting
the \*LSVC_NOXPGCAT\*O environment variable to 1 (or any nonzero value).  This
will force the routines to always go to the in-memory table for the specified
message; they will never look for the message catalog.
...\" ----------------------------------------------------------------------
.H 3 "Dynamically Filtering Messages Before Output"
.iX "message" "filtering"
...\" ----------------------------------------------------------------------
.P
The serviceability interface provides for a ``hook'' into the message-output
mechanism that allows applications to decide at the time of messaging whether
the given message should be output or not.  The application defines its own
routine to perform whatever checking is desired, and installs the routine
with a call to \*Ldce_svc_define_filter(\|)\*O.
.P
In addition, an application that installs such a message-filtering routine can
also define and install a routine that can be called remotely to alter the
operation of the filter routine.  The remote-control routine is installed by
the same call to \*Ldce_svc_define_filter(\|)\*O.
.P
The two routines must have the following signatures.  The yes/no routine you
define and install is as follows:
.iS
\*Lboolean \*Vyour_filter_routine\*L(
                                 \*Ldce_svc_prolog_t \*Vprolog\*L,
                                 \*Lva_list \*Vargs\*L)\*O
.iE
.P
The filter remote-control call is as follows:
.iS
\*Lvoid \*Vyour_filter_remote_control\*L(
                                     \*Lidl_long_int \*Varg_size\*L;
                                     \*Lidl_byte \*V*arg\*L;
                                     \*Lerror_status_t \*V*status\*L)\*O
.iE
.P
.ne 8
Once installed, the filter routine will be automatically invoked every time
a serviceability routine is called to output a message.  The filter receives
a \*Vprolog\*O argument that contains all the pertinent information about
the message.  If the filter returns TRUE, the message is output per
the original serviceability call.  If the filter returns FALSE, the
message is not output.  The information in the \*Vprolog\*O allows such
decisions to be made on the basis of severity level, subcomponent, message
index, and so on.  Its fields are as follows:
...\"     
.VL 2.25i
...\" typedef struct dce_svc_prolog_s_t {
.LI "\*Ldce_svc_handle_t\ \*Vhandle\*O"
Serviceability handle of the application writing the message.
.LI "\*Lint\ \*Vversion\*O"
Version number of the interface that generated the message.
.LI "\*Lutc_t\ \*Vt\*O"
Pointer to an opaque binary timestamp containing the time at
which the message was written.  The opaque timestamp can be
converted to a \*Ltm\*O structure by calling one of the DCE DTS
\*Lutc_...(\|)\*O routines.
.LI "\*Lconst\ char\ \*V*argtypes\*O"
The format-specifier string for the message.
.LI "\*Lunsigned32\ \*Vtable_index\*O"
.25The subcomponent table index (for example, \*Lhel_s_main\*O as defined in the
\*Lsams\*O file in Section 4.1.2.1.
.LI "\*Lunsigned32\ \*Vattributes\*O"
Message attributes, ORed together.
.LI "\*Lunsigned32\ \*Vmessage_index\*O"
Index number of the message in the message table (for example, \*Lhel_s_hello\*O
in the example at the beginning of this chapter).
.LI "\*Lchar\ \*V*format\*O"
Format argument values for the message.
.LI "\*Lconst\ char\ \*V*file\*O"
Filename string identifying the file to which the message is to be output.
.LI "\*Lchar\ \*Vprogname[dce_svc_c_progname_buffsize]\*O"
.nL
Program name string, set by 
the application's call to \*Ldce_svc_set_progname(\|)\*O.
.LI "\*Lint\ \*Vline\*O"
Line number in \*Vfile\*O from where the message was printed.
.LI "\*Lpthread_t\ \*Vthread_id\*O"
ID of the application thread that is causing the message to be output.
...\" } *dce_svc_prolog_t;
.LE
.P
.ne 8
The filter remote control routine is part of the remote serviceability 
interface, which is described in detail in Section 4.3.14.
Its operation is simple.  If filter remote control is desired, the filter
routine should be coded so that its operation can be switched to the various
desired alternatives by the values of static variables to which it has access.
These variables are also accessible to the remote control routine, and can be
changed by it.  The filter routine receives an argument string (which it uses to
set the variables) whose contents are entirely application defined.
...\" the remote control routine is called when dce_svc_filter_control() is
...\"  called; this calls into xxx_svc_filter_ctl() (the app-defined remote
...\"  entry); then this is supposed (after making an authorization check)
...\"  to call dce_svc_filter(), which calls your remote filter control.  So
...\"  far I have not been able to get the last part of this to work.
.P
The following code fragments show a skeleton filter that can be added to the
\*Lhello_svc.c\*O example at the beginning of this chapter:
.oS
#include <stdarg.h>
#include <dce/svcfilter.h>

             \*V<.\ .\ .>\*C

/*****
* Filter routine-- once installed, this routine will be called
*                  automatically every time a serviceability 
*                  routine (in our case, dce_svc_printf(\|)) is 
*                  called to write a message.
*****/
boolean hel_filter(dce_svc_prolog_t   prolog,
                   va_list            args)
{

    /* Code could be inserted here to test the values of static
       variables that would control the operation of the filter,
       and which could be altered by calling the filter control
       routine below. */

    printf("The progname is %s\en", prolog->progname);

    if (prolog->attributes | svc_c_sev_notice)
        printf("This is a Notice-type message\en");

.ne 9
    switch (prolog->table_index)
    {
        case hel_s_main:
            printf("Main subcomponent\en");
            break;
        default:
            printf("Error\en");
            break;
    }


    /* The routine returns 1, thus permitting the output 
       operation to go ahead; if 0 were returned here, the 
       operation would be suppressed ... */

    return 1;

}

/*****
* Filter Control routine-- this routine is normally called 
*                          through the remote interface.
*****/
void hel_filter_control(idl_long_int arg_size,
                        idl_byte *arg,
                        error_status_t *status)
{

    /* Code would be inserted here to interpret the arg passed 
       and, on the basis of that, change the value(s) of one 
       or more static variables that control the operation of 
       hel_filter(\|)                                         */

}

.ne 13
/*****
* install_filters-- calls dce_svc_define_filter(\|) to install 
*                   the above 2 routines.  Note that this must 
*                   be done after dce_svc_register(\|) is 
*		    called, not before.
*****/
void install_filters(\|)
{
    unsigned32  status;

    dce_svc_define_filter(hel_svc_handle, hel_filter, \\
      hel_filter_control, &status);
}
.oE
...\" ----------------------------------------------------------------------
.H 3 "Using Serviceability for Debug Messages"
...\" ----------------------------------------------------------------------
.P
Apart from the \*Ldce_svc_printf(\|)\*O routine for writing production
serviceability messages, the interface provides several macros that can be
used for debug messaging in a server.  The advantages in using these macros
.iX "debug messaging"
in debugging are the following:
.ML
.LI
All of the debug messaging code can easily be compiled in or out of the
executable by changing the value of a compilation switch.
.LI
Nine levels of debug messaging are provided for; the active level of debug
messaging can be controlled through the remote serviceability interface
or by a value passed to the server at startup.
.LI
One of the macros allows message text to be specified in the call itself,
rather than extracting it by message ID from the message table.
.LE
.P
The debug serviceability messaging routines are the following:
.ML
.LI
\*LDCE_SVC_LOG(\|)\*O
.P
Outputs a message specified by the message ID. The main differences between
using this routine and using \*Ldce_svc_printf(\|)\*O to write a message
are (1) that \*LDCE_SVC_LOG(\|)\*O generates records \*Vonly\*O in binary format,
and (2) the macro can be compiled out of the executable by turning off
debugging.
.P
.ne 11
Suppose the following message had been defined in the \*Lhel.sams\*O file
for the example application at the beginning of this chapter:
.oS
start
code                hel_s_debug_message_1
subcomponent       hel_s_main
attributes	        "svc_c_debug3 | svc_c_route_stderr"
text                "This is a level 1 test debug message"
explanation         "Debug level 3 test"
action              "None required."
end
.oE
.P
The following call in \*Lhello_svc.c\*O would have written this message as
a binary record to the specified route, provided that debug level 3 had been
activated:
.oS
DCE_SVC_LOG((HEL_S_DEBUG_MESSAGE_1_MSG));
.oE
.P
Note the use of the double parentheses.  This is made necessary by the fact
that it is a macro that takes a variable number of arguments.  Note alse the
use of the convenience macro form of the message.  A full form of the call,
with all arguments explicitly specified, would have been as follows:
.oS
DCE_SVC_LOG((DCE_SVC(hel_svc_handle, ""), \\
     hel_s_main, svc_c_debug3, hel_s_debug_message_1));
/*       |           |                 |                */
/*  table_index      |                 |                */
/*               debug level           |                */
/*                                message ID            */
.oE
.P
Debug messages, like normal serviceability messages, can also contain format
specifiers and argument lists.
.LI
\*LDCE_SVC_DEBUG(\|)\*O
.P
Outputs a message whose text is specified in the call.  For example, the
following call could have appeared in \*Lhello_svc.c\*O:
.oS
.ps 11
.vs 13
.ne 10
DCE_SVC_DEBUG((hel_svc_handle, \\
/*                  |                                         */
/*                handle                                      */
/*                                                            */
     hel_s_main, svc_c_debug2, "A Debug Level %d message", 2));
/*       |           |                  |                  |  */
/* table_index       |                  |                  |  */
/*              debug level             |                  |  */
/*                                 message text            |  */
/*                                                   argument */
.ps 12
.vs 14
.oE
.P
Note here too the use of the double parentheses.
.P
Note also that \*LDCE_SVC_DEBUG\*O cannot be used with the convenience
macro forms of serviceability messages.
.LI
\*LDCE_SVC_DEBUG_ATLEAST(\|)\*O
.P
Tests the active debug level for a subcomponent.  Returns TRUE if
the debug level (set by calling \*Ldce_svc_debug_set_levels(\|)\*O;
see Section 4.3.12.1) is not less than the specified
level; otherwise returns FALSE. For example, the following call
would return TRUE if the debug level for the \*Lhel_s_main\*O
subcomponent of the \*Lhello_svc\*O application had been set to
\*Lsvc_c_debug2\*O or any higher value:
.oS
.ps 11
DCE_SVC_DEBUG_ATLEAST(hel_svc_handle, hel_s_main, svc_c_debug2);
.ps 12
.oE
.P
This macro can be used to test the active debug level and avoid
calling a debug output routine if the level of its message is disabled
at the time of the call (disabling the level does not stop any routines
from being executed; it only suppresses the output messages at that level).
See Section 4.3.13 for more information.
.LI
\*LDCE_SVC_DEBUG_IS(\|)\*O
.P
Tests the active debug level for a subcomponent.  Returns TRUE if the
debug level is the same as that specified in the call; otherwise
returns FALSE. For example, the following call
would return TRUE only if the debug level for \*Lhel_s_main\*O
had been set to \*Lsvc_c_debug2\*O:
.oS
DCE_SVC_DEBUG_IS(hel_svc_handle, hel_s_main, svc_c_debug2);
.oE
.LI
.ne 7
\*Ldce_assert(\|)\*O
.P
Evaluates an \*Lint\*O expression passed to it and, if the expression
evaluates to 0 (that is, if the expression is false), automatically calls
\*Ldce_svc_printf(\|)\*O with parameters that will cause a message with
a severity level of \*Lsvc_c_sev_fatal\*O (that is, fatal) and an action
attribute of \*Lsvc_c_action_abort\*O to be printed that will identify
the following:
.ML
.LI
The expression
.LI
The source file in which the assertion failed
.LI
The line at which the assertion failed
.LE
.P
For example, the following call
will cause the failed expression (namely, the string) to be printed
and the program to be aborted.  
.oS
.ps 11
dce_assert(hel_svc_handle, ("Test diagnostic message" == NULL))
.ps 12
.oE
.P
A NULL can be substituted for the serviceability handle as the first argument.
.LE
...\" from RFC, p. 6:
.P
It is very important that debug messages not be used for errors that can
occur during ordinary operation.  This is because the debug messaging code
can be omitted when compiling for production.
...\" ----------------------------------------------------------------------
.H 4 "Setting Debug Levels"
...\" ----------------------------------------------------------------------
.P
Nine serviceability debug message levels are available.  The precise meaning
of each level for an application is left to the developer; but the general
intention is that ascending to a higher level (for example, from \*Lsvc_c_debug2\*O
to \*Lsvc_c_debug3\*O) should increase the level of information detail.
.P
Setting debug messaging at a certain level means that all levels up to and
including the specified level are enabled.  For example, if the debug level
is set at \*Lsvc_c_debug4\*O, then the \*Lsvc_c_debug1\*O, \*Lsvc_c_debug2\*O,
and \*Lsvc_c_debug3\*O levels are enabled as well.
.P
A message can have a debug level attached to it in either of two ways:
.ML
.LI
The debug level can be specified as one of the \*Lattributes\*O in the message's
definition in the \*Lsams\*O file.
.LI
.ne 2
If \*LDCE_SVC_DEBUG(\|)\*O or \*LDCE_SVC_LOG(\|)\*O is used to output the
message, the debug level is specified in the call.
.LE
.P
The debug level can be set by calling \*Ldce_svc_debug_set_levels(\|)\*O and
passing to it a specially formatted string (the debug level is also set when
debug routing is specified; see the next section for further information).
Levels can be separately specified for subcomponents.  For example, suppose
two subcomponents (rather than one) had been defined in the \*Lsams\*O file for the
\*Lhello_svc\*O application at the beginning of this chapter, as follows:
.oS
# Part II
serviceability table hel_svc_table handle hel_svc_handle
start
    subcomponent   hel_s_main      "main"  hel_i_svc_main
    subcomponent   hel_s_utils     "utils" hel_i_svc_utils
end
.oE
.P
The following string
would, when passed to \*Ldce_svc_debug_set_levels(\|)\*O, set the debug level
for the \*Lmain\*O subcomponent to be \*Lsvc_c_debug1\*O, and the debug level
for the \*Lutils\*O subcomponent to be \*Lsvc_c_debug4\*O:
.oS
unsigned_char_t *levels = "hel:main.1,utils.4";
.oE
.P
The general format for the debug level specifier string is as follows:
.iS
\*Vcomponent\*L:\*Vsub_comp\*L.\*Vlevel\*L,\*Vsub_comp\*L.\*Vlevel\*L,\*V.\ .\ .\*O
.iE
.P
where:
.VL 1.5i
.LI "\*Vcomponent\*O"
Is the three-character component code for the program.
.LI "\*Vsub_comp\*L.\*Vlevel\*O"
Is a subcomponent name, followed (after a dot) by a debug level
(expressed as a single digit from 1 to 9).  Note that multiple
subcomponent/level pairs can be specified in the string.
.LE
.P
If there are multiple subcomponents, and it is desired to set the debug level
to be the same for all of them, then the following form
will do this (where the \*L*\*O (asterisk) specifies all subcomponents).
.iS
\*Vcomponent\*L:*.\*Vlevel\*O
.iE
.P
The string can be passed to \*Ldce_svc_debug_set_levels(\|)\*O as follows:
.iS
dce_svc_debug_set_levels(levels, &status);
.iE
.P
where \*Llevels\*O is a string declared similarly to the example shown
earlier in this section.
.P
The nine serviceability debug message level specifiers are as follows:
.ML
.LI
\*Lsvc_c_debug1\*O
.LI
\*Lsvc_c_debug2\*O
.LI
\*Lsvc_c_debug3\*O
.LI
\*Lsvc_c_debug4\*O
.LI
\*Lsvc_c_debug5\*O
.LI
\*Lsvc_c_debug6\*O
.LI
\*Lsvc_c_debug7\*O
.LI
\*Lsvc_c_debug8\*O
.LI
\*Lsvc_c_debug9\*O
.LE
.in -1i
...\" ----------------------------------------------------------------------
.H 4 "Routing Debug Messages"
...\" ----------------------------------------------------------------------
...\" see also ``How to Route Messages'' above
.P
Routing for serviceability debug messages can be specified in any of four
ways:
...\" Again, what is the precedence among these?
...\" 	Explicitly set with dce_svc_routing call, if not then
...\" 	value of SVC_<level> environment variable, if not then
...\" 	file named by DCE_SVC_ROUTING_FILE environment variable.
...\" 	The default value of DCE_SVC_ROUTING_FILE is /opt/dcelocal/svc/routing
...\" 	If that file does not exist, then there are compiled-in defaults:
...\" 		send to stderr.
.ML
.LI
By calling the \*Ldce_svc_debug_routing(\|)\*O routine
.LI
By the contents of the \*LSVC_\*VCMP\*L_DBG\*O environment variable
(where \*VCMP\*O is the three-character serviceability name of the
component, in uppercase)
.LI
By the contents of the routing file \*Vdce-local-path\*L/svc/routing\*O
.iE
.LI
By one of the message's \*Lattributes\*O (as coded in the \*Lsams\*O
file)
.LE
.P
.ne 4
In all but the last method, the routing is specified by the contents of
a specially formatted string that is either included in the value of the
environment variable, is part of the contents of the routing file, or is
passed to the \*Ldce_svc_debug_routing(\|)\*O routine.
.P
The general format for the debug routing specifier string is
.iS
.ps 10
\*Vcomponent\*L:\*Vsub_comp\*L.\*Vlevel\*L,\*V.\ .\ .\*L:\*Vout_form\*L:\*Vdest\*O [\*Vout_form\*L:\*Vdest\*O .\ .\ .\ ] [\*LGOESTO:\*O{\*Vsev\*O | \*Vcomp\*O}]
.ps 12
.iE
.P
where:
.VL 1.5i
.LI "\*Vcomponent\*O"
Specifies the component name.
.LI "\*Vsub_comp\*L.\*Vlevel\*O"
Specifies a subcomponent name, followed (after a dot) by a debug level
(expressed as a single digit from 1 to 9).  Note that multiple
subcomponent/level pairs can be specified in the string.
.LE
.P
The meanings of the remaining elements of the string are the same as those
for the identically named elements in Section 4.3.4.
...\" .LI "\*Vout_form\*O
...\" specifies how the messages should be processed, and must be one of the
...\" following:
...\" .BL
...\" .LI
...\" \*LBINFILE\*O
...\" .P
...\" Write these messages as binary log entries
...\" .LI
...\" \*LTEXTFILE\*O
...\" .P
...\" Write these messages as human-readable text
...\" .LI
...\" \*LFILE\*O
...\" .P
...\" Equivalent to TEXTFILE
...\" .LI
...\" \*LDISCARD\*O
...\" .P
...\" Do not record messages of this severity level
...\" .LI
...\" \*LSTDOUT\*O
...\" .P
...\" Write these messages as human-readable text to standard output
...\" .LI
...\" \*LSTDERR\*O
...\" .P
...\" Write these messages as human-readable text to standard error
...\" .LE
...\" .P
...\" Files written as \*LBINFILE\*Os can be read and manipulated with a set of
...\" logfile functions.  For further information, see ``Logging and Log Reading'',
...\" above.
...\" .P
...\" The \*Vout_form\*O specifier may be followed by a two-number specifier of the form:
...\" .DS
...\"     \*Vgens\*L.\*Vcount\*O
...\" .DE
...\" .P
...\" See ``How to Route Messages'' above for further information.
...\" .LI "\*Vdest\*O
...\" specifies where the message should be sent, and is a pathname.  The field
...\" can be left blank if the \*Vout_form\*O specified is \*LDISCARD\*O,
...\" \*LSTDOUT\*O, or \*LSTDERR\*O.  The field can also contain a \*L%ld\*O
...\" string in the filename which, when the file is written, will be replaced
...\" by the process ID of the program that wrote the message(s).  For further
...\" information see ``How to Route Messages'' above.
...\" .LE
.P
Multiple routings for the same group of subcomponents can be specified by
adding semicolon-separated strings of the following format:
.iS
\*Vout_form\*L:\*Vdest\*O
.iE
to the specification, in a form analogous to that followed for
specifying production (nondebug) message routes, shown previously.
.P
The following string would, when passed to \*Ldce_svc_debug_routing(\|)\*O, 
set the debug level and routing for all \*Lhel\*O subcomponents:  
.oS
unsigned_char_t *debug_routes = \\
  "hel:*.4:TEXTFILE:/tmp/hel_debug_log_%ld;STDERR:-";
.oE
.P
A debug level of \*Lsvc_c_debug4\*O
is specified, and all debug messages of that level or lower will be written
both to standard error and in text form to the following file:
.iS
\*L/tmp/hel_debug_log_\*Vprocess_ID\*O
.iE
.P
where \*Vprocess_ID\*O is the process ID of the program writing the messages.
.P
.ne 4
The specification string could be passed to \*Ldce_svc_debug_routing(\|)\*O as
follows:
.oS
dce_svc_debug_routing(debug_routes, &status);
.oE
.P
To specify the same routing by environment variable, the string following 
value should be assigned to \*LSVC_\*VCMP\*L_DBG\*O:
.oS
hel:*.4:TEXTFILE:/tmp/hel_debug_log_%ld;STDERR:-
.oE
.P
The same string information could also be inserted into the \*LSVC_\*VCMP\*O
environment variable or into the contents of the routing file.
.P
Debug routing by attribute (as specified in the \*Lsams\*O file) is done in the
same way as routing for normal messages.  See Section 4.3.4.4.
...\" ----------------------------------------------------------------------
.H 3 "Performance Costs of Serviceability Debugging"
...\" ----------------------------------------------------------------------
.P
If serviceability debugging routines are used in an application, one of
three different things can happen to any given debugging routine at
runtime:
.ML
.LI
The routine is called, and its output is generated (because the debug level
associated with the message has been enabled).
.LI
The routine is called, but its output is not generated (because the debug
level associated with the message has been disabled).
.LI
The routine call is not present in the application code because serviceability
debugging has been compiled out (\*LDCE_DEBUG\*O was not defined when the
application was compiled).
.LE
.P
Note that, even if a certain debug level has been disabled, any routine or
macro call to output a message with that level will still be executed unless
other steps are taken to prevent this.  The performance cost associated with
such ``smothered'' calls will usually be insignificant, but situations can
occur in which this will not be so.
.P
.ne 6
For example, developers should understand the implications of supplying
function calls as arguments to serviceability debug output routines (such
as \*LDCE_SVC_DEBUG\*O).  If the debug code is compiled in 
(that is, if \*LDCE_DEBUG\*O is defined), then the parameterized 
function calls will always be executed because the output routine 
itself will still be called\(emeven though it will produce no output.
.P
In situations like this, the desirable course of action is simply to not
call the output routine at all if the currently set debug level has turned
it into a no-op.  This can be done by using the \*LDCE_SVC_DEBUG_ATLEAST\*O
macro to check the current level, as shown in the following example:
.oS
.ps 10
.vs 12
if (DCE_SVC_DEBUG_ATLEAST(hel_svc_handle, hel_s_main, svc_c_debug3))
{
    DCE_SVC_DEBUG((
        hel_svc_handle,
        hel_s_main,
        svc_c_debug3,
        " \*Va_function_call\*C(\|) return value is: %s",
        \*Va_function_call\*C(\*Vparm\*C, status)));
}
.ps 12
.vs 14
.oE
.P
The normal performance cost of a serviceability logging operation normally
amounts to one mutex lock and (usually) one file lock access per operation.
...\" ----------------------------------------------------------------------
.H 3 "Using the Remote Serviceability Interface"
.iX "remote" "serviceability interface"
.iX "serviceability" "interface" "remote"
...\" ----------------------------------------------------------------------
...\" Remote serviceability interface
...\"   Additional subsections will be required here...
.P
Serviceability is primarily a mechanism intended to be used by servers.
Like other server functionality, it should be remotely controllable by
properly authorized entities.  This allows such things as message routing
and debug levels to be adjusted without having to restart the server.
.P
The standard remote serviceability interface is defined in the file
\*L/usr/include/dce/service.idl\*O.
...\" ...actually it's not there yet (only service.h is), but it seems
...\"  that it will have to be.  Ask Rich about this.
...\" Exporting it makes it available to control by dcecp, correct?
...\" Anything else?
.P
.ne 8
An application server using serviceability is responsible for providing
routines that implement the operations defined in \*Lservice.idl\*O.  However,
``implementing'' the operations themselves is a simple matter of calling library
routines that actually perform them.  The job of 
the application implementation is mainly to check the authorization 
of the remote caller and then either reject the request (if authorization 
is found to be insufficient) or call the appropriate library routine to 
perform the operation.
.P
Table 4-3 lists such remote operations.
.TB "Remote Operations by Application Servers"
.na
.ps 10
.vs 12
.TS H
center tab(@) allbox;
lb | lb | lb
lb | lb | l.
Server ``Implementation''@Library Routine@Purpose
.TH
_
\*Vcom\*L_svc_set_route(\|)@\*Ldce_svc_routing(\|)\*O@T{
Remotely sets serviceability message routing.
T}
\*Vcom\*L_svc_set_dbg_route(\|)@\*Ldce_svc_debug_routing(\|)\*O@T{
Remotely sets serviceability debug message routing.
T}
\*Vcom\*L_svc_set_dbg_levels(\|)@\*Ldce_svc_debug_set_levels(\|)\*O@T{
Remotely sets serviceability debug message levels.
T}
\*Vcom\*L_svc_inq_components(\|)@\*Ldce_svc_components(\|)\*O@T{
Returns a listing of all components that have been registered
with the \*Ldce_svc_register(\|)\*O routine.
T}
\*Vcom\*L_svc_inq_table(\|)@\*Ldce_svc_table(\|)\*O@T{
Returns the message table registered with a given component.
T}
\*Vcom\*L_svc_inq_routings(\|)@\*Ldce_svc_routings(\|)\*O@T{
Returns a list of routings in effect for a component.
T}
\*Vcom\*L_svc_filter_control(\|)@\*Ldce_svc_filter(\|)\*O@T{
Remotely controls the behavior of the serviceability message
filtering routine (if one exists).
T}
\*Vcom\*L_svc_inq_stats(\|)@\*Ldce_svc_inq_stats(\|)\*O@T{
Returns operating statistics.
T}
.TE
.ps 12
.vs 14
.ad
.P
...\" ----------------------------------------------------------------------
.H 4 "Basic Steps in Setting Up the Remote Interface"
...\" ----------------------------------------------------------------------
.P
To make the interface available, the developer must do the following:
.AL
.LI
Coding steps
.ML
.LI
Define the server implementation routines for the remote operations.
.LI
Initialize the serviceability interface manager entry point vector
(manager EPV) with the implementation routines.
.LE
.LI
Build steps
.ML
.LI
Process the \*Lservice.idl\*O file to produce the following:
.ML
...\" .LI
...\" \*Lservice.h\*O
...\" .P
...\" This header must be \*L#include\*Od in any client code that intends to
...\" access the remote interface. [ALREADY INSTALLED IN /usr/include/dce]
.LI
Client stub
.P
This will be linked into the client object.  The client itself can contain
calls to the remote routines, expressed by their interface names.
.LI
Server stub
.P
This will be linked into the server object (just as its ``own'' stub(s) are)
to produce the server executable.  Note that the server stub is generated with
the \*L-no_mepv\*O IDL option, which allows the implementation routines to be
named anything that suits the developer.  This is why the EPV
must be explicitly initialized with the implementation routines' addresses.
.LE
.LE
.LI
Runtime steps
.ML
.LI
At server startup:
.P
The binding handles that the server receives from the RPC runtime, and
which it then registers both with the Name Server Interface (NSI)
and the endpoint mapper under its
``own'' interface, must also be registered to the endpoint mapper with the
serviceability interface.  Note that servers \*Vdo not\*O explicitly register
the serviceability interface with the NSI.  Instead, they use their existing
namespace entries without change.  They \*Vdo\*O register the serviceability
interface with their endpoint mapper.
...\" ...this makes the NULL UUID trick used by clients work (Rich).
.LI
.ne 9
For a client application:
.P
To call one of a server's remote serviceability routines, the client must
import a binding handle using a NULL UUID; this operation will yield a
``plain'' handle.  The client can then pass this handle to the desired
remote serviceability routine and make the call.  The server's host endpoint
mapper will recognize the incoming serviceability UUID in the RPC, and will
send the RPC on to one of the registered endpoints.
...\" ...actually that serviceability UUID comes from the stub, as I remember;
...\"  the whole point of this operation being that the UUID is not in the
...\"  handle itself.  But I don't want to go into that stuff.
.LE
.LE
.P
The following code fragments illustrate how to define, export, and access
the serviceability remote interface.
...\" ----------------------------------------------------------------------
.H 4 "Implementing the Remote Routines"
...\" ----------------------------------------------------------------------
.P
The following code fragments show in skeletal form how an application's
remote serviceability routines should be implemented.  The pseudo-code
references to ``access tests'' are calls to the application's ACL manager
to assess the caller's authorization.  For information on implementing an
ACL manager, see the security chapters of the \*(Di and the \*(Ac.
.oS
.ps 11
.vs 13
#include <dce/dce.h>
#include <dce/dce_msg.h> 
#include <dce/dcesvcmsg.h>
#include <dce/svcremote.h>

struct serviceability_v1_0_epv_t       dce_svc_epv;

/*****
*
* hel_svc_set_route -- remote call-in to set routing.
*
*****/
static void
hel_svc_set_route(
    handle_t                h,
    idl_byte                where[],
    error_status_t          *st
)
.ne 8
{

    if (!\*Vyour_test_write_access\*C(h))
        *st = \*Vno_authorization_error\*C;
    else
        dce_svc_routing(where, st);

}

/*****
*
* hel_svc_set_dbg_route -- remote call-in to set debug routing.
*
*****/
static void
hel_svc_set_dbg_route(
    handle_t                h,
    idl_byte                where[],
    error_status_t          *st
)
{

    if (!\*Vyour_test_write_access\*C(h))
        *st = \*Vno_authorization_error\*C;
    else
        dce_svc_debug_routing(where, st);

}

             \*V<.\ .\ .>\*C

/*****
*
* hel_svc_inq_stats -- remote request for operating statistics.
*
*****/
static void
hel_svc_inq_stats(
    handle_t                h,
    dce_svc_stats_t         *stats,
    error_status_t          *st
)
.ne 9
{

    if (!\*Vyour_test_access\*C(h))
        *st = \*Vno_authorization_error\*C;
    else
        /* operation is currently not implemented in library ...  */
        *st = svc_s_no_stats;

}

/*                                                                */
/* The table of slots is created by IDL from the service.idl      */
/* file, src/dce/utils/svc/service.idl, the output of which       */
/* is service.h.  It's then the job of the application that       */
/* wishes to offer the remote operations to fill in the table     */
/* with the implementations' entry points.  That's what's being   */
/* done below.  Typically the application simply interposes an    */
/* appropriate ACL check between the entry into an implementation */
/* and the subsequent call to the "real" operation as implemented */
/* in the serviceability library.                                 */
/*                                                                */

serviceability_v1_0_epv_t dce_svc_epv = {
    hel_svc_set_route,
    hel_svc_set_dbg_route,
    hel_svc_set_dbg_levels,
    hel_svc_inq_components,
    hel_svc_inq_table,
    hel_svc_inq_routings,
    hel_svc_filter_ctl,
    hel_svc_inq_stats
};
.ps 12
.vs 14
.oE
...\" ----------------------------------------------------------------------
...\" ----------------------------------------------------------------------
.H 4 "Registering and Exporting the Remote Interface"
...\" ----------------------------------------------------------------------
.P
The following code fragments show how the remote serviceability interface could
be exported and registered by a \*Lhello_svc\*O server.  Note that only the steps
that are closely or directly related to exporting and registering the server's
and the serviceability remote interface are shown.  For a full example of how to
get a DCE server application up and running, see the \*(Di.
.P
The steps shown are the following:
.AL
.LI
Register interfaces with the RPC runtime
.LI
Request binding handles for the server interface from the RPC runtime
.LI
Request binding handles for the serviceabilty interface from the RPC runtime
.LI
Register both sets of binding handles with the endpoint map
.LI
Export both sets of binding handles to the namespace
.LE
.P
Note that (for brevity's sake) status return checks have been omitted from
this code.
.oS
.ps 11
.vs 13
.ne 7
                 \*V<.\ .\ .>\*C

/* Register server interface/type_uuid/epv associations          */
/* with rpc runtime.                                             */
rpc_server_register_if(timop_v1_0_s_ifspec, &type_uuid,
    (rpc_mgr_epv_t)&manager_epv, &status);

/* Register serviceability remote interface with rpc             */
/* runtime ...                                                   */
rpc_server_register_if(serviceability_v1_0_s_ifspec, &type_uuid,
   (rpc_mgr_epv_t)&dce_svc_epv, &status);

                 \*V<.\ .\ .>\*C

/* Tell rpc runtime we want to use all supported protocol        */
/* sequences.                                                    */
rpc_server_use_all_protseqs(MAX_CONC_CALLS_PROTSEQ, &status);

/* Get server binding handles ...                                */
rpc_server_inq_bindings(&hello_bind_vector_p, &status);

/* Get binding handles for serviceability remote                 */
/* interface ...                                                 */
rpc_server_inq_bindings(&svc_bind_vector_p, &status);

                 \*V<.\ .\ .>\*C

.ne 5
/* Register endpoints with server interface ...                  */
rpc_ep_register(hello_v1_0_s_ifspec, hello_bind_vector_p,
    (uuid_vector_t *)&obj_uuid_vec,
    (unsigned_char_t *)"hello server, version 1.0",
    &status);

/* Register endpoints with serviceability interface ...          */
rpc_ep_register(serviceability_v1_0_s_ifspec, svc_bind_vector_p,
    (uuid_vector_t *)&obj_uuid_vec,
    (unsigned_char_t *)"Hello SVC",
    &status);

/* Export server interface binding info to the namespace.        */
rpc_ns_binding_export(rpc_c_ns_syntax_dce, server_name,
    hello_v1_0_s_ifspec, hello_bind_vector_p,
    (uuid_vector_t *)&obj_uuid_vec, &status);

...\"  /* Export serviceability interface binding info to the namespace.     */
...\"  rpc_ns_binding_export(rpc_c_ns_syntax_dce, server_name,
...\"      serviceability_v1_0_s_ifspec, svc_bind_vector_p,
...\"      (uuid_vector_t *)&obj_uuid_vec, &status);
.ps 12
.vs 14
.oE
...\" ----------------------------------------------------------------------
...\" ----------------------------------------------------------------------
.H 4 "Importing and Accessing the Remote Interface"
...\" ----------------------------------------------------------------------
.P
The following code fragments are intended to give an idea how a client
might import both the \*Lhello_svc\*O server's interface and its exported
serviceability interface.
.P
Note that (for brevity's sake) status return checks have been omitted from
this code.
...\"     
.oS
.ps 11
.vs 13
/* Import binding info from namespace. */
for (server_num = 0; server_num < nservers; server_num++)
{
    /* Begin the binding import loop. */
    rpc_ns_binding_import_begin(rpc_c_ns_syntax_dce,
        server_name[server_num], hello_v1_0_c_ifspec,
        &obj_uuid, &import_context, &status);

    /* Begin the svc binding import loop. */
    rpc_ns_binding_import_begin(rpc_c_ns_syntax_dce,
        server_name[server_num], NULL,
        &obj_uuid, &svc_import_context, &status);

.ne 5
    /* Import bindings one at a time. */
    while (1)
    {
        rpc_ns_binding_import_next(import_context,
            &bind_handle[server_num], &status);

        rpc_ns_binding_import_next(svc_import_context,
            &svc_bind_handle[server_num], &status);

        /* Select, say, the first binding over UDP. */
        rpc_binding_to_string_binding(bind_handle[server_num],
            &string_binding, &status);

        rpc_binding_to_string_binding(svc_bind_handle[server_num],
            &svc_string_binding, &status);

        rpc_string_binding_parse(string_binding, NULL,
            &protseq, NULL, NULL, NULL, &status);

        rpc_string_binding_parse(svc_string_binding, NULL,
            &svc_protseq, NULL, NULL, NULL, &status);

        rpc_string_free(&string_binding, &status);
        ret = strcmp((char *)protseq, "ncadg_ip_udp");
        rpc_string_free(&protseq, &status);

        rpc_string_free(&svc_string_binding, &status);
        svc_ret = strcmp((char *)svc_protseq, "ncadg_ip_udp");
        rpc_string_free(&svc_protseq, &status);

        if ((svc_ret == 0) || (ret == 0))
        {
            break;
        }

    }

    /* End the binding import loop. */
    rpc_ns_binding_import_done(&import_context, &status);
    rpc_ns_binding_import_done(&svc_import_context, &status);

}

.ne 6
/* Annotate binding handles for security. */
for (server_num = 0; server_num < nservers; server_num += 1)
    rpc_binding_set_auth_info(bind_handle[server_num],
        SERVER_PRINC_NAME, rpc_c_protect_level_pkt_integ,
        rpc_c_authn_dce_secret, NULL /*default login context*/,
        rpc_c_authz_name, &status);

for (server_num = 0; server_num < nservers; server_num += 1)
    rpc_binding_set_auth_info(svc_bind_handle[server_num],
        SERVER_PRINC_NAME, rpc_c_protect_level_pkt_integ,
        rpc_c_authn_dce_secret, NULL /*default login context*/,
        rpc_c_authz_name, &status);
.ps 12
.vs 14
.oE
...\" ----------------------------------------------------------------------
...\" ----------------------------------------------------------------------
...\" .H 3 "Conventions for Server Command Line Serviceability Flags"
...\" ----------------------------------------------------------------------
...\" [from RFC, p. 10 ...]
...\" .P
...\" .VL .5i
...\" .LI "\*L-d\*O"
...\" to set debug levels
...\" .LI "\*L-l\*O"
...\" to list subcomponents
...\" .LI "\*L-w\*O"
...\" to specify routing
...\" .LE
...\" .P
...\" .nP
...\" ----------------------------------------------------------------------
...\" .H 2 "Serviceability and Internationalization"
...\" ----------------------------------------------------------------------
...\" .P
...\" Should cover:
...\" .P
...\" Implications of using in-memory table or message catalog: why would one do
...\" either?
...\" .P
...\" How to install a message catalog, if that's what you choose to use (although
...\" this could just refer to the messaging chapter, where this same thing will
...\" have to be explained).
...\" .sp 2
...\" .P
...\" There are two aspects of internationalizing any application, namely:
...\" .BL
...\" .LI
...\" Internationalizing the message text (that is, language)
...\" .LI
...\" Internationalizing the message representation (that is, character set)
...\" .LE
...\" .P
...\" The first of these is accomplished by using message catalogs.  The second is
...\" accomplished through proper use of the new IDL/RPC international character set
...\" compatibility/conversion functionality.
...\" FOLLOWING IS ALL WRONG...
...\" .P
...\" The DCE Serviceability component uses message catalogs, but it makes no attempt
...\" to negotiate or convert character sets between ``client'' (that is, the server
...\" application making a serviceability call) and server (the serviceability daemon).
...\" The serviceability character set is implicitly restricted to the Portable Character
...\" Set.
...\" .P
...\" Other chapters in this book describe how to internationalize a DCE application's
...\" messaging and character representation.  The \*Lsams\*O utility can be used to generate
...\" ``plain'' sets of message catalogs (that is, without the serviceability extras) for DCE
...\" applications.
...\" .P
...\" Codeset negotiation does not enter into serviceability, at least not at present,
...\" because the operation of the messaging facility is strictly local: calls such as
...\" \*Ldce_svc_printf(\|)\*O are library routines that merely send messages to various
...\" kinds of output.  The serviceability remote interface is used only to adjust various
...\" details of the messaging from a remote machine; but the messaging itself occurs
...\" only locally at the machine on which the routines are invoked.
...\" ----------------------------------------------------------------------
...\" .H 2 "Use of DCE Non-Serviceability Messaging Routines"
...\" ----------------------------------------------------------------------
...\" e.g., the define_msg_table routine.
...\" .P
...\" ----------------------------------------------------------------------
...\" .H 3 ""
...\" ----------------------------------------------------------------------
...\" .P
...\" NOTE MESSAGES ARE FROM TIMOP...
...\" .P
...\" With no message catalog installed:
...\" .oS
...\" 1994-03-21-14:40:26.463-05:00I----- timop NOTICE top server 0xa4427e7c Unknown message number 0x178af002
...\" 1994-03-21-14:40:26.583-05:00I----- timop NOTICE top server 0xa4427e7c Unknown message number 0x178af001
...\" .oE
...\" .P
...\" With message catalog installed:
...\" .oS
...\" 1994-03-21-14:41:00.601-05:00I----- timop NOTICE top server 0xa4427e7c This is a test
...\" 1994-03-21-14:41:00.621-05:00I----- timop NOTICE top server 0xa4427e7c This is the server
...\" .oE
...\" ----------------------------------------------------------------------
