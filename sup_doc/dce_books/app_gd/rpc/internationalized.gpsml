...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" 
...\" 
...\" HISTORY
...\" $Log: internationalized.gpsml,v $
...\" Revision 1.1.4.1  1996/03/27  13:07:11  wardr
...\" 	{edit R1.2.1}
...\" 	More Release Edits
...\" 	[1996/03/27  13:06:43  wardr]
...\"
...\" Revision 1.1.2.11  1995/06/07  14:38:21  rcb
...\" 	PRENTICE HALL reformat; final edits and changes
...\" 	[1995/06/05  19:56:08  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/04/20  16:34:27  rcb]
...\" 
...\" 	incorporated 1.1 edits
...\" 	[1995/04/20  15:02:34  rcb]
...\" 
...\" Revision 1.1.2.10  1994/11/03  23:34:24  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:38:57  neilson]
...\" 
...\" 	Substituted macros for book names in cross refs.
...\" 
...\" Revision 1.1.2.9  1994/10/27  19:43:00  jshirley
...\" 	Final edits.
...\" 	[1994/10/27  19:42:00  jshirley]
...\" 
...\" Revision 1.1.2.8  1994/10/20  23:43:42  jshirley
...\" 	Minor cross ref. changes.
...\" 	[1994/10/20  23:43:28  jshirley]
...\" 
...\" Revision 1.1.2.7  1994/10/19  23:05:58  zahn
...\" 	{edt,5284,R1.1}
...\" 
...\" 	Fixed programming example formatting errors.
...\" 	[1994/10/19  23:05:18  zahn]
...\" 
...\" Revision 1.1.2.6  1994/10/19  20:48:35  zahn
...\" 	{edt,5284,R1.1}
...\" 
...\" 	Added technical review comments.
...\" 	[1994/10/19  20:48:20  zahn]
...\" 
...\" Revision 1.1.2.5  1994/10/06  18:06:43  zahn
...\" 	{edt,5284,R1.1}
...\" 
...\" 	Cleaned up examples, made some technical changes,
...\" 	added index entries.
...\" 	[1994/10/06  18:06:29  zahn]
...\" 
...\" Revision 1.1.2.4  1994/10/05  11:46:10  zahn
...\" 	{edt,5284,R1.1}
...\" 
...\" 	Added a sample character and code sets
...\" 	evaluation routine.
...\" 	[1994/10/05  11:45:50  zahn]
...\" 
...\" Revision 1.1.2.3  1994/10/04  19:17:56  zahn
...\" 	{edt,5284,R1.1}
...\" 
...\" 	Updated to latest functionality, added tested examples,
...\" 	added tables, made misc. edits.
...\" 	[1994/10/04  19:17:32  zahn]
...\" 
...\" Revision 1.1.2.2  1994/07/13  19:44:45  zahn
...\" 	{def,10526,R1.1}
...\" 
...\" 	Renamed chapter title per RPC reorg plan.
...\" 	[1994/07/13  19:44:24  zahn]
...\" 
...\" Revision 1.1.2.1  1994/07/08  14:23:52  jshirley
...\" 	{def,10562,R1.1}
...\" 	Created new file for the RPC reorganization based on the old file
...\" 	.../rpc/char_codeset_i14y.gpsml.
...\" 	[1994/07/08  14:23:21  jshirley]
...\" 
...\" $EndLog$
...\"
...\"
.H 1 "Writing Internationalized RPC Applications"
.iX "RPC" "internationalized"
.iX "internationalized RPC"
.iX "code set" "interoperability"
.iX "character set" "interoperability"
An \*Einternationalized\*O DCE RPC application is one that
.ML
.LI
Uses the operating system platform's locale definition functions
to establish language-specific and culture-specific
conventions for the user and programming environment.
.LI
Isolates all user-visible messages into message catalogs
by using the \*Lsams\*O (symbols and message strings) utility.
.LI
Uses the DCE general-purpose application messaging routines,
\*Ldce_msg_\*V*\*L(\|)\*O and \*Ldce_svc_\*V*\*L(\|)\*O, 
to display all program messages.
.LI
Uses DCE RPC-provided or user-defined character and code
set evaluation and automatic conversion features to
ensure character and code set interoperability
during the transfer of international characters
in remote procedure calls between RPC clients and servers.
.LE
.P
.iX "locale"
A \*Elocale\*O defines the subset of a user's environment
that depends upon language and cultural conventions.
A locale consists of categories; each category
controls specific aspects of some operating system components'
behaviors.  Categories exist for character classification
and case conversion, collation order, date and time formats,
numeric nonmonetary formatting, monetary formatting,
and formats of informative and diagnostic messages
and interactive responses.
.P
.ne 5
The locale also determines
the character sets and code sets used in the environment.
The syntax and use of a locale definition function
depends on the operating system platform in use with DCE.
See your operating system programming guide and
reference documentation for a description of the system's
locale definition functions and locale categories.
.P
.iX "sams utility" "and internationalized RPC"
.iX "messaging" "routines and internationalized RPC"
The \*Lsams\*O utility provides DCE services and application
programs with a method for defining and cataloging
user-visible messages, while the DCE messaging functions
allow DCE services and application programs to display messages
in a consistent manner.  Chapter 3 
describes how to develop an application that uses
the DCE messaging routines and how to use the \*Lsams\*O
utility to create and generate message catalogs.
See the \*(Dr for a description of
DCE messaging routine syntax, and the \*Lsams(1dce)\*O
reference page for a description of
\*Lsams\*O usage.
.P
The remainder of this chapter describes the DCE RPC
features for character and code set interoperability
in remote procedure calls that are available to programmers
who are developing internationalized DCE RPC applications.
The first section describes the concepts of character
sets, code sets and code set conversion and explains
the default character and code set conversion mechanism that
the RPC runtime protocol supports for remote procedure calls.
The remaining sections describe the execution of
a remote procedure call when it uses the DCE RPC features
for character and code set interoperability, and explains
how to build an RPC application that uses these features.
.H 2 "Character Sets, Code Sets, and Code Set Conversion"
.iX "character set" 
A \*Echaracter set\*O is a group of characters, such as the
English alphabet, Japanese Kanji, and the European
character set.  To enable world-wide connectivity,
DCE guarantees that a minimum group of
characters is supported in DCE.
The DCE RPC communications protocol ensures this guarantee
by requiring that all DCE RPC clients and servers support
.iX "PCS"
.iX "Portable Character Set (PCS)"
the DCE Portable Character Set (PCS).
The \*(In lists the characters in the DCE PCS.
The IDL base type specifiers \*Lchar\*O and \*Lidl_char\*O identify
DCE PCS characters.
.P
.ne 7
.iX "code set"
A \*Ecode set\*O is a mapping of the members of a character set
to specific numeric code values.  Examples of code sets include
ASCII, JIS X0208 (Japenese Kanji), and ISO 8859-1 (Latin 1).
The same character set can be encoded in different code sets;
consequently, DCE can contain RPC clients and
servers that use the same character set but represent
that character set in different numeric encodings.
.iX "code set" "conversion" "in RPC protocol"
\*ECode set conversion\*O is the ability for a DCE RPC client
or server to convert character data between different
code sets.
.P
The DCE RPC communications protocol, through the NDR transfer syntax, 
provides automatic code set conversion for DCE PCS characters
encoded in two code sets: ASCII and EBCDIC. The RPC communications
protocol automatically converts character data declared as
\*Lchar\*O or \*Lidl_char\*O between ASCII and
EBCDIC encodings, as necessary, for all DCE RPC
clients and servers.
.P
The DCE RPC communications protocol does not provide support
for the recognition of characters outside of the DCE PCS,
nor does it provide automatic conversion for characters
encoded in code sets other than ASCII and EBCDIC.
.P
.iX "code set" "conversion" "in RPC applications"
.iX "international characters"
However, DCE RPC does provide IDL constructs and RPC runtime
routines that programmers can use to write RPC applications
that exchange nonPCS, or ``international,'' character data
that is encoded in code sets other than ASCII and EBCDIC.
These features provide mechanisms for international character
and code set evaluation and automatic code set conversion between
RPC clients and servers.  Using these features, programmers can design
their applications to run in a DCE that supports
multiple heterogeneous character sets and code sets.
.P
The next section describes the remote procedure call execution
model when the DCE RPC features for character and code set interoperability
are used.
.iX "internationalized RPC" "execution model"
.H 2 "Remote Procedure Call with Character/Code Set Interoperability"
.PP
Table 11-1 in Chapter 11 illustrates 
the basic tasks of an RPC application.  Table 16-1
shows these basic tasks integrated with the additional
tasks required to implement an RPC that provides character
and code set interoperability.
.P
.ne 2i
.TB "Tasks of an Internationalized RPC Application"
.na
.ps 11
.vs 13
.TS H
center, box, tab(@);
cB s | cB s
l  l | l  l.
Client Tasks@Server Tasks
=
.TH
@@
@@1.@Set locale.
@@2.@Select network protocols.
@@3.@Register RPC interfaces.
@@4.@T{
Advertise RPC interfaces and objects in the namespace.
T}
@@5.@T{
Get supported code sets and register them in the namespace.
T}
@@6.@Listen for calls.
@@
7.@Set locale.
8.@T{
Establish a character and code set evaluation routine.
T}@@
9.@T{
Find compatible servers that offer the procedures.
T}@@
10.@\*LCall the remote procedure\*O.
11.@T{
Establish a binding relationship with the server.
T}@@
12.@T{
Get code set tags from the binding handle.
T}@@
13.@T{
Calculate the buffer size for possible conversion of
input arguments from a local to a network code set.
T}@@
14.@T{
Convert input arguments from a local to a network code set
(if necessary).
T}@@
15.@Marshall input arguments@@
16.@T{
Transmit arguments to the server's runtime.
T}@@
@@
@@17.@Receive a call.
@@18.@T{
Get code set tags sent from the client.
T}
@@19.@T{
Calculate the buffer size for possible conversion
of input arguments from network to local code set.
T}
@@
@@20.@Unmarshall input arguments.
@@21.@T{
Convert input arguments from a network to a local code set
(if necessary).
T}
@@22.@T{
Locate and invoke the called procedure.
T}
@@23.@\*LExecute the remote procedure\*O
@@24.@T{
Calculate the buffer size for possible conversion of
output arguments from a local to network code set
T}
@@25.@T{
Convert output arguments from a local to a network code set
(if necessary).
T}
@@26.@T{
Marshall output arguments and return value.
T}
@@27.@T{
Transmit results to the client's runtime.
T}
@@28.@T{
Remove code set information from namespace on exit.
T}
@@
29.@Receive results.
30.@T{
Calculate the buffer size for possible conversion
of output arguments from a network to a local code set.
T}@@
31.@Unmarshall output arguments.
32.@T{
Convert output arguments from a network to a local code set
(if necessary).
T}@@
33.@T{
Pass to the calling code the results and return control to it.
T}@@
.TE
.ps 12
.vs 14
.ad
.sp .5
.P
As illustrated in the table, the internationalized RPC execution model
consists of the following new steps:
.AL
.iX "code set" "local"
.iX "character set" "local"
.LI
Both client and server invoke a platform-dependent function
to set their locale during initialization.  This step establishes
the client's and the server's local character and code set; that is,
the character and code set currently in use by processes on the client
host and processes on the server host.
.iX "code set" "supported"
.LI
.ne 6
The server, as part of its initialization phase, calls a DCE RPC
routine that retrieves information about code sets support on
the server's host.  The RPC routine examines the host's locale
environment and its code set registry to determine the
host's \*Esupported code sets\*O; that is, code sets for
which conversion routines exist that processes on the
host can use to convert between code sets, if necessary.
.iX "code set" "registry"
.P
The code set registry is a per-host file that contains mappings
between string names for the supported code sets and their unique
identifiers.  OSF assigns the unique identifiers for the code
sets and DCE licensees, and DCE administrators 
assign their platform string names for the code sets.  The
DCE RPC routines for character set and code set interoperability
depend upon a code set registry existing on each DCE host.
For more information about the code set registry, see 
the \*(Ai and the \*Lcsrc(8dce)\*O reference page.
.P
The routine returns a list of the supported code sets to the
server; the list consists of each code set's unique identifier.
.iX "code set" "exporting"
.iX "registering code sets in the namespace"
.iX "exporting code sets to the namespace"
.LI
The server next calls a new RPC NSI routine to register the supported
code sets information in the name service database.  Recall
that a server can use the NSI to store its \*Ebinding information\*O
(information about its interfaces, objects, and addresses) into
its own namespace entry, called a \*Eserver entry\*O. The new RPC
NSI routine adds the supported code sets information as an
attribute that is associated with the server entry, which
the server created when it used the NSI export operation to export
its binding information into the name service database.
Placing the code sets information into the name service
database gives RPC clients access to this information.
.iX "code set" "evaluation"
.iX "code set" "compatibility evaluation"
.iX "character set" "compatibility evaluation"
.LI
Before it calls the RPC NSI routines that locate a server
that offers the desired remote procedure, the client calls
a new RPC routine that sets up a character and code sets
compatiblity evaluation routine. 
.LI
The client calls RPC NSI routines to locate a compatible server.
The RPC NSI routines invoke the character and code set compatibility
evaluation routine set up by the client to evaluate potential compatible
servers for character and code set compatibility with the client.
.LI
.ne 6
The evaluation routine imports the server's supported code
sets information from the name service database, retrieves
the client's supported code sets information from the client
host, and compares the two.  If the client and the server are
using the same \*Elocal code set\*O\(emthe code set that
processes on the host use to encode character data\(emthen 
no code set conversion is necessary, and no data loss will result.
.PP
If client and server are using different local code sets, then it is 
possible that the server is using a different character set than
the client.  The client does not want to bind to a server that is using a
different character set, since significant data loss would result
during character data conversion.  Consequently, the evaluation routine
uses the server's code set information to determine its supported
character sets, and rejects servers using incompatible character sets.
For example, if a client is using the Japanese Kanji character set
(such as JIS0208), the
evaluation routine rejects a server that offers the desired remote procedure
but which is using the Korean character set (such as KS C 5601).
.PP
If the client and server are character set compatible, and they
support a common code set into which one or the other (or both)
can convert, the evaluation routine deems the server to be
compatible with the client.  The NSI import routines return
this server's binding information to the client.
.LI
The client makes the remote procedure call.
.LI
A client stub is called, with the character data represented
in the local form and in the local code set.
.iX "stub support routines" "for internationalized RPC"
.iX "internationalized RPC" "stub support routines"
.iX "code set" "conversion" "stub routines for"
.LI
Before marshalling the input arguments, the client stub calls
a new stub support routine that retrieves code set identifying
information that the evaluation routine established in the binding handle.
.LI
The client stub next calls a new stub support routine that determines,
based on the code set identifying information, whether the character
data needs to be converted to another code set and, if so, whether
the buffer that currently holds the character data in the local form
and code set is large enough to hold the data once it is converted.  If the
routine determines that conversion is necessary and a new buffer is required,
it calculates the size of that buffer and returns the value to the client stub.
.LI
.iX "network code set"
.iX "code set" "network"
.ne 4
The client stub next calls a new stub support routine that converts,
based on the code set identifying information, the character data
from the local code set to the appropriate code set to be used to
transmit the data over the network to the server (called the \*Enetwork
code set\*O).
.LI
The client stub then marshalls the input arguments and transmits
them to the server runtime along with code set identifying information.
.LI
The server stub is called, with the character data represented in
the network form (which is always \*Lidl_byte\*O) and in the network
code set.
.LI
The server stub unmarshalls the input arguments.
.LI
The server stub next calls a new stub support routine that determines,
based on the code set identifying information passed in the client call,
whether the character data
needs to be converted from the network code set to the server's local
code set and, if so, whether the buffer that currently holds the character data
in the network format and code set is large enough to hold the data
once it is converted.  If the routine determines that conversion is
necessary and a new buffer is required, it calculates the size of that
buffer and returns the value to the server stub.
.LI
The server stub next calls a new stub support routine that converts,
based on the code set identifying information, the character data
from the code set used on the network to the server's local code set.
.LI
The server stub invokes the manager routine to execute the remote procedure.
.LI
Before marshalling the results of the remote procedure (the output
arguments and return values), the server calls a new stub support
routine to determine whether conversion from the server's local
code set is necessary, based on the code set identifying information
it received from the client, and whether or not the buffer currently
holding the character data is large enough to accommodate the converted
data.  If a new buffer is required, the stub support routine calculates
the size of this new buffer and returns it to the server stub.
.LI
The server stub next calls a new stub support routine that converts,
based on the code set identifying information from the client,
the character data from the server's local code set to the
network code set.
.LI
The server stub marshalls the converted output arguments
and transmits them to the client runtime along with code set
identifying information.
.LI
The server initialization procedure also contains a call
to a new RPC routine that removes the code set information
from the server entry in the name service database if the
server exits or is terminated.
.LI
The client stub is called, with the character data in network
format and code set.
.LI
The client stub unmarshalls the output arguments.
.LI
The client stub next calls a new stub support routine that determines,
based on the code set identifying information passed by the server,
whether the character data needs to be converted from the network
code set to the client's local code set and, if so, whether the buffer
that currently holds the character data
in the network format and code set is large enough to hold the data
once it is converted.  If the routine determines that conversion is
necessary and a new buffer is required, it calculates the size of that
buffer and returns the value to the client stub.
.LI
The client stub next calls a new stub support routine that converts,
based on the code set identifying information, the character data
from the code set used on the network to the client's local code set.
.LI
The client stub passes the data to the client in the local format and code set.
.LE
.P
.iX "iconv routines"
.iX "code set" "conversion" "operating system routines for"
Note that the stub conversion routines do not implement code set conversion.
Instead, they call POSIX compliant \*Liconv\*O code set conversion
routines, which are part of the local operating system.  As a result, if
the platform to which DCE is ported does not provide these POSIX conversion
routines, DCE applications that run on this platform cannot use the DCE RPC
character and code set interoperability features.
.iX "internationalized RPC" "application development steps for"
.H 2 "Building an Application for Character and Code Set Interoperability"
.PP
An application programmer who wishes to design his or her RPC
application for character and code set interoperability
performs the following steps:
.AL
.LI
.ne 3
Writes the interface definition file (\*L.idl\*O) to include
constructs that will enable automatic code set conversion during remote
procedure execution.
.LI
Writes an associated attribute configuration file (\*L.acf\*O) for
the interface that includes ACF attributes that will enable automatic
code set conversion during remote procedure execution.
.LI
Writes the stub support routines that client and server stubs
use to carry out automatic code set conversion during a remote
procedure call.  You can omit this step if you use the stub support
routines supplied with DCE.
.LI
Writes the server code and includes the steps to get the server's
supported code sets and export them to the name service database,
and to remove them from the name service database upon termination
or exit.
.LI
Writes the client code and includes the steps to set up the
character and code set evaluation mechanism.
.LI
Writes the character and code set compatibility evaluation routine.
You can omit this step if you use one of the evaluation routines
supplied with DCE.
.LE
.P
Note that building an RPC application for character and code
set interoperability imposes some restrictions on the application.
For example, an application that uses the RPC character and
code set interoperability features cannot use customized binding
handles.  See Chapter 18 for more details on
internationalized RPC application restrictions.
.P
The next sections describe the steps just outlined in more detail.
.iX "internationalized RPC" "interface definition for"
.iX "international characters" "representing in \*L.idl\*O files"
.H 3 "Writing the Interface Definition File"
The interface definition file is where the
set of remote operations that constitute the interface are defined.
The first step in writing an interface definition file
that supports automatic code set conversion is to
create a special \*Ltypedef\*O that, when used in
operation parameters, represents international character
data that can be automatically converted, if necessary,
before marshalling and unmarshalling at client and server
sites.  
.P
.ne 6
As described in Chapter 17, the data representation for
a \*Lbyte\*O data type is guaranteed not to change
when the data is transmitted by the RPC communications
protocol.  Consequently, the special international
character data type defined in the \*L.idl\*O is always
declared to be a \*Lbyte\*O type so that the RPC 
protocol will not automatically treat it as a DCE PCS character
and convert it between ASCII and EBCDIC.
.P
.iX "code set" "tags" "operation parameters"
The second step in writing an interface definition
file that supports automatic code set conversion
is to define, for each operation that will transmit
the special international character data type, a
maximum of three operation parameters that will
\*Etag\*O the international characters being passed in
the operation's input and output parameters with code set
identifying information established during the client-server
evaluation and binding procedure.  These parameters are the following:
.ML
.LI
The sending tag, which indicates the code set the client
is using for international characters it transmits over
the network.  The sending tag has the \*Lin\*O parameter
attribute and is applied to international character data
declared in the operation's input parameters.  If the operation
does not specify any international character data as input,
then it is not necessary to create this parameter.
.LI
The desired receiving tag, which indicates the code set
in which the client prefers to receive international
character data sent back from the server as output.
The desired receiving tag has the \*Lin\*O parameter
attribute.  If the operation does not specify any
international character output data, then it is not
necessary to create this parameter.
.LI
The receiving tag, which indicates the code set
the server is using for international characters
it transmits over the network.  The receiving tag
has the \*Lout\*O parameter attribute and
is applied to international character data
declared in the operation's output parameters.
If the operation does not specify any international
character output data, then it is not
necessary to create this parameter.
.LE
.P
You must define these code set tag parameters
as unsigned long integers or unsigned long integers
passed by reference.  The receiving tag parameter
must be declared as a pointer to the receiving
tag unsigned long integer.
.P
.ne 9
When international character data is to be unmarshalled, the
client or server stub needs to have received a description of
the code set being used before it receives the data.  For this reason,
the sending tag parameter must occur in an operation's
parameter list before any \*Lin\*O international character
data, and the receiving tag parameter must occur in an operation's
parameter list before any \*Lout\*O international character data.
The requirement that a tag must be received before the data it relates to
is received also means that a customized binding handle cannot include
international characters. This is because a binding handle must be the
first parameter in a parameter list.
.P
Here is an example \*L.idl\*O file for an interface
named \*Lcs_test\*O that uses the special international character
type definition and the code set tag parameters for
input and output parameters that are fixed arrays
of characters from an international character set:
.oS
[
uuid(b076a320-4d8f-11cd-b453-08000925d3fe),
version(1.0)
]
interface cs_test
{
    const unsigned short SIZE = 100;
    typedef byte net_byte;

    error_status_t cs_fixed_trans (
	[in] handle_t	IDL_handle,
	[in] unsigned	long stag,
	[in] unsigned	long drtag,
	[out] unsigned	long *p_rtag,
	[in] net_byte	in_string[SIZE],
	[out] net_byte	out_string[SIZE]
    );
.oE
.H 3 "Writing the Attribute Configuration File"
.iX "internationalized RPC" "ACF for"
.PP
The next step in building an RPC application that
supports character and code set interoperability is
to create an attribute configuration file (\*L.acf\*O)
to be associated with the \*L.idl\*O file.  This \*L.acf\*O
file uses the following attributes:
.ML
.LI
.ne 7
.iX "cs_char attribute"
The \*Lcs_char\*O attribute, which associates the local
data type that the application code uses to represent
international characters in the local code set with
the special \*Ltypedef\*O defined in the \*L.idl\*O file.
This is a required ACF attribute for an RPC application that
passes international character data.  Chapter 18 provides
complete details on how to specify the \*Lcs_char\*O ACF attribute
and the programming restrictions associated with its use.
.LI
.iX "cs_stag attribute"
.iX "cs_drtag attribute"
.iX "cs_rtag attribute"
.iX "code set" "tags" "ACF attributes"
The \*Lcs_stag\*O, \*Lcs_drtag\*O, and \*Lcs_rtag\*O attributes,
for each operation in the interface that specifies sending tag,
desired receiving tag, and/or receiving tag parameters.
These ACF attributes declare the tag parameters defined
in the corresponding \*L.idl\*O file to be special code set
tag parameters.  Operations defined in the \*L.idl\*O file that
specify international character in input parameters must
use the \*Lcs_stag\*O attribute.
Operations defined in the \*L.idl\*O file
that specify international character in output parameters
must use the \*Lcs_drtag\*O and \*Lcs_rtag\*O attributes. 
Chapter 19 provides complete details on how to specify
the \*Lcs_stag\*O, \*Lcs_drtag\*O, and \*Lcs_rtag\*O ACF attributes.
.LI
.iX "tag-setting routine" "ACF attribute"
.iX "cs_tag_rtn attribute"
The \*Lcs_tag_rtn\*O attribute, which specifies the
name of a routine that the client and server stubs
will call to set an operation's code set tag
parameters to specific code set values.  The \*Lcs_tag_rtn\*O
attribute is an optional ACF attribute for internationalized RPC
applications; application developers can use it to provide
code set tag transparency for callers of their application's operations.
See Chapter 19 for complete details on how to specify
the \*Lcs_tag_rtn\*O attribute.  Section 16.3.3.3 provides
more information on the role of the tag-setting routine.
.LE
.P
Here is the companion \*L.acf\*O file for the \*Lcs_test\*O
interface defined in Section 16.3.1:
.oS
.ne 13
[
explicit_handle
]
interface cs_test
{
    include "dce/codesets_stub";

    typedef [cs_char(cs_byte)] net_byte;

    [comm_status, cs_tag_rtn(rpc_cs_get_tags)] cs_fixed_trans (
	[cs_stag] stag,
	[cs_drtag] drtag,
	[cs_rtag] p_rtag );
.oE 
.P
.ne 5
The ACF for \*Lcs_test\*O uses the \*Lcs_char\*O attribute
to define \*Lnet_byte\*O as a data type that represents
international characters.
.iX "cs_byte type"
Note that the local type specified in the \*Lcs_char\*O
attribute definition is \*Lcs_byte\*O.  This local type is analogous to
the \*Lbyte\*O type.  The ACF for \*Lcs_test\*O also uses
the \*Lcs_tag_rtn\*O attribute to specify a tag-setting routine.
.H 3 "Writing the Stub Support Routines"
.iX "internationalized RPC" "stub support routines"
.iX "code set" "conversion" "stub routines for"
.iX "cs_tag_rtn attribute"
.iX "cs_char attribute"
When you use the \*Lcs_char\*O attribute to define an
international character data type, you must provide
stub support routines that check the buffer storage
requirements for character data to be converted and
stub support routines that perform the conversions
between the local and network code sets.
And, if you use the \*Lcs_tag_rtn\*O attribute, you
must provide the routine that sets the code set tag
parameters for the operations in the application that
transfer international characters.
.P
DCE RPC provides several buffer-sizing routines and
one tag-setting routine.  You can use the DCE RPC
routines, or you can develop your own customized
buffer-sizing and tag-setting routines; the choice depends upon your
application's requirements.  The next sections describe
these types of stub support routines in more detail.
.H 4 "Buffer-Sizing Routines"
.iX "buffer-sizing routines"
Different code sets use different numbers of bytes to encode a single character.
Consequently, there is always the possibility that the converted string
can be larger than the original string when converting data from one code
set to another.  The function of the buffer-sizing routines is to calculate
the necessary buffer size for code set conversion between local and network code
sets and return their findings to the client and server stubs, which call
these buffer-sizing routines before marshalling and unmarshalling any
international character data.  The stubs then allocate a new buffer, if necessary,
before calling the code set conversion routines.
.P
You must provide the following buffer-sizing routines for each local type
that you define with the \*Lcs_char\*O attribute:
.ML
.LI
\*Vlocal_type_name\*L_net_size(\|)\*O\(emCalculates the necessary buffer size
for code set conversion from a local code set to a network code set.  Client
and server stubs call this routine before they marshall any international
character data.
.LI
\*Vlocal_type_name\*L_local_size(\|)\*O\(emCalculates the necessary buffer size
for code set conversion from a network code set to a local code set.  Client and
server stubs call this routine before they unmarshall any international character
data.
.LE
.P
You specify the name for the local data type in the \*Vlocal_type_name\*O portion
of the function name and the appropriate suffix name (\*L_net_size\*O or \*L_local_size\*O).
.P
.iX "wchar_t type"
.iX "cs_byte type"
DCE RPC provides buffer-sizing routines for the \*Lcs_byte\*O
and \*Lwchar_t\*O data types.  The \*Lcs_byte\*O data type is
equivalen to the \*Lbyte\*O type, while the \*Lwchar_t\*O data
type is a platform-dependent data type whose range of values
can represent encodings for all members of the largest international
character set that exists within the set of character/code sets
supported on the host.
.P
The DCE RPC buffer-sizing routines are
.ML
.LI
\*Lcs_byte_net_size(\|)\*O\(emCalculates the necessary
buffer size for code set conversion from a local code set
to a network code set when the \*Lcs_byte\*O type
has been specified as the local data type in the .\*Lacf\*O file.
.LI
\*Lcs_byte_local_size(\|)\*O\(emCalculates the necessary
buffer size for code set conversion from a network code set
to a local code set when the \*Lcs_byte\*O
type has been specified as the local data type in the \*L.acf\*O file.
.LI
\*Lwchar_t_net_size(\|)\*O\(emCalculates the necessary buffer size for
code set conversion from a local code set to a network code set when
the \*Lwchar_t\*O data type has been specified as the local data type in
the \*L.acf\*O file.
.LI
\*Lwchar_t_local_size(\|)\*O\(emCalculates the necessary buffer size
for code set conversion from a network code set to a local code set
when the \*Lwchar_t\*O data type has been specified as the local data
type in the \*L.acf\*O file.
.LE
.P
If your internationalized RPC application uses either of these
data types as the local type in the ACF, it can use these
DCE RPC buffer-sizing routines; in order to do so, simply
link with the DCE library when compiling your application.
The example ACF shown earlier in this chapter uses the \*Lcs_byte\*O
type as the local type.  Consequently, the client and server
stubs will use the \*Lcs_byte_\*O buffer-sizing routines.
Refer to the \*Lcs_byte_\*V*\*L(3rpc)\*O and \*Lwchar_t_\*V*\*L(3rpc)\*O
reference pages for a description of the \*Lcs_byte_\*O
and \*Lwchar_t_\*O routine signatures and functions.
.P
Applications that use data types other than \*Lcs_byte\*O
or \*Lwchar_t\*O as their local data types will need to
provide their own buffer-sizing routines.  User-provided
buffer-sizing routines must follow the same signature
as the DCE RPC-provided buffer-sizing routines.  See the
\*Lcs_byte_\*V*\*L(3rpc)\*O and \*Lwchar_t_\*V*\*L(3rpc)\*O
reference pages for a description of the required routine signatures.
.H 4 "Code Set Conversion Routines"
.iX "code set" "conversion" "stub support routines"
When RPC clients and servers exchange international character data,
the data being exchanged needs to be understood by both client
and server.  Both client and server need to understand a character
set, and both client and server need to understand the way that
character set is expressed.  Code set conversion provides a
way for a character set to be represented in a form
that both client and server can understand, given that the
client and server are using a compatible character set.
(In general, character set conversion is not recommended;
it is unlikely that clients and servers would want to map,
for example, German characters to Chinese characters due
to the data loss that would occur as a result.)
.P
.ne 6
The stub support routines for code set conversion provide the mechanism
for the stubs to use to convert between different code sets, given
that character set compatibility has been established.  The code
set conversion routines translate a character set from one encoding
to another.  Consequently, the code set conversion routines provide
the way for a character set to be represented in a form that both
client and server can understand.
.P
You must provide the following code set conversion routines for each local type
that you define with the \*Lcs_char\*O attribute:
.ML
.LI
\*Vlocal_type_name\*L_to_netcs(\|)\*O\(emConverts international character data
from a local code set to a network code set.  Client and server stubs call this
routine before they marshall any international character data.
.LI
\*Vlocal_type_name\*L_from_netcs(\|)\*O\(emConverts international character
data from a network code set to a local code set.  Client and server stubs call
this routine before they unmarshall any international character data.
.LE
.P
You specify the name for the local data type
in the \*Vlocal_type_name\*O portion of the function name
and the appropriate suffix name (\*L_to_netcs\*O or \*L_from_netcs\*O).
.P
DCE RPC provides code set conversion routines for
the \*Lcs_byte\*O and \*Lwchar_t\*O data types.  These routines are
.ML
.LI
\*Lcs_byte_to_netcs(\|)\*O\(emConverts international character data
from a local code set to a network code set when the \*Lcs_byte\*O type
has been specified as the local data type in the \*L.acf\*O file.
.LI
\*Lcs_byte_from_netcs(\|)\*O\(emConverts international character data
from a network code set to a local code set when the \*Lcs_byte\*O
type has been specified as the local data type in the \*L.acf\*O file.
.LI
\*Lwchar_t_to_netcs(\|)\*O\(emConverts international character data
from a local code set to a network code set when
the \*Lwchar_t\*O data type has been specified as the local data type in
the \*L.acf\*O file.
.LI
\*Lwchar_t_from_netcs(\|)\*O\(emConverts international character data
from a network code set to a local code set
when the \*Lwchar_t\*O data type has been specified as the local data
type in the \*L.acf\*O file.
.LE
.P
If your application uses either of these data types as
the local type, it can use these DCE RPC code set conversion
routines; in order to do so, simply link with the DCE library
when compiling your application.
Refer to the \*Lcs_byte_\*V*\*L(3rpc)\*O and \*Lwchar_t_\*V*\*L(3rpc)\*O
reference pages for a description of the \*Lcs_byte_\*O
and \*Lwchar_t_\*O routine signatures and functions.
.P
.ne 6
Applications that use data types 
other than \*Lcs_byte\*O or \*Lwchar_t\*O as their
local data types will need to provide their own code set conversion routines.
User-provided code set conversion routines must follow the same signature
as the DCE RPC-provided code set conversion routines.
See the \*Lcs_byte_\*V*\*L(3rpc)\*O and \*Lwchar_t_\*V*\*L(3rpc)\*O
reference pages for a description of the \*Lcs_byte_\*O
and \*Lwchar_t_\*O routine signatures and functions.
.P
.iX "code set" "conversion" "operating system routines"
The DCE code set conversion routines depend upon the presence of the
XPG4 \*Liconv\*O code set conversion facility in the underlying
operating system platform.  The \*Liconv\*O facility consists of
the following routines:
.ML
.LI
\*Liconv_open(\|)\*O\(emCode conversion allocation function; returns
a conversion descriptor that describes a conversion from the code set
specified in one string pointer argument to the code set specified
in another string pointer argument.
.LI
\*Liconv(\|)\*O\(emCode conversion function; converts the sequence
of characters from one code set into a sequence of corresponding
characters in another code set.
.LI
\*Liconv_close(\|)\*O\(emCode conversion deallocation function;
deallocates the conversion descriptor and all associated resources
allocated by the \*Liconv_open(\|)\*O function.
.LE
.P
Note that the \*Liconv\*O facility identifies a code set by a
string name.  This string name is the name that the local platform
uses to refer to the code set.  However, all of the stub support
routines for automatic code set conversion use the unique identifier
assigned to the code set in the code set registry to identify a code set. 
Before the DCE code set conversion routines can invoke the \*Liconv\*O
facility, they must access the code set registry to retrieve
the platform-specific string names associated with the local
and network code set identifiers.
.P
The DCE code set conversion routines use the
\*Ldce_cs_loc_to_rgy(\|)\*O and \*Ldce_cs_rgy_to_loc(\|)\*O
routines to access the code set registry and translate between
code set string names and their corresponding unique identifiers.
The \*(Dr provides
a description of these routines' signatures and functions;
developers who are writing their own code set conversion routines
and who are using the \*Liconv\*O facility for conversion may
want to use these DCE routines to convert between code set names
and identifiers.
.H 4 "Tag-Setting Routine"
.iX "tag-setting routine"
.iX "cs_tag_rtn attribute"
Recall from Section 16.3.1 that operations that specify
international characters as input and output parameters
declare special code set tag parameters.  The purpose of
these parameters is to hold the unique identifier for
the code set into which the input or output data
is to be encoded when it is transferred over the network.
.P
The function of the tag-setting routine is to provide a
way to set an operation's code set tag parameters to
specific code set values from within the stubs rather
than in the application code.  The application specifies
the name of the tag-setting routine
as the argument to the \*Lcs_tag_rtn\*O ACF attribute; the
client and server stubs call this routine when the operation
is invoked to set the tag parameters to specific network code set
values before they call the stub support routines for buffer-sizing and
code set conversion.  The stubs use the network code set values
returned by the tag-setting routine as input to the buffer-sizing
and conversion routines.  In turn, these routines compare the
network code set values to be used for input and output data to
the local code set in use for the data, and determine whether
or not new buffer allocation and code set conversion are necessary.
.P
When called from the client stub, the tag-setting routine sets the sending tag
parameter to the code set to use for input character data.  If the
client expects output character data from the server, the routine
also sets the desired receiving tag parameter to the code set that
the client prefers the server to use for sending back the output data.
On the client side, the buffer-sizing routines
\*Vlocal_type_name\*L_net_size(\|)\*O 
and the code set conversion routines 
\*Vlocal_type_name\*L_to_netcs(\|)\*O 
use the value in the sending tag as the network
code set value to use for transmitting the input data.  When the
input data arrives at the server side, the server stub uses
the sending tag as input to the \*Vlocal_type_name\*L_local_size(\|)\*O 
buffer-sizing routine and the \*Vlocal_type_name\*L_from_netcs(\|)\*O code set
conversion routines, which use the value to determine whether or
not new buffer allocation and conversion is necessary from the
network code set to the local code set.
.P
.ne 14
When called from the server stub, the tag-setting routine
sets the receiving tag parameter to the code set to use
for transmitting the output character data back to the server.
The routine can use the desired receiving tag
value as input to determine the most appropriate code
set in which to encode output data for the client.
On the server side, the buffer-sizing routines 
\*Vlocal_type_name\*L_net_size(\|)\*O 
and the code set conversion routines 
\*Vlocal_type_name\*L_to_netcs(\|)\*O 
use the value in the receiving tag as the network
code set value to use for transmitting the output data.
When the output data arrives at the client side, the client stub uses
the receiving tag as input to the \*Vlocal_type_name\*L_local_size(\|)\*O 
buffer-sizing routine and the \*Vlocal_type_name\*L_from_netcs(\|)\*O code set
conversion routines, which use the value to determine whether or
not new buffer allocation and conversion is necessary from the
network code set to the local code set.
.P
DCE RPC provides one tag-setting routine named \*Lrpc_cs_get_tags(\|)\*O
that applications can use to set code set tag values within the stubs.
To use this routine, specify its name as the argument to the \*Lcs_tag_rtn\*O
attribute and link your application with the DCE library.
The example ACF for the \*Lcs_test\*O interface specifies
the \*Lrpc_cs_get_tags(\|)\*O routine.
.P
Note that the \*Lrpc_cs_get_tags(\|)\*O routine always sets
the receiving tag value on the server side to the value that
the client specified in the desired receiving tag.  See the
\*Lrpc_cs_get_tags(3rpc)\*O reference page 
for an explanation of this routine's signature and function.
.P
RPC application programmers who are developing their own tag-setting
routines can also refer to the \*Lrpc_cs_get_tags(3rpc)\*O
reference page to obtain the required signature
for their user-written routine.
.P
The tag-setting routine generally obtains the code set tag values
from the binding handle.  These values are usually determined by the
character and code set evaluation routine invoked during the
server binding import process, although they can be explicitly set
in the binding handle by using the \*Lrpc_cs_binding_set_tags(\|)\*O routine.
However, applications can design the tag-setting routine to perform
evaluation within the stubs rather than in the application (client)
code.  For example, when called from the client side, the DCE RPC tag-setting routine
\*Lrpc_cs_get_tags(\|)\*O performs character and code set compatibility
evaluation itself if it does not find the tag values in the binding handle.
See Section 16.3.6 for more information on deferred evaluation.
.H 3 "Writing the Server Code"
.iX "internationalized RPC" "server code"
A programmer who is developing an RPC server that supports
character and code set interoperability needs to add the following
steps to the server's initialization functions in addition
to the normal initialization functions it carries out for RPC:
.ML
.LI
Setting the server's locale
.LI
Establishing the server's supported code sets
.LI
Registering the server's supported code sets in the name service database
.LI
Establishing a cleanup function that removes the
server's supported code sets from the name service
database on the server's termination or exit.
.LE
.P
The next sections explain these steps in detail.
.H 4 "Setting the Server's Locale"
.iX "locale" "setting"
.iX "internationalized RPC" "setting locale in"
The server initialization code needs to include a platform-specific
routine that sets the locale environment for the server.  This step
establishes
.ML
.LI
.iX "code set" "local"
.iX "local code set"
The name of the server's local code set.
.LI
The names of the code sets for which converters exist on the host
and consequently, into which processes that run on the
host can convert if necessary.
.LE
.P
An example of a locale-setting function is the POSIX, XPG3, XPG4
\*Lsetlocale(\|)\*O function, which is
defined in \*Llocale.h\*O.  The server code should call
the locale-setting function as the first step in the
initialization code, before calling the DCE RPC routines
that register the interface and export the binding information.
.P
The locale-setting function also establishes the value for
two platform-specific macros that indicate
.ML
.LI
The maximum number of bytes the local code set uses to encode one character.
.LI
The maximum number of bytes that any of the supported code sets on
the host will use to encode one character.
.LE
.P
On POSIX, XPG3, and XPG4 platforms, these macros are \*LMB_CUR_MAX\*O
and \*LMB_LEN_MAX\*O and are defined in \*Lstdlib.h\*O and
\*Llimits.h\*O, respectively.  The buffer-sizing 
routines use \*LMB_CUR_MAX\*O when calculating the size of a new
buffer to hold converted character data.
.P
.iX "code set" "intermediate"
.iX "code set" "universal"
.iX "intermediate code set"
.iX "universal code set"
.iX "code set" "ISO 10646"
Note that all hosts that are members of an internationalized DCE
cell (that is, a cell that supports internationalized RPC applications)
must provide converters that convert between their supported
code sets and the ISO 10646 ``universal'' code set.  The DCE RPC
functions for character and code set interoperability use the
universal code set as the default ``intermediate'' code set into
which a client or server can convert if there are no other
compatible code sets between them.  Section 16.3.6
discusses intermediate code sets in more detail.
.H 4 "Establishing the Server's Supported Code Sets"
.iX "code set" "supported"
.iX "supported code sets" "establishing"
The next step in writing an internationalized RPC server
is to add to the server's initialization code a call to
the DCE RPC routine \*Lrpc_rgy_get_codesets(\|)\*O.
This routine gets the supported code set names
defined in the locale environment and translates those
names to their unique identifiers by accessing the
code set registry on the host.  The server initialization
code should call this routine after it has registered the
interface and created a server entry for its binding
information in the name service database (by calling
the DCE RPC NSI binding export routine \*Lrpc_ns_binding_export(\|)\*O).
.P
The routine returns an array of unique identifiers
from the code set registry that correspond to the server's
local code set and the code sets into which the server
can convert, if necessary;
.iX "code set" "array"
this data structure is
called the \*Ecode sets array\*O. The code sets array also
contains, for each code set, the maximum number of bytes
that code set uses to encode one character.
.P
The purpose of this step is to obtain the registered
unique identifiers for the server's supported code sets
for use by the DCE character and code set interoperability
features, rather than using the string names for the code sets.
The DCE features for character and code set interoperability
do not use string names because different operating systems
commonly use different string names to refer to the same
code set, and clients and servers passing international
characters in a cell of heterogeneous platforms need
to ensure that they both refer to the same code set when
establishing compatibility.
.P
.ne 4
The code set registry provides the means for
clients and servers to uniquely identify a code set while
permitting different platforms and the code set converters
offered on those platforms to continue to use the string names
for the code sets.
.P
See the \*Lrpc_rgy_get_codesets(3rpc)\*O reference pages
for a description of the \*Lrpc_rgy_get_codesets(\|)\*O
routine's signature and arguments.
.H 4 "Registering the Server's Supported Code Sets in the Namespace"
.iX "supported code sets" "exporting to the namespace"
.iX "code set" "exporting"
.iX "exporting code sets to the namespace"
.iX "code set" "attribute"
.iX "attribute" "code sets"
.iX "NSI" "attribute" "code sets"
The next step in writing an internationalized RPC server is to
make a call in the server's initialization code to the DCE RPC routine
\*Lrpc_ns_mgmt_set_attribute(\|)\*O, which takes the code sets array
returned by \*Lrpc_rgy_get_codesets(\|)\*O and exports it to the server's
entry in the name service database.  The routine creates a ``code sets''
NSI attribute in the name service database and associates it with the server
entry created by the NSI export operation.
.P
The purpose of this step is to register the server's supported code sets
into the name service database so that clients can gain access to the
information.  Note, then, that server entries for internationalized RPC
servers will have code sets attributes in addition to the binding attributes
and object attributes for the servers.
For a general discussion of NSI attributes, see
Chapter 14.  Refer to the
\*Lrpc_ns_mgmt_set_attribute(3rpc)\*O reference page
for a description
of the \*Lrpc_ns_mgmt_set_attribute(\|)\*O routine's signature and arguments.
.H 4 "Establishing a Cleanup Function for the Namespace"
.iX "code set" "removing from the namespace"
The last step in writing an internationalized RPC server is
to add a call to the DCE RPC routine \*Lrpc_ns_mgmt_remove_attribute(\|)\*O
to the cleanup code within the server's initialization code.  This
DCE RPC routine will remove the code sets attribute associated with
the server entry from the name service database when it is called
from the cleanup code as the result of a server crash or exit.
See the \*Lrpc_ns_mgmt_remove_attribute(3rpc)\*O reference page
for a description
of the \*Lrpc_ns_mgmt_remove_attribute(\|)\*O routine's signature and arguments.
.H 4 "Sample Server Code"
Here is an example of an internationalized RPC server that
exports the \*Lcs_test\*O interface defined in Section 16.3.1.
...\" 
...\" DCE 1.2 WRITERS: This and all other code samples in this chapter
...\" must be carefully checked.  I suspect there were typos and
...\" formatting errors.
.P
.oS
.ps 10
.vs 12
#include <stdio.h>
#include <stdlib.h>
#include <dce/rpc.h>
#include <dce/nsattrid.h>
#include <dce/dce_error.h>
#include <locale.h>
#include <pthread.h>
#include <dce/codesets.h>
#include "cs_test.h"

/* 
 * Macro for result checking 
 */
#define CHECK_STATUS(t, func, returned_st, expected_st) \\
{ \\
    if (returned_st == expected_st) { \\
    } \\
    else { \\
	dce_error_inq_text(returned_st, \\
	 (unsigned char *)unexpected, &dce_status); \\
	dce_error_inq_text(expected_st,\\
	 (unsigned char *)expected, &dce_status); \\
	printf("FAILED %s()\\nresult:   %s\\nexpected:   %s\\n\\n", \\
	    func, unexpected, expected); \\
    } \\
} \\

static unsigned char	unexpected[dce_c_error_string_len];
static unsigned char	expected[dce_c_error_string_len];
static int		dce_status;

int
main(int argc, char *argv[])
{
    error_status_t		status;
    int				i;
    rpc_ns_handle_t		inq_contxt;
    rpc_binding_vector_t	*binding_vector;
    rpc_codeset_mgmt_p_t 	arr;
    pthread_t			this_thread = pthread_self();
    sigset_t			sigset;
    char			*nsi_entry_name;
    char			*server_locale_name;
    error_status_t		expected = rpc_s_ok;
    int				server_pid;

.ne 5
    /* The environment variable I18N_SERVER_ENTRY needs
     * to be set before running this program.  This is
     * not a DCE environment variable, so you can set up
     * your own environment variable if you like.
     */

    nsi_entry_name = getenv("I18N_SERVER_ENTRY");

    (void)pthread_mutex_init(&mutex, pthread_mutexattr_default);

    /* Set the locale.  In this way, the current locale
     * information is extracted from XPG/POSIX defined
     * environment variable LANG or LC_ALL.
     */

    setlocale(LC_ALL, "");

    /*
     * Get supported code sets.
     */
    rpc_rgy_get_codesets (
	&arr,
	&status );

	CHECK_STATUS(TRUE, "rpc_rgy_get_codesets", status, expected);

    rpc_server_register_if (
	cs_test_v1_0_s_ifspec,
	NULL,
	NULL,
	&status );

    CHECK_STATUS(TRUE, "rpc_server_register_if", status, expected);

    rpc_server_use_all_protseqs (
	rpc_c_protseq_max_reqs_default,
	&status );

    CHECK_STATUS(TRUE, "rpc_server_use_all_protseqs", status, expected);
	
    rpc_server_inq_bindings (
	&binding_vector,
	&status );

    CHECK_STATUS(TRUE, "rpc_server_inq_bindings", status, expected);

.ne 7
    rpc_ns_binding_export (
	rpc_c_ns_syntax_default,
	(unsigned_char_p_t)nsi_entry_name,
	cs_test_v1_0_s_ifspec,
	binding_vector,
	NULL,
	&status );

    CHECK_STATUS(TRUE, "rpc_ns_binding_export", status, expected);

    rpc_ep_register (
	cs_test_v1_0_s_ifspec,
	binding_vector,
	NULL,
	NULL,
	&status );

    CHECK_STATUS(TRUE, "rpc_ep_register", status, expected);

    /*
     * Register the server's supported code sets into the name space.
     */
    rpc_ns_mgmt_set_attribute (
	rpc_c_ns_syntax_default,
	(unsigned_char_p_t)nsi_entry_name,
	rpc_c_attr_codesets,
	(void *)arr,
	&status );

    CHECK_STATUS(TRUE, "rpc_ns_mgmt_set_attribute", status, expected);

    /*
     * Free memory allocated by getting code sets.
     */
    rpc_ns_mgmt_free_codesets (&arr, &status);

    CHECK_STATUS(TRUE, "rpc_ns_mgmt_free_codeset", status, expected);

    sigemptyset(&sigset);
    sigaddset(&sigset, SIGINT);

    if (pthread_signal_to_cancel_np(&sigset, &this_thread) != 0)
    {
	printf("pthread_signal_to_cancel_np failed\\n");
	exit(1);
    }
    TRY
    {
.ne 7
	server_pid = getpid();

	printf("Listening for remote procedure calls...\\n");

	rpc_server_listen (
	    rpc_c_listen_max_calls_default,
	&status );

	CHECK_STATUS(TRUE, "rpc_server_listen", status, expected);

	/* 
	 * Remove code set attributes from namespace on return.
	 */
	rpc_ns_mgmt_remove_attribute (
	    rpc_c_ns_syntax_default,
	    (unsigned_char_p_t)nsi_entry_name,
	    rpc_c_attr_codesets,
	    &status );

	CHECK_STATUS(TRUE, "rpc_ns_mgmt_remove_attribute", status, \\
	  expected);

	rpc_ns_binding_unexport (
	    rpc_c_ns_syntax_default,
	    (unsigned_char_p_t)nsi_entry_name,
	    cs_test_v1_0_s_ifspec,
	    (uuid_vector_p_t)NULL,
	    &status );

	CHECK_STATUS(TRUE, "rpc_ns_binding_unexport", status, expected);

	rpc_ep_unregister (
	    cs_test_v1_0_s_ifspec,
	    binding_vector,
	    NULL,
	    &status );

	CHECK_STATUS(TRUE, "rpc_ep_unregister", status, expected);
		
	rpc_binding_vector_free (
	    &binding_vector,
	    &status );

	CHECK_STATUS(TRUE, "rpc_binding_vector_free", status, expected);

	rpc_server_unregister_if (
	    cs_test_v1_0_s_ifspec,
	    NULL,
	    &status );

	CHECK_STATUS(TRUE, "rpc_server_unregister_if", status, expected);

	(void)pthread_mutex_destroy(&mutex);
    }
    CATCH_ALL
    {
	/* 
	 * Remove code set attribute from namespace on a signal.
	 */
	rpc_ns_mgmt_remove_attribute (
	    rpc_c_ns_syntax_default,
	    (unsigned_char_p_t)nsi_entry_name,
	    rpc_c_attr_codesets,
	    &status );

	CHECK_STATUS(TRUE, "rpc_ns_mgmt_remove_attribute", status, \\
	  expected);

	rpc_ns_binding_unexport (
	    rpc_c_ns_syntax_default,
	    (unsigned_char_p_t)nsi_entry_name,
	    cs_test_v1_0_s_ifspec,
	    (uuid_vector_p_t)NULL,
	    &status );

	CHECK_STATUS(TRUE, "rpc_ns_binding_unexport", status, expected);

	rpc_ep_unregister (
	    cs_test_v1_0_s_ifspec,
	    binding_vector,
	    NULL,
	    &status );

	CHECK_STATUS(TRUE, "rpc_ep_unregister", status, expected);
		
	rpc_binding_vector_free (
	    &binding_vector,
	    &status );

	CHECK_STATUS(TRUE, "rpc_binding_vector_free", status, expected);

	rpc_server_unregister_if (
	    cs_test_v1_0_s_ifspec,
	    NULL,
	    &status );

	CHECK_STATUS(TRUE, "rpc_server_unregister_if", status, expected);

	(void)pthread_mutex_destroy(&mutex);
    }
    ENDTRY;
}
.ps 12
.vs 14
.oE
.H 3 "Writing the Client Code"
.iX "internationalized RPC" "client code"
A programmer who is developing an RPC client that supports
character and code set interoperability needs to add the following
steps to the client code in addition to the basic functions for RPC:
.AL
.LI
Setting the client's locale
.LI
Establishing a character and code set compatibility evaluation routine
that the NSI server binding import routines will call to evaluate
potential servers for character and code set compatibility
.LE
.P
The next sections explain these steps in detail.
.H 4 "Setting the Client's Locale"
.iX "locale"
.iX "locale" "setting"
The first step in developing an internationalized RPC client is
to add a call within the client code to a platform-specific
function that sets the locale environment for the client.
This step establishes
.ML
.LI
.iX "code set" "local"
The name of the client's local code set.
.LI
The names of the code sets for which converters exist on the host
and, consequently, into which processes that run on the
host can convert if necessary.
.LE
.P
The call to the locale-setting function must be the first call made
within the client code.  An example of a locale-setting function is
the POSIX, XPG3, XPG4 \*Lsetlocale(\|)\*O function, which is
defined in \*Llocale.h\*O.
.P
The locale-setting function also establishes the value for
two platform-specific macros that indicate
.ML
.LI
The maximum number of bytes the local code set uses to encode one character.
.LI
The maximum number of bytes that any of the supported code sets on
the host will use to encode one character.
.LE
.P
On the POSIX, XPG3, XPG4 platform, these macros are \*LMB_CUR_MAX\*O
and \*LMB_LEN_MAX\*O and are defined in \*Lstdlib.h\*O and \*Llimits.h\*O,
respectively.  The buffer-sizing routines use
the \*LMB_CUR_MAX\*O macro when calculating the size of a new
buffer to hold converted character data.
.P
Note that all hosts that are members of an internationalized DCE
cell must provide converters that convert between their supported
code sets and the ISO 10646 ``universal'' code set.  The DCE RPC
functions for character and code set interoperability use the
universal code set as the default ``intermediate'' code set into
which a client or server can convert if there are no other
compatible code sets between them.  Section 16.3.6
discusses intermediate code sets in more detail.
.H 4 "Establishing the Compatibility Evaluation Routine"
.iX "code set" "compatibility evaluation"
.iX "character set" "compatibility evaluation"
.iX "evaluation routine" "establishing"
The last step in writing an internationalized RPC client
is to call the DCE RPC NSI routine \*Lrpc_ns_import_ctx_add_eval(\|)\*O.
The purpose of this NSI routine is to add evaluation routines to the
import context created by the \*Lrpc_\%ns_\%binding_\%import_\%begin(\|)\*O
routine that the NSI routine \*Lrpc_\%ns_\%binding_\%import_\%next(\|)\*O will call
to perform additional compatibility evaluation on potential servers.
.P
The internationalized RPC client code calls the
\*Lrpc_\%ns_\%import_\%ctx_\%add_\%eval(\|)\*O routine to set up one or more
character and code set compatibility evaluation routines to be
called from \*Lrpc_\%ns_\%binding_\%import_\%next(\|)\*O.
The client code must make the call
to \*Lrpc_\%ns_\%import_\%ctx_\%add_\%eval(\|)\*O once
for each compatibility routine that it wants to add to the import
context for \*Lrpc_\%ns_\%binding_\%import_\%next(\|)\*O.
See the \*Lrpc_\%ns_\%import_\%ctx_\%add_\%eval(3rpc)\*O reference page
for a description of the
\*Lrpc_\%ns_\%import_\%ctx_\%add_\%eval(\|)\*O routine's 
signature and arguments.
.P
The \*Lrpc_ns_import_ctx_add_eval(\|)\*O must be used in conjunction
with the \*Lrpc_ns_binding_import_begin/next/done(\|)\*O suite of
RPC NSI binding functions because these functions provide an
import context argument.  If you want to use the 
\*Lrpc_ns_binding_lookup_begin/next/done/select(\|)\*O suite
of RPC NSI routines, your client code will need to perform
character and code set evaluation logic on the binding handle returned
by \*Lrpc_ns_binding_select(\|)\*O.  Section 16.3.6.4 provides a
sample client that performs character and code set evaluation
in conjunction with the \*Llookup\*O and \*Lselect\*O RPC NSI routines.
.H 4 "Sample Client Code"
.PP
Here is an example of an internationalized RPC client that
calls the operation defined in the \*Lcs_test\*O interface
shown in Section 16.3.1. The client establishes the DCE
RPC evaluation routine \*Lrpc_\%cs_\%eval_\%without_\%universal(\|)\*O
as the character and code set evaluation routine to use.
.P
.oS
.ps 10
.vs 12
#include <stdio.h>
#include <locale.h>
#include <dce/rpc.h>
#include <dce/rpcsts.h>
#include <dce/dce_error.h>

#include "cs_test.h"		/* IDL generated header file */

/*
 * Result check MACRO
 */
#define CHECK_STATUS(t, func, returned_st, expected_st) \\
{ \\
	if (returned_st == expected_st) { \\
/*
 * Do nothing.
 */
    } else { \\
	dce_error_inq_text(returned_st,\\
	  (unsigned char *)unexpected, &dce_status); \\
	dce_error_inq_text(expected_st, \\
	  (unsigned char *)expected, &dce_status); \\
	printf("FAILED %s()\\nresult:   %s\\nexpected:   %s\\n\\n", \\
	    func, unexpected, expected); \\
    } \\
} \\

static unsigned char	unexpected[dce_c_error_string_len];
static unsigned char	expected[dce_c_error_string_len];
static int		dce_status;

.ne 14
void
main(void)
{
    rpc_binding_handle_t    bind_handle;
    rpc_ns_handle_t         import_context;
    error_status_t	    status;
    error_status_t	    temp_status;
    cs_byte		    net_string[SIZE];
    cs_byte		    loc_string[SIZE];
    unsigned char	    err_buf[256];
    char		    *nsi_entry_name;
    char		    *client_locale_name;
    int			    i, rpc_num;
    FILE		    *fp_in, *fp_out;

    /* The environment variable I18N_SERVER_ENTRY needs
     * to be set before running this program.  This is
     * not a DCE environment variable, so you can set up
     * your own environment variable if you like.
     */

    nsi_entry_name = getenv("I18N_SERVER_ENTRY");

    setlocale(LC_ALL, "");

    rpc_ns_binding_import_begin (
	rpc_c_ns_syntax_default,
	(unsigned_char_p_t)nsi_entry_name,
	cs_test_v1_0_c_ifspec,
	NULL,
	&import_context,
	&status );

    CHECK_STATUS(TRUE, "rpc_ns_binding_import_begin", status, rpc_s_ok);

    /*
     *  Add code set compatibility checking logic to the context.
     */
    rpc_ns_import_ctx_add_eval (
	&import_context,
	rpc_c_eval_type_codesets,
	(void *)nsi_entry_name,
	rpc_cs_eval_without_universal,
	NULL,
	&status );

    CHECK_STATUS(TRUE, "rpc_ns_import_ctx_add_eval", status, rpc_s_ok);

.ne 5
    while (1) {
	rpc_ns_binding_import_next (
	    import_context,
	    &bind_handle,
	    &status );

	CHECK_STATUS(TRUE, "rpc_ns_binding_import_next", status, \\
	  rpc_s_ok);
	    if (status == rpc_s_ok)
		break;
	    else
	    {
		return;
	    }
    }

    rpc_ns_binding_import_done (
	&import_context,
	&status );

    CHECK_STATUS(TRUE, "rpc_ns_binding_import_done", status, rpc_s_ok);

    rpc_ep_resolve_binding (bind_handle,
	cs_test_v1_0_c_ifspec,
	&temp_status);

    CHECK_STATUS(TRUE, "rpc_ep_resolve_binding", temp_status, rpc_s_ok);

    if(rpc_mgmt_is_server_listening(bind_handle, &status)
	&& temp_status == rpc_s_ok)
    {
	; /* Do nothing. */
    }
    else
    {
	dce_error_inq_text ((unsigned long)status,
	 err_buf, (int *)&temp_status);
	printf("is_server_listening error -> %s\\n", err_buf);
    }

.ne 14
    /*
     *  This program reads the data from a file.
     */

    fp_in = fopen("./i18n_input_data", "r");

    if (fp_in == NULL)
    {
	printf("i18n_input_data open failed\\n");
	return;
    }

     fp_out = fopen("./i18n_method_fixed_result_file", "w");

     if (fp_out == NULL)
     {
	printf("i18n_result_file open failed\\n");
	fclose(fp_in);
	return;
    }

    rpc_num = 1;
    while (!feof(fp_in))
    {
	(void)fgets((char *)net_string, SIZE, fp_in);

	temp_status = cs_fixed_trans(bind_handle, net_string, loc_string);

	if (temp_status != rpc_s_ok)
	{
	    dce_error_inq_text(temp_status, err_buf, (int *)&status);

	    printf("FAILED %ld  MSG: %s\\n", (unsigned long)temp_status, \\
	      err_buf);
	}
	else
	{
	    printf("PASSED rpc #%d\\n", rpc_num++);
	    (void)fputs((char *)loc_string, fp_out);
	    (void)fputs("\\n", fp_out);
	}
    }

    fclose(fp_in);
    fclose(fp_out);

    return;
}
.ps 12
.vs 14
.oE
.H 3 "Writing the Evaluation Routine"
.iX "code set" "evaluation"
.iX "character set" "evaluation"
.iX "evaluation routine"
.iX "internationalized RPC" "evaluation routines"
Recall from Chapter 1 of the \*(Di and Chapter 11 of
this guide that when a prospective client
attempts to import binding information from a namespace entry
that it looks up by name, the NSI import routine checks the
binding for compatibility with the client by comparing interface
UUIDs and protocol sequences.  If the UUIDs match and
the protocol sequences are compatible, the NSI operation
considers the binding handle contained in the server entry to be
compatible and returns it to the client.  Internationalized
clients need to perform additional compatibility
checking on potential server bindings: they need to
evaluate the server for character and code set compatibility.
.P
The purpose of the character and code set compatiblity
evaluation routine is to determine
.ML
.LI
Whether the character set the server supports is compatible
with the client's character set, since incompatible character
sets result in unacceptable data loss during character conversion.
.LI
.iX "conversion method"
.iX "code set" "conversion" "method"
The level of code set compatibility between client and server,
which determines the \*Econversion method\*O that the client and
server will use when transferring character data between them.
.LE
.P
A conversion method is a process for converting one code set
into another.  There are four conversion methods:
.ML
.LI
Receiver Makes It Right (RMIR)\(emThe
recipient of the data is responsible for converting the data
from the sender's code set to its own code set.
This is the method that the RPC communications protocol uses
to convert PCS character data between ASCII and EBCDIC code sets.
.LI
Client Makes It Right (CMIR)\(emThe client converts the input
character data to be sent to the server into the server's code set
before the data is transmitted over the network, and converts output
data received from the server from the server's code set into its own
local code set.
.LI
Server Makes It Right (SMIR)\(emThe server converts the input
character data received from the client into its local code set
from the client's code set and converts output data to be sent
to the client into the client's code set before the data is
transmitted over the network.
.LI
.ne 7
Intermediate\(emBoth client and server convert to a common
code set.  DCE defines a default intermediate code set to be used when there
is no match between the client and server's supported code sets;
.iX "code set" "ISO 10646"
.iX "code set" "universal"
.iX "universal code set"
.iX "intermediate code set"
.iX "code set" "intermediate"
this code set is the ISO 10646 ``universal'' code set.  Sites can
also specify other code sets to be used as intermediate code sets
in preference to ISO 10646; to do this, they run the \*Lcsrc\*O
utility.  See the \*Lcsrc(8dce)\*O reference pages 
for a description of \*Lcsrc\*O utility usage.
.LE
.P
.iX "code set" "conversion" "model"
.iX "conversion model"
A character and code set compatibility evaluation routine
generally employs a \*Econversion model\*O when determining
the level of code set compatibility.
A conversion model is an ordering of conversion methods; for example,
``CMIR first, then SMIR, then intermediate.''  Consequently, the actual
conversion method used is determined at runtime.
.H 4 "DCE RPC Evaluation Routines"
.iX "evaluation routine"
DCE RPC provides two character and code set compatibility evaluation
routines: \*Lrpc_cs_eval_with_universal(\|)\*O and
\*Lrpc_\%cs_\%eval_\%without_\%universal(\|)\*O.  To use either one of
these routines, specify their names in the evaluation function
argument to the \*Lrpc_\%ns_\%import_\%ctx_\%add_\%eval(\|)\*O routine.
(The sample client code shown in Section 16.3.5.3 specifies
a DCE RPC character and code set evaluation routine.)
.P
The \*Lrpc_cs_eval_with_universal(\|)\*O routine first compares the
client's local code set with the server's local code set.  If they
are the same, client-server character and code set compatibility
exists.  The routine returns to the
NSI import routine, which returns the server binding to the client.
.P
If the routine finds that the client and server local code sets differ,
it calls the routine \*Lrpc_cs_char_set_compat_check(\|)\*O to determine
client-server character set compatibility.  If the client and server
are using the same character set, it will be safe for them to
exchange character data despite their use of different encodings
for the character data.  Clients and servers using different
character sets are considered to be incompatible since the
process of converting the character data from one character
set to the other will result in significant data loss.
.P
.ne 10
Using the client and server's local code set identifiers
as indexes into the code set registry, the
\*Lrpc_cs_char_set_compat_check(\|)\*O routine obtains the
registered values that represent the character set(s) that
the specified code sets support.  If the client and server support
just one character set, the routine compares the values for compatibility.
If the values do not match, then the client-server character sets
are not compatible; for example, the client is using the German
character set and the server is using the Korean character set.
In this case, the routine returns the status code
\*Lrpc_s_ss_no_compat_charsets\*O to the evaluation routine
so that binding to that server will be rejected.
.P
If the client and server support multiple character sets,
the \*Lrpc_cs_char_set_compat_check(\|)\*O routine determines
whether at least two of the sets are compatible.  If two or more
sets match, the routine considers the character sets compatible
and returns a success status code to the evaluation routine.
.PP
In the case where the client and server are character set
compatible, the \*Lrpc_cs_eval_with_universal(\|)\*O
routine uses the following model to determine a conversion method: 
.ML
.LI
RMIR (receiver makes it right)
.LI
SMIR (client uses its local code set, server converts to and from it)
.LI
CMIR (server uses its local code set, client converts to and from it)
.LI
Use an intermediate code set
.LI
Use the universal (ISO 10646) code set
.LE
.P
This conversion model translates into the following steps:
.AL
.LI
The \*Lrpc_cs_eval_with_universal(\|)\*O routine
takes the client's local code set and searches through the
server's code sets array to determine whether it has a converter
for the client's local set.  Then it takes the server's local code
set and searches through the client's code sets array to see if
it has a converter for the server's local code set.
.LI
If both client and server support converters for each other's
local code sets (that is, they can convert to and from each other's
local code set), the routine sets the conversion method to RMIR.
.LI
If the server can convert to and from the client's local code set,
but the client cannot convert from the server's local code set,
the routine sets the conversion method to SMIR.
.LI
.ne 3
If the client can convert to and from the server's local code
set, but the server cannot convert to and from the client's
local code set, the routine sets the conversion method to CMIR.
.P
If the conversion method is SMIR or RMIR, the \*Lrpc_cs_eval_with_universal(\|)\*O
routine sets both the sending tag and the desired receiving tag to 
the code set value that represents the client's local code set.
In the case of CMIR, the routine sets both the sending tag and
the desired receiving tag to the code set value that represents
the server's local code set.
.LI
If neither client nor server support each other's local
code set, the routine next determines if they both
support a code set into which they both can convert to/from
their local code sets.  If it finds an intermediate set
into which they both can convert, it sets the conversion
method to INTERMEDIATE and sets the sending tag and desired
receiving tag to the code set value that represents the
intermediate code set to use.
.LI
If the routine does not find any intermediate code set
into which client and server can convert, it sets the
sending tag and desired receiving tag to the code set
value that represents the ISO 10646 universal code set, which
is the default intermediate code set that all DCE clients
and servers support.
.LE
.P
The \*Lrpc_cs_eval_without_universal(\|)\*O routine uses the
following conversion model to determine a conversion method: 
.ML
.LI
RMIR
.LI
SMIR (client uses its local code set, server converts to and from it)
.LI
CMIR (server uses its local code set, client converts to and from it)
.LI
Intermediate
.LI
Reject for code set incompatibility
.LE
.P
Consequently, the \*Lrpc_cs_eval_without_universal(\|)\*O uses the same
evaluation logic as \*Lrpc_cs_eval_with_universal(\|)\*O except that
it rejects the server binding if the client and server do not support
a common code set to use as an intermediate code set.
.H 4 "Writing Customized Evaluation Routines"
Programmers writing internationalized RPC applications can
develop their own character and code set compatibility evaluation
routines if their applications' needs are not met by the DCE RPC evaluation
routines.  These programmers may want to use the following DCE RPC routines
within their evaluation routine:
.ML
.LI
The \*Lrpc_rgy_get_codesets(\|)\*O routine
.LI
The \*Lrpc_cs_char_set_compat_check(\|)\*O routine
.LI
The \*Lrpc_cs_binding_set_tags(\|)\*O routine
.LI
The \*Ldce_cs_loc_to_rgy(\|)\*O routine
.LI
The \*Lrpc_ns_mgmt_read_codesets(\|)\*O routine
.LI
The \*Lrpc_ns_mgmt_free_codesets(\|)\*O routine
.LE
.P
Refer to the \*(Dr for complete details about these routines.
.P
Programmers who write their own evaluation routines can also select
when evaluation is performed; that is, they can defer evaluation
from occurring in the client code, or they can defer evaluation
completely at the client side and let it take place in the server instead.
Programmers who desire to defer evaluation to the client stub can write
an evaluation routine that sets the client's and server's supported code
sets into the binding handle returned by the client, then write
the evaluation logic into the stub support routine for tag setting
so that it performs evaluation within the client stub.
.P
Applications that do evaluation in the client stub take
the chance that the binding handle that is evaluated
is the only binding handle available.  For example, suppose there
are three binding handles.  Two are character and code set compatible,
and one is incompatible.  The incompatible binding is selected for RPC.
If you evaluate in the tag-setting routine, you cannot reselect to get the
other compatible bindings.
.P
In general, it is recommended that character and code set evaluation
take place in the client, rather than the server, for performance reasons.
Also, once the server is selected and a connection is established between
it and the client, the client cannot typically reselect the server
because the code sets are incompatible.
.P
Within the client, it is recommended that evaluation be performed
in the client code rather than in the client stub because deferring
evaluation to occur in the client stub removes any way for the
client to gain access to other potential binding handles.
.H 4 "Notes About Tag Setting"
.PP
The DCE RPC character and code set compatibility
evaluation routines set the method and the
code set tag values into a data structure in
the binding handle returned to the client.
These routines always set the sending tag and
desired receiving tag to the same code set value.
.P
In addition, if the application uses the DCE RPC routine
\*Lrpc_cs_get_tags(\|)\*O to set the code set tags
for the stubs, the value of the server's receiving tag
will always be the value of what the client sent to it
in the desired receiving tag.  If RMIR is used, the desired
receiving tag is the server's current code set.
.P
RPC application programmers who do not want to use the
DCE RPC-provided evaluation routines can use the
\*Lrpc_cs_binding_set_tags(\|)\*O routine
to set the code set tag values into a binding
handle.
.H 4 "Example Character and Code Set Evaluation Logic"
.PP
Here is an example client program of the \*Lcs_test\*O
interface that provides its own character and code
set evaluation logic.  This example client uses
the \*Lrpc_cs_binding_set_tags(\|)\*O routine to
set the code set tags within the client code
rather than using a tag-setting routine to set
them within the stub code.
.P
.oS
.ps 10
.vs 12
#include <stdio.h>
#include <locale.h>
#include <dce/rpc.h>
#include <dce/rpcsts.h>
#include <dce/dce_error.h>

#include "cs_test.h"		/* IDL generated header file */

.ne 7
/*
 * Result check MACRO
 */
#define CHECK_STATUS(t, func, returned_st, expected_st) \\
{ \\
    if (returned_st == expected_st) { \\
    ;  /* No operation */

    } else { \\
	dce_error_inq_text(returned_st,\\
	  (unsigned char *)unexpected, &dce_status); \\
	dce_error_inq_text(expected_st,\\
	 (unsigned char *)expected, &dce_status); \\
	printf("FAILED %s()\\nresult:   %s\\nexpected:   %s\\n\\n", \\
	    func, unexpected, expected); \\
    } \\
} \\

static unsigned char    unexpected[dce_c_error_string_len];
static unsigned char    expected[dce_c_error_string_len];
static int              dce_status;


void 
main(void)
{
    rpc_binding_handle_t	bind_handle;
    rpc_ns_handle_t	lookup_context;
    rpc_binding_vector_p_t	bind_vec_p;
    unsigned_char_t	*entry_name;
    unsigned32		binding_count;
    cs_byte		net_string[SIZE];
    cs_byte		loc_string[SIZE];
    int			i, k, rpc_num;
    int			model_found, smir_true, cmir_true;
    rpc_codeset_mgmt_p_t	client, server;
    unsigned32		stag;
    unsigned32		drtag;
    unsigned16		stag_max_bytes;
    error_status_t		status;
    error_status_t		temp_status;
    unsigned char		err_buf[256];
    char			*nsi_entry_name;
    char			*client_locale_name;
    FILE			*fp_in, *fp_out;

    nsi_entry_name = getenv("I18N_SERVER_ENTRY");

    setlocale(LC_ALL, "");

.ne 8
    rpc_ns_binding_lookup_begin (
	rpc_c_ns_syntax_default,
	(unsigned_char_p_t)nsi_entry_name,
	cs_test_v1_0_c_ifspec,
	NULL,
	rpc_c_binding_max_count_default,
	&lookup_context,
	&status );

    CHECK_STATUS(TRUE, "rpc_ns_binding_lookup_begin", status, rpc_s_ok);

    rpc_ns_binding_lookup_next (
	lookup_context,
	&bind_vec_p,
	&status );

    CHECK_STATUS(TRUE, "rpc_ns_binidng_lookup_next", status, rpc_s_ok);

    rpc_ns_binding_lookup_done (
	&lookup_context,
	&status );

    CHECK_STATUS(TRUE, "rpc_ns_binding_lookup_done", status, rpc_s_ok);

    /* 
     *  Get the client's supported code sets 
     */
    rpc_rgy_get_codesets (
	&client,
	&status );

    CHECK_STATUS(TRUE, "rpc_rgy_get_codesets", status, rpc_s_ok);

    binding_count = (bind_vec_p)->count;
    for (i=0; i < binding_count; i++)
    {
	if ((bind_vec_p)->binding_h[i] == NULL)
	    continue;

	rpc_ns_binding_select (
	    bind_vec_p,
	    &bind_handle,
	    &status );

	CHECK_STATUS(FALSE, "rpc_ns_binding_select", status, rpc_s_ok);

.ne 6
	if (status != rpc_s_ok)
	{
	    rpc_ns_mgmt_free_codesets(&client, &status);
	    CHECK_STATUS(TRUE, "rpc_ns_mgmt_free_codesets",
	     status, rpc_s_ok);
	}

	rpc_ns_binding_inq_entry_name (
	    bind_handle,
	    rpc_c_ns_syntax_default,
	    &entry_name,
	    &status );

	CHECK_STATUS(TRUE, "rpc_ns_binding_inq_entry_name", status, \\
	  rpc_s_ok);
	if (status != rpc_s_ok)
	{
	    rpc_ns_mgmt_free_codesets(&client, &status);
	    CHECK_STATUS(TRUE, "rpc_ns_mgmt_free_codesets",
	     status, rpc_s_ok);
	}

	/* 
    	 *  Get the server's supported code sets from NSI 
    	 */
	rpc_ns_mgmt_read_codesets (
	    rpc_c_ns_syntax_default,
	    entry_name,
	    &server,
	    &status );

	CHECK_STATUS(FALSE, "rpc_ns_mgmt_read_codesets", status, \\
	  rpc_s_ok);

	if (status != rpc_s_ok)
	{
	rpc_ns_mgmt_free_codesets(&client, &status);
	    CHECK_STATUS(TRUE, "rpc_ns_mgmt_free_codesets",
	     status, rpc_s_ok);
	}

.ne 12
	/*  
    	 *  Start evaluation 
    	 */
	if (client->codesets[0].c_set == server->codesets[0].c_set)
	{
	    /* 
	     *  client and server are using the same code set 
	     */
	    stag = client->codesets[0].c_set;
	    drtag = server->codesets[0].c_set;
	    break;
	}

	/* 
	 *  check character set compatibility first 
	 */
	rpc_cs_char_set_compat_check (
	    client->codesets[0].c_set,
	    server->codesets[0].c_set,
	    &status );

	CHECK_STATUS(FALSE, "rpc_cs_char_set_compat_check",
			 status, rpc_s_ok);

	if (status != rpc_s_ok)
	{
	    rpc_ns_mgmt_free_codesets(&server, &status);
	    CHECK_STATUS(TRUE, "rpc_ns_mgmt_free_codesets",
	     status, rpc_s_ok);
	}

	smir_true = cmir_true = model_found = 0;

	for (k = 1; k <= server->count; k++)
	{
	    if (model_found)
		break;

	    if (client->codesets[0].c_set 
		== server->codesets[k].c_set)
	    {
		smir_true = 1;
		model_found = 1;
	    }

.ne 7
	    if (server->codesets[0].c_set
		== client->codesets[k].c_set)
	    {
		cmir_true = 1;
		model_found = 1;
	    }
	}

	if (model_found)
	{
	    if (smir_true && cmir_true)
	    {
		/* RMIR model works */
		stag = client->codesets[0].c_set;
		drtag = server->codesets[0].c_set;
		stag_max_bytes 
		    = client->codesets[0].c_max_bytes;
	    }
	    else if (smir_true)
	    {
		/* SMIR model */
		stag = client->codesets[0].c_set;
		drtag = client->codesets[0].c_set;
		stag_max_bytes
		    = client->codesets[0].c_max_bytes;
	    }
	    else
	    {
		/* CMIR model */
		stag = server->codesets[0].c_set;
		drtag = server->codesets[0].c_set;
		stag_max_bytes
		    = server->codesets[0].c_max_bytes;
	    }

	    /* 
	     *  set tags value to the binding 
	     */
	    rpc_cs_binding_set_tags (
		&bind_handle,
		stag,
		drtag,
		stag_max_bytes,
		&status );

.ne 12
	    CHECK_STATUS(FALSE, "rpc_cs_binding_set_tags",
	     status, rpc_s_ok);
	    if (status != rpc_s_ok)
	    {
		rpc_ns_mgmt_free_codesets(&server, &status);
		CHECK_STATUS(FALSE, "rpc_ns_mgmt_free_codesets",
		 status, rpc_s_ok);
		rpc_ns_mgmt_free_codesets(&client, &status);
		CHECK_STATUS(TRUE, "rpc_ns_mgmt_free_codesets",
		 status, rpc_s_ok);
	    }
	}
	else
	{
.ne 6
	    /* 
	     *  try another binding 
	     */
	    rpc_binding_free (
		&bind_handle,
		&status );

	    CHECK_STATUS(FALSE, "rpc_binding_free", status, rpc_s_ok);
	    if (status != rpc_s_ok)
	    {
		rpc_ns_mgmt_free_codesets(&server, &status);
		CHECK_STATUS(FALSE, "rpc_ns_mgmt_free_codesets", \\
		  status, rpc_s_ok);
		rpc_ns_mgmt_free_codesets(&client, &status);
		CHECK_STATUS(TRUE, "rpc_ns_mgmt_free_codesets", \\
		  status, rpc_s_ok);
	    }
	}
    }

    rpc_ns_mgmt_free_codesets(&server, &status);
    CHECK_STATUS(FALSE, "rpc_ns_mgmt_free_codesets", status, rpc_s_ok);

    rpc_ns_mgmt_free_codesets(&client, &status);
    CHECK_STATUS(TRUE, "rpc_ns_mgmt_free_codesets", status, rpc_s_ok);

    if (!model_found)
    {
	printf("FAILED No compatible server found\\n");
	tet_result(TET_DCE_FAIL);
    }

    rpc_ep_resolve_binding (bind_handle,
	cs_test_v1_0_c_ifspec,
	&temp_status);

    CHECK_STATUS(TRUE, "rpc_ep_resolve_binding", temp_status, rpc_s_ok);

.ne 11
    if(rpc_mgmt_is_server_listening(bind_handle, &status)
	&& temp_status == rpc_s_ok)
    {
	printf("PASSED rpc_mgmt_is_server_listening()\n");
    }
    else
    {
	dce_error_inq_text ((unsigned long)status, err_buf,
	 (int *)&temp_status);
	    printf("is_server_listening error -> %s\\n", err_buf);
    }

    fp_in = fopen("./i18n_input_data", "r");

    if (fp_in == NULL)
    {
	printf("i18n_input_data open failed\\n");
	tet_result(TET_DCE_FAIL);
    }

    fp_out = fopen("./i18n_tags_fixed_result_file", "w");

    if (fp_out == NULL)
    {
	printf("i18n_result_file open failed\\n");
	tet_result(TET_DCE_FAIL);
    }

    rpc_num = 1;
    while (!feof(fp_in))
    {
	(void)fgets((char *)net_string, SIZE, fp_in);

	temp_status = cs_fixed_trans(bind_handle, net_string, loc_string);

	if (temp_status != rpc_s_ok)
	{
	    dce_error_inq_text(temp_status, err_buf, (int *)&status);

	    printf("FAILED %ld  MSG: %s\\n", (unsigned long)temp_status, \\
	      err_buf);
	}
	else
	{
	    printf("PASSED rpc #%d\\n", rpc_num++);
	    (void)fputs((char *)loc_string, fp_out);
	    (void)fputs("\n", fp_out);
	}
    }

.ne 5
    fclose(fp_in);
    fclose(fp_out);

    return;
}
.ps 12
.vs 14
.oE
