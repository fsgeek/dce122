...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990-1996 Open Software Foundation, Inc. 
...\" ALL RIGHTS RESERVED (DCE). See the file named COPYRIGHT.DCE in the 
...\" src directory for the full copyright text. 
...\" 
...\" 
...\" HISTORY
...\" $Log: distrib_obj_usage.gpsml,v $
...\" Revision 1.1.4.2  1996/12/17  19:54:27  damon
...\" 	Expanded OSF C O P Y R I G H T   N O T I C E
...\" 	[1996/12/17  19:53:33  damon]
...\"
...\" Revision 1.1.4.1  1996/05/10  21:27:33  wardr
...\" 	{enh,R1.2.2}
...\" 	Removed Changebars
...\" 	[1996/05/10  21:27:05  wardr]
...\" 
...\" Revision 1.1.2.5  1996/03/25  14:04:41  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/25  14:04:15  wardr]
...\" 
...\" Revision 1.1.2.4  1996/03/07  20:12:16  weir
...\" 	Commented out several iX entries-- they cause AIX build errors
...\" 	[1996/03/07  20:11:27  weir]
...\" 
...\" Revision 1.1.2.3  1995/11/10  16:17:20  wardr
...\" 	{enh CR13032 R1.2.1} Final touchup and indexing.
...\" 	[1995/11/10  16:16:41  wardr]
...\" 
...\" Revision 1.1.2.2  1995/11/02  01:00:46  wardr
...\" 	{enh CR13032 R1.2.1} Fixed figures and final edits.
...\" 	[1995/11/02  01:00:20  wardr]
...\" 
...\" Revision 1.1.2.1  1995/09/13  20:13:07  wardr
...\" 	{enh,13032,R1.2.1}
...\" 	Add new chapter 15 - distrib_obj_usage.gpsml
...\" 	[1995/09/13  20:12:47  wardr]
...\" 
...\" $EndLog$
...\" 
.H 1 "Developing Applications that Use Distributed Objects"
.P
.iX "distributed objects"
.iX "objects" "developing distributed"
Before you read this chapter and begin developing with distributed objects,
first read 
\*VOSF DCE Application Development Guide - Introduction and Style Guide\*O,
chapter 8.
This chapter describes how to develop object-oriented, 
DCE applications that have distributed objects. 
The chapter introduces C++ features of the 
Interface Definition Language (IDL) 
that allow direct development of C++ DCE applications.
It covers the following topics:
.iX "C++ features"
.iX "C++ DCE applications"
.ML
.LI
IDL and the class hierarchy of a DCE application
.LI
Servers that manage distributed objects
.LI
Clients that use distributed objects
.LI
Multiple interfaces and interface inheritance
.LI
Integrating C and C++ clients and servers
.LI
Using objects from class libraries as RPC parameters
.LE
.H 2 "IDL and the Class Hierarchy of a DCE Application"
.P
.iX "class hierarchy"
When you develop a DCE application, be it object oriented or
otherwise, you begin by creating an interface definition file.
This file specifies the operations (with necessary data structures)
available for a client to call, all of which a server of this
interface must implement.
.P
Although IDL resembles the C programming language, 
it is intended to be language independent.
This means that the applications that are developed could use any
programming language that makes sense for them.  However, the IDL
compiler generates intermediate stub files in either C or C++, two of
the most popular languages in use today.  We use a particular
programming language to take advantage of its features when developing
an application.  However, an application developed in another language
could use mechanisms (such as wrapper routines) that call the routines
generated by the IDL compiler.
.P
...\" COMMENTED OUT FOR AIX:
...\" .iX "-lang cxx option"
.iX "cxx argument to -lang"
.iX "IDL compiler" "-lang cxx option"
The \*L-lang\*O option of the IDL compiler when used with a
\*V\*Lcxx\*O\*O argument generates C++ intermediate stub files
rather than C intermediate stub files.  In order to support the
generation of C++ stubs, the IDL also needs
additional features to give applications developed in C++ a cleaner
and more efficient use of the distributed application features of DCE.
This section describes how to use these features in interface
definitions.

.H 3 "Specifying a C++ Class via an IDL Interface"
.P
.iX "C++ class via IDL interface"
An IDL interface definition and a C++ class are very similar.  An IDL
interface definition specifies the data structures and operations that
an application needs to use a distributed interface.  A C++ class
specifies the data structures and functions that an application needs
to use a type of object.  IDL and the IDL compiler blend together the
distributed computing capabilities of an interface definition with the
object-oriented features of a C++ class to specify \*Vdistributed
objects\*O.
.P
The following example shows an interface definition for a distributed
Matrix object:
.oS
FILE matrix.idl ---------------------------------------------------
[
    uuid(24cb0eda-3eb9-11ce-b1ce-08002bbbf636) 
] interface Matrix 
{
    /* Create a new 2 by 2 Matrix. This operation requires an ACF */
    /* to tell the stubs this is a creator operation.  */
    Matrix * createMatrix(
	[in] long v11,
	[in] long v12,
	[in] long v21,
	[in] long v22
    );

    /* Create a new Matrix of size rows by columns and return TRUE.*/
    /* If server does not support the size requested, return FALSE  */
    /* and the maximum size in rows and columns that it supports.*/
    /* This operation requires an ACF to tell the stubs this is a    */
    /* static operation.  */
    boolean newMatrix(
	[in, out] long &rows,
	[in, out] long &columns,
	[out] Matrix ** m
    );

    /* The rest of the operations operate on the existing object */
    /* that invokes them (this Matrix).  */

    /* Set a new value in this Matrix. */
    void set(
	[in] long row,
	[in] long col,
	[in] long value
    );

    /* Get a value from this Matrix. */
    long get(
	[in] long row,
	[in] long col
    );

    /* Return a new Matrix that is the inverse of this Matrix. */
    Matrix * inverse();

    /* Return a new Matrix that is the product of this Matrix */
    /* and m1.*/
    Matrix * multiply(
	[in] Matrix * m1
    );

    /* Return in Matrix m2 the sum of this Matrix and m1. */
    void add(
	[in] Matrix * m1,
	[out] Matrix ** m2
    );

}
.oE
.P
Interface definitions and C++ classes are both specifications, not
implementations.  An implementation of the IDL interface definition is
a server's manager code, and an instance of the class is an object of
that class.  The operations of the Matrix interface are described as
follows:
.VL
.LI "\*LcreateMatrix\*O"
If an interface designer expects clients to create dynamic objects, at
least one operation must be a static function that creates a new
object. For example, the \*LcreateMatrix\*O operation is intended to
be a static member function.  Static member functions do not require
an existing object before they are called.
.LI "\*LnewMatrix\*O"
.iX "C++ reference operator"
.iX "reference operator, &"
.iX "&, reference operator"
Parameters are typically passed-by-value in C++. Apply the reference
operator (\*L&\*O) to parameters you want to pass by reference.  A reference
parameter is required if the function changes the value.  In this
example, the number of the rows and columns are input but the values
change if the function cannot create the Matrix requested.
.LI "\*Lset\*O"
The \*Lset\*O operation sets an individual value in an existing Matrix
object.
.LI "\*Lget\*O"
The \*Lget\*O operation obtains an individual value from an existing
Matrix object.
.LI "\*Linverse\*O"
The \*Linverse\*O operation returns a new Matrix object that is the
inverse of an existing Matrix object.
.LI "\*Ladd\*O"
The \*Ladd\*O operation does not return a value but has an output
parameter that is a new Matrix object.  The output is the sum of an
existing Matrix object and an input parameter that is a Matrix object.
.LE
.P
.iX "encapsulated data"
.iX "public interface"
.iX "private data"
It is not appropriate to encapsulate data in the definition of a
public interface; that would be implementation detail, which does not
belong in the interface definition.  Therefore, there is no IDL
concept of \*Vprivate\*O data as there is in C++.  However, the base
class from which all IDL interface classes are derived does
encapsulated binding data and RPC mechanisms.

.H 3 "IDL-Generated Classes as Part of Your Hierarchy"
.P
.iX "manager class header file"
...\" COMMENTED OUT FOR AIX:
...\" .iX "-lang cxx option"
The interface definition is compiled with the following IDL compiler
command to generate an intermediate C++ header file, client stub, 
server stub, and manager class header file:
.iS
\*Lidl -lang cxx matrix.idl\*O
.iE
.P
The IDL compiler then automatically invokes the local language
compiler by default.  In this case it invokes the C++ compiler to
create binary stub files that are used in the development of clients
and servers.
.P
The IDL compiler automatically uses an Attribute Configuration File 
(ACF) if one is available in its
search directories.  C++ applications use an ACF to specify features
such as static member functions, implementation class names, a lookup
function for named or persistent objects, and header files for
inclusion in stub files.
.P
.iX "class hierarchies"
.iX "RPC base class"
.iX "interface class"
.iX "proxy class"
.iX "manager class"
Class hierarchies are created by the IDL compiler 
and made part of the clients and servers.  
The hierarchies include an RPC base class that encapsulates
the distributed nature of objects.  An abstract interface class is also 
created by the IDL compiler and derived from the RPC base class.  
The interface class
includes the data types and nonstatic member functions of the
interface definition and is the common interface used by clients and
servers.  The interface class contains no implementation.  Therefore,
clients and servers each need to derive implementation classes from
the interface class. 
Clients have an \*Lidl\*O-generated
implementation class generated for them, called a \*Vproxy class\*O.
Servers have an \*Lidl\*O-generated
class generated for them called a \*Vmanager class\*O.  
.P
.iX "manager class functions"
Server developers must implement the manager class functions by either
modifying the generated manager class header file or deriving an 
application-specific class from the manager class.
The manager class name generated by the IDL compiler is a combination
of the interface name and \*LMgr\*O.  For example, the manager class
for our \*LMatrix\*O interface is \*LMatrixMgr\*O.  
The generated class is placed in a header file with a name
created from the combination the interface file name and the \*L_mgr\*O suffix.
For example, \*Lmatrix_mgr.h\*O.
.P
.ne 1.5i
If you decide to implement the manager by modify the generated 
manager class, you want to be sure that any subsequent invocation 
of the IDL compiler does not overwrite your manager class code.
...\" COMMENTED OUT FOR AIX:
...\" .iX "-no_cxxmgr option"
.iX "IDL compiler" "-no_cxxmgr option"  
Use the \*L-no_cxxmgr\*O option with the 
IDL compiler command to supress generating a manager class.
.iS
\*Lidl -lang cxx -no_cxxmgr  matrix.idl\*O
.iE
.P
.H 2 "Servers that Manage Distributed Objects"
.P
.iX "managing distributed objects"
An application creates local objects for its own internal use.
Servers must manage these application-specific objects, just as any
application does.  In addition, distributed object servers must manage
two other basic kinds of objects for their clients: 
.iX "dynamic objects"
.iX "named objects"
\*Edistributed dynamic objects\*O and \*Edistributed named objects\*O.
The following
subsections cover a number of programming tasks and topics of interest
to server developers.  The basic programming tasks server
developers typically perform include the following:
.AL
.LI
Implementing dynamic objects for clients, if needed
.LI
Implementing static member functions, if any
.LI
If clients can pass local objects in calls to the server,
linking in both server and client stubs so that manager functions
automatically access parameters that are client-local objects
.LE
.P
Other topics of interest to server developers include naming objects, 
dynamically creating named or persistent objects with a lookup function,
and using the DCE backing store for persistent objects.

.H 3 "Initializing Object-Oriented Servers"
.P
.iX "initializing object-oriented servers"
.iX "object-oriented servers" "initializing"
DCE servers consist of two major portions of code: 
\*Einitialization code\*O and \*Emanager code\*O.
All servers must perform some initialization prior
to providing services and objects.  In addition to initialization
code, the server also has manager code that implements each interface
that a server supports.  The manager code contains the implementation
.iX "methods"
of both the static and nonstatic member functions (or methods).
.P
In an object-oriented development environment, 
there would generally be a server class with each server being an 
instance of that class.
Although interesting and important for object-oriented applications, 
the design and implementation of
such an environment is beyond the scope of this chapter.  However,
there are a few issues to consider when initializing C++ servers,
as follows:
.ML
.LI
.ne 2i
Server Registration
.P
.iX "server registration in C++"
Servers are automatically registered by server stubs, so if your code calls 
the \*Lrpc_server_register_if(\|)\*O routine, 
you will get a warning indicating the server is already registered.
.LI
Entry point vectors (EPVs) and C++ function tables
.P
.iX "entry point vectors in C++"
When a C++ application is compiled, a function table is 
automatically generated for each class.  The EPV mechanism in 
DCE is necessary for languages that do not supply such a feature, 
such as C.  Use NULL (the default EPV) for C++ applications.  
.LI
Named and persistent objects
.P
Your server may need to create persistent or long-lived named objects 
before the server begins servicing client requests.  
Naming objects is described later in this chapter.
.LI
Exceptions
.P
.iX "exceptions in C++"
DCE supplies exception handling macros such as 
\*LTRY\*), \*LCATCH\*O, and \*LFINALLY\*O
for use in distributed applications.  You should 
use DCE's macros in your applications instead of the standard 
C++ macros to be sure exceptions are propagated properly 
from servers to clients.
.LE
.P
See the first chapter of the 
\*VOSF DCE Application Development Guide
- Introduction and Style Guide,\*O 
for the typical steps DCE requires to initialize a server.  
The following subsections describe features needed in 
manager code, the code responsible for a server's
specific implementations of the interfaces supported.
.P
.H 3 "Implementing Distributed-Dynamic Objects"
.P
.iX "distributed-dynamic objects"
After the server has been initialized and is listening for calls, one
obvious question arises:  How does the server create distributed
objects?  The server creates objects locally, just as they are created
in typical C++ applications, by allocating variables of the class
.iX "C++ new operator"
.iX "new operator"
types or by dynamically creating them with the C++ \*Lnew\*O operator,
as shown in the following example:
.oS
// m1 is allocated as a variable of class Matrix
Matrix m1;
// m2 is a pointer variable of class Matrix allocated with "new"
Matrix *m2 = new MatrixMgr(0, 0, 0, 0);
.oE
.P
However, clients have no way to use these objects since they are only
local and not yet available as distributed objects.
.P
For distributed dynamic objects, the server needs a way to know
when a client requests that the server create a dynamic object.
This is done by using an ACF to associate an appropriate 
interface operation with the server's implemented manager class. 
You must then write manager code that turns server-local
objects into distributed dynamic objects.
.P
When you compile the interface definition file to create the interface
header file and server stub, you use an ACF to customize how your
application code uses the interface, as shown in the following:
.ne 2.5i
.oS
/* FILE NAME: matrix.acf */
/* This file defines some attributes for the Matrix interface */
interface Matrix
{
	/* include header files generated into the server stub */
	[sstub] include "matrix_mgr";

	/* createMatrix should be mapped as a creator function.       */
	/* The MatrixMgr is a class derived from the interface class. */
	[cxx_new(MatrixMgr)] createMatrix();
	.
	.
	.
.oE
.VL
.LI "\*L[sstub] include "matrix_mgr";"
.br
\*OUse the \*Linclude\*O statement with the\*L sstub\*O attribute to
.iX "sstub attribute"
.iX "ACF" "sstub attribute use"
make the IDL compiler include specific header files in the server stub.  
In this example, this is required so that the stub
has a declaration of the manager class.  
.LI "\*L[cxx_new(MatrixMgr)] createMatrix(\|);\*O"
.br
.iX "cxx_new attribute of ACF"
Use the \*Lcxx_new\*O attribute with the name of the implemented
manager class (\*LMatrixMgr\*O) as an argument, and apply it to the
interface operation that is intended to create a dynamic object,
\*LcreateMatrix.\*O
The manager class can be the \*Lidl\*O-generated one,
as in this example, or it can be one you derived from 
the generated manager class.
.LE
.P
The following C++ code shows examples of constructor and destructor 
functions you write for the manager class (\*L MatrixMgr\*O):
.oS
	.
	.
	.
// Constructor 
MatrixMgr::MatrixMgr(idl_long_int v1, idl_long_int v2,
                     idl_long_int v3, idl_long_int v4)
{
	d[0][0] = v1;
	d[0][1] = v2;
	d[1][0] = v3;
	d[1][1] = v4;
}

// Destructor for a 2x2 Matrix.  
// In this application, the destructor does nothing.
MatrixMgr::\^\*O\s+1~\s-1\*C\^MatrixMgr(void)
{
	return;
}
.oE
.VL
.LI "\*LMatrixMgr::MatrixMgr\*O"
.br
.iX "constructors in C++"
In the trivial case, a constructor automatically initializes the
object allocated by the C++ new operator.  For this application, the
constructor simply fills in the data structure with the values sent in
the remote procedure call. In more realistic applications, the C++
constructor may have to perform additional work. C++ allows you to
define constructor functions that contain application-specific code
that is automatically called immediately after the object is created.
.LI "\*LMatrixMgr::~MatrixMgr\*O"
.br
.iX "destructors in C++"
In addition to a constructor, C++ allows you to define destructor code
that is called to do application-specific cleanup just prior to the
release of storage for the object.  In this example, the
destructor is a dummy function that has no special code and does
nothing.
.LE
.P
When a client initiates the creation of a dynamic object, the server
receives a remote procedure call request for the \*LcreateMatrix\*O
function.  This causes the server stub to call the C++ constructor for
the specified manager class (in this example \*LMatrixMgr\*O), which
creates a new object on the server.  When this happens, the DCE
runtime stores information about the object in a table that also
associates the object with the requesting client.  No other clients
have access to a dynamic object unless the originating client gives an
object reference to another client.  The runtime uses reference
counting to keep track of how many clients know about the
.iX "reference counting"
object.  When a client deletes the object, the reference count on the
server is reduced.  The object on the server is deleted only when the
reference count reaches zero, which indicates that there are no more
clients with references to the object.

.H 3 "Implementing Static Member Functions"
.P
.iX "static member functions"
.iX "static keyword in IDL"
.iX "IDL" "static keyword"
\*EStatic member functions\*O are specified in the interface definition or
with an ACF.  Those operations of an interface that the designer knows
should be static have the \*Lstatic\*O keyword before the operation in
the interface definition file.  For example, the \*LnewMatrix\*O
operation of the Matrix interface is designed to work without an
invoking Matrix, so it could have been specified in the interface
definition as a static member function as follows:
.oS
interface Matrix
	.
	.
	.
	static boolean newMatrix(...);
.oE
.P
The IDL compiler automatically compiles this kind of operation as a
static member function in both the server and client stubs.  Depending
on how a developer wants to implement the interface, it may be
undesirable to commit to a static function.  For example, the
\*LCreateMatrix(\|)\*O function described in the previous section could
have been specified as static in the interface, but it would prevent
the server developer from directly using the built-in constructor
feature of C++ to implement an object creator function.  
Therefore, to give maximum flexibility to both client and server 
developers, the static keyword can be left off the operation and 
then specified as needed in an ACF file.
.P
Of course, creating new objects is just one thing a static member
function can do, and so any number of other static member functions
may be specified in the interface to do whatever application-specific
work is required.
.P
The Matrix interface declares the following operations:
.oS
   Matrix * createMatrix(
	[in] long  v11,
	[in] long  v12,
	[in] long  v21,
	[in] long  v22
    );

    boolean newMatrix(
	[in, out] long   &rows,
	[in, out] long   &columns,
	[out]     Matrix ** m
    );
.oE
.P
The IDL compiler requires an ACF to implement these as static member
functions.  A sample server ACF contains the following:
.oS
/* FILE NAME: matrix.acf */
/* This file defines some attributes for the Matrix interface */

interface Matrix
{
	/* include header files generated into the server stub */
	[sstub] include "matrix_mgr";

	/* createMatrix should be mapped as a creator function.       */
	/* The MatrixMgr is a class derived from the interface class. */
	[cxx_new(MatrixMgr)] createMatrix();

    	/* newMatrix should be mapped as a static member function. */
	[cxx_static] newMatrix();
}
.oE
.VL
.LI "\*L[sstub] include \"matrix_mgr\";"
.br
\*OUse the \*Linclude\*O statement with the \*Lsstub\*O attribute to make
.iX "include statement in ACF"
.iX "sstub attribute"
.iX "ACF" "sstub attribute"
the IDL compiler include specific header files in the server stub.  
In this example, this is required so that the stub has a
declaration of the manager class.
.LI "\*L[cxx_new(MatrixMgr)] createMatrix(\|);\*O"
.br
.iX "cxx_new attribute"
.iX "ACF" "cxx_new attribute"
Use the\*L cxx_new\*O attribute with the name of the implemented
manager class (\*LMatrixMgr\*O) as an argument, and apply it to the
interface operation that is intended to create a dynamic object,
\*LcreateMatrix\*O.  This feature is described in the previous
section.
.LI "\*L[cxx_static] newMatrix;\*O"
.br
.iX "cxx_static attribute"
.iX "ACF" cxx_static attribute
Apply the \*Lcxx_static\*O attribute to the names of all interface
operations you intend to implement as static member functions.
.LE
.P
To complete the story of a static function, the following is an 
example of one trivial implementation of the \*LnewMatrix\*O function.
The code implements only a 2 by 2 Matrix. 
If a client inputs values other than \*L2\*O for
\*Lrows\*O or \*Lcolumns\*O, 
the values are changed to \*L2\*O, and \*LFALSE\*O is returned.
.oS
// Implementation of the static member function declared with an ACF
idl_boolean
Matrix::newMatrix(idl_long_int &rows, idl_long_int &columns, Matrix **m)
{
	if(rows != 2 && columns != 2) //implementing only a 2 by 2 Matrix
	{
	    rows = columns = 2;
	    *m = 0;
	    return FALSE;
	}
	else
	{
	    *m = new MatrixMgr(0, 0, 0, 0);
	    return TRUE;
	}
}
.oE
.P
The \*Lcxx_static\*O attribute can also take an argument that
represents a new name to use for the function.  This may be necessary
in your application if it needs to distinguish between remote and
local versions of a static member function.  In any case, to minimize
changes to your code modules, it is a good idea to keep the
implementation of static functions in files separate from the
nonstatic member functions (the rest of the manager code).  The
following section describes a common example of when to use an
argument for the \*Lcxx_static\*O attribute.

.H 3 "When Function Parameters Are Remote Objects"
.P
.iX "parameters and remote objects"
.iX "remote objects as parameters"
.iX "distributed objects as parameters"
With distributed applications, especially with distributed objects,
the distinction between a client and server is not determined so much
by a program on a specific machine as it is by a state the program is
currently in.  Thus a program can be both a client and a server,
depending on its purposes.  For example, it is possible that, when a
client object uses a function that has another object as an input
parameter (our \*Ladd(\|)\*O function, for example), the input could
easily be an object that is local to the client.  When the server is
executing the \*Ladd(\|)\*O function, it needs a way to transparently
access the input object that is now remote to the server (but local to
the client).
.P
A server accesses client objects by linking in the client stub in
addition to the server stub.  When an object is remote to the server,
information in the binding from a client is used automatically by the
server stub during unmarshalling to create an object reference 
.iX "proxy"
(a proxy) and make remote calls back to the client to access the object
there.  Server code itself does not have to do any special calls.
.P
.ne 1.5i
The following figure illustrates a brief review of all the code
modules a typical server needs.  The server stub for each interface
and initialization code are required to access DCE's distributed
environment.  Each interface requires a manager class, manager code,
and static member functions to implement them.  Each interface with
input object parameters should include the client stub in order for
the server stub to access client-local objects.
.iX "servers use client stub"
.iX "client stub for servers"
.ne 2.5 i
.FG "Servers Need the Client Stub to Access Client-Local Objects"
.pI ../rpc/figures/distrib_obj_usage_01.ps
.P
.iX "C++ and name conflicts"
.iX "cxx_static attribute"
.iX "ACF" "cxx_static attribute"
Making this work includes one other step besides linking in a client
stub.  If there are any static member functions in the interface
class, linking together a client and server stub will produce a C++
compiler error due to a name conflict in the server and client stub
versions of the function.  You use the \*Lcxx_static\*O attribute in
an ACF to rename the server's local version of the static functions.
An example of such an ACF is as follows:
.oS
/* FILE NAME: matrix.acf */

interface Matrix
{
	/* include files generated into the server stub */
	[sstub] include "matrix_mgr", "staticfunc";

	/* createMatrix should be mapped as a creator function.  The  */
	/* argument represents the class that implements the interface.*/
	[cxx_new(MatrixMgr)] createMatrix();

	/* newMatrix should be mapped as a static member function. */
	[cxx_static(LocalMatrix)] newMatrix();
}
.oE
.P
The \*LLocalMatrix\*O argument to the \*Lcxx_static\*O attribute is
the name for this server's local implementation of the function, and
the \*LnewMatrix\*O name refers to the remote (in this case, the
client stub) function.
.P
.iX "include in ACF"
.iX "sstub attribute"
The \*Linclude\*O statement is needed with the \*Lsstub\*O
attribute to include header files that contain declarations needed by
the server stub only.  In this example, the \*Lmatrix_mgr.h\*O file
contains the server's manager class declaration, and the \*Lstaticfunc.h\*O
file contains the declaration of the renamed static function,
\*LLocalMatrix\*O.  The \*Lstaticfunc.h\*O header file is as follows:
.ne 1.5i
.oS
// FILE NAME: staticfunc.h
// This file declares the function(s) to call 
// when invoking local versions of an interface's static functions.
// The prototype signatures should match that of the remote versions.

idl_boolean LocalMatrix(idl_long_int, idl_long_int, Matrix **m);
.oE
.nS note
Servers will work without including the client stub and renaming the
local version of the static functions.  However, if a client ever uses
a member function with an object parameter that is remote to the
server, a runtime error occurs.  If this happens, the server raises an
.iX "\*Lrpc_x_no_client_stub\*O exception"
.iX "no client stub exception"
exception (\*Lrpc_x_no_client_stub\*O) to propagate back to the 
client that indicates the client stub is not included in the server.
.nE

.H 3 "Naming Objects"
.P
.iX "naming objects"
.iX "objects" "naming"
This section explains how to do the following for named objects:
.ML
.LI
Register named objects
.P
The built-in \*Lregister_named_object(\|)\*O function uses the name
service and endpoint map to name and advertise an object.
.LI
Place object names in name service directly
.P
The name service can be used to advertise objects for which an
instance has not yet been created.
.LI
Dynamically create instances of named or persistent objects
.P
The server's runtime can automatically call a lookup function to
create objects it supports but does not yet have an instance created.
.LE

.H 4 "Registering Named Objects"
.P
.iX "registering named objects"
.iX "objects" "registering named"
.iX "named objects" "registering"
.iX "\*Lregister_named_object(\|)\*O"
DCE RPC supplies every interface class with a member function,
\*Lregister_named_object(\|)\*O, to do all that is required to register
named objects.  The following example shows how a server might create
an object and then register it as a named object.  The server first creates
an object by using the \*Lnew\*O operator.  Then the server calls the
\*Lregister_named_object\*O function to register the object's name,
universal unique identifier (UUID), and its server binding information 
with the name service.  
The function also registers the object's UUID and binding information 
with the host's endpoint map, and it updates the runtime's object table.
.oS
 .
 .
 .
 // Create an object on the server.
Matrix *  matrix = new MatrixMgr(1, 1, 1, 1);
 matrix->register_named_object((unsigned_char_t *) "/.:/MatrixObject");
 .
 .
 .
.oE
.P
.iX "\*Lregister_named_object(\|)\*O"
The\*L register_named_object(\|)\*O function greatly simplifies your 
work, but you need to be aware of the information it uses and generates.
The following lists the approximate order of events that occur when an
object invokes this function:
.AL
.LI
.iX "name service and objects"
A name service entry is created if one is not already there, 
using the name in the first argument of the function.
.LI
If the named object does not already have a UUID associated 
with it in the name service, one is created.
.LI
The server's binding information is associated with the name service entry.
.LI
All interfaces supported by the object are also registered with the 
name service.
.LI
.iX "object UUID"
The object UUID is associated with the server's location on the host
by registering endpoints in the host's endpoint map.
.P
.iX "optional parameters"
.iX "C++" "optional parameters"
The function has an optional second argument of type \*Lboolean\*O.
The default value is \*LTRUE\*O, which means this is the\*V only\*O
server on this host that services this interface.  (In C++, using no
argument is the same as using the default value for the argument.)  If
the default value is used, values in the endpoint map are updated.
.iX "endpoint map"
.P
If the second argument to the function is \*LFALSE\*O, this is not the
only server this host has that services this interface.  In this case,
the\*L register_named_object(\|)\*O function adds server binding
information to the endpoint map (rather than updating the endpoint
map) so clients can find any of the servers.  
.iX "\*Lrpc_ep_register_no_replace(3rpc)\*O"
See the \*Lrpc_ep_register_no_replace(3rpc)\*O reference page 
for more on this topic.
.LI
.iX "object table"
Finally, an object table maintained by the server's RPC runtime is
updated so that requests for specific objects are directed to the
correct member function invocation.  Even though creating the object
in the first place registers it with the runtime's object table, some
information (such as the object's UUID) may need to be updated.
.LE
.P
.H 4 "Placing an Object's Name Directly in the Name Service"
.P
.iX "object name in name service"
Consider the following situations:
.ML
.LI
.iX "\*Lregister_named_object(\|)\*O"
Suppose you want a server to just advertise the named objects it 
supports and not use resources to create them until they are needed.
As described in the previous section, an object must be created before 
it can register itself with the \*Lregister_named_object(\|)\*O function. 
.LI
Suppose you want to use a known UUID to represent a named object.  If
the name does not already exist in the name service, a new UUID is
generated via the \*Lregister_named_object(\|)\*O call on the fly.  
This may be fine for many applications, but, for some,
manipulating objects only by their name service names may be
cumbersome and inflexible.
.LE
.P
If you wish to place a named object in the name service and at the same 
time use a consistent, stable, and well-known UUID for a named object, 
you first associate the UUID with the named object in the name service 
\*Eprior to\*O using the \*Lregister_named_object(\|)\*O function.  
There are typically two ways to place object names in the name service:
.ML
.LI
Prior to server startup, you can create or update a named object entry
by using \*Ldcecp\*O with the \*Lrpcentry\*O object and its export
operation.
.LI
.iX "\*Lrpc_ns_binding_export(\|)\*O"
Your server can create or update a named object entry by using
\*Lrpc_ns_binding_export(\|)\*O during server initialization.
.LE
.P
The following example shows a script of \*Ldcecp\*O commands and
arguments to execute on the server's host to export an object's name
and then show the data exported to the entry:
.iX "dcecp" "rpcentry export"
.oS
dcecp -c rpcentry export /.:/objects/IdentityMatrix
	-interface \{24cb0eba-3eb9-11ce-b1ce-08002bbbf636   0.0\} \\
	-binding   \{ncacn_ip_tcp `hostname`\} \\
	-binding   \{ncadg_ip_udp `hostname`\} \\
	-object    \{dcea4900-65ba-11cd-bb34-08002b3d8412\}
dcecp -c rpcentry show /.:/objects/IdentityMatrix
.oE
.P
Attributes and arguments are as follows:
.VL
.LI "\*V/.:/objects/IdentityMatrix\*O"
.br
The object name.
.LI "\*L-interface\*O ..."
The interface's UUID and version numbers from the interface definition header.
.LI "\*L-binding\*O   \*Vncacn_ip_tcp\*O \*C`\*O\*Lhostname\*C`\*O \\\*O"
.br
Binding information including a protocol sequence and the host's name
(generated with the \*Lhostname\*O command).
.LI "\*L-object ...\*O"
The object UUID desired.
.LE
.P
Whether you call \*Ldcecp\*O's \*Lrpcentry export\*O operation or the
\*Lrpc_ns_binding_export(\|)\*O routine, the first call automatically
creates the entry in the name service and each additional call adds
binding information to the entry.

.H 4 "Dynamically Creating Named or Persistent Objects"
.P
.iX "dynamically creating objects"
.iX "objects" "creating dynamically"
.iX "persistent objects"
.iX "objects" "persistent"
If there are potentially thousands of persistent objects, you may want
your application to conserve resources and not register all of them at
server startup.  Servers may defer creating objects until a client
makes a request to use one.
.P
.iX "object table"
The server's runtime maintains a table of all its objects.  The server
gets a request from a client on an object that is uniquely identified
by an object UUID (from the binding handle), and the object table maps
object UUIDs to each object's address in the server's address space.
The server's object table is a C++ class containing the following
information:
.ML
.LI
Object UUIDs
.LI
Interface UUIDs
.LI
Object addresses
.LE
.P
.iX "object lookup function"
.iX "lookup function for objects"
If the runtime cannot find the UUID of the object requested, an
exception is raised on the server to propagate to the client unless a
user-defined \*Vobject lookup function\*O exists.  If the lookup
function does exist, the runtime automatically executes it.  The
lookup function is created by the server developer to create the
object and, if required, register it as a named object.  If the lookup
function cannot create an object for the specified UUID, it should
.iX "\*Lrpc_x_object_not_found\*O exception"
.iX "object not found exception"
return a 0, which causes the runtime to raise an exception 
(\*Lrpc_x_object_not_found\*O).
.P
After the named object is registered, the object table contains the
new object UUID, so subsequent attempts to use the object do not
invoke the lookup function again.  Alternatively, the lookup function
can maintain its own object map.  By not registering with the runtime,
subsequent operations will invoke the lookup function.  This allows
the developer to use the lookup function to maintain complete 
control over the existence of the object.
.P
A lookup function name is specified using an ACF when the interface is
compiled.  The following example is a portion of an ACF that specifies
a lookup function:
.oS
[
	cxx_lookup(object_lookup)
]
interface Matrix
{
	[sstub] include "matrix_mgr", "lookup";
	.
	.
	.
.oE
.VL
.LI "\*Lcxx_lookup(object_lookup)\*O"
.br
.iX "cxx_lookup attribute"
.iX "ACF" "cxx_lookup attribute"
To specify a lookup function use the \*Lcxx_lookup\*O attribute
with the name of the lookup function (in this case, \*Lobject_lookup\*O) 
as an argument.  A lookup function is interface-wide, 
so it is defined in the ACF header.
.LI "\*L[sstub] include \"matrix_mgr\", \"lookup\";"
.br
\*OUse the include statement with the \*V\*Lsstub\*O attribute to make
.iX "sstub attribute"
.iX "ACF" "sstub attribute"
the IDL compiler include implementation-specific header files in the
server stub.  The \*Lmatrix_mgr.h\*O header file contains the manager
class and the\*L lookup.h\*O file contains a declaration
of the lookup function you create.
.LE
.P
.iX "object lookup function"
The following example shows the declaration of the 
\*Lobject_lookup\*O function in the \*Llookup.h\*O header file:
.oS
//FILE NAME: lookup.h
//This file declares the lookup function used 
// for server management of object lookup.

Matrix *object_lookup(uuid_t *);
.oE
.P
A lookup function has the following signature requirements:
.ML
.LI
The lookup function returns a pointer to the interface class (\*LMatrix *\*O).
.LI
The function name matches the one declared in the ACF (\*Lobject_lookup\*O).
.LI
There is one input parameter pointer of type \*Luuid_t\*O.
.LE
.P
An implementation of the \*Lobject_lookup(\|)\*O function
is shown in the following section.

.H 4 "Storing and Retrieving Persistent Objects"
.P
.iX "persistent object storage"
.iX "backing store usage"
.iX "database storage"
.iX "cxx_lookup attribute"
.iX "ACF" "cxx_lookup attribute"
DCE provides a convenient database storage facility 
called the backing store, that lets you store and retrieve objects in a 
system-independent manner.  
The following implementation of a lookup function shows how
to use a backing store database to lookup an object.
.oS
// FILE NAME: lookup.cxx 
// This file contains the server lookup callout function 
// specified by the [cxx_lookup] attribute in an ACF. It is called
// whenever an object cannot be found within the DCE runtime.

extern "C" {
#include <dce/dce.h> 	// standard DCE header file
#include <dce/dbif.h>	// backing store facility header file
}
#include "matrix_mgr.h"
#include <check_status.h>
#include "backing.h"	// IDL generated header file
//
// This function performs the server management of object lookups.
// If the uuid_t parameter identifies one of the persistent objects,
// this function creates and returns the object.
// 
.oE
.P
.oS
Matrix *
object_lookup(uuid_t *key)
{
   dce_db_handle_t	db_h;
   backing_data_s_t	data;
   int 			found;
   unsigned32		status;
   Matrix		*matrix;

   //
   // Lookup the UUID's in a backing store database and get the data.
   //
   dce_db_open(
   	"backing.store",
	0,
	db_c_index_by_uuid | db_c_readonly,
	(dce_db_convert_func_t) backing_data_convert,
	&db_h,
	&status
	);

   dce_db_fetch_by_uuid(
	db_h,
	key,
	(void *) &data,
	&status
	);
   if (status != rpc_s_ok)
	found = 0;
   else
	found = 1;

   dce_db_close(&db_h, &status);

   if (!found)
	return 0;

   // Found the object's data so create an instance of it.
  matrix = new MatrixMgr(data.v00, data.v01, data.v10, data.v11);

   // register the object so clients can find it directly
   // and the server won't have to look it up again.
   matrix->register_named_object((unsigned_char_t *) data.name);

   return matrix;
}
.oE
.P
The example is described as follows:
.ne 1.5i
.VL
.LI "\*Ldce_db_open(\|)\*O"
.br
.iX "\*Ldce_db_open(\|)\*O"
Applications that have persistent objects commonly store in a database
the information necessary to regenerate the object.  In this example, 
the data is stored in a backing store data file (\*Lbacking.store\*O).  
The argument \*Ldb_c_index_by_uuid | db_c_readonly\*O indicates 
the file is opened for read-only access and to be indexed by UUID.
The argument \*Lbacking_data_convert\*O is the function (defined in
the backing interface) that the backing store facility uses to store
or retrieve the data.  
A record for this database is also defined in the backing interface
to contain the entry name and values for a two-by-two matrix.
The backing interface is in the file \*Lbacking.idl\*O,
and looks as follows:
.oS
[
uuid(3e9400dc-0895-11cf-abec-08002b39f4b8)
] interface backing
{
	import "dce/database.idl";

	/* Data: object name (for CDS) and values for 2-by-2 matrix */
	typedef struct backing_data_s_t {
		[string] char name[100];
		int v00;
		int v01;
		int v10;
		int v11;
	} backing_data_s_t;

	/* conversion function declaration */
	void backing_data_convert(
		[in] handle_t			h,
		[in,out] backing_data_s_t	*data,
		[in,out] error_status_t		*st
	);
}
.oE
.LI "\*Ldce_db_fetch_by_uuid(\|)\*O"
.br
.iX "\*Ldce_db_fetch_by_uuid(\|)\*O"
This DCE routine obtains the data for the object represented by
the key UUID.
.LI "\*Lmatrix = new MatrixMgr(data.v00, data.v01, data.v10, data.v11);\*O"
.br
An instance of the persistent object is created for this server.  Note
that each server of the object would have its own implementation and
instance of the object.
.LI "\*Lregister_named_object((unsigned_char_t *) data.name);\*O"
.br
.iX "\*Lregister_named_object(\|)\*O"
This function registers the object's name, UUID, and its server
binding information with the cell's name service.  It also registers
the object's UUID and binding information with the host's endpoint
map.  Finally, this routine updates the runtime object table.
As an option for more specific control, 
you can choose not to call this function and implement
your own object table instead.
.LI "\*Lreturn(0);\*O"
.iX "\*Lrpc_x_object_not_found\*O exception"
If the object was not found, return a 0 value.  This will cause the
server to raise an exception (\*Lrpc_x_object_not_found\*O).
.LE
.ne 1.5i
.P
The \*Lbacking.idl\*O file is compiled with the following ACF:
.oS
interface backing
{
	[encode,decode] backing_data_convert(
		[comm_status] st
	);
}
.oE
.P
The application must also declare the database conversion
function as shown in the following \*Lbacking.cxx\*O file:
.oS
#include "backing.h" 

extern "C" {

void
backing_data_convert(
	idl_es_handle_t		h,
	backing_data_s_t	*data
) {
}

}
.oE
For more on how to use the backing store facility, 
see the chapter, \*VThe DCE Backing Store\*O.

.H 2 "Clients That Use Distributed Objects"
.P
.iX "clients and distributed objects"
This section describes how to write object-oriented DCE clients.  The
subsections describe how to do the following:
.ML
.LI
Create remote, dynamic objects
.LI
Create both local and remote instances of the same class
.LI
Call functions that intermix the use of local and remote objects
.LI
Bind to named objects by using names stored in the name service
.LI
Bind to named objects by using their UUID identifiers.  This method
uses your local name service hierarchy to begin the namespace search.
.LI
Bypass the name service to bind to objects by using binding information
.LE
.H 3 "Creating Remote-Dynamic Objects"
.P
.iX "remote-dynamic objects"
.iX "C++ new operator"
In C++ we create new objects dynamically by calling the \*Lnew\*O
operator for the class.  This works to creates local objects, but how
do clients create remote dynamic objects?  In order for a client to
create dynamic objects, at least one static object creator operation
must be defined in an interface to create its objects.  Remember that
a static member function does not have to be invoked by an existing
object, and thus it is appropriate as a way to create new objects.
The operation can be declared to return a new object as a return value
.iX "object creator function"
or an output parameter.  Object creator functions are declared as
static in either of two ways:
.ML
.LI
In the IDL file explicitly by using the \*Lstatic\*O keyword
.LI
In an ACF by using the \*Lcxx_static\*O (or \*Lcxx_new\*O) attribute 
.LE
.P
The following example is an ACF that specifies object creator member
functions for the Matrix interface:
.oS
/* FILE NAME: matrix.acf */
/* This file defines some attributes for a simple client of the */
/* Matrix interface. */

interface Matrix
{
	/* createMatrix needs to be mapped as a creator function */
	[cxx_static] createMatrix();

	/* newMatrix needs to be mapped as a static member function */
	[cxx_static] newMatrix();
}
.oE
.P
When the interface is compiled with this ACF, the IDL compiler
generates a proxy class for the client in which these operations are
declared as static member functions.  The proxy class is our client's
interface to DCE, and it is DCE's mechanisms that let clients
interact with objects in the distributed environment.
.P
In some ACFs, static object creator functions may be specified with
the \*Lcxx_new\*O attribute instead of \*Lcxx_static\*O, and both the
attributes may include an argument.  These differences do not affect
the client stub and are significant only for server stubs.
.P
The following example shows how a client calls the Matrix interface's
static member functions:
.oS
#include "matrix.h"		// IDL generated header file
#include printmatrix.h

void
main()
{
	Matrix	*m1;

	cout << "Creating dynamic objects:" << endl;

	// Create a remote Matrix object on a server using an 
	// object creator function.
	m1 = Matrix::createMatrix(1, 2, 3, 4);
	cout << "m1 created by an object creator function:" << endl;
	print(m1);
	delete m1;

	// Create a remote Matrix object on a server using 
	// a static member function.
	idl_boolean result = Matrix::newMatrix(2, 2, &m1); 
	if(result)
	{
	    print(m1);
	    delete m1;
	}
	.
	.
	.
.oE
.P
\*L#include "matrix.h"\*O
.br
.in +1i
The interface class and proxy class are defined in the \*Lmatrix.h\*O
header file generated by the IDL compiler.
.in
.VL
...\: .LI "\*L#include \"matrix.h\" "
...\" .br
...\" \*OThe interface class and proxy class are defined in the \*Lmatrix.h\*O
...\" header file generated by the IDL compiler.
.LI "\*LMatrix *m1;\*O"
.br
.iX "object reference"
.iX "pointers to abstract classes"
Object references are declared as pointers to an interface class.  The
interface class is an abstract class, and C++ does not allow you to
create instances of it.  However, pointers to abstract classes are
allowed.  When a remote object is created for one of these object
references, the client stub actually creates a proxy class object on
the client.
.LI "\*Lm1 = Matrix::createMatrix(...)\*O"
.br
.iX "C++ scope operator"
.iX "scope operator, ::"
Object creator functions are invoked using the interface class name
(Matrix) with the standard C++ scope operator (::).  This function
creates a remote Matrix object on a server and returns a reference to
the remote object.
.LI "\*Lprint(m1);\*O"
After a dynamic object is created, the application uses it just like
any local object.  This function is an application-specific inline
function to display a Matrix.  It is defined in the
\*Lprintmatrix.h\*O header file and uses the Matrix interface's\*L
get(\|)\*O function.
.LI "\*Ldelete m1;\*O"
.iX "C++ delete operator"
.iX "decrementing reference count"
.iX "reference count decrement"
Remote dynamic objects are deleted with the standard C++ \*Ldelete\*O
operator, just like local objects.  However, for the remote object, an
RPC is sent to it to decrement the reference count.  If no other
clients have a reference to it, the object is also deleted from the
server's address space.  Client applications should take care to
delete all dynamic objects prior to exiting.  Otherwise, the object
remains in the server's address space wasting resources.  Dynamic
objects are created for the use of the invoking client.  This means
that servers cannot give a different client a reference to a dynamic
object.  However, the client could behave as a server and give a copy
of the object reference to another client.  For this reason, a
reference count is maintained on the server for objects.
.LI "\*L... = Matrix::newMatrix(2, 2, &m1)\*O"
.br
.iX "static memeber functions"
Static member functions are invoked using the interface class name
(Matrix) with the standard C++ scope operator (\*L::\*O).  
This function is also an object creator function that creates a 
remote Matrix object on a server.
.LE

.H 3 "Creating Client-Local Objects"
.P
.iX "client-local objects"
The client code in the previous section showed only the case in which a
class of objects is remote.  However, many client applications also
need to create and use local objects of the same class.  The
significant difference is that the local object is not created by way
of a remote procedure call as is the remote object.  The interface
class generated by the IDL compiler from the interface definition is
an abstract class.  This means that another class must be derived from
it to create and manipulate objects. The client stub has a proxy class
automatically defined for remote objects, but your client application
must define a local implementation class so that your client can
create and manipulate local interface objects.
.P
Do the following to create and use local versions of interface
objects:
.AL
.LI
Derive a local class from the interface class to implement the
client-local objects.  This class is just like a manager class used in 
server development:  in fact, this example uses the same manager 
class as the server.
.LI
Write the local code that implements the interface class.  Our example
uses the same manager code implementation as for the server. 
You implement the manager class by adding the code to the 
manager header file generated by the IDL compiler, 
or by deriving a new class from the manager class and 
implementing those functions.
.LI
Link the local class and local implementation code into your client
application.
.LE
.P
The following sample code shows how a client creates a local Matrix
object:
.oS
#include "matrix.h"		// IDL generated header file

#include "matrix_mgr.h"		// local class implementation
	.
	.
	.
	Matrix		*mlocal;
	// Create a local Matrix object in this program
	mlocal = new MatrixMgr(4, 3, 2, 1);
	cout << "mlocal created:" << endl;
	print(mlocal);
	.
	.
	.
.oE
.P
\*L#include "matrix_mgr.h"\*O
.br
.in +1i
To implement client-local objects, the application includes a local
manager class that is derived from the interface class.  Local code is
also linked to the application that implements the client-local
objects.
.in
.VL
...\" .LI "\*L#include \"matrix_mgr.h\" "
...\" .br
...\" \*OTo implement client-local objects, the application includes a local
...\" manager class that is derived from the interface class.  Local code is
...\" also linked to the application that implements the client-local
...\" objects.
.LI "\*Lmlocal = new MatrixMgr( ... )\*O"
.br
Clients create a local object by using the C++ \*Lnew\*O operator on
the local manager class defined in the \*Lmatrix_mgr.h\*O header file.
.LE

.H 3 "Location Transparency of Local and Remote Objects"
.P
.iX "object location transparency"
.iX "objects" "local and remote"
.iX "remote and local objects"
The previous sections showed separate cases of how to create objects
that are either remote or local.  However, many applications use a
mixture of remote and local objects.  For example, a presentation
application can link in a video clip from another system (remote), or
it can embed a copy of the video clip into the presentation itself
(local).  After the objects are created, we want the distinction to be
as transparent as possible to simplify application code.  In DCE, you
can also intermix local and remote objects in function calls without
needing to keep track of which is which.
.P
To prepare your application to handle both local and remote objects
simultaneously, do the following development steps:
.AL
.LI
.iX "static function renaming"
Use the \*Lcxx_static\*O ACF attribute to rename
local versions of static functions.
.LI
Use the IDL compiler to produce both the client and server stub code.
.LI
Link into your client the client stub, server stub, and local object
implementation code.
.LE
.P
To accomplish this, you develop the client as if you are producing
both a client and a server simultaneously.  The only real difference
is that you do not need any server initialization code.  This means that 
your application includes the \*Lidl\*O-generated manager class header 
and server stub, and manager implementation code for each interface.
(See the following figure.)
A client uses the client stub to produce and use remote objects.  
The client uses the server code to produce and use client-local objects 
of the interface class.  
This makes more sense when you think about server development:
the manager class and code implement distributed objects of the 
interface class that are \*Vlocal\*O to the server, so it helps to think 
local implementation code rather than server implementation code 
when we use server stubs, manager classes, and manager code in a client.
.iX "\*Lrpc_x_no_server_stub\*O exception"
.iX "no server stub exception" 
If your application fails to use the server stub, the exception 
\*Lrpc_x_no_server_stub\*O is raised by the client if your application 
tries to use local objects.
.iX "clients use server stub"
.iX "server stub in clients"
.ne 2.25i
.FG "Clients Use the Server Stub"
.pI ../rpc/figures/distrib_obj_usage_02.ps
.P
The IDL compiler requires an ACF such as the following when a client
uses both remote and local objects:
.oS
/* FILE NAME: matrix.acf */

interface Matrix
{
        /* include files generated into the server stub */
        [sstub] include "matrix_mgr", "staticfunc";

	/* createMatrix must be mapped as a creator member function.  */
	/* The argument MatrixMgr names the class that implements the */
	/* interface for the server stub.                             */
	[cxx_new(MatrixMgr)] createMatrix();

	/* The "newMatrix" name represents the remote version of the  */
	/* function that is used by either the client application or  */
	/* the server stub.                                           */
	[cxx_static(LocalMatrix)] newMatrix();
}
.oE
.VL
.LI "\*L[sstub] include \"matrix_mgr\", \"staticfunc\";"
.br
\*OThe \*Linclude\*O statement causes the IDL compiler to include header
files in stubs. Data structures and definitions in code that are
required by stubs need to be included in this way.  This example
applies the \*Lsstub\*O attribute to specify the inclusion of
\*Lmatrix_mgr.h\*O and \*Lstaticfunc.h\*O files in the server stub only.
The\*L matrix_mgr.h\*O file contains the definition of the client-local
manager class.  This class defines the implementation of the interface
and is derived from the interface class.  The file \*Lstaticfunc.h\*O
contains declarations of static member functions for the interface.
In this example, there is only one static member function:
\*LLocalMatrix(\|)\*O.
.ne 1.5i
.LI "\*L[cxx_new(MatrixMgr)] createMatrix(\|);\*O"
.br
The\*L cxx_new\*O attribute specifies that a static member function of
the interface is an object creator function.  An argument (in this
case, \*LMatrixMgr\*O) is needed to name the manager class, the class
derived from the interface class to implement local interface objects.
For the client stub, the argument is ignored and the function
\*LcreateMatrix(\|)\*O is generated as a static member function.  The
client application uses this function to create a remote interface
object.  For the server stub (or, in this case, the client-local
implementation), the \*LMatrixMgr\*O argument represents the manager
class name defined in a header file previously specified in the ACF
with the \*Linclude\*O statement.  The application uses the \*Lnew\*O
operator on the \*LMatrixMgr\*O class to create a local interface
object.
.LI "\*L[cxx_static(LocalMatrix)] newMatrix(\|);\*O"
.br
The \*Lcxx_static\*O attribute specifies the interface's static member
functions.  All static member functions need to have this attribute
(unless you use the \*Lstatic\*O keyword in the interface definition
to specify the function as static).  An argument is required to avoid
name conflicts between the local and remote versions of the function
when both client and server stubs are linked together in the same
application.  For the client stub, the argument is ignored and the
client application calls \*LnewMatrix(\|)\*O for remote access to the
interface.  For the client-local (server) stub, the argument is used
to name the function, and the application calls \*LLocalMatrix(\|)\*O
for local access to the interface.
.LE
.P
The following example shows client code to create and use both remote
and local objects from an interface class:
.oS
#include "matrix_mgr.h"	
#include "printmatrix.h"	// print(\|) macro

void
main()
{
   idl_long_int	d1, d2, d3, d4;
   Matrix		*mremote, *mlocal, *mr, *ml;

   d1 = 1; d2 = 2; d3 = 3; d4 = 4;

   cout << "Creating dynamic objects:" << endl;

   // Create a remote Matrix object on a server
   mremote = Matrix::createMatrix(d1, d2, d3, d4);
   cout << "mremote created:" << endl;
   print(mremote);

   // Create a local Matrix object in this program
   mlocal = new MatrixMgr(d4, d3, d2, d1);
   cout << "mlocal created:" << endl;
   print(mlocal);

   // Create another object from a local and remote one.
   // Whether the new matrix is local or remote depends on whether
   // the invoking object is local or remote.

   // create another remote Matrix while accessing a local object
   mremote->add(mlocal, &mr);
   cout << "mr is remote. It's the sum of mremote and mlocal:" << endl;
   print(mr);

   // create another local Matrix while accessing a remote object
   mlocal->add(mremote, &ml);
   cout << "ml is local. It is the sum of mlocal and mremote:" << endl;
   print(mr);
 
   // Applications should ALWAYS delete remote dynamic objects when
   // through, otherwise, the server will waste resources maintaining
   // them.
   delete mremote, mlocal, mr, ml; 

   cout << "Client exiting" << endl;

   return;
}
.oE
.VL
.LI "\*LMatrix *mremote, *mlocal, *mr, *ml;\*O"
.br
.iX "object references" "local and remote"
.iX "remote and local object references"
Local and remote object references are both defined as pointers to the
interface class.  Depending on how an object is created, polymorphism
causes the invocation of a client stub function for remote objects or
the locally defined function for local objects.
.LI "\*Lmremote = Matrix::createMatrix(d1, d2, d3, d4);\*O"
.LI "\*Lmlocal = new MatrixMgr(d4, d3, d2, d1);\*O" 
.br
Clients call a static creator function to create a remote object 
on a server and use the C++ \*Lnew\*O operator to create a local object.
.LI "\*Lmremote->add(mlocal, &mr);\*O"
.br
A client can use remote and local objects together.  In this example,
a local object (\*Lmlocal\*O) is added to the invoking remote object
(\*Lmremote\*O) to create a new remote object (\*Lmr\*O) that is the
sum of the two.
.LI "\*Lmlocal->add(mremote, &ml);\*O"
.br
In this example, a remote object (\*Lmremote\*O) is added to the
invoking local object (\*Lmlocal\*O) to create a new local object
(\*Lml\*O).  Whether the resulting object is local or remote depends
on the invoking object.
.LI "\*Ldelete mremote, mlocal, mr, ml;\*O"
.br
Clients use the C++ \*Ldelete\*O operator to delete both local and
remote objects.  If a client does not delete local objects prior to
exiting, no real harm is done since all the memory for the application
is released.  However, clients should always delete remote objects
when finished with them because the servers maintain them even after
the client has exited.
.LE
.H 3 "Finding Known Remote Objects"
.P
.iX "finding remote objects"
.iX "CDS"
.iX "named objects"
.iX "overloaded operation"
.iX "C++ overloading"
Servers can register objects with the name service, 
such as the Cell Directory Service (CDS).  
Such objects are termed named objects.  
When an interface is compiled, 
the IDL compiler generates an overloaded \*Lbind(\|)\*O
operation that allows a client to bind to a named object in several
ways.  These include the following:
.ML
.LI
Bind by an object's name
.LI
Bind by an object's UUID
.LI
Bind by a binding handle
.LE
.P
An \*Voverloaded\*O operation's argument list and functionality
varies depending on which argument is used.  The \*Lbind(\|)\*O
operation of an interface is a static operation that returns a typed
interface pointer.  A zero is returned upon failure to locate and bind
to the object.

.H 4 "Binding to Named Objects By Name"
.P
.iX "binding by object name"
.iX "\*Lbind(\|)\*O by name"
To bind to a named object by its CDS name, the argument provided 
to the \*Lbind(\|)\*O operation should be an \*Lunsigned_char_t\*O 
pointer that specifies the name of the registered object in the 
CDS hierarchy.  
For example, the following code fragment uses a CDS name to create
a local object proxy in the client application 
bound to a remote object:
.ne 1.75i
.oS
        Matrix m;

        cout << "Binding to objects by name stored in CDS:" << endl;
        m = Matrix::bind((unsigned_char_t *)  "/.:/objects/identityMatrix");
        if (m) {
           print (m);
       } else {
           cerr << Cant bind to named object << endl;
       }
.oE
.P
.iX "\*Lregister_named_object(\|)\*O"
In order for this to work, a server must have registered the object in 
CDS by calling the \*Lregister_named_object(\|)\*O function.

.H 4 "Binding to Named Objects by UUID"
.P
.iX "binding by object UUID"
.iX "\*Lbind(\|)\*O by UUID"
.iX "RPC_DEFAULT_ENTRY"
To bind to a named object by its object ID, the argument provided to the
\*Lbind(\|)\*O operation should be a \*Luuid_t\*O reference.  The 
argument specifies the UUID of the registered object in the CDS hierarchy.
The DCE environment variable \*LRPC_DEFAULT_ENTRY\*O 
must be set to indicate where the search for the object is to begin in the 
CDS name space.  For example, the following code fragment uses an 
object's UUID to create a local object proxy in the client application 
bound to the remote object:
.oS
const char *UUID = "f063cf5a-c5c8-11ce-8a4b-08002be415b2";
Matrix	*m;	// interface pointer
uuid_t	u;	// uuid of named object
unsigned32	status;	 // error status

// get a uuid from string format
uuid_from_string ((unsigned_char_t *) UUID, &u, &status);
if (status !=uuid_s_ok) {
	// handle error case
}
// bind to a named object by uuid
m = Matrix::bind(u);
if (m) {
	print (m);
} else {
	cerr << Cannot bind to named object << endl;
}
.oE

.H 4 "Binding Explicitly to Known Objects"
.P
.iX "binding by object binding handle"
.iX "\*Lbind(\|)\*O by binding handle"
To bind to an object explicitly by its binding handle, 
the argument provided to the \*Lbind(\|)\*O operation should be
a server binding handle of type \*Lrpc_binding_handle_t\*O.  
Note that this method does not use CDS at all.
For example, the following code fragment uses a binding handle
to create a local object proxy in the client application bound to a
remote object:
.oS
const char *UUID = "f063cf5a-c5c8-11ce-8a4b-08002be415b2";
const char *PROT = "ncacn_ip_tcp";
const char *HOST = "16.01.02.03";
const char *ENDP = "4041";

Matrix			*m; 			// interface pointer
unsigned_char_t		*string_binding;	// string binding
rpc_binding_handle_t	binding_handle;	// binding handle
unsigned32			status;		// error status

// build a string binding from the various components
rpc_string_binding_compose(
  	(unsigned_char_t *) UUID,	// object uuid
  	(unsigned_char_t *) PROT,	// protocol sequence
 	(unsigned_char_t *) HOST,	// host address
  	(unsigned_char_t *) ENDP,	// transport endpoint
  	NULL,			// network options
  	&string_binding,
  	&status
);
if (status != rpc_s_ok) {
	// handle error case
}

// convert a string binding into a binding handle
rpc_binding_from_string_binding(
	string_binding,
	&binding_handle,
	&status
);
if (status != rpc_s_ok) {
	// handle error case
}

m = Matrix::bind(binding_handle);
if (m) {
	print(m);
} else {
	cerr << "Cannot bind to named object" << endl;
}
.oE
.VL
.LI "\*Lrpc_string_binding_compose(\|)\*O"
.br
This RPC API routine combines string components of 
binding information into a single string representation
of a binding.
.LI "\*Lrpc_binding_from_string_binding(\|)\*O"
.br
This RPC API routine creates a binding handle from a
string representation of a binding handle.
.LI "\*Lm= Matrix::bind(binding_handle);\*O"
.br
The \*Lbind(\|)\*O operation when used with a
binding handle parameter binds to the object specified
by the object's UUID and specific server binding information.
.LE

.H 2 "Multiple Interfaces and Interface Inheritance"
.P
.iX "multiple interfaces"
.iX "interface inheritance"
.iX "object hierarchies"
Objects in useful applications are organized into groups (using
classes) and hierarchies in order for people to more easily develop
and maintain them.  For the same reason, you use more than one IDL
interface to logically group the objects and functionality of your
applications.  In addition, you can organize your interfaces into
hierarchies that take advantage of the inheritance capabilities of C++
classes.
.P
.iX "inheritance operator, :"
.iX "import statement"
.iX "IDL" "import statement"
This discussion uses a traditional savings account example, as
shown in the class hierarchy diagram of the following figure.  
First there is a high-level \*VAccount\*O interface and then a 
\*VSavings\*O interface derived from the \*VAccount\*O interface.
The \*VAccount\*O interface is specified separately from the 
\*VSavings\*O interface for the basic
operations all accounts might have and to show how interface
inheritance works.  With this scheme, we can easily specify other
kinds of accounts by using additional interfaces. (For example, we
could also have a \*VChecking\*O interface.)  Our example also has a
separate \*VLoan\*O interface to show how to combine interfaces in
applications.  In the implementation of these interfaces, we derive a
simple savings account class (\*LsimpleSave\*O) from the 
savings interface, and we derive an overdraft-protected savings 
account class (\*Loverdraft\*O) from both the savings and the 
loan interfaces.
.ne 2.25 i
.FG "Multiple Interfaces and Inheritance"
.pI ../rpc/figures/distrib_obj_usage_03.ps
.P
The Account interface contains the most basic operations for accounts,
including one to obtain the account's balance, one to make deposits,
and one to make withdrawals.  This interface definition is as follows:
.oS
[
uuid(b3896a1c-8ee2-11ce-badc-08002b2bf322)
] interface Account
{
        double getAccountBalance();

        double deposit(	/* Value returned is the balance. */
                [in] double amt
        );

        double withdraw(/* Value returned is actual amount withdrawn */
                [in] double amt
        );
} 
.oE
.P
Use the inheritance operator, \*L:\*O, in an interface
definition to specify \*Vinterface inheritance.\*O In the following
example, the Savings interface \*Vinherits\*O operations from the
Account interface. (Depending on your perspective, you can also say
the Savings interface \*Vis derived from\*O the Account interface.)
When an interface inherits another, it also uses the \*Limport\*O
statement to be sure the operations and any data types of the
inherited interface are available to the derived interface.  The
Savings interface definition is as follows:
.ne 1.5i
.oS
[
    uuid(b388ab7c-8ee2-11ce-badc-08002b2bf322)
]   interface Savings : Account
{
        import "account.idl";

        static Savings * openSimple(
                [in] double   amt
        );

        static Savings * openOverdraft(
                [in] double   amt
        );

        double getSavingsBalance();

        void   setInterestRate(
                [in] double rate
        );

        void   addInterest();
}    
.oE
.P
.iX "object creator operation"
The \*LopenSimple(\|)\*O and\*L openOverdraft(\|)\*O static operations
are object creator operations used to create new accounts on a server.
Notice that the Account interface has no creator operations specified.
This means that clients cannot create an Account object directly, but
servers of course can.  The non-static operations for the Savings
interface include one to get the savings account balance
(\*LgetSavingsBalance(\|)\*O), one to set the interest rate
(\*LsetInterestRate(\|)\*O), and one to add the interest to the balance
of the account (\*LaddInterest(\|)\*O)
.P
In this application, we have decided that our server implements 
the overdraft account with a Loan interface. 
(Note we could have chosen to implement it in another way, 
and without an additional interface.)
The Loan interface is not derived from another interface and is shown 
in the following example:
.ne 1i
.oS
[
    uuid(912ef43d-8ee2-11ce-a54e-08002b2bf322)
]
interface Loan
{
    static Loan * openLoan(
        [in]  double   amt,
        [in]  double   rate,
        [in]  long     months,
        [out] double   &payment
    );

    double getLoanBalance();

    void payment(
        [in] double amt
    );

    double recalculateLoan( /* returns payment amount required */
        [in]  double   rate,
        [in]  long     months
    );
}
.oE
.P
The \*LopenLoan(\|)\*O operation is a static object creator 
operation to create a loan object.  
The \*LgetLoanBalance(\|)\*O operation gets the 
current balance of the loan and the \*Lpayment(\|)\*O operation 
is used to make a payment on the loan.
The \*LrecalculateLoan(\|)\*O operation sets new terms for 
the loan and returns the new monthly payment required.
.P
There are no special techniques to follow in server initialization
code except be sure that whatever is required for an individual
interface is done for each interface your application uses.  
For example, the initialization code must be sure to register the
endpoints for all interfaces.

.H 3 "Implementing Multiple Managers"
.P
.iX "manager implementaton"
.iX "multiple managers"
Our implementation derives a simple savings account manager class
(\*LsimpleSave\*O) from the Savings interface class.  Since the
Savings interface is derived from the Account interface, all nonstatic
operations in both interfaces must be declared in the manager class
and defined in the manager code.  Of course, additional functions and
data types (such as constructors and destructors) can also be declared
to specifically implement the interface.
.P
Our implementation also derives an \*Loverdraft\*O manager class for
an overdraft type of savings account.  The overdraft account has
characteristics of both a savings account and a loan and demonstrates
\*Vmultiple interface inheritance\*O.  It is defined to have multiple
inheritance by being derived from both the Savings and Loan interface
classes.
.nS note
Applications can create C++ classes that inherit from multiple
interface classes, but interface classes cannot inherit from multiple
interfaces.
.nE
.P
The following code shows the overdraft manager class and its
implementation.  This example has the manager implementation included
within the class definition header file itself, rather than in
separate C++ code.  C++ allows you to combine implementation as part
of the C++ class declarations.  This is common practice when the
implementation code for each member function is small.
.oS
#ifndef overdraft_i_h
#define overdraft_i_h
#include <iostream.h>
#include "savings.h"
#include "loan.h"

class overdraft : public Savings, public Loan {
    public:
        overdraft(idl_long_float amt)
        {
            balance = amt;
        }
        ~overdraft(void)
        {
                return;
        }
        idl_long_float getBalance()
        {
            return balance;
        }
/////////////// Member Functions from all interfaces ///////////////
        idl_long_float deposit(idl_long_float amt)
        {
                balance += amt;
                return balance;
        }
        void payment(idl_long_float amt)
        {
                balance += amt;
        }
        idl_long_float withdraw(idl_long_float amt)
        {
                balance -= amt;
                return amt;
        }
        void setInterestRate(idl_long_float r)
        {
                rate = r/loanTerm;
        }
        void addInterest()
        {
                balance += (balance * rate);
        }
       idl_long_float recalculateLoan(idl_long_float r, idl_long_int m)
        {
                if(balance < 0)
                    {
                    loanRate = r;
                    loanTerm = m;
                    return abs(balance) / loanTerm;
                    }
                else
                    return 0;
        }
        idl_long_float getAccountBalance()
        {
                return getBalance();
        }
        idl_long_float getSavingsBalance()
        {
                return getBalance();
        }
        idl_long_float getLoanBalance()
        {
                static idl_long_float loanBalance;
                if(balance < 0)
                  loanBalance = abs(balance);
                else
                  loanBalance = 0;
                return loanBalance;
        }
    private:
        idl_long_float balance  = 0; //loan is automatic if negative balance
        idl_long_float rate     = 0.02; //2%
        idl_long_float loanRate = 0.15; //15%
        idl_long_int   loanTerm = 12;   //12 months
};
.oE
.P
.iX "manager class"
The manager class must declare all the nonstatic functions of all its
inherited interfaces.  These include all nonstatic operations defined
in all three interfaces, including the Account, Savings, and Loan
interfaces. Be sure to define the operation signatures exactly as they
are declared in each \*Lidl\*O-generated header file, or else the C++
compiler may not interpret the function as an implementation but
rather as a new function.  If this occurs, the class is interpreted as
an abstract class, which means that your application cannot create
instances of the manager class.  
.P
For this example, refer to the
\*Lsavings_mgr.h\*O and \*Lloan_mgr.h\*O header files generated by
the IDL compiler to find the signatures of all the functions required.  
For example, the \*Ldeposit(\|)\*O, \*Lwithdraw(\|)\*O, and 
\*LgetAccountBalance(\|)\*O functions are from the Account interface 
but are redeclared in the derived Savings interface.  
The \*Lpayment(\|)\*O, \*LrecalculateLoan(\|)\*O, 
and \*LgetLoanBalance(\|)\*O functions are declared in the Loan interface.  
The \*LsetInterestRate(\|)\*O,\*LaddInterest(\|)\*O, 
and \*LgetSavingsBalance(\|)\*O are declared in the Savings interface.
.P
The static function implementations for the Savings and the Loan
interface classes are not shown here but include \*LopenSimple(\|)\*O,
\*LopenOverdraft(\|)\*O, and\*L openLoan(\|)\*O.

.H 3 "Using Objects that Support Multiple Interfaces"
.P
.iX "objects" "multiple interfaces"
When clients use objects whose interfaces are independent from each
other, no special coding is required beyond the conventions described
earlier: you just create, use, and delete objects for each interface.
The most interesting circumstances involving multiple interfaces 
are those in which an object itself supports more than one interface.

.H 4 "Binding by Object Reference to Use a Different Interface"
.P
.iX "binding by object reference"
.iX "objects" "swapping interfaces"
We defined our overdraft savings account to be derived from two
different interfaces (see the following figure).  However, the client
does not have any knowledge of how a server implements the overdraft
account.  The client does have a way to create an overdraft account by
calling the static function \*LopenOverdraft(\|)\*O, but that is
defined in the Savings interface which has no access to the Loan
interface.  So how does an overdraft object inquire about its loan
balance by using the Loan interface's\*L getLoanBalance(\|)\*Omember
function, when the object reference is to the Savings interface?  We
obviously cannot simply create another object reference to the Loan
interface and expect the two different object references to both refer
to the same overdraft object.
.ne 3.0 i
.FG "Clients Do Not Know About Server Implementations"
.pI ../rpc/figures/distrib_obj_usage_04.ps
.P
.iX "\*Lbind(\|)\*O by object reference"
The solution is to use an \*Lidl\*O-generated member function.  When
the IDL compiler generates the interface classes, it also generates an
additional \*Lbind(\|)\*O member function that allows the client to
easily use other interfaces.  The following examples show sample
client code that creates and uses a new simple savings account object
and an overdraft account object:
.oS
#include "savings.h"
#include "loan.h"

Account *a  = 0;
Savings *ss = 0;
Savings *od = 0;
Loan    *iLoan  = 0;
.oE
.P
The interface classes are declared in the header files generated by
the IDL compiler as follows:
.oS
ss = Savings::openSimple(456.12); 
od = Savings::openOverdraft(568.19);
.oE
.P
In this example, the client creates a new simple savings account
object on a server by calling the \*LopenSimple(\|)\*O function.  The
function creates an object reference to the Savings interface.  The
client also creates a new overdraft account object on a server by
calling the\*L openOverdraft(\|)\*O function.  This function also
creates an object reference to the Savings interface.
.fS 
A robust server would likely give clients a way to find accounts 
again later by making the objects named and persistent; 
but, to simplify our examples, we use only dynamic objects.  
Therefore, accounts must be recreated each time a client runs. 
.fE
.oS
balance = ss::getSavingsBalance();
assert(balance == 456.12);
balance = od::getSavingsBalance();
assert(balance == 568.19);
.oE
.P
Object references to the Savings interface can call any member
functions of the Savings and Account interfaces as follows:
.oS
iLoan = Loan::bind(od);
.oE
.P
To use a different interface, clients use the built-in \*Lbind(\|)\*O
member function with an object reference parameter.  In this example,
the function creates an object reference to the Loan interface, \*LiLoan\*O,
from the object reference to the Savings interface,\*L od\*O:
.oS
balance = iLoan->getLoanBalance();
cout << "Loan Balance: " << balance << endl;
.oE
.P
The object can now call any member function of the Loan interface 
as follows:
.oS
ss->deposit(20.01);
.oE
.P
An object reference to one interface can access member functions of
its inherited interfaces, as expected.  In this example, \*Lss\*O is
an object reference to a Savings object, but the \*Ldeposit(\|)\*O
function is specified in the Account interface:
.oS
balance = ss->getAccountBalance();
cout << Balance: " << balance << endl;
a = Account::bind(ss);
balance = a->getAccountBalance();
cout << Balance: " << balance << endl;
.oE
.P
As an aid to debugging, it is a good idea to use the interface in
which the operation is declared, even if the inherited operation can
be resolved.  When the object calls \*LgetAccountBalance(\|)\*O with a
Savings object reference, the function is executed in the client stub
for the Savings interface.  On the other hand, when the same function
is called with an Account object reference, the Account client stub
function is executed.

.H 4 "Finding Out if an Interface is Supported"
.P
.iX "interface" "checking if supported"
One of the most common reasons to find out if an interface is
supported is to determine whether or not a new version of an application 
uses an additional interface.  The new clients must check for application
compatibility by inquiring as to whether the new interface is
supported.  Compatibility is easily tested by calling the
\*Lidl\*O-generated \*Lbind(\|)\*O function with an object reference
parameter, as described in the previous section.  An interface is not
supported if the returned result is 0 (zero).  This simple test
implies that it is easy to create new versions of applications by
adding additional interfaces, rather than running the risk of creating
incompatibility by modifying existing interfaces.
.P
The following example shows how to inquire if an interface is
supported.  Suppose we are told that some servers on our network
implemented the overdraft account without using the Loan interface.
This would not prevent our clients from creating and using overdraft
objects; we would just not have the Loan interface to use to inquire
about the status of an overdraft.  In this scenario, the client that
has the Savings interface could inquire as to whether the object also
supports the Loan interface, as in the following:
.oS
iLoan = Loan::bind(ss);
if(iLoan == 0)
   cout <<"Simple accounts do not support the Loan interface."<< endl;
iLoan = Loan::bind(od);
if(iLoan == 0)
   cout <<
      "This overdraft account doesn't support the Loan interface." << endl;
.oE
.P
In the first case, attempting to bind a simple savings object to the
Loan interface should always return 0 (zero).  In the second case, if
a zero value is returned, this overdraft object does not support the
Loan interface (the Loan interface is not inherited).

.H 4 "Multiple Interfaces and Local Objects: a C++ Enhancement"
.P
.iX "multiple interfaces"
.iX "C++ enhancement"
.iX "\*L bind(\|)\*O and local objects"
The\*L bind(\|)\*O member function that takes an object reference also
works for local interfaces and objects.  This means that you can use
IDL to specify, implement, and test combinations of local interfaces
without the overhead of remote procedure calls.  You may find this a
useful approach when designing, prototyping, and debugging your
interfaces and implementations.  The steps are as follows:
.AL
.LI
Create your IDL files by using the \*Luuid\*O and \*Llocal\*O
attributes in the interface headers.
.LI
Use the IDL compiler with the \*L-lang cxx\*O option to compile the
interfaces.  The IDL compiler generates only the header files for each
interface when the interface has the \*Llocal\*O attribute.  No stubs
are generated.
.LI
Develop the manager class, manager implementations, and static member
functions as you would for typical servers.
.LI
Create a client that includes the \*Lidl\*O-generated header files.
The client also calls the \*Lidl\*O-generated \*Lbind(\|)\*O function
that binds by object reference, to switch between local interfaces.
.LI
Link together the machine object code for the client, manager class,
manager code, and static functions.
.LI
Test the client application program.
.LE

.H 2 "Passing C++ Objects as DCE RPC Parameters"
.P
.iX "C++ objects as parameters"
.iX "objects" "library objects as parameters"
IDL allows the passing of any C language 
basic or constructed data type as an RPC parameter, 
mainly through the use of attributes.  
However, the C++ language makes it much easier and convenient for 
the programmer to define new types using class definitions. 
A C++ application can contain a wealth of class definitions
modeled after real world objects, usually in the form of class libraries.
The implementation details of a class library definition are 
hidden from the programmer in favor of a public interface or set of 
operations to manipulate the class instance.
In addition, software vendors are in the 
business of providing class libraries containing all sorts of class 
definitions that are ready to use by the application programmer. 
.P
As applications move towards the client/server model, and as 
distributed object technology becomes the vehicle for such a model, 
RPC must be able to pass C++ objects as parameters efficiently and 
intrinsically.
.P
When an application is distributed, a number of issues arise that must 
be dealt with. 
These issues include the ability of the network to pass large 
amounts of data, the problem of passing pointers as RPC arguments, 
and the differences in the representation of a piece of data in the 
computer's memory that results from different machine architectures. 
These problems are addressed by DCE implementations adhering to 
the network data representation (NDR) for data types and the effective 
use of attributes in the interface definition. However, other 
problems that are specific to the C++ language include the following:
.VL
.LI "Data Hiding"
.iX "data hiding"
.iX "class libraries"
One advantage of a class definition is that it allows the application 
designer to model a programming language construct after some 
real world object and to interact with the construct in a high level fashion. 
The details of how the construct is built and manipulated should be 
handled by the designer of the class. The application programmer 
should be insulated from the class internals and only needs to be aware 
of the public interface to the object. However, this programming model 
exposes a fundamental problem when extended to DCE RPC. 
In passing a parameter to a remote procedure, 
the DCE runtime library must be able to marshal the RPC parameters 
over the network on behalf of the caller of the remote operation and 
unmarshal those parameters and reconstruct the data type on the 
server side of the application. If users are able to create new and exotic 
data types, how can the DCE runtime know how to marshal them? 
It is unreasonable to expect that DCE could  be extensible enough to 
track and know how to marshal new data types as they are created. 
It is also unreasonable to expect class designers to supply their own 
support for marshaling objects. This is especially true for data types 
that are provided as class libraries by outside vendors having no 
connection at all with DCE.
.LI "Inheritance"
.iX "inheritance"
.iX "polymorphism"
Inheritance and polymorphism are techniques available with C++ 
whereby a generic class type is used by an application but the actual 
object is created from a more specific class type. 
A classic example of this is a generic class called Shape and a 
number of specific classes such as Circle, Square and Cylinder 
that all derive from the Shape class. Shape might have operations 
such as draw() and rotate() which cause the object to be drawn 
onto the screen and rotated. The application can have an array of 
Shape objects and cause each one in turn to be displayed and 
manipulated. However, the array could be a mix of Circle, 
Square and Cylinder objects. Each object will know how to 
draw and rotate itself. For some objects, a function such as rotate() 
may have no meaning. The polymorphic behavior of the Shape class 
will forward the draw() operation to the correct specific drawing 
operation implemented by the object. The rotate() operation behaves 
similarly for classes that support rotation. 
And if the object does not support rotation, 
the Shape class will supply its own rotate implementation which 
may actually do nothing.
.P
The problem of passing a Shape object is that the DCE runtime may 
not know what type of shape the object really is. 
A Shape could have some self-identifying information, 
but this will often not be the case. Furthermore, 
if there were some shape identifier, it would need to track new 
class types as they are introduced into the application. 
This type of design is not very extensible and contrary to the 
object oriented methodology.
.LI "Lots of data"
Another problem with passing a C++ object over the network is 
fundamental to any RPC argument. 
As the amount of data needed to be passed over the wire and 
recreated in the server process increases, the performance of the 
RPC call will obviously decrease. The decision as to what kinds of 
operations are remote and what types of data they require is a basic 
design issue. For example, consider a stack type. If the stack is small 
then it may be advantageous to pass the entire stack over the wire, 
recreate it on the server side, allow the server to update it, and then 
pass it back to the client side so that it reflects any updates the 
server made to it. The IDL language supports such a paradigm by using
an array network type along with other parameters to indicate the array size. 
However, this paradigm quickly breaks down as the stack size increases. 
A better way for the server to access a large stack would be to pass a 
stack reference to the server and allow the server to access the stack 
by making RPC calls to it.
.LE
.P
Two programming methodologies are presented to illustrate how C++ 
objects can be passed as DCE RPC parameters: 
data representation and delegation. 
It is a design choice as to which solution better applies to a 
specific application problem. 
By using these methodologies, class libraries can be easily integrated 
into an application. 
Both solutions are intended to be handled primarily at the 
interface definition level so that the application itself can be 
designed in a normal and natural way while minimizing the issue 
of distributing the application. 

.H 3 "Representation"
.P
.iX "representation of C++ objects"
.iX "objects" "representation"
.iX "represent_as attribute"
.iX "ACF" "represent_as attribute"
The DCE IDL compiler supports a feature to allow a network 
representation of a data type to differ from the representation used 
by the application. This feature is invoked by using the \*Lrepresent_as\*O
attribute on a data type in the Attribute Configuration File (ACF). 
Applying this attribute to an IDL data type allows the network 
representation of a data type to be isolated within the generated stubs. 
The programmer is required to supply four conversion routines when 
using this feature. The function signatures for these four routines are 
generated by the IDL compiler. Their purpose is to convert an RPC 
argument from the application presented type to the network type, 
convert from the network type to the presented type, and to free 
memory used by the network and presented types. 
Presumably, a class library designer could supply the four conversion 
routines along with the IDL generated stub routines as a library. 
In this way, the application programmer need not be aware of how 
the data is transmitted across the wire nor that the conversions take place. 
.P
For example, consider the C++ String class which is commonly 
supplied by C++ compiler vendors or easily implemented by the 
programmer. The IDL compiler has no notion of a String class since 
it is not a primitive or constructed IDL type. 
The class definition must be made known to the IDL compiler by 
using the include directive to include the class definition into the 
generated header file. But the DCE runtime does not know how to 
marshal the String type since its internals are hidden and, in fact, 
could very well differ in its implementation between vendors.
.P
To allow a String type to be passed as an RPC argument, 
a network type for a String object is defined in the IDL file to be an 
array of characters with the string attribute applied. 
An ACF file is then created for the interface to apply the 
\*Lrepresent_as\*O attribute to the network type. 
The following code fragment is for the IDL file
represent an IDL character array as a String class in an application:
.oS
[ uuid(c5a7c094-c5e3-11ce-bac2-08002be415b2) ]
IText {
	typedef [string,unique] char * net_string;	/* 1 */
	static net_string toUpper([in] net_string s);	/* 2 */
	static net_string toLower([in] net_string s);	/* 3 */
}
.oE
.P
The following code is an ACF definition for a String type:
.oS
{
	include "String"; 				/* 4 */

	typedef [represent_as(String)] net_string;	/* 5 */
}
.oE
The code is described as follows:
.AL
.LI
A net_string is defined to be a unique pointer to a string 
.LI
The static \*VtoUpper()\*O operation takes a String argument 
and returns another one
.LI
The static \*VtoLower()\*O operation takes a String argument 
and returns another one
.LI
Include the String.h file into the \*Lidl\*O-generated header file
.LI
The network type net_string is presented as the C++ String type 
in the application
.LE
.P
Using automatic binding, the client application would invoke the static 
toUpper() operation as follows:
.oS
String s1("Hello, World");	// create a local String object
String s2 = IText::toUpper(s1);	// RPC call returns another String object
.oE
Note that a unique attribute is specified for the net_string type. 
Unique pointers should always be used when the \*Lrepresent_as\*O 
attribute is applied to a pointer type.
.P
The routines to convert between the network type and the presented 
type are automatically invoked by the DCE runtime during the 
marshalling and unmarshalling process. 
The IDL compiler generates a function signature to free the presented 
data type. In this example, this routine would be named 
\*Lnet_string_free_local(String *)\*O.
The purpose of this routine is to free the memory occupied by the 
stack variable in the server stub that represents the RPC parameter. 
But since the C++ compiler will generate code to delete local stack 
objects when the server stub routine is exited, 
this routine should not free its argument.
.P
The \*Lrepresent_as\*O attribute is properly used when the data 
comprising the C++ object can be represented by some primitive 
or constructed IDL data type. The object's data must be accessible by 
the application. The overhead involved with using the 
\*Lrepresent_as\*O attribute is the conversion from one type to the 
other and the freeing of memory.
.P
It may not always be advantageous to use the \*Lrepresent_as\*O 
attribute to pass a C++ object as an RPC parameter. 
Consider the case presented earlier where a generic Shape class is 
used in a class hierarchy with the more specific Square, 
Circle, and Cylinder shapes derived from it. 
An application may wish to pass a Shape object as an RPC parameter. 
Using the \*Lrepresent_as\*O feature would require the 
conversion routines to convert from a shape to some NDR structure 
that can be defined in IDL. However, this is complicated by the fact 
that one IDL type may not be sufficient to represent all possible shapes. 
To solve this, a discriminated union of different shape types could be 
defined. But it is also very possible that the internals of the classes 
are not exposed to the application. The user may have no knowledge 
of what data types are needed to represent even the simplest shapes 
such as a square. Furthermore, as new shapes are introduced into 
the application, the conversion routines would also require extensions 
to handle the new shapes.  An object oriented application should be 
extensible without requiring such overhead.
.P
Another drawback to using conversion routines is efficiency. 
Consider a common C++ Stack class and a distributed implementation 
of a reverse Polish notation algorithm. The algorithm maintains a stack 
of operands. When an operator is processed, the required number of 
operands are popped off the stack, the operation is performed on them, 
and the result is pushed back onto the stack. For this example, 
let's assume that the algorithm supports the plus(), minus(), multiply() 
and divide() binary operations. In order to illustrate the distributed nature 
of the algorithm, we can further assume that the client reads an 
equation in reverse Polish notation from standard input and maintains 
the stack locally, but the binary operations are implemented within a 
remote server process. Hence, the server process needs access to the 
same stack as the client. Simply passing the stack to the server 
process in its entirety would be inefficient since only the top two 
elements need to be accessed per operation. 
A large stack would quickly degrade the performance of the algorithm, 
especially since the stack would have to be passed as both an 
input and output parameter.
.P
.H 3 "Delegation"
.iX "delegation for C++ objects"
.iX "objects" "delegation"
An alternative to passing the stack is to treat the stack as a 
distributed object and pass a reference to it. 
The server and client would have access to the single stack in the 
application and the server could use the stack object reference to 
push and pop elements. A DCE distributed object requires that there 
be an interface defined for the object and the object implementation 
be derived from the generated interface class. 
If the stack being used is supplied by a third party vendor, 
it may not be possible to modify its definition to derive it from an 
IDL generated class. The solution is to create a delegate class for the 
stack to act as an interface to the actual stack object. 
A delegate class encapsulates the real object and forwards operation 
invocations to it. The IDL language has been extended to include the 
.iX "cxx_delegate attribute"
.iX "ACF" "cxx_delegate attribute"
ACF attribute \*Lcxx_delegate\*O to take advantage of this idiom. 
.P
An interface using this attribute will cause the generated interface class 
to wrap the real object. Only the operations that need to be remote 
need to be defined in the delegate class interface definition file. 
The application would then link the delegate server stub with the client. 
Likewise, the delegate client stub would be linked with the server. 
The DCE runtime will transparently perform the necessary setup to 
allow the client application to act as a server for the delegate class. 
The following example illustrates the use of the \*Lcxx_delegate\*O 
attribute with a Stack class definition:
.ne 1.5i
.oS
[ uuid(0ea74f20-e2dc-11ce-9a8e-08002be415b2) ]
interface IStack 				/* 1 */
{
	void push([in] double x);		/* 2 */
	double pop();				/* 3 */
}
.oE
.P
The ACF definition for delegation of the IStack interface is as follows:
.oS
[ cxx_delegate(Stack) ]				/* 4 */
interface IStack{
	include "Stack";			/* 5 */
}
.oE
.AL
.LI
An IStack interface is defined
.LI
The push() operation pushes an element onto the encapsulated stack
.LI
The pop() operation pops an element from the encapsulated stack
.LI
The IStack interface is a delegate for a Stack class
.LI
include the Stack.h file into the IDL generated header file
.LE
.P
Using the generated server stub and header file from the above 
IDL fragment, the client application would instantiate an IStack 
interface pointer and pass it to the remote procedure as follows:
.oS
Stack	s;			// create a local stack object
IStack *iStack;			// declare an interface pointer to the local stack
iStack = new IStackMgr(&s);	// create the interface ptr using the local stack
.oE
.iX "cxx_delegate attribute"
.iX "ACF" "cxx_delegate attribute"
The \*Lcxx_delegate\*O attribute causes the IDL generated classes 
to be built slightly different than a normal interface class. 
The interface class contains a constructor that takes a pointer 
to the delegated class instance as an argument and the manager 
class supplies complete function bodies. 
The programmer does not need to supply a manager class for an 
interface using this attribute.
.P
The server application would use the interface pointer to invoke 
the push() and pop() operations on the client's stack instance. 
The overhead involved is the remoteness of the push() and pop() 
operations which are implemented as RPC calls from the server 
to the client.  In this example, the client application would be 
linked with the IDL generated server stub from the IStack interface 
and the server application would be linked with the IDL generated 
client stub from the IStack interface. No extra DCE API calls are 
required on the part of the client or server stubs. The DCE runtime 
will handle the necessary overhead to allow the client application 
to act as a server for the IStack interface.
.P
This idiom is most effectively used when a class type is needed as
an RPC argument but the class hierarchy can not be changed by 
the application or when the overhead of the RPC calls to access 
the object is outweighed by the combined overhead of converting 
the object to a network type and the complexity of  passing or 
updating a large amount of data in the RPC call.
.P

.H 2 "Integrating C and C++ Clients and Servers"
.P
.iX "C and C++ integration"
This chapter has assumed your clients and servers are both written in
C++, and the rest of this guide describes how to write clients and
servers that are both written in C.  Two fundamental differences
between these types of applications are their perception of what
interfaces represent and whether clients bind to servers or objects.
.P
For C applications, the model tends to be functionally oriented.  The
important features are the operations, in which an interface represents a
convenient set of operations with associated data structures.  Clients
bind to servers that support the set of operations and data.
.P
For C++ applications, the model tends to be object oriented.  In this
model, the important feature is the interface itself, which represent
a class of objects.  Operations are an integral part of each object,
but data structures tend to be hidden in the implementations on the
servers and not exposed in the interface.  In this model, clients bind
to objects that support the interfaces.
.P
This section addresses the intersection of these two models in the
following ways:
.ML
.LI
Writing C++ clients with a functional approach so that they bind
to servers (written in C) rather than to distributed objects
.LI
Writing C clients so that they can bind to distributed objects
rather than to servers
.LE
.H 3 "Writing a C++ Client for C Servers"
.P
.iX "C++ clients for C servers"
Suppose you are writing a C++ client that needs to use an interface
definition that has not taken advantage of the IDL C++ features.  A
logical example is an older interface definition written prior to the
introduction of the C++ features of OSF DCE Version 1.2.  
An older interface is not designed to specify a
class of objects and the associated member functions.  This means that
servers for older interfaces do not maintain objects in the way
described in this chapter (if they maintain objects at all).  
.P
This section uses the following simplistic interface for demonstration:
.oS
[
    uuid(166ab38b-95f9-11ce-9387-08002b2bf322)
]   interface old_interface
{
        double op1();

        void   op2([in] long input);

        void   op3();
}
.oE
.P
If you simply compile this interface definition for the C++ language 
and build the C++ client application, the application cannot invoke 
any of the old
interface's member functions because no object can exist on a server.
However, static member functions do not require an object in order to
invoke them, so the solution is to make the operations of an older
interface static member functions.
.P
In order for your C++ client to use an older interface, perform the
following steps:
.AL
.LI
Create an ACF for the interface and apply the \*Lcxx_static\*O
attribute to \*Vevery\*O operation of the interface.  For example:
.oS
interface old_interface
{
	[cxx_static] op1();
	[cxx_static] op2();
	[cxx_static] op3();
}
.oE
.LI
Use the IDL compiler with the \*L-lang cxx\*O option to compile the
interface and generate the header files and C++ stubs.  Link the code
into your C++ client application as usual.
.LI
Call the static functions where needed in the C++ client application
by using the scope operator (::).  For example:
.oS
#include "old_interface.h"

main()
{
	idl_long_float	result;
	idl_long_int	input = 1;

	result = old_interface::op1();
	old_interface::op2(input);
	old_interface::op3();
	return 0;
}
.oE
.LE
.H 3 "Writing a C Client for C++ Servers"
.P
.iX "C Client for C++ Servers"
If you wish, you can develop C language clients that use interfaces
written with C++ features.  Whenever the interface definition is
compiled for C++, C structures, macros, and function prototypes are
automatically built into the header file and stubs to give this
capability.
.P
For example, the following \*Lget(\|)\*O operation is defined in the
Matrix interface definition:
.oS
long get(
	long row,
	long col
);
.oE
.P
The macros generated by the IDL compiler are formed by combining the
name of the interface and the name of the operation with an underscore
between.  For example, to allow a C client to invoke the \*Lget\*O 
operation on the interface, 
the IDL compiler generates the following macro in the header file: 
.oS
Matrix_get(obj, row, col)
.oE
.P
Since member functions cannot be called in C with an implied object 
(the C++ \*Vthis\*O object), each member function for the C macros has
an additional object argument as the first parameter.
The remaining arguments are the same as those specified
in the IDL input file.
.P
To obtain the interface pointer using the C mapping, use one of the
bind routines generated by the IDL compiler for the C interface.
These are also generated in the header file.  For example, the Matrix
interface supports the following C macros for binding to a remote
object:
.oS
Matrix *Matrix_bind_by_name(unsigned_char_t *name);
Matrix *Matrix_bind_by_uuid(uuid_t * u);
Matrix *Matrix_bind_by_hndl(rpc_binding_handle_t bh);
.oE
.P
All static member functions of an interface are also supported for C.
The macros are formed in a manner similar to the normal member
functions (by joining the interface name and the operation name with
an underscore), except there is no need for an additional argument to
represent a current object.  For example, if the Matrix interface
supports the \*LcreateMatrix(\|)\*O static operation, the following
example C code invokes the operation:
.oS
/* code fragment showing the use of C macros */
Matrix *m;	/* a C structure to represent an interface */
/*
** invoke a static member function to get an interface
** pointer and invoke operations on it.
*/
m = Matrix_createMatrix(1, 2, 3, 4);
if (!m) {
	/* handle error */
} else {
	printf("[%d, %d]\\n", Matrix_get(m, 0, 0), Matrix_get(m, 0, 1));
	printf("[%d, %d]\\n", Matrix_get(m, 1, 0), Matrix_get(m, 1, 1));
}
.oE

