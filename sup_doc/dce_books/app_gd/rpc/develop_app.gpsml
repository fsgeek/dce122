...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
...\" src directory for the full copyright text.
...\"
...\"         
...\" HISTORY
...\" $Log: develop_app.gpsml,v $
...\" Revision 1.1.4.2  1996/03/27  13:32:22  wardr
...\" 	{edit R1.2.1}
...\" 	More Release Edits
...\" 	[1996/03/27  13:31:45  wardr]
...\"
...\" Revision 1.1.4.1  1996/03/21  20:31:31  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/21  20:31:01  wardr]
...\" 
...\" Revision 1.1.2.8  1995/06/07  14:37:35  rcb
...\" 	PRENTICE HALL reformat; final edits and changes
...\" 	[1995/06/05  19:55:49  rcb]
...\" 
...\" 	1.1 edits: minor addition
...\" 	[1995/05/01  20:04:48  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/04/20  15:22:39  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/04/20  15:20:35  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/04/17  16:46:38  rcb]
...\" 
...\" 	incorporated 1.1 edits
...\" 	[1995/04/17  15:39:14  rcb]
...\" 
...\" Revision 1.1.2.7  1994/10/27  19:42:52  jshirley
...\" 	Final edits.
...\" 	[1994/10/27  19:41:43  jshirley]
...\" 
...\" Revision 1.1.2.6  1994/10/20  22:52:37  jshirley
...\" 	Fixed figure and pagination problems.
...\" 	[1994/10/20  22:52:11  jshirley]
...\" 
...\" Revision 1.1.2.5  1994/10/19  21:55:41  neilson
...\" 	Automatic fix to mistake in .zA-.zZ
...\" 	[1994/10/19  21:54:46  neilson]
...\" 
...\" Revision 1.1.2.4  1994/09/14  19:21:10  jshirley
...\" 	{def,10526,R1.1,Reorg RPC chapters.
...\" 	[1994/09/14  19:20:31  jshirley]
...\" 
...\" Revision 1.1.2.3  1994/07/13  15:02:17  jshirley
...\" 	{def,10220,R1.1} Remove reference to rpcd and sec_clientd
...\" 	[1994/07/13  15:01:36  jshirley]
...\" 
...\" Revision 1.1.2.2  1994/07/11  14:05:40  jshirley
...\" 	{def,10526,R1.1}
...\" 	Merged in information from old files (1_intro.gpsml, 5_dce_rpc_ops.gpsml)
...\" 	and modified headings.  Data is still in a rough state.
...\" 	[1994/07/11  14:05:19  jshirley]
...\" 
...\" Revision 1.1.2.1  1994/07/07  16:56:12  jshirley
...\" 	{def, 10526, R1.1}
...\" 	Created new file for the RPC reorganization based on the
...\" 	old file 3_build_app.gpsml.
...\" 	[1994/07/07  16:54:36  jshirley]
...\" 
...\" $EndLog$
...\"
...\" (c) Copyright 1991, Open Software Foundation, Inc.  ALL RIGHTS RESERVED
...\" Copyright 1991, Open Software Foundation, Inc.  ALL RIGHTS RESERVED.
...\"   (C) Copyright Hewlett-Packard Company 1990.
...\"
...\"  All Rights Reserved.  Reproduction, adaptation,
...\"  or translation without prior written permission
...\"  is prohibited, except as allowed under the
...\"  copyright laws.
...\"
...\" ********************************************************************
...\"                                                                    *
...\" COPYRIGHT (c) 1990 BY DIGITAL EQUIPMENT CORPORATION,               *
...\" Maynard, Mass.                                                     *
...\"                                                                    *
...\" This document is furnished under a license and may be used and     *
...\" copied only in accordance with the terms of such license and with  *
...\" the inclusion of the above copyright notice.  This document or any  *
...\" other copies thereof may not be provided or otherwise made         *
...\" available to any other person.  No title to or ownership of the     *
...\" document is hereby transferred.                                    *
...\"                                                                    *
...\" The information in this document is subject to change without      *
...\" notice and should not be construed as a commitment by DIGITAL      *
...\" Equipment Corporation.                                             
.H 1 "Developing a Simple RPC Application"
.P
This chapter first explains how to write an interface definition in the
DCE RPC Interface Definition Language (IDL) and illustrates the basic
features of IDL.  As an example, we present an interface definition
for \*Lgreet\*O, a very simple application that prints greetings from
a client and a remote server. 
The remainder of the chapter describes how to develop, build, and 
run the \*Lgreet\*O client and server programs.
.P
The 
...\" Intro&Style Volume
\*(Di
describes how to develop a DCE application by
using many of the features of DCE.
The following chapters use the term 
\*Eremote procedure call application\*O (\*ERPC application\*O)
to mean essentially the same thing, 
except in this context an RPC application concentrates on the features
of the RPC technology, glossing over other DCE issues such as security,
threads, and messaging.
Since the RPC mechanism is the root technology for all DCE
applications, the basic development approach is the same.
.iX "-: IDL" "Interface Definition Language"
.iX "-; RPC" "interface" "interface"
.iX "-; API" "interface"
.iX "-; RPC" "application" "application"
.iX "-; RPC" "remote procedure call"
...\"
...\"
...\"
.H 2 "The Remote Procedure Call Model"
.iX "remote procedure call"
A remote procedure call executes a procedure located in a separate address
space from the calling code.  The RPC model is a well-tested, 
industry-wide framework for distributing applications.
The RPC model is derived from the programming
model of local procedure calls 
and takes advantage of the fact that every procedure contains a
...\" .gL "procedure declaration"
.iX "procedure declaration"
procedure declaration.  The procedure declaration
defines the interface between the calling code and the called procedure. 
The procedure declaration defines the call syntax and parameters of the
procedure.  
All calls to a procedure must conform to the procedure declaration. 
.P
Applications that use remote procedure calls 
look and behave much like local applications.  
However, an RPC application is divided into two parts: 
.iX "server"
a server, which offers one or more sets of remote procedures, and a
.iX "client" "definition of"
client, which makes remote procedure calls to RPC servers.  A server
and its clients generally reside on separate systems and communicate over a
network.  RPC applications depend on the RPC runtime
to control network communications for them.
The DCE RPC runtime supports additional tasks, such as
finding servers for clients and managing servers.
.P
A distributes application uses dispersed computing resources such as CPUs,
databases, devices, and services.  The following are examples:
.ML
.LI
A calendar-management application that allows authorized users
to access the personal calendars of other users.
.LI
A graphics application that processes data on central CPUs
and displays the results on workstations.
.LI
A manufacturing application that
shares information about assembly components 
among design, inventory, scheduling,
and accounting programs located on different computers.
.LE
.P
DCE RPC meets the basic requirements of a distributed application, including
.ML
.LI
Clients finding the appropriate servers 
.LI
Data conversion for operating in a heterogeneous environment 
.LI
Network communications
.LE 
.P
.ne 5
Distributed applications include tasks such as managing communications, 
finding servers, providing security, and so forth. 
A standalone distributed application needs to perform all of these
tasks itself. 
Without a convenient mechanism for these distributed computing tasks,
writing distributed applications is difficult, expensive, and error-prone. 
.P
DCE RPC software provides the code, called stubs, and the RPC runtime that
perform distributed computing tasks for your applications.
This code and the runtime libraries are linked with client and server
application code to form an RPC application. 
.P
Table 11-1 shows the basic tasks for the client and server of a
distributed application.  Calling the procedure and executing the
remote procedure, shown in bold text, are performed by your application
code (just as in a local application) but here they are in the client
and server address spaces.
For the other tasks, some are performed automatically by the stubs and
RPC runtime, while others are performed by the RPC runtime via API
calls in your application.
.iX "application" "Basic RPC tasks of"
.PP
.ne 6i
.TB "Basic Tasks of an RPC Application"
.na
.ps 11
.vs 13
.TS
center, box, tab(@);
cB s | cB s
l l | l l.
Client Tasks@Server Tasks
=
@@
@@1.@Select network protocols.
@@2.@Register RPC interfaces.
@@3.@T{
Register endpoints in endpoint map.
T}
@@4.@T{
Advertise RPC interfaces and objects in the namespace.
T}
@@5.@Listen for calls.
@@
6.@T{
Find compatible servers that offer the procedures.
T}@@
7.@\*LCall the remote procedure\*O.@@
8.@T{
Establish a binding with the server.
T}@@
9.@T{
Convert input arguments into network data.
T}@@
10.@T{
Transmit arguments to the server's runtime.
T}@@
@@
@@11.@Receive a call.
@@12.@T{
Disassemble network data and convert input arguments into local data.
T}
@@13.@T{
Locate and invoke the called procedure.
T}
@@14.@\*LExecute the remote procedure\*O.
@@15.@T{
Convert the output arguments and return value into network data.
T}
@@16.@T{
Transmit results to the client's runtime.
T}
@@
17.@Receive results.@
18.@T{
Disassemble network data and convert output arguments into local data.
T}@@
19.@T{
Return results and control to calling code.
T}@@
.TE
.ps 12
.vs 14
.ad
.P
...\"OLD FIGURE .FG "Basic Tasks of an RPC Application"
...\" DEC-file name .P! pictures/rpc-dp-steps-generic.ps 8.0i
...\".pI ../rpc/figures/1_intro_01.ps 0 0 1
.H 3 "RPC Application Code"
.P
.iX "RPC" "parts of application"
An RPC server or client contains application code, one or more RPC stubs, 
and the RPC runtime. 
.iX "application" "RPC code"
RPC application code is the code written for a specific RPC application
by the application developer.  Application code implements and calls remote
procedures, and also calls any RPC runtime routines the application needs. 
.iX "stub"
An RPC stub is an interface-specific code module that uses an RPC
interface to pass and receive arguments.  A server and a client contain
complementary stubs for each RPC interface they share. 
The DCE RPC runtime manages communications for RPC applications. 
In addition, the DCE RPC runtime
supports an application programming interface (API) used
.iX "API" "definition of"
by RPC application code to enable RPC applications 
to set up their communications, manipulate information about servers, 
and perform optional tasks such as remotely managing servers and accessing
security information. 
.P
Figure 11-1 shows the relationship of application code,
stubs, and the RPC runtime in the server and client portions of an RPC
application.  
The arrows show the direction calls are made by pointing to the called code.
.PP
.FG "The Parts of an RPC Application"
.pI ../rpc/figures/parts_of_rpc_app.ps 0 0 1
...\" DEC-file name: zk-5465a.ps
...\" DEC-file name .P! pictures/rpc-appl.ps 4.5i
...\" OLD 1.0.3 FILE .pI ../rpc/figures/1_intro_05.ps 0 0 1
.sp .5
.PP
.ne 4
RPC application code differs for servers and clients.  Minimally,
server application code contains the remote procedures that
implement one RPC interface, and the corresponding client contains
calls to those remote procedures. 
.H 3 "Stubs"
.P
The stub performs basic support functions for remote procedure calls.
For instance, stubs prepare input
and output arguments for transmission between systems with different forms of
data representation. 
The stubs use the RPC runtime to handle the transmission between the
client and server.
The client stub can also use the runtime to find servers for the client. 
.P
When a client application calls a remote procedure, the client stub
first prepares the input arguments for transmission.
The process for preparing arguments for transmission is known as
\*Emarshalling\*O.  Marshalling converts call 
.iX "marshalling" "RPC"
arguments into a byte-stream format and packages them for transmission.
Upon receiving call arguments, a stub unmarshalls them.
.iX "unmarshalling" "RPC"
Unmarshalling is the process by which a stub disassembles incoming
network data and converts it into application data by using a format that
the local system understands.  Marshalling and unmarshalling both
occur twice for each remote procedure call; that is, the client stub
marshalls input arguments and unmarshalls output arguments, and the
server stub unmarshalls input arguments and marshalls output
arguments.  Marshalling and unmarshalling permit client and server
systems to use different data representations for equivalent data.
For example, the client system can use ASCII characters and the server
system can use EBCDIC characters, as shown in Figure 11-2.
.PP
.ne 3i
.FG "Marshalling and Unmarshalling Between ASCII and EBCDIC Data"
...\" DEC-file name .P! pictures/rpc-marshalling.ps 3.0i
.pI ../rpc/figures/1_intro_06.ps 0 0 1
.sp .5
.P
The DCE IDL compiler (a tool for DCE application development) generates stubs by
compiling an RPC interface definition written by application developers. 
The compiler generates marshalling and unmarshalling routines for
platform-independent IDL data types.  
.P
To build the client for an RPC application, a developer
links client application code with the client stubs of all the RPC
interfaces the application uses.  To build the server, the developer links 
the server application code with the corresponding server stubs.
.H 3 "The RPC Runtime"
.P
In addition to one or more RPC stubs, every RPC server and RPC client is linked
with a copy of the RPC runtime.
.iX "RPC" "runtime"
Runtime operations perform tasks such as controlling communications between
clients and servers and finding servers for clients on request.
An interface's client and server stubs exchange arguments through their local
RPC runtimes. 
The client runtime transmits remote procedure calls to the server. 
The server runtime receives the
calls and dispatches each call to the appropriate server stub.  The server
runtime sends the call results to the client runtime. 
The DCE RPC runtime supports the RPC API used
by RPC application code to call runtime routines.
.P
.ne 6
Server application code must also contain 
.iX "server" "initialization code"
server initialization code that calls RPC runtime routines when the
server is starting up and shutting down.  Client application code can also call
RPC runtime routines.  Server and client application code can also contain calls
to RPC stub-support routines.  Stub-support routines allow applications to
manage programming tasks such as allocating and freeing memory. 
.H 3 "RPC Application Components That Work Together"
.P
Figure 11-3 shows the roles of application code, RPC stubs, and RPC
runtimes during a remote procedure call. 
.P
.ne 5i
.FG "Interrelationships During a Remote Procedure Call"
...\" DEC-file name .P! pictures/rpc-call.ps  5.25i
...\"OLD 1.0.3 file .pI ../rpc/figures/1_intro_07.ps 0 0 1
.pI ../rpc/figures/during_an_rpc.ps 0 0 1
.sp .5
.PP
.ne 2
The following steps describe the interrelationships of the components
of RPC applications, as shown in the previous figure:
.AL
.LI
.ne 2
The client's application code invokes a remote procedure call,
passing the input arguments to the stub for the particular 
RPC interface.
.LI
The client's stub marshalls the input arguments
and dispatches the call to the client's RPC runtime.
.LI
The client's RPC runtime transmits the input arguments
to the server's RPC runtime, which dispatches the
call to the server stub for the RPC interface of the called procedure.
.LI
The server's stub unmarshalls the input
arguments and passes them to the called remote procedure.
.LI
The procedure executes and then returns any results
(output arguments or a return value or both) to the server's stub.
.LI
The server's stub marshalls the results
and returns them to the server's RPC runtime.
.LI
The server's RPC runtime transmits the results to the client's RPC
runtime, which dispatches them to the correct client stub.
.LI
The client's stub unmarshalls output arguments and returns them to the calling
code.
.LE
.H 3 "Overview of DCE RPC Development Tasks"
.P
The tasks involved in developing an RPC application resemble
those involved in developing a local application.  As 
an RPC developer, you perform the following basic tasks:
.AL
.LI
Design your application, deciding what procedures you need, which
will be remote procedures, and how the remote procedures will be
grouped into RPC interfaces. 
.LI
Use the Universal Unique Identifier (UUID) generator to generate
a UUID for each new interface.
.LI
Use the IDL 
to describe the RPC interfaces for the planned data types and remote procedures.
.LI
.ne 3
Use the DCE IDL compiler to generate the client and server stubs.  
(The IDL compiler can invoke the C compiler to create the stub object code.)
Figure 11-4 illustrates this task.
.P
.ne 2.5i
.FG "Generating Stubs"
...\" DEC-file name .P! pictures/rpc-idl-compiler.ps 3.0i
.pI ../rpc/figures/1_intro_08.ps 0 0 1
.sp .5
.P
.nS note
Optionally, instead of generating stub object code
(which is not portable), 
the IDL compiler can generate the stubs as ANSI C compliant source code.
.nE
.LI
Write or modify application code 
...\" .gL "compatible programming language"
.iX "compatible" "programming language"
by using a compatible programming language; that is, a language that can be
linked with C and can invoke C procedures, so the application code works with
the stubs. 
.PP
Application code includes several kinds of code, as follows:
.AL
.LI
Remote procedure calls 
.LI
Remote procedure implementations
.LI
Initialization code (calls to RPC stub-support or 
runtime routines)
.LI
Any non-RPC code your application requires
.LE 
.LI
Generate object code from application code.
.LI
Create an executable client and server from the object files.
Figure 11-5 illustrates this task.
.PP
For the client, link object code of the client stub(s) and the
client application with the RPC runtime and any other needed runtime libraries.
.PP
For the server,
link object code for the server stub(s), the initialization routines, and
the set(s) of remote procedures with the RPC runtime and 
any other needed runtime libraries. 
.LI
After initial testing, distribute the new application by separately installing
the server and client executable images on systems on the network. 
.LE
.PP
.FG "Building a Simple Client and Server"
...\" DEC-file name .P! pictures/rpc-build-appl.ps 2.75i
.pI ../rpc/figures/1_intro_09.ps 0 0 1
.H 2 "Writing an Interface Definition"
.P
Traditionally, calling code and called procedures share the same address space. 
In an RPC 
application, the calling code and the called remote procedures are not
linked; rather, they communicate
indirectly through an RPC interface.  An
.iX "RPC" "interface"
RPC interface is a logical grouping of operations, 
data types, and constants that serves as a contract for a set of
remote procedures.   
DCE RPC interfaces are compiled from formal interface definitions written 
by application developers using IDL.
.P
The first step in developing a distributed application is to write
an interface definition file in IDL. The IDL compiler, \*Lidl\*O,
uses the interface definition to generate a header
file, a client stub file, and a server stub file.  The IDL compiler
produces header files in C and can produce stubs as C source
files or as object files. 
.P
.ne 5
For some applications, you may also need to write an Attribute Configuration
File (ACF) to accompany the interface definition.  If an ACF exists,
the IDL compiler interprets the ACF when it compiles the interface
definition.  Information in the ACF is used to modify the code that the
compiler generates. (The \*Lgreet\*O example does not require an ACF.)
.P
The remainder of this section briefly explains how to create an interface
definition and gives simple examples of each kind of IDL declaration.
For a detailed description of IDL, see Chapter 18.
For information on the IDL compiler, see the \*Lidl(1rpc)\*O reference page.
.P
An IDL interface definition consists of a header and a body.
The following example shows the interface definition for the \*Lgreet\*O
application:
.oS
/*
 * greet.idl
 *
 * The "greet" interface.
 */

[uuid(3d6ead56-06e3-11ca-8dd1-826901beabcd),
version(1.0)]

interface greetif
{
    const long int REPLY_SIZE = 100;

    void greet(
        [in]            handle_t h,
        [in, string]    char client_greeting[],
        [out, string]   char server_reply[REPLY_SIZE]
    );
}
.oE
.P
The header of each RPC interface contains a
.iX "universal unique identifier"
.iX "UUIDs" "definition of"
UUID, which is a hexadecimal number that uniquely identifies an entity. 
A UUID that identifies an RPC interface is known as an 
.iX "interface" "RPC UUIDs"
.iX "interface" "UUID" "RPC definition of"
\*Einterface UUID\*O.  The interface UUID ensures that the
interface can be uniquely identified across all possible network configurations.
In addition to an interface UUID, each RPC interface
contains major and minor version numbers.  Together, the interface UUID and
version numbers form an interface identifier that identifies an
instance of an RPC interface across systems and through time. 
.P
The interface body can contain the following constructs:
.ML
.LI
Import declarations (not shown)
.LI
Constant declarations (\*LREPLY_SIZE\*O)
.LI
Data type declarations (not shown)
.LI
Operation declarations (\*Lvoid greet(...);\*O)
.LE
.P
IDL declarations resemble declarations in ANSI C. IDL is purely a
declarative language, so, in some ways, an IDL interface definition
is like a C header file.  However, an IDL interface definition must
specify the extra information that is
needed by the remote procedure call mechanism.
Most of this information is expressed via IDL attributes. 
IDL attributes can apply to types, to type members, to operations, 
to operation parameters, or to an interface as a whole. 
An attribute is represented 
in \*L[ ]\*O (brackets) before the item to which it applies.
In the \*Lgreet.idl\*O example, the \*L[in, string]\*O attributes
associated with the \*Lclient_greeting\*O array means the parameter is
for input only and that the array of characters has the properties of
strings. 
.P
A comment can be inserted at any place in an interface definition where
whitespace is permitted.  IDL comments, like C comments, begin with 
\*L/*\*O (a slash and an asterisk) and end with \*L*/\*O
(an asterisk and a slash).
.H 3 "RPC Interfaces That Represent Services"
.P
The simplest RPC application uses only one RPC interface.
However, an application can use multiple RPC interfaces,
and, frequently, an integral set of RPC interfaces work together as an
.iX "service" "RPC"
RPC service.  An RPC server is a logical 
grouping of one or more RPC interfaces. 
For example, you can write a calendar server that contains only 
a personal calendar interface or a calendar server that contains additional
RPC interfaces such as a scheduling interface for meetings.
.PP
Different servers can share one or more RPC interfaces. 
For example, an administrative-support application can include an RPC
interface from a calendar service.
.P
.ne 7
An RPC interface exists independently of specific applications. 
Each RPC interface can be implemented by any set of procedures that conforms
to the interface definition. 
The operations of an interface are exactly the same for
all implementations of the same version of the interface.  
This makes it possible for clients from different implementations to call the
same interface, and servers from different implementations to offer the same
interface.
.P
Figure 11-6 shows the role of RPC interfaces in remote
procedure calls.  This client contains calling code that makes two
remote procedure calls.  The first is a remote procedure call to Procedure A.
The second is a remote procedure call to Procedure B.
.P
.ne 3.75i
.FG "Role of RPC Interfaces"
...\" DEC-file name .P! pictures/rpc-if-role.ps 2.75i
...\" FIGURE for 1.0.3  .pI ../rpc/figures/1_intro_04.ps 0 0 1
.pI ../rpc/figures/role_of_interface.ps 0 0 1
.sp .5
.PP
Clients can use any practical combination of RPC interfaces, whether offered
by the same or different servers.  For this example, using a database access
interface, a client on a graphics workstation can call a remote procedure on
a database server to fetch data from a central database. 
Then, using a statistics interface, the client can call a procedure
on another server on a parallel processor to analyze the data from the
central database and return the results to the client for display.
.H 3 "Generating an Interface UUID"
.iX "interface" "UUID"
.iX "interface" "definitions"
.iX "skeletal interface definitions"
.P
The first step in building an RPC application is to generate a
skeletal interface definition file and a UUID for the interface.  Every
interface in an RPC application must have a UUID.  
When you define a new interface, you must generate a new UUID for it. 
.P
Typically, you run \*Luuidgen\*O with the \%\*L-i\*O option,
which produces a skeletal interface definition file and 
includes the generated UUID for the interface.  For example, the
following command creates a file \*Lchess.idl\*O:
.iS
uuidgen -i > chess.idl
.iE
The contents of the file are as follows:
.oS
[
uuid(443f4b20-a100-11c9-baed-08001e0218cb),
version(1)
]
interface INTERFACENAME {

}
.oE
.P
The first part of the skeletal definition is the header, which 
specifies a UUID, a version number, and a name for the 
interface.  The last part of the definition is \*L{ }\*O (an empty pair of 
braces); import, constant, type, and operation declarations 
go between these braces.
.P
.iX "names"
.iX "conventions"
By convention, the names of interface definition files end with the 
suffix \*L.idl\*O.  
The IDL compiler constructs names for its output files based on the 
interface definition filename and uses the following default suffixes:
.ML
.LI 
\*L.h\*O for header files
.LI 
\*L_cstub.o\*O for client stub files
.LI 
\*L_sstub.o\*O for server stub files
.LE
.P
For example, compilation of a \*Lchess.idl\*O interface definition
file would produce a \*Lchess.h\*O header file, a \*Lchess_cstub.o\*O
client stub file, and a \*Lchess_sstub.o\*O server stub file. 
(The IDL compiler creates C language intermediate files and by default
invokes the C compiler to produce object files, but it can also retain the C
language files.)
.P
For more information on the UUID generator, see the \*Luuidgen(1rpc)\*O
reference page.
.P
.H 3 "Naming the Interface"
.P
After you have used \*Luuidgen\*O to generate a skeletal interface
definition, replace the dummy string \*LINTERFACENAME\*O with the
name of your interface.
.P
By convention, the name of an interface definition file is the same
as the name of the interface it defines, with the suffix \*L.idl\*O
appended.  For example, the definition for a \*Lbank\*O interface
would reside in a \*Lbank.idl\*O interface definition file,
and, if the application required an ACF, its name would be \*Lbank.acf\*O.
.P
The IDL compiler incorporates the interface name in identifiers it
constructs for various data structures and data types in the \*L.h\*O
file, so the length of an interface name can be at most 17 characters.
.iX "conventions"
.iX "names"
(Most IDL identifiers have a maximum length of 31
characters.)
.P
.H 3 "Specifying Interface Attributes"
.P
Interface attributes are defined within \*L[ ]\*O (brackets) 
in the header of the
interface definition.  The definition for any remote interface needs to
specify the \*Luuid\*O and \*Lversion\*O interface attributes, so
these are included in the skeletal definition that \*Luuidgen\*O
produces.
.P
If an interface is exported by servers on well-known endpoints,
these endpoints must be specified via the \*Lendpoint\*O attribute.
Interfaces that use dynamic endpoints do not have this attribute.
(A well-known endpoint is a stable address on the host, 
while a dynamic endpoint is an
address that the RPC runtime requests when the server is started.)
.P
The interface definition language can be used to specify procedure prototypes
for any application, even if the procedures are never used remotely.
If all of the procedures of an interface are called only locally and
never remotely, the interface can be given the \*Llocal\*O attribute.
Since local calls do not have any network overhead, the \*Llocal\*O attribute
causes the compiler to generate only a header file, not stubs, for the
interface.
.H 3 "Import Declarations"
.P
The IDL \*Limport\*O declaration specifies another interface definition
whose types and constants are used by the importing interface.
(Similar to the \*Linclude\*O declaration in C.)
.P
The \*Limport\*O declaration allows you to collect declarations for
types and constants that are used by several interfaces into one
common file.  For example, if you are defining two database interfaces
named \*Ldblookup\*O and \*Ldbupdate\*O, and these interfaces have
many data types and constants in common, you can declare those data
types and constants in a \*Ldbcommon.idl\*O file and import this file in the
\*Ldblookup.idl\*O and\*L dbupdate.idl\*O interface definitions.
For example:
.oS
import "dbcommon.idl";
.oE
.P
By default, the IDL compiler resolves relative pathnames of imported
files by looking first in the current working directory and then in
the system IDL directory.  The \%\*L-I\*O option of the IDL compiler
allows you to specify additional directories to search.  You can
thereby avoid putting absolute pathnames in your interface
definitions.  For example, if an imported file has the absolute
pathname \*L/dbproject/src/dbconstants.idl\*O, then the IDL compiler
option \*L-I/dbproject/src\*O allows you to import the file by its
leaf name, \*Ldbconstants.idl\*O.
.P
.H 3 "Constant Declarations"
.P
The IDL \*Lconst\*O declaration allows you to declare integer,
Boolean, character, string, and null pointer constants, some of which are
shown in the following examples:
.oS
const short TEN = 10;
const boolean VRAI = TRUE;
const char* JSB = "Johann Sebastian Bach";
.oE
.H 3 "Type Declarations"
.P
To support application development in a variety of languages and to
support the special needs of distributed applications, IDL provides
an extensive set of data types, including the following:
.ML
.LI
Simple types, such as integers, floating-pointing
numbers, characters, Booleans, and the primitive binding-handle
type \*Lhandle_t\*O (usually equivalent to \*Lrpc_binding_handle_t\*O)
.LI
Predefined types, including ISO international character
types and the error status type \*Lerror_status_t\*O
.LI
Constructed types, such as strings, structures, unions,
arrays, pointers, and pipes
.LE
.P
The IDL \*Ltypedef\*O declaration lets you give a name to any types you
construct.
.P
The general form of a type declaration is
.iS
typedef \*O[\*Vtype_attribute\*L,\*O...] \*Vtype_specifier type_declarator\*L,\*O...\*L;
.iE
.P
where the bracketed list of type attributes is optional.  The
\*Vtype_specifier\*O specifies a simple type, a constructed type, a
predefined type, or a type previously named in the interface. 
Each \*Vtype_declarator\*O is a name
for the type being defined.  As in C, arrays and pointers are declared
by the \*Vtype_declarator\*O constructs \*L[ ]\*O (brackets)
and \*L*\*O (asterisk).
.P
The following type declaration uses the IDL's simple
data type, \*Llong\*O (a 32-bit data type), 
to define the \*Linteger32\*O integer type:
.oS
typedef long integer32;
.oE
.P
The \*Vtype_specifier\*O constructs for structures and unions permit
the application of attributes to members.  In the following example,
one member of a structure is a conformant array (an array without
a fixed upper bound), and the \*Lsize_is\*O attribute names another
member of the structure that at runtime provides information
about the size of the array:
.iS
.ne 4
typedef struct {
     long dsize;
     [size_is(dsize)] float darray[];
     } dataset;
.iE
.H 3 "Operation Declarations"
.P
Operation declarations specify the signature of each operation in
the interface, including the operation name, the type of data returned,
and the types of all parameters passed (if any) in a call.
.P
The general form of an operation declaration is
.iS
.ps 11
\*O[\*Voperation_attribute\*L,\*O ...] \*Vtype_specifier operation_identifier\*L ([\*Vparameter_declaration\*L,\*O ...\*L]);
.ps 12
.iE
.P
where the bracketed list of operation attributes is optional.  Among
the possible attributes of an operation are \*Lidempotent\*O, 
\*Lbroadcast\*O, and \*Lmaybe\*O, which specify semantics to be applied by
the RPC runtime mechanism when the operation is called.  If an operation
when called once can safely be executed more than once, the IDL declaration
of the operation may specify the \*Lidempotent\*O attribute;
\*Lidempotent\*O semantics allow remote procedure calls to execute more
efficiently by letting the underlying RPC mechanism retry the procedure if it
deems it necessary.
.P
The \*Vtype_specifier\*O specifies the type of data returned by
the operation.
.P
The \*Voperation_identifier\*O names the operation.  Although operation
names are arbitrary, a common convention is to use the name of an
interface as a prefix for the names of its operations.  For example,
a \*Lbank\*O interface may have operations named \*Lbank_open\*O,
\*Lbank_close\*O, \*Lbank_deposit\*O, \*Lbank_withdraw\*O,
and \*Lbank_balance\*O.
.P
Each \*Vparameter_declaration\*O in an operation declaration declares
a parameter of the operation.  A \*Vparameter_declaration\*O 
takes the following form:
.iS
\*O[\*Vparameter_attribute\*L,\*O ...] \*Vtype_specifier parameter_declarator
.iE
.P
.ne 4
Every parameter attribute must have at least one of the parameter
attributes \*Lin\*O or \*Lout\*O to specify whether the parameter
is passed as an input, as an output, or in both directions.  The 
\*Vtype_specifier\*O and 
\*Vparameter_declarator\*O specify the type and name of the parameter.
.P
Output parameters must be passed by reference and therefore must be
declared as pointers via the pointer operator \*L*\*O (an asterisk) or
an array.
.P
If you want an interface to always use explicit binding handles, 
the first parameter of each operation declaration must be a binding handle,
as in the following example:
.oS
void greet(
    [in]            handle_t h,
    [in, string]    char client_greeting[],
    [out, string]   char server_reply[REPLY_SIZE]
);
.oE
.P
However, if you want applications to use the ACF feature of an
implicit binding handle (or even an automatic binding handle) 
for some or all procedures, operation declarations
must not have binding handle parameters in the interface definition:
.oS
void greet_no_handle(
    [in, string]    char client_greeting[],
    [out, string]   char server_reply[REPLY_SIZE]
);
.oE
.P
This form of operation declaration is the most flexible because 
applications can always specify explicit, implicit, or automatic binding
handles through an ACF.
.H 2 "Running the IDL Compiler"
.P
After you have written an interface definition, run the IDL compiler
to generate header and stub files.
The compiler offers many options that, for example, allow you to choose
what C compiler or C preprocessor commands are run, what directories
are searched for imported files, which of the possible output
files are generated, and how the output files are named.
.P
...\"When you compile the definition of a remote interface, you must ensure
...\"that the system IDL directory is among those that the compiler 
...\"searches for imported files because any remote interface implicitly
...\"imports \*Lrpc.idl\*O.
...\".P
The \*Lgreet.idl\*O interface definition can be compiled by the
following command:
.iS
idl greet.idl
.iE
.P
This compilation produces a header file (\*Lgreet.h\*O), a client
stub file (\*Lgreet_cstub.o\*O), and a server stub file 
(\*Lgreet_sstub.o\*O.
For complete information on running the IDL compiler,
see the \*Lidl(1rpc)\*O reference page.
.H 2 "Writing the Client Code"
.P
This section describes
the client program for the \*Lgreet\*O application,
whose interface definition was shown earlier in this chapter.
.P
The client performs the following major steps:
.AL
.LI
It checks the command-line arguments for an entry name to use for its
search in the namespace.
.LI
It calls \*Lrpc_ns_binding_import_begin(\|)\*O
to start the search in the namespace.
.LI
It calls \*Lrpc_ns_binding_import_next(\|)\*O
to obtain a binding to a server.
.LI
It calls the \*Lgreet\*O remote procedure
with a string greeting.
.LI
It prints the reply from the server.
.LE
.P
The \*Lgreet_client.c\*O module is as follows:
.oS
.ne 50
.ps 11
.vs 13
/* 
 * greet_client.c
 *
 * Client of "greet" interface.
 */
#include <stdio.h>
#include <dce/rpc.h>

#include "greet.h"
#include "util.h"

int
main(
    int argc,
    char *argv[]
)
{
    rpc_ns_handle_t import_context;
    handle_t binding_h;
    error_status_t status;
    idl_char reply[REPLY_SIZE];

    if (argc < 2) {
        fprintf(stderr, "usage: greet_client <CDS pathname>\\n");
        exit(1);
    }
    /*
     * Start importing servers using the name specified
     * on the command line.
     */
    rpc_ns_binding_import_begin(
        rpc_c_ns_syntax_default, (unsigned_char_p_t) argv[1], 
            greetif_v1_0_c_ifspec, NULL, &import_context, &status);
    ERROR_CHECK(status, "Can't begin import");
    /*
     * Import the first server (we could iterate here,
     * but we'll just take the first one).
     */
    rpc_ns_binding_import_next(import_context, &binding_h, &status);
    ERROR_CHECK(status, "Can't import");
    /*
     * Make the remote call.
     */
    greet(binding_h, (idl_char *) "hello, server", reply);

    printf("The Greet Server said: %s\\n", reply);
}
.ps 12
.vs 14
.oE
.P
.ne 2
The module first includes \*Lgreet.h\*O, the header file for
the \*Lgreet\*O interface generated by the IDL compiler.  
.P
In this example, after each call to an RPC runtime routine, the client
program calls the application-specific \*LERROR_CHECK\*O macro.
If the status from the RPC runtime routine is not \*Lerror_status_ok\*O, 
\*Ldce_error_inq_text(\|)\*O is called and the error message is printed.
...\".nS Note  TOO MUCH DETAIL FOR HERE
...\"Unlike production-quality software, the \*Lgreet\*O example does not do any
...\"exception handling.  As a result, it may terminate abnormally if
...\"unexpected events occur during a remote procedure call.  For example,
...\"if the \*Lgreet\*O server is stopped while the client is still running, the
...\"client will abort.  Production-quality applications should place all
...\"remote procedure calls within the scope of a \*LTRY\*O ... \*LCATCH\*O
...\"exception handler, thus guarding against unexpected runtime events.
...\"Applications can also check for server failures by using the
...\"\*Lcomm_status\*O attribute, described in the \*EAttribute Configuraton
...\"Language\*O chapter of this guide.
...\".iX "exceptions" "client"
...\".iX "exceptions" "server"
...\".iX "exceptions" "raising"
...\".nE
.P
As specified in the \*Lgreet.idl\*O interface definition,
the \*Lgreet\*O application uses explicit handles.
The client therefore passes a binding handle of type \*Lhandle_t\*O as
the first parameter of the \*Lgreet\*O procedure. 
At runtime, when the
client makes its first remote procedure call, the handle is only partially
bound because the client does not know the particular endpoint on
which the server is listening; for delivery of its
requests to the server endpoint, the client depends on the endpoint
mapping service of the \*Ldced\*O process on the server host.
.H 2 "Writing the Server Code"
.P
The following subsections describe 
the server program for the \*Lgreet\*O application.
The \*Lgreet_server\*O program takes one argument and is invoked as follows:
.iS
greet_server \*VCDS_pathname\*O
.iE
.P
The \*Lgreet_server\*O program uses the input argument to establish an entry 
for itself in the DCE CDS namespace.
.P
The \*Lgreet\*O server program has two user-written modules:
.P
.ML
.LI
The \*Lgreet_server.c\*O module contains the server \*Lmain\*O
function and performs the initialization and registration required
to export the \*Lgreet\*O interface.
.LI
The \*Lgreet_manager.c\*O module contains the code that actually
implements the \*Lgreet\*O operation.
.LE
.H 3 "The greet_server.c Source Code"
.P
Most applications should use the DCE convenience routines for server
initialization routines (routines that begin with \*Ldce_server_\*O) to
prepare servers to listen for remote procedure calls.  
These routines are simple to use, 
prepare a server so that \*Ldced\*O can manage it, and they
allow enough flexibility to do most typical initializations.
However, for detailed control, applications can also use the
lower-level RPC API to do server initialization.
In this chapter, we describe how to use the RPC API for server initialization.
.P
In this section, the \*Lgreet_server.c\*O module is described and
shown in successive pieces.
.H 4 "Including \*Lidl\*O-Generated Headers"
Like \*Lgreet_client.c\*O, the \*Lgreet_server.c\*O module 
includes \*Lgreet.h\*O so that constants, data types, and procedure
prototypes are available in the application.  For example:
.P
.oS
.ne 27
/* 
 * greet_server.c
 *
 * Main program (initialization) for "greet" server.
 */

#include <stdio.h>
#include <dce/dce_error.h>
#include <dce/rpc.h>

#include "greet.h"
#include "util.h"

.ne 13
int
main(
    int argc,
    char *argv[]
)
{
    unsigned32 status;
    rpc_binding_vector_t *binding_vector;

    if (argc < 2) {
        fprintf(stderr, "usage: greet_server <CDS pathname>\\n");
        exit(1);
    }
.oE
.H 4 "Registering the Interface"
.P
The server calls \*Lrpc_server_register_if(\|)\*O, supplying its interface
specifier (defined in \*Lgreet.h\*O), to register each interface with
the RPC runtime:
.oS
/* 
 * Register interface with RPC runtime.
 */
rpc_server_register_if(greetif_v1_0_s_ifspec, NULL, NULL,
    &status);
ERROR_CHECK(status, "Can't register interface");
.oE 
.H 4 "Selecting Protocol Sequences"
The server calls \*Lrpc_server_use_all_protseqs(\|)\*O to obtain endpoints
on which to listen for remote procedure calls: 
.P
.oS
/* 
 * Use all protocol sequences that are available.
 */
rpc_server_use_all_protseqs(rpc_c_protseq_max_reqs_default,
    &status);
ERROR_CHECK(status, "Can't use protocol sequences");
.oE
.H 4 "Obtaining the Server's Binding Handles"
To obtain a vector of binding handles that it can use when registering
endpoints, the server calls \*Lrpc_server_inq_bindings(\|)\*O:
.oS
/* 
 * Get the binding handles generated by the runtime.
 */
rpc_server_inq_bindings(&binding_vector, &status);
ERROR_CHECK(status, "Can't get bindings for server");
.oE
.H 4 "Registering Endpoints"
A call to \*Lrpc_ep_register(\|)\*O registers the server endpoints in
the endpoint mapper service of the local \*Ldced\*O:
.oS
/* 
 * Register assigned endpoints with endpoint mapper.
 */
rpc_ep_register(
    greetif_v1_0_s_ifspec, binding_vector, NULL, 
    (unsigned_char_p_t) "greet server version 1.0", &status);
ERROR_CHECK(status, "Can't register with endpoint map");
.oE
.H 4 "Exporting to CDS"
To advertise itself to clients, the server calls 
\*Lrpc_ns_binding_export(\|)\*O.  The server entry for the namespace
is obtained from the argument input when the server is invoked
(\*Largv[1]\*O). 
.oS
/* 
 * Export ourselves into the CDS namespace.
 */
rpc_ns_binding_export(
    rpc_c_ns_syntax_default, (unsigned_char_p_t) argv[1], 
    greetif_v1_0_s_ifspec, binding_vector, NULL, &status);
ERROR_CHECK(status, "Can't export into CDS namespace");
.oE
.H 4 "Listening for Calls"
To begin listening for remote procedure call requests, the server
calls \*Lrpc_server_listen(\|)\*O.  
.oS
/*
 * Start listening for calls.
 */
printf("Listening...\\n");

rpc_server_listen(rpc_c_listen_max_calls_default, &status);
ERROR_CHECK(status, "Can't start listening for calls");
.oE
.H 3 "The greet_manager.c Source Code"
.P
The \*Lgreet_manager.c\*O module includes \*Lgreet.h\*O and it
also defines the routine \*Lgreet\*O, as follows:
.P
.oS
.ne 20
/* 
 * greet_manager.c
 *
 * Implementation of "greet" interface.
 */

#include <stdio.h>
#include "greet.h"

void 
greet(
    handle_t h, 
    idl_char *client_greeting, 
    idl_char *server_reply
)
{
    printf("The client says: %s\\n", client_greeting);

    strcpy(server_reply, "Hi, client!");
}
.oE
.H 2 "Building the greet Programs"
.P
The client side of the \*Lgreet\*O application is the \*Lgreet_client\*O
program, which is built from the following:
.ML
.LI
The user-written \*Lgreet_client.c\*O client module
.LI
The IDL-compiler-generated \*Lgreet_cstub.o\*O client stub module
.LI
The user-written \*Lutil.c\*O module containing the error-checking routine
.LI
DCE libraries
.LE
.P
.ne 4
The server side of the \*Lgreet\*O application is the \*Lgreet_server\*O
program, which is built from the following:
.ML
.LI
The user-written \*Lgreet_server.c\*O server module
.LI
The user-written \*Lgreet_manager.c\*O manager module
.LI
The user-written \*Lutil.c\*O module containing the error-checking routine
.LI
The IDL-compiler-generated \*Lgreet_sstub.o\*O server stub module
.LI
DCE libraries
.LE
.P
These programs can be built by \*Lmake\*O with a makefile
such as the following:
.oS
.ps 10
.vs 12
DCEROOT		= /opt/dcelocal
CC		= /bin/cc
IDL		= idl
LIBDIRS		= -L${DCEROOT}/usr/lib
LIBS		= -ldce
LIBALL		= ${LIBDIRS} ${LIBS}
INCDIRS		= -I. -I${DCEROOT}/share/include
CFLAGS		= -g ${INCDIRS} 
IDLFLAGS	= -v ${INCDIRS} -cc_cmd "${CC} ${CFLAGS} -c"

all:	greet_client greet_server

greet.h greet_cstub.o greet_sstub.o: greet.idl
	${IDL} ${IDLFLAGS} greet.idl

greet_client:	greet.h greet_client.o util.o greet_cstub.o
	${CC} -o greet_client greet_client.o greet_cstub.o util.o \\
	  ${LIBALL}

greet_server:	greet.h greet_server.o greet_manager.o util.o \\
  greet_sstub.o
	${CC} -o greet_server greet_server.o greet_manager.o \\
    	  greet_sstub.o util.o ${LIBALL}

greet_client.c greet_server.c util.c: util.h
greet_manager.c greet_client.c greet_server.c: greet.h
.ps 12
.vs 14
.oE
.P
.H 2 "Running the greet Programs"
.P
Running the \*Lgreet\*O application involves starting the server
program and then running the client program. 
Before starting the server program, 
you need write access to the CDS namespace and
you need to ensure that the \*Ldced\*O process is running on the server host.  
For more information, see the \*Ldced(8dce)\*O reference page.
.P
You start the server program by 
using a CDS entry such as the following:
.iS
.ne 2
greet_server /.:/greet_entry
\*CListening...
.iE
.P
You start the client on another host (or even the same host) 
by using the same CDS entry as follows:
.iS
greet_client /.:/greet_entry\*O
.iE
The following message is printed on the server's host:
.oS
The client says: hello, server
.oE
The following reply is printed on the client's host:
.oS
The Greet Server said: Hi, client!
.oE
.P
The server program can be terminated at any time by a signal,
which on many systems can be generated by \*L<Ctrl-c>\*O.
.iX "exceptions" "client"
.iX "exceptions" "server"
.iX "exceptions" "raising"
.P
.iX "comm_status attribute"
.iX "fault_status attribute"
.iX "-; exceptions" "errors"
.iX "communication failure"
.iX "-: communication failure" "transport errors and exceptions"
When applications such as \*Lgreet\*O execute, many errors can occur
that have nothing to do with your own code.  
In general, errors that occur when a remote procedure call executes
are reported as exceptions.  
For example, exceptions that the client side of \*Lgreet_client\*O
could raise if the server suddenly and unexpectedly halts include
(but are not limited to) \*Lrpc_x_comm_failure\*O and
\*Lrpc_x_call_timeout\*O.  Other ways to 
respond to these errors are available
through the \*Lcomm_status\*O and \*Lfault_status\*O attributes in an interface
definition or attribute configuration file.  Explanations of these attributes
appear in Chapter 19.  Also, see Chapter 17, which explains the guidelines
for error handling.  
.P
.iX "\*LTRY\*O statement"
.iX "\*LCATCH\*O statement"
.iX "\*LENDTRY\*O statement"
In addition, Part 2 of this guide
contains information about the macros
(such as those specified by \*LTRY\*O, \*LCATCH\*O, and
\*LENDTRY\*O statements)
for exception handling.  If an exception occurs that the client
application does not handle, it causes the client to terminate
with an error message.  The client's termination could include a core dump
or other system-dependent error-reporting method.  
Detailed explanations of RPC status codes and RPC exceptions are in the
...\"\*VProblem Determination Guide\*O.
\*(Tg.
