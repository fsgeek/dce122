...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" 
...\" 
...\" HISTORY
...\" $Log: idl.gpsml,v $
...\" Revision 1.1.7.4  1996/09/17  18:59:07  wardr
...\" 	{def,CR13428,R1.2.2}
...\" 	idl info missing from guide
...\" 	[1996/09/17  18:57:50  wardr]
...\"
...\" Revision 1.1.7.3  1996/09/06  13:08:13  wardr
...\" 	{def,13469, R1.2.2}
...\" 	document limit on linked-list marshalling
...\" 	[1996/09/06  13:07:39  wardr]
...\" 
...\" Revision 1.1.7.2  1996/08/16  17:27:04  sherman
...\" 	{def,13428,R1.2.2}
...\" 	Remove align attribute
...\" 	[1996/08/16  17:26:34  sherman]
...\" 
...\" Revision 1.1.7.1  1996/05/10  21:27:38  wardr
...\" 	{enh,R1.2.2}
...\" 	Removed Changebars
...\" 	[1996/05/10  21:27:08  wardr]
...\" 
...\" Revision 1.1.5.5  1996/03/27  13:07:17  wardr
...\" 	{edit R1.2.1}
...\" 	More Release Edits
...\" 	[1996/03/27  13:06:49  wardr]
...\" 
...\" Revision 1.1.5.4  1996/03/07  20:12:20  weir
...\" 	Commented out several iX entries-- they cause AIX build errors
...\" 	[1996/03/07  20:11:31  weir]
...\" 
...\" Revision 1.1.5.3  1995/11/10  18:50:18  wardr
...\" 	{enh CR13032 R1.2.1} Final touchup and indexing.
...\" 	[1995/11/10  18:49:19  wardr]
...\" 
...\" Revision 1.1.5.2  1995/11/02  01:05:59  wardr
...\" 	{enh CR13032 R1.2.1} Do final edits
...\" 	[1995/11/02  01:05:34  wardr]
...\" 
...\" Revision 1.1.5.1  1995/09/15  21:49:43  wardr
...\" 	{enh, 13032, R1.1}
...\" 	adding xidl information
...\" 	[1995/09/15  21:48:25  wardr]
...\" 
...\" Revision 1.1.2.11  1995/06/07  14:38:08  rcb
...\" 	PRENTICE HALL reformat; final edits and changes
...\" 	[1995/06/05  19:56:02  rcb]
...\" 
...\" 	a couple of edits from DEC that I left out before
...\" 	[1995/05/01  18:10:16  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/04/27  16:01:06  rcb]
...\" 
...\" 	incorporated 1.1 edits
...\" 	[1995/04/26  15:44:09  rcb]
...\" 
...\" Revision 1.1.2.10  1994/10/28  15:14:08  jshirley
...\" 	Some final edits from Rico.
...\" 	[1994/10/28  15:13:46  jshirley]
...\" 
...\" Revision 1.1.2.9  1994/10/27  19:42:56  jshirley
...\" 	Final edits.
...\" 	[1994/10/27  19:41:51  jshirley]
...\" 
...\" Revision 1.1.2.8  1994/10/12  21:53:11  jshirley
...\" 	{def,10160,R1.1} Pipe documentation needs improvement.
...\" 	    Moved some info. to a more complete pipes discussion.
...\" 	[1994/10/12  21:52:09  jshirley]
...\" 
...\" Revision 1.1.2.7  1994/09/01  18:37:38  buckler
...\" 	{enh, 8569, R1.1}
...\" 	Added another caveat about input argument size limit.
...\" 	[1994/09/01  18:37:14  buckler]
...\" 
...\" Revision 1.1.2.6  1994/09/01  18:27:17  buckler
...\" 	{enh, 8569, R1.1}
...\" 	Added caveats about broadcasting.
...\" 	[1994/09/01  18:26:47  buckler]
...\" 
...\" Revision 1.1.2.5  1994/08/11  20:36:30  jhh
...\" 	expand copyright
...\" 	[1994/08/11  19:58:34  jhh]
...\" 
...\" Revision 1.1.2.4  1994/07/19  21:02:36  zahn
...\" 	{enh,11063,R1.1}
...\" 
...\" 	Incorporated T. Jordahl's review comments on
...\" 	the "opaque" context handle documentation.
...\" 	[1994/07/19  21:02:16  zahn]
...\" 
...\" Revision 1.1.2.3  1994/07/19  17:31:17  zahn
...\" 	{enh,11063,R1.1}
...\" 
...\" 	Added documentation for "opaque" context handles
...\" 	to the description of "normal" context handles.
...\" 	[1994/07/19  17:30:56  zahn]
...\" 
...\" Revision 1.1.2.2  1994/07/18  20:24:33  zahn
...\" 	{enh,10513,R1.1}
...\" 
...\" 	Modified the section on Strings to describe
...\" 	the integer-string types for 1.1.
...\" 
...\" 	Also moved an example of the exceptions attribute here
...\" 	from the file /app_gd/rpc/topics.gpsml (section on error
...\" 	handling) and changed/corrected the syntax description.
...\" 	[1994/07/18  20:24:11  zahn]
...\" 
...\" Revision 1.1.2.1  1994/07/08  15:52:59  jshirley
...\" 	{def,10526,R1.1}
...\" 	Created new file for the RPC reorganization based on the old file
...\" 	.../rpc/9_idl.gpsml.
...\" 	[1994/07/08  15:52:32  jshirley]
...\" 
...\" $EndLog$
...\"
...\"
.H 1 "Interface Definition Language"
.iX "interface" "definitions"
This chapter describes how to construct an Interface Definition Language 
(IDL) file.  First, it describes the IDL syntax notation conventions and 
lexical elements.  It then describes the interface definition structure 
and the individual language elements supported by the IDL compiler.
.H 2 "The Interface Definition Language File"
.P
The IDL file defines all aspects of an
interface that affect data passed over the network between a caller (client) 
and a callee (server).  An interface definition file has the suffix \*L.idl\*O.
In order for a caller and callee to interoperate, they
both need to incorporate the same interface definition.
.H 2 "Syntax Notation Conventions"
.iX "IDL" "syntax notation"
.P
In addition to the documentation conventions described in the 
Preface of this guide, the IDL syntax uses the special notation
described in the following subsections.
.H 3 "Typography"
.iX "IDL" "typography"
.P
IDL documentation uses the following typefaces:
.VL 1i
.LI "\*LBold\*O"
\*LBold\*O typeface indicates a literal item.  Keywords and literal punctuation
are represented in bold typeface.  Identifiers used in a particular example
are represented in bold typeface when mentioned in the text.
.LI "\*VItalic\*O"
\*VItalic\*O typeface indicates a symbolic item for which
you need to substitute a particular value.  In IDL syntax descriptions,
all identifiers that are not keywords are represented in italic typeface.
.LI "\*CConstant\*O"
\*CConstant width\*O typeface is used for source code
examples (in IDL or in C) that are displayed separately from regular text.
.LE
.H 3 "Special Symbols"
.iX "IDL" "special symbols"
.P
IDL documentation uses the following symbolic notations:
.VL 1i
.LI "\*V[item]\*O"
\*VItalic\*O brackets surrounding an item, which may include brackets in
regular typeface, indicate that the item contained within them is optional.
.LI "[\*Vitem\*O]"
Brackets shown in regular typeface surrounding a variable \*Vitem\*O
indicate that the brackets are a required when the item is
included, whether or not the item itself is required.
.LI "\*Vitem\*O ..."
Ellipsis points following an item indicate that
the item may occur one or more times.
.LI "\*Vitem\*O \*L,\*O ..."
.ne 4
If an item\  is followed by\  a literal
punctuation\  character\  and then by ellipsis points, the item may occur
either once without the punctuation character or more than once
with the punctuation character separating each instance.
.LI "\&..."
If ellipsis points are shown on a line by themselves, the item
or set of items in the preceding line may occur any number of additional
times.
.LI "\*Vitem\*O | \*Vitem\*O"
If several\  items are shown separated
by vertical bars, exactly one of those items must occur.
.LE
.H 2 "IDL Lexical Elements"
.iX "IDL" "lexical elements"
.P
The following subsections describe these IDL lexical elements:
.P
.ML
.LI
Identifiers
.LI
Keywords
.LI
Punctuation characters
.LI
Whitespace
.LI
Case sensitivity
.LE
.H 3 "Identifiers"
.iX "IDL" "identifiers"
.P
The character set for IDL identifiers comprises the alphabetic characters
A to Z and a to z, the digits 0 to 9, and the \*L_\*O (underscore) character. 
An identifier must start with an alphabetic character.
.P
No IDL identifier can exceed 31 characters.  In some cases, an identifier
has a shorter maximum length because the IDL compiler uses the identifier
as a base from which to construct other identifiers; we identify such
cases as they occur.
.H 3 "Keywords"
.iX "IDL" "keywords"
.P
IDL reserves some identifiers as keywords.  In the text of this chapter,
keywords are represented in \*Lbold\*O typeface, 
and identifiers chosen by application
developers are represented in \*Vitalic\*O typeface.
.H 3 "Punctuation Characters"
.iX "IDL" "punctuation characters"
.P
IDL uses the following graphic characters:
.oS
"  '  (  )  *  ,  .  /  :  ;  | =  [  \\  ]  {  }
.oE
.P
The \*L{\*O (left brace) and \*L}\*O (right brace) characters
are national replacement set characters that may not be available
on all keyboards.  Wherever IDL specifies a left brace, the 
\*L??<\*O trigraph
may be substituted.  Wherever IDL specifies a
right brace, the \*L??>\*O trigraph may be substituted.
.P
Use of these trigraph sequences adds the following punctuation characters
to the set in the preceding list:
.oS
<  >  ?
.oE
.H 3 "Whitespace"
.iX "IDL" "whitespace"
.P
Whitespace is used to delimit other constructs.  IDL defines the following
whitespace constructs:
.ML
.LI
A space
.LI
A carriage return
.LI
A horizontal tab
.LI
A form feed at the beginning of a line
.LI
A comment
.LI
A sequence of one or more of the preceding whitespace
constructs
.LE
.P
A keyword, identifier, or number not preceded by a punctuation character
must be preceded by whitespace.  A keyword, identifier, or number not
followed by a punctuation character must be followed by whitespace.
Unless we note otherwise, any punctuation character may be preceded
and/or followed by whitespace.
.P
When enclosed in \*L""\*O (double quotes) or \*L''\*O (single quotes),
whitespace constructs are treated literally.  Otherwise, they
serve only to separate other lexical elements and are ignored.
.iX "IDL" "comments"
.P
Just as in C, 
the character sequence \*L/*\*O (slash and asterisk) begins a comment,
and the character sequence \*L*/\*O (asterisk and slash)
ends a comment.  For example:
.oS
/* all natural */
import "potato.idl";  /* no preservatives */
.oE
.P
Comments do not nest.
.H 3 "Case Sensitivity"
.iX "IDL" "case sensitivity"
.P
The IDL compiler does not force the case of 
identifiers in the generated code.
.P
The only case sensitivity issue that you have to be aware of 
is the implications involved in calling generated stubs 
from languages other than C.
.H 2 "IDL Versus C"
.P
IDL resembles a subset of ANSI C. The major difference between 
IDL and C is that there are no executable statements in IDL.
.H 3 "Declarations"
.iX "IDL" "declarations"
.P
An interface definition specifies how operations are called, not how
they are implemented.  IDL is therefore a purely declarative language.
.H 3 "Data Types"
.iX "IDL" "data types"
.P
To support applications written in languages other than C, IDL defines
some data types that do not exist in C and extends some data types
that do exist in C. For example, IDL defines a Boolean data type.
.P
Some C data types are supported by IDL only with modifications or
restrictions.  For example, unions must be discriminated, and all 
arrays must be accompanied by bounds information.
.H 3 "Attributes"
.iX "-[" "IDL" "attributes"
.iX "attributes" "IDL"
.P
The stub modules that are generated from an interface definition require
more information about the interface than can be expressed in C. For
example, stubs must know whether an operation parameter is an input
or an output.
.P
The additional information required to define a network interface
is specified via IDL attributes.  IDL attributes can apply to types,
to structure members, to operations, to operation parameters, or to the
interface as a whole.  Some attributes are legal in only one of the
preceding contexts; others are legal in more than one context.  
An attribute is always represented in \*L[ ]\*O 
(brackets) before the item to which it applies.  For
example, in an operation declaration, inputs of the operation are
preceded by the \*Lin\*O attribute and outputs are preceded by
the \*Lout\*O attribute:
.iX "attributes" "out"
.oS
void arith_add (
     [in] long a,
     [in] long b,
     [out] long *c,
     );
.oE
.H 2 "Interface Definition Structure"
.iX "interface" "definitions"
.iX "IDL" "interface definition structure"
.P
An interface definition has the following structure:
.iS
\*O[\*Vinterface_attribute\*L,\*O ...] \*Linterface\*O \*Vinterface_name\*O
\*L{\*O
\*Vdeclarations
\*L}\*O
.iE
.P
The portion of an interface definition that precedes the \*L{\*O (left brace)
is the interface header.  The remainder of the definition is the interface
body.  Interface header syntax and interface body syntax are 
described separately in the following two subsections.
.H 3 "Interface Definition Header"
.iX "IDL" "interface definition header"
.iX "interface" "definitions" "header"
.P
The interface header comprises a list of interface attributes enclosed
in \*L[ ]\*O (brackets), the keyword \*Linterface\*O, and the interface name:
.iS
\*O[\*Vinterface_attribute\*L,\*O ...] \*Linterface\*O \*Vinterface_name\*O
.iE
.P
Interface names, together with major and minor version numbers, are
used by the IDL compiler to construct identifiers for interface specifiers,
entry point vectors, and entry point vector types.  If the
major and minor version numbers are single digits, the interface name
can be up to 17 characters long.
.P
.iX "C++ output from IDL"
.iX "IDL inheritance operator"
.iX "inherit an interface"
.iX "interface inheritance"
For C++  output, the interface header can also inherit an interface 
by using the inheritance operator (:) as follows:
.iS
\*O[\*Vinterface_attribute\*L,\*O ...] \*Linterface\*O \*Vinterface_name\*O \*L:\*O \*Vinherited_interface\*O
.iE
.nL
.ne 20
.H 3 "Interface Definition Body"
.iX "IDL" "interface definition body"
.iX "interface" "definitions"
.P
The \*Vdeclarations\*O in an interface definition body are
one or more of the following:
.iS
\*Vimport_declaration
constant_declaration
type_declaration
operation_declaration\*O
.iE
.P
A \*L;\*O (semicolon) terminates each declaration,
and \*L{ }\*O (braces) enclose the entire
body.
.iX "IDL" "import declarations"
.P
Import declarations must precede other declarations in the interface
body.
Import declarations specify
the names of other IDL interfaces that define types and constants
used by the importing interface.
.P
Constant, type, and operation declarations specify the constants,
types, and operations that the interface exports.  These declarations
can be coded in any order, provided any constant or type is defined
before it is used.
.H 2 "Overview of IDL Attributes"
.iX "uuid attribute"
.iX "version attribute"
.iX "endpoint" "attribute"
.iX "local attribute"
.iX "pointer_default attribute"
.iX "broadcast attribute"
.iX "maybe attribute"
.iX "reflect_deletions attribute"
.iX "exceptions" "attribute"
.iX "idempotent attribute"
.iX "in attribute"
.iX "out attribute"
.iX "ignore attribute"
.iX "max_is attribute"
.iX "min_is attribute"
.iX "size_is attribute"
.iX "first_is attribute"
.iX "last_is attribute"
.iX "length_is attribute"
.iX "string" "attribute"
.iX "ptr attribute"
.iX "ref attribute"
.iX "handle" "attribute"
.iX "context_handle attribute"
.iX "transmit_as attribute"
.P
Table 18-1 lists the attributes allowed in interface definition
files and specifies the declarations in which they can occur.
.P
.ne 5i
.TB "IDL Attributes"
.TS
center, box, tab(@);
lb | l.
\*LAttribute\*O@\*LWhere Used\*O
=
\*Luuid\*O@Interface definition headers
\*Lversion\*O@
\*Lendpoint\*O@
\*Lexceptions\*O
\*Lpointer_default\*O@
\*Llocal\*O
_
\*Lbroadcast\*O@Operations
\*Lmaybe\*O@
\*Lidempotent\*O
\*Lreflect_deletions\*O
_
\*Lin\*O@Parameters
\*Lout\*O
_
\*Lignore\*O@Structures
_
\*Lmax_is\*O@Arrays
\*Lmin_is\*O@
\*Lsize_is\*O@
\*Lfirst_is\*O@
\*Llast_is\*O@
\*Llength_is\*O
_
\*Lstring\*O@Arrays
_
\*Lptr\*O@Pointers
\*Lref\*O@
\*Lunique\*O
_
\*Lhandle\*O@Customized handles
_
\*Lcontext_handle\*O@Context handles
_
\*Ltransmit_as\*O@Type declarations
.TE
.H 2 "Interface Definition Header Attributes"
.P
The following subsections describe in detail the usage and semantics of the IDL
attributes that can be used in interface definition headers.
The attributes provided for interface definition headers are as follows:
.P
.ML
.LI
\*Luuid\*O
.LI
\*Lversion\*O
.LI
\*Lendpoint\*O
.LI
\*Lexceptions\*O
.LI
\*Lpointer_default\*O
.LI
\*Llocal\*O
.LE
.H 3 "The uuid Attribute"
.iX "uuid attribute"
.P
The\*L uuid\*O attribute specifies the Universal Unique Identifier
(UUID) that is assigned to an interface.  The \*Luuid\*O attribute 
takes the following form:
.iS
\*Luuid (\*Vuuid_string\*L)
.iE
.P
A \*Vuuid_string\*O is the string representation of a UUID. This
string is typically generated as part of a skeletal interface definition
by the utility \*Luuidgen\*O.  A \*Vuuid_string\*O contains
one group of 8 hexadecimal digits, three groups of 4 hexadecimal
digits, and one group of 12 hexadecimal digits, with hyphens separating
the groups, as in the following example:
.oS
01234567-89ab-cdef-0123-456789abcdef
.oE
.P
A new UUID should be generated for any new interface.  If several versions
of one interface exist, all versions should have the same interface
UUID but different version numbers.  A client and a server cannot communicate
unless the interface imported by the client and the interface exported
by the server have the same UUID. The client and server stubs in an
application must be generated from the same interface definition or
from interface definitions with identical \*Luuid\*O attributes.
.P
Any remote interface must have the \*Luuid\*O attribute.  An interface
must have either the \*Luuid\*O attribute or the \*Llocal\*O
attribute, but cannot have both.
.P
The \*Luuid\*O attribute can appear at most once in an interface.
.P
The following example illustrates use of the \*Luuid\*O attribute:
.oS
uuid(4ca7b4dc-d000-0d00-0218-cb0123ed9876)
.oE
.H 3 "The version Attribute"
.iX "version attribute"
.P
The \*Lversion\*O attribute specifies a particular version of a
remote interface.  The \*Lversion\*O attribute takes the following form:
.iS
\*Lversion (\*Vmajor \*V[\*L.\|\*Vminor \*V]\*L)
.iE
.P
A version number can be either a pair of integers (the major
and minor version numbers) or a single integer (the major version
number).  If both major and minor version numbers are supplied, the
integers should be separated by a period without whitespace.  If no
minor version number is supplied, 0 (zero) is assumed.
.P
The following examples illustrate use of the \*Lversion\*O attribute:
.oS
version (1.1)   /* major and minor version numbers */

version (3)     /* major version number only */
.oE
.P
The \*Lversion\*O attribute can be omitted altogether, in which
case the interface is assigned 0.0 as the default version number.
.P
A client and a server can communicate only if the following requirements
are met:
.P
.ML
.LI
The interface imported by the client and the interface
exported by the server have the same major version number.
.LI
The interface imported by the client has a minor version
number less than or equal to that of the interface exported by the
server.
.LE
.P
.ne 4
You must increase either the minor version number or the major version
number when you make any compatible change to an interface definition.
You must not decrease
the minor version number unless you simultaneously increase the major
version number.
.P
You must increase the major version number when you make any incompatible
change to an interface definition. (See the definition of compatible
changes that follows.) You cannot decrease the major version number.
.P
The following are considered compatible changes to an interface definition:
.ML
.LI
Adding operations to the interface, if and only if
the new operations are declared after all existing operation declarations
in the interface definition.
.LI
Adding type and constant declarations, if the new
types and constants are used only by operations added at the same
time or later.  Existing operation declarations cannot have 
their signatures modified.
.LE
.P
The \*Vmajor\*O and \*Vminor\*O integers in the \*Lversion\*O
attribute can range from 0 to 65,535, inclusive.  However, these typically
are small integers and are increased in increments of one.
.P
The following are considered incompatible changes to an interface definition:
.ML
.LI
Changing the signature of an existing operation
.LI
Changing the order of existing operations
.LI
Adding a new operation other than at the end
.LE
.P
The \*Lversion\*O attribute can appear at most once in an interface.
.H 3 "The endpoint Attribute"
.iX "endpoint" "attribute"
.iX "protocol" "family"
.iX "port"
.P
The \*Lendpoint\*O attribute specifies the well-known endpoint 
or endpoints on which servers that export the interface will listen. 
The \*Lendpoint\*O attribute takes the following form:
.iS
\*Lendpoint (\*Vendpoint_spec\*L,\*O ...\*L)
.iE
.P
.ne 3
Each \*Vendpoint_spec\*O is a string in the following form:
.iS
" \*Vfamily \*L:\*O [\*Vendpoint\*O]\*L "
.iE
.P
The \*Vfamily\*O identifies a protocol family.  The following
are accepted values for \*Vfamily\*O:
.ML
.LI
\*Lncacn_ip_tcp\*O:
NCA Connection over Internet Protocol: Transmission
Control Protocol (TCP/IP)
...\" .LI "\*Lncacn_dnet_nsp\*O"
...\" NCA Connection over DECnet: Network Services
...\" Protocol (DECnet Phase IV)
...\" .LI "\*Lncacn_osi_nsp\*O"
...\" NCA Connection over Open Systems Interconnection:
...\" Network Services Protocol (DECnet Phase V)
...\" .LI "\*Lncacn_osi_tp4\*O"
...\" NCA Connection over Open Systems Interconnection:
...\" ISO Transport Protocol Class 4
.LI 
\*Lncadg_ip_udp\*O:
NCA Datagram over Internet Protocol: User
Datagram Protocol (UDP/IP)
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo protocol
...\" ** sequences, add the following four lines.  Also, either add
...\" ** ncadg_dds to the two examples later in this file or replace
...\" ** "ncacn_ip_tcp:[1025]" with "ncadg_dds:[19]" -- just the way it
...\" ** was in V1.0 (with a print date of December 31, 1991).  Of course,
...\" ** remove the .zA ... .zZ lines just after the .cE line.
...\" .LI "\*Lncadg_dds\*O"
...\" NCA Datagram over Domain Datagram Service (DDS)
...\" DIGITAL_END
...\" .cE
.LE
.P
The \*Vendpoint\*O identifies a well-known endpoint for the
specified \*Vfamily\*O.  The values accepted for \*Vendpoint\*O
depend on the \*Vfamily\*O but typically are integers within a
limited range.  IDL does not define valid \*Vendpoint\*O
values.
.P
Well-known endpoint values are typically assigned by the central
authority that ``owns'' a protocol.  For example, the Internet Assigned 
Numbers Authority assigns well-known
endpoint values for the IP protocol family.
.P
At compile time, the IDL compiler checks each \*Vendpoint_spec\*O
only for gross syntax.  At runtime, stubs pass the \*Vfamily\*O
and \*Vendpoint\*O strings to the RPC runtime, which validates
and interprets them.
.P
Most applications should not use well-known endpoints and should
instead use dynamically assigned opaque endpoints.  Most interfaces
designed for use by applications should therefore not have the
\*Lendpoint\*O attribute.
.P
The following example illustrates use of the \*Lendpoint\*O attribute:
.oS
endpoint ("ncacn_ip_tcp:[1025]", "ncadg_ip_udp:[6677]")
.oE
.P
.P
The \*Lendpoint\*O attribute can appear at most once in an interface.
.H 3 "The exceptions Attribute"
.iX "exceptions" "attribute"
.P
The \*Lexceptions\*O attribute specifies a set of user-defined exceptions
that can be generated by the server implementation of the interface.  The
\*Lexceptions\*O attribute takes the following form:
.iS
\*Lexceptions (\*Vexception_name\*O [\*L,\*Vexception_name\*O] ...\*L)\*O
.iE
.P
.ne 16
The following is a sample declaration of an \*Lexceptions\*O attribute:
.oS
[uuid(06255501-08AF-11CB-8C4F-08002B13D56D),
version (1.1),
  exceptions (
      exc_e_exquota,
      binop_e_aborted,
      binop_e_too_busy,
      binop_e_shutdown)
] interface binop
  {
      long binop_add(
           [in] long a,
           [in] long b
           );
   }\*O
.oE
.P
See Chapter 17 for more information on using exceptions.
.H 3 "The pointer_default Attribute"
.iX "pointer_default attribute"
.P
IDL supports two kinds of pointer semantics.  The \*Lpointer_default\*O
attribute specifies the default semantics for pointers that are declared
in the interface definition.  The 
\*Lpointer_default\*O attribute takes the following form:
.iS
\*Lpointer_default (\*Vpointer_attribute\*O)
.iE
.P
Possible values for \*Vpointer_attribute\*O are \*Lref, unique,\*O and
\*Lptr\*O.
.P
The default semantics established by the \*Lpointer_default\*O
attribute apply to the following usages of pointers:
.P
.ML
.LI
A pointer that occurs in the declaration of a member
of a structure or a union.
.LI
A pointer that does not occur at the top level of an operation parameter
declared with more than one pointer operator.  A top-level pointer is one
that is not the target of another pointer and is not a field of a
data structure that is the target of a pointer.
(See Section 18.14.7.2 for more information on top-level pointers.)
.LE
.P
Note that the \*Lpointer_default\*O attribute does not apply to 
a pointer that is the return value of an operation because this is 
always a full pointer.
.P
The default semantics can be overridden by pointer attributes in the
declaration of a particular pointer.  If an interface definition does
not specify \*Lpointer_default\*O and contains a declaration that
requires default pointer semantics, the IDL compiler will issue a
warning.  For additional information on pointer semantics, 
refer to Section 18.14.7.1. 
.P
The \*Lpointer_default\*O attribute can appear at most once in an interface.
.H 3 "The local Attribute"
.iX "local attribute"
.P
The \*Llocal\*O attribute indicates that an interface definition
does not declare any remote operations and that the IDL compiler should
therefore generate only header files, not stub files.  The 
\*Llocal\*O attribute takes the following form:
.iS
\*Llocal\*O
.iE
.P
An interface containing operation definitions must have either 
the \*Llocal\*O attribute or the \*Luuid\*O attribute.
No interface can have both.
.P
The \*Llocal\*O attribute can appear at most once in an interface.
.H 3 "Rules for Using Interface Definition Header Attributes"
.P
An interface cannot have both the \*Llocal\*O attribute and the \*Luuid\*O
attribute.  In an interface definition that contains any operation
declarations, either \*Llocal\*O or \*Luuid\*O must be specified.
In an interface definition that contains no operation declarations,
both \*Llocal\*O and \*Luuid\*O can be omitted.
.P
The \*Llocal\*O, \*Luuid\*O, and \*Lversion\*O attributes cannot
be coded more than once.  If the \*Lendpoint\*O or the
\*Lpointer_default\*O attribute is coded more than once, the IDL
compiler issues a warning and, where conflicts exist, the IDL compiler
accepts the last value specified.
.H 3 "Examples of Interface Definition Header Attributes"
.P
The following example uses the \*Luuid\*O and \*Lversion\*O
attributes:
.oS
[uuid(df961f80-2d24-11c9-be74-08002b0ecef1), version(1.1)]
interface my_interface_name
.oE
.P
The following example uses the \*Luuid\*O, \*Lendpoint\*O, and \*Lversion\*O attributes:
.oS
[uuid(0bb1a080-2d25-11c9-8d6e-08002b0ecef1),
endpoint("ncacn_ip_tcp:[1025]", "ncacn_ip_tcp:[6677]"),
version(3.2)]
interface my_interface_name
.oE
.H 2 "Import Declarations"
.iX "import declarations"
.iX "IDL" "import declarations"
.P
The IDL \*Vimport_declaration\*O specifies interface definition files
that declare types and constants used by the importing interface.
It takes the following form:
.iS
\*Limport \*Vfile\*L,\*O... \*L;\*O
.iE
.P
The \*Vfile\*O argument is the pathname, enclosed in double quotes,
of the interface definition you are importing.  This pathname can be
relative; the \%\*L-I\*O option of the IDL compiler allows you to
specify a  directory from which to resolve import pathnames.
.P
The effect of an import declaration is as if all constant, type, and
import declarations from the imported file occurred in the importing
file at the point where the import declaration occurs.  Operation
declarations are not imported.
.P
For example, suppose that the interface definition \*Laioli.idl\*O
contains a declaration to import the definitions for the \*Lgarlic\*O
and \*Loil\*O interfaces:
.oS
import "garlic.idl", "oil.idl";
.oE
.P
The IDL compiler will generate a C header file named \*Laioli.h\*O
that contains the following \*L#include\*O directives:
.oS
#include "garlic.h"
#include "oil.h"
.oE
.P
The stub files that the compiler generates will not contain code for
any \*Lgarlic\*O and \*Loil\*O operations.
.P
Importing an interface many times has the same effect as importing
it once.
.H 2 "Constant Declarations"
.iX "constant declarations"
.iX "IDL" "const declaration"
.iX "IDL" "constant declarations"
.P
The IDL \*Vconstant_declaration\*O can take any one of the following forms:
.iS
\*Lconst\*O \*Vinteger_type_spec identifier\*O \*L=\*O \*Vinteger\*O | \*Vvalue\*O | \*Vinteger_const_expression\*L;
const boolean\*O \*Videntifier\*O \*L=\*O \*LTRUE\*O | \*LFALSE\*O | \*Vvalue\*L;
const char\*O \*Videntifier\*O \*L=\*O \*Vcharacter\*O | \*Vvalue\*L;
const char*\*O \*Videntifier\*O \*L=\*O \*Vstring\*O | \*Vvalue\*L;
const void*\*O \*Videntifier\*O \*L=\*O \*LNULL\*O | \*Vvalue\*L;\*O
.iE
.P
The \*Vinteger_type_spec\*O is the data type of the integer constant 
you are declaring.  The \*Videntifier\*O is the name of the constant.  
The \*Vinteger\*O, \*Vinteger_const_expression\*O, \*Vcharacter\*O, 
\*Vstring\*O, or \*Vvalue\*O specifies the value to be 
assigned to the constant.
.iX "constants" "integers"
.iX "constants" "strings"
.iX "integers"
.iX "strings"
A \*Vvalue\*O can be any previously
defined constant.
.P
IDL provides only integer, Boolean, character, string, and null pointer
constants.
.iX "constant expressions"
.P
Following are examples of constant declarations:
.oS
const short TEN = 10;
const boolean FAUX = FALSE;
const char* DSCH = "Dmitri Shostakovich";
.oE
.H 3 "Integer Constants"
.iX "integers"
.iX "constants" "integers"
.P
An \*Vinteger_type_spec\*O is a \*Vtype_specifier\*O for an
integer, except that the \*Vint_size\*O for an integer 
constant cannot be \*Lhyper\*O.
.P
An \*Vinteger\*O is the decimal representation of an integer.  IDL 
also supports the C notation for hexadecimal, octal, and long integer 
constants.
.P
You can specify any previously defined integer constant as the \*Vvalue\*O
of an integer constant.
.P
You can specify any arithmetic expression as the 
\*Vinteger_const_expression\*O that evaluates to an integer constant.
.H 3 "Boolean Constants"
.iX "Booleans"
.iX "constants" "Booleans"
.P
A Boolean constant can take one of two values: TRUE or FALSE.
.P
You can specify any previously defined Boolean constant as the \*Vvalue\*O
of a Boolean constant.
.H 3 "Character Constants"
.iX "characters"
.iX "constants" "characters"
.P
A \*Vcharacter\*O is an ASCII character enclosed in single quotes.  A white 
space character is interpreted literally.  The \*L\e\*O (backslash)
character introduces an escape sequence, as defined
in the ANSI C standard.  The \*L'\*O (single quote) character can
be coded as the \*Vcharacter\*O only if it is escaped by a backslash.
.P
You can specify any previously defined character constant as
the \*Vvalue\*O of a character constant.
.H 3 "String Constants"
.iX "strings"
.iX "constants" "strings"
.P
A \*Vstring\*O is a sequence of ASCII characters enclosed in double quotes.  
Whitespace characters are interpreted literally.
The \*L\e\*O (backslash) character introduces an escape sequence,
as defined in the ANSI C standard.  The \*L"\*O (double quote) character
can be coded in a \*Vstring\*O only if it is escaped by a backslash.
.P
You can specify any previously defined string constant as the \*Vvalue\*O
of a string constant.
.H 3 "NULL Constants"
.iX "null constants"
.iX "constants" "nulls"
.P
A \*Lvoid*\*O constant can take only one literal value: NULL.
.P
You can specify any previously defined \*Lvoid*\*O constant as
the \*Vvalue\*O of a \*Lvoid*\*O constant.
.H 2 "Type Declarations"
.iX "type" "declarations"
.iX "typedef declaration"
.iX "-[" "types" "IDL"
.iX "named types"
.iX "IDL" "named types"
.P
The IDL \*Vtype_declaration\*O enables you to associate a
name with a data type and to specify attributes of the data type.
It takes the following form:
.iS
\*Ltypedef \*V[\*O[\*Vtype_attribute\*L,\*O ...]\*V] type_specifier type_declarator\*L,\*O ... \*L;\*O
.iE
.P
A \*Vtype_attribute\*O specifies characteristics of the type being
declared.
.P
The \*Vtype_specifier\*O can specify a base type, a constructed
type, a predefined type, or a named type.
A function pointer can be specified if the \*Llocal\*O attribute has been
specified.
.P
Each \*Vtype_declarator\*O is a name for the type being defined.  Note, though, 
that a \*Vtype_declarator\*O can also be preceded by an \*L*\*O
(asterisk), followed by \*L[\ ]\*O (brackets), and can
include \*L(\ )\*O (parentheses) to indicate the precedence of its
components.
.H 3 "Type Attributes"
.iX "IDL" "type attributes"
.P
A \*Vtype_attribute\*O can be any of the following:
.ML
.LI 
\*Lhandle\*O:
.iX "handle" "attribute"
The type being declared is a user-defined,
customized-handle type.
.LI 
\*Lcontext_handle\*O:
.iX "context_handle attribute"
The type being declared is a
context-handle type.
.LI 
\*Ltransmit_as\*O:
.iX "transmit_as attribute"
The type being declared is a \*Epresented type\*O.  When it is passed in
remote procedure calls, it is converted to a specified \*Etransmitted type\*O.
.LI 
\*Lref\*O:
.iX "ref attribute"
The type being declared is a reference pointer.
.LI 
\*Lptr\*O:
.iX "-[" "ptr attribute"
The type being declared is a full pointer.
.LI 
\*Lunique\*O:
.iX "-[" "unique attribute"
The type being declared is a unique pointer.
.LI 
\*Lstring\*O:
.iX "string" "attribute"
The array type being declared is a string type.
.LE
.H 3 "Base Type Specifiers"
.iX "base type specifiers"
.iX "type" "specifiers"
.P
IDL base types include integers, floating-point numbers, characters,
a \*Lboolean\*O type, 
a \*Lbyte\*O type, a \*Lvoid\*O type, and a primitive handle type.
.P
Table 18-2 lists the IDL base data type 
specifiers.  Where applicable, the table shows the 
size of the corresponding transmittable type and the type 
macro emitted by the IDL compiler for resulting declarations.
.P
.ne 4.5i
.TB "Base Data Type Specifiers"
.P
.TS
center, box, tab(@);
cb cb lb | l | lb.
@\*LSpecifier\*O@@@\*LType Macro\*O
\*L(sign)@(size)@(type)@\*LSize\*O@\*LEmitted by idl\*O
=
@small@int@8 bits@idl_small_int
_
@short@int@16 bits@idl_short_int
_
@long@int@32 bits@idl_long_int
_
@hyper@int@64 bits@idl_hyper_int
_
unsigned@small@int@8 bits@idl_usmall_int
_
unsigned@short@int@16 bits@idl_ushort_int
_
unsigned@long@int@32 bits@idl_ulong_int
_
unsigned@hyper@int@64 bits@idl_uhyper_int
_
@@float@32 bits@idl_short_float
_
@@double@64 bits@idl_long_float
_
@@char@8 bits@idl_char
_
@@boolean@8 bits@idl_boolean
_
@@byte@8 bits@idl_byte
_
@@void@\(em@idl_void_p_t
_
@@handle_t@\(em@\*O\(em\*O
.TE
.sp .5
.P
The base types are described individually later in this chapter.
.iX "idl_ macros"
.iX "IDL" "idl_macros"
.P
Note that you can use the \*Lidl_\*O macros in the code you write for
an application to ensure that your type declarations are consistent
with those in the stubs, even when the application is ported to
another platform.  The \*Lidl_\*O macros are especially useful when
passing constant values to RPC calls.  For maximum portability, all
constants passed to RPC calls declared in your network interfaces
should be cast to the appropriate type because the size of integer
constants (like the size of the \*Lint\*O data type) is ambiguous in
the C language.
.P
The \*Lidl_\*O macros are defined in \*Ldce/idlbase.h\*O, which 
is included by header files that the IDL compiler generates.
.H 3 "Constructed Type Specifiers"
.iX "constructed type specifiers"
.iX "type" "specifiers"
.iX "IDL" "constructed type specifiers"
.P
IDL constructed types include structures, unions, enumerations, 
pipes, arrays, and pointers. (In IDL, as in C, arrays and pointers
are specified via declarator constructs rather than type specifiers.)
Following are the keywords used to declare constructed type specifiers:
.iS
struct
union
enum
pipe
.iE
.P
Constructed types are described in detail later in this chapter.
.H 3 "Predefined Type Specifiers"
.iX "predefined type specifiers"
.iX "type" "specifiers"
.iX "IDL" "predefined type specifiers"
.P
While IDL per se does not have any predefined types, DCE RPC IDL 
implicitly imports \*Lnbase.idl\*O, which does predefine some types.  
Specifically, \*Lnbase.idl\*O predefines an error status type, 
several international character data types, and many other types.  
Following are the keywords used to declare these \*Epredefined\*O type
specifiers:
.iS
error_status_t
ISO_LATIN_1
ISO_MULTI_LINGUAL
ISO_UCS
.iE
.P
The error status type and international characters are described 
in detail later in this chapter.
.H 3 "Type Declarator"
.iX "type" "declarators"
.P
An IDL \*Vtype_declarator\*O can be either a simple declarator or 
a complex declarator.
.P
A simple declarator is just an identifier.
.P
A complex declarator is an identifier that specifies an 
array, a function pointer, or a pointer.
.H 2 "Operation Declarations"
.iX "operation" "declaration"
.iX "operations"
.iX "IDL" "operation declaration"
.P
The IDL \*Voperation_declaration\*O can take the following forms:
.iS
\*V[\*O[\*Voperation_attribute\*L,\*O ...]\*V] [\*O\*Lstatic\*O\*V] type_specifier operation_identifier \*L(\*Vparameter_declaration\*L,\*O ...);

\*V[\*O[\*Voperation_attribute\*L,\*O ...]\*V] [\*O\*Lstatic\*O\*V] type_specifier operation_identifier \*L(\*V[\*Lvoid\*V]\*L);\*O
.iE
.P
Use the first form for an operation that has one or more parameters;
use the second form for an operation that has no parameters.
.iX "static keyword"
Use the \*Lstatic\*O keyword if the operation is a static member function 
of the interface class (C++ output only).
.P
An \*Voperation_attribute\*O can take the following forms:
.ML
.LI 
\*Lidempotent\*O:
.iX "idempotent attribute"
The operation is idempotent.
.LI 
\*Lbroadcast\*O:
.iX "broadcast attribute"
.iX "broadcasting"
The operation is always
to be broadcast.
.LI 
\*Lmaybe\*O:
.iX "maybe attribute"
The caller of the operation does
not require and will not receive any response.
.LI
\*Lreflect_deletions\*O:
If \*Lrpc_ss_free(\|)\*O is applied by application code on the server side
to memory used for the referent of a full pointer that is part of an
\*L[in]\*O parameter, the storage occupied by that referent on the client side
is released.
.LI 
\*Lptr\*O:
The operation returns a full pointer.
This attribute must be supplied if the operation returns a 
pointer result and reference pointers are the default
for the interface.
.LI 
.ne 3
\*Lcontext_handle\*O:
.iX "context_handle attribute"
The operation returns a context handle.
.LI 
\*Lstring\*O:
.iX "string" "attribute"
The operation returns a string.
.LE
.iX "type" "specifiers"
.iX "operations"
.P
The \*Vtype_specifier\*O in an operation declaration specifies
the data type that the operation returns, if any.  This type must be
either a scalar type or a previously defined type.  If the
operation does not return a result, its \*Vtype_specifier\*O must
be \*Lvoid\*O.
.iX "operation" "declaration"
.P
For information on the semantics of pointers as operation return values, 
refer to the discussion of pointers in Section 18.14.7.
.P
The \*Voperation_identifier\*O in an operation declaration is an
identifier that names the operation.
.iX "operations"
.iX "parameters"
.iX "IDL" "parameter declarations"
.P
Each \*Vparameter_declaration\*O in an operation declaration declares
a parameter of the operation.  A \*Vparameter_declaration\*O takes
the following form:
.iS
\*O[\*Vparameter_attribute\*L,\*O ...] \*Vtype_specifier parameter_declarator\*O
.iE
.P
Parameter declarations and the parameter attributes are described 
separately in the following sections.
.H 3 "Operation Attributes"
.iX "operation" "attributes"
.P
Operation attributes determine the semantics to be applied by the
RPC client and server protocol when an operation is called.
.H 3 "Operation Attributes: Execution Semantics"
.iX "idempotent attribute"
.P
The \*Lidempotent\*O attribute specifies that an operation is idempotent;
that is, it can safely be executed more than once.
.P
.iX "broadcast attribute"
.iX "broadcasting"
.P
The \*Lbroadcast\*O attribute specifies that an operation is to
be broadcast to all hosts on the local network each time the operation
is called.  The client receives output arguments from the first reply
to return successfully, and all subsequent replies are discarded.
.P
An operation with the \*Lbroadcast\*O attribute is implicitly idempotent.
.P
Note that the broadcast capabilities of RPC runtime have a number 
of distinct limitations:
.ML
.LI
Not all systems and networks support broadcasting.  In particular,
broadcasting is not supported by the RPC connection-oriented
protocol.
.LI
Broadcasts are limited to hosts on the local network.
.LI
Broadcasts make inefficient use of network bandwidth and processor
cycles.  
.LI
The RPC runtime library does not support \*Lat-most-once\*O
semantics for broadcast operations; it applies \*Lidempotent\*O
semantics to all such operations.
.LI
The input arguments for broadcast calls are limited to
944 bytes.
.LE
.iX "maybe attribute"
.P
The \*Lmaybe\*O attribute specifies that the caller of an operation
does not expect any response.  An operation with the \*Lmaybe\*O
attribute cannot have any output parameters and cannot return anything.
Delivery of the call is not guaranteed.
.P
An operation with the \*Lmaybe\*O attribute is implicitly idempotent.
.H 3 "Operation Attributes: Memory Management"
.iX "reflect_deletions attribute"
.P
Use the \*Lreflect_deletions\*O attribute to mirror the release of memory
from server pointer targets to client pointer targets.  When you use
the \*Lreflect_deletions\*O attribute, memory occupied by pointer targets on the
client will be released when the corresponding pointer targets on the server are
released.  This is only true for pointer targets that are components of
\*L[in]\*O parameters of the operation.
By default, the mechanism used by RPC to release the pointer targets is the 
C language \*Lfree(\|)\*O
function unless the client code is executing as part of RPC
server application code, in which case the \*Lrpc_ss_free\*O(\|)
function is used.  You can override the default by
calling \*Lrpc_ss_set_client_alloc_free\*O(\|) or \*Lrpc_ss_swap_client_alloc_free\*O(\|) before
the call to the remote operation.
.H 2 "Parameter Declarations"
.iX "operation" "declaration"
.iX "parameters"
.iX "operations"
.P
A \*Vparameter_declaration\*O is used in an operation declaration to 
declare a parameter of the operation.  A \*Vparameter_declaration\*O 
takes the following form:
.iS
\*O[\*Vparameter_attribute\*L,\*O ...] \*Vtype_specifier parameter_declarator\*O
.iE
.P
If an interface does
not use implicit handles or use interface-based binding,
the first parameter must be an explicit handle that gives
the object UUID and location.  The handle parameter can be of a primitive
handle type, \*Lhandle_t\*O, or a nonprimitive user-defined handle type.
.iX "handle"
.P
A \*Vparameter_attribute\*O can be any of the following:
.ML
.LI 
\*Varray_attribute\*O:
.iX "array" "attributes"
One of several attributes that
specifies the characteristics of arrays.
.LI 
\*Lin\*O:
.iX "in attribute"
The parameter is an input attribute.
.LI 
\*Lout\*O:
.iX "out attribute"
The parameter is an output attribute.
.LI 
\*Lref\*O:
.iX "ref attribute"
The parameter is a reference pointer;
it cannot be NULL and cannot be an aliased pointer.
.LI 
\*Lptr\*O:
.iX "-]" "ptr attribute"
The parameter is a full pointer; it can be NULL and can be an
aliased pointer.
.LI 
\*Lunique\*O:
.iX "-]" "unique attribute"
The parameter is a unique pointer; it can be NULL.
.LI 
\*Lstring\*O:
.iX "string" "attribute"
The parameter is a string.
.LI 
\*Lcontext_handle\*O:
.iX "context_handle attribute"
The parameter is a context handle.
.LI 
\*Lswitch_is\*O:
.iX "switch_is attribute"
.LE
.P
The directional attributes \*Lin\*O and \*Lout\*O specify the
directions in which a parameter is to be passed.  The \*Lin\*O attribute
specifies that the parameter is passed from the caller to the callee.
The \*Lout\*O attribute specifies that the parameter is passed
from the callee to the caller.
.P
An output parameter must be passed
by reference and therefore must be declared with an explicit \*L*\*O
(asterisk).  (Note that an array is implicitly passed by reference 
and so an output array does not require an explicit \*L*\*O.) 
At least one directional attribute must be specified for each
parameter of an operation.
.P
An explicit handle parameter must have
at least the \*Lin\*O attribute.
.P
The \*Lref, unique,\*O and \*Lptr\*O attributes are 
described later in Section 18.14.7. 
The \*Lstring\*O attribute is described in Section 18.14.6. 
The \*Lcontext_handle\*O attribute is 
described in Section 18.14.9.1.
.P
.iX "parameters"
.iX "type" "specifiers"
The \*Vtype_specifier\*O in a parameter declaration specifies the
data type of the parameter.
.P
The \*Vdeclarator\*O in a parameter declaration can be any simple
or complex declarator.
.P
A parameter with the \*Lout\*O attribute must be either an array
or an explicitly declared pointer.  An explicitly declared pointer
is declared by a \*Vpointer_declarator\*O, rather than by a 
\*Vsimple_declarator\*O with a named pointer type as its \*Vtype_specifier\*O.
.P
For information on the semantics of pointers as operation parameters, 
refer to the discussion of pointers in Section 18.14.7.
.iX "directional attributes"
.iX "in attribute"
.iX "out attribute"
.H 2 "Basic Data Types"
.iX "IDL" "basic data types"
.P
The following subsections describe the basic data types provided by 
IDL and the treatment of international characters 
within IDL.  The basic data types are as follows:
.P
.ML
.LI
Integer types
.LI
Floating-point types
.LI
The \*Lchar\*O type
.LI
The \*Lboolean\*O type
.LI
The \*Lbyte\*O type
.LI
The \*Lvoid\*O type
.LI
The \*Lhandle_t\*O type
.LI
The \*Lerror_status_t\*O type
.LE
.P
Section 18.14 describes the constructed data types that are 
built on the basic data types.
.H 3 "Integer Types"
.iX "integers"
.iX "int type"
.P
IDL provides four sizes of signed and unsigned integer data types,
specified as follows:
.iS
\*Vint_size [\*Lint\*V]\*L
unsigned\*O \*Vint_size [\*Lint\*V]\*O
\*Vint_size \*Lunsigned \*V[\*Lint\*V]
.iE
.P
The \*Vint_size\*O can take the following values:
.iS
hyper
.iX "hyper type"
long
.iX "long type"
short
.iX "short type"
small
.iX "small type"
.iE
.P
The\*O\*L hyper\*O types are represented in 64 bits.  A \*Llong\*O
is 32 bits.  A \*Lshort\*O is 16 bits.  A \*Lsmall\*O is 8 bits.
.P
The
.iX "integers"
keyword \*Lint\*O is optional and has
no effect.  The
.iX "unsigned integer types"
.iX "IDL" "unsigned integer types"
keyword \*Lunsigned\*O denotes an unsigned integer type; it can 
occur either before or after the size keyword.
.H 3 "Floating-Point Types"
.iX "floating-point numbers"
.P
IDL provides two sizes of floating-point data types, specified
as follows:
.iS
float
.iX "float type"
double
.iX "double type"
.iX "-: types, IDL" "IDL" "types"
.iE
.P
A \*Lfloat\*O is represented in 32 bits.  A \*Ldouble\*O is represented
in 64 bits.
.H 3 "The char Type"
.iX "characters"
.P
The IDL character type is specified as follows:
.iS
\*V[\*Lunsigned\*V] \*Lchar\*O
.iE
.P
A\*L char\*O is unsigned and is represented in 8 bits.
.P
The keyword \*Lunsigned\*O is optional and has no effect.  IDL does
not support a signed character type.  IDL provides the \*Lsmall\*O 
data type for representing signed 8-bit integers.
.H 3 "The boolean Type"
.iX "IDL" "boolean type"
.iX "boolean type"
.P
The IDL \*Lboolean\*O type is specified as follows:
.iS
boolean
.iE
.P
A \*Lboolean\*O is represented in 8 bits.  A \*Lboolean\*O is
a logical quantity that assumes one of two values: 
TRUE or FALSE.
Zero is FALSE and any nonzero value is TRUE.
.H 3 "The byte Type"
.iX "IDL" "byte type"
.iX "byte type"
.P
The IDL \*Lbyte\*O type is specified as follows:
.iS
\*Lbyte\*O
.iE
.P
A\*L byte\*O is represented in 8 bits.  The data representation
format of \*Lbyte\*O data is guaranteed not to change when the
data is transmitted by the RPC mechanism.
.P
The IDL integer, character, and floating-point types (and hence
any types constructed from these) are all subject to format conversion
when they are transmitted between hosts that use
different data representation formats.  You can protect data
of any type from format conversion by transmitting that type as an
array of \*Lbyte\*O.
.H 3 "The void Type"
.iX "void type"
.P
The IDL \*Lvoid\*O type is specified as follows:
.iS
\*Lvoid\*O
.iE
.P
The \*Lvoid\*O type may be used to do the following:
.ML
.LI
Specify the type of an operation that does not
return a value
.LI
Specify the type of a context handle parameter,
which must be \*Lvoid*\*O
.LI
Specify the type of a NULL pointer constant, which
must be \*Lvoid*\*O
.LE
.H 3 "The handle_t Type"
.iX "handle_t type"
.P
The IDL primitive handle type is specified as follows:
.iS
\*Lhandle_t\*O
.iE
.P
A \*Lhandle_t\*O is a primitive handle type that is opaque to application
programs but meaningful to the RPC runtime library.  Section 18.14.8
discusses primitive and nonprimitive handle types.
.H 3 "The error_status_t Type"
.iX "error_status_t type"
.P
IDL provides the following 
predefined data type to hold RPC communications status
information:
.iS
\*Lerror_status_t\*O
.iE
.P
The values that can be contained in the \*Lerror_status_t\*O data type
are compatible with the \*Lunsigned long\*O and \*Lunsigned32\*O IDL data types.
These data types are used for status values in the DCE.
.P
.ne 8
The
\*Lerror_status_t\*O data type contains an additional semantic to indicate that
this particular \*Lunsigned long\*O contains a DCE format error status value.
This additional semantic enables the IDL compiler to perform any
necessary translation when moving the status value between systems
with differing hardware architectures and software operating systems.
If you are using status codes that are not in the DCE error status format
or if you do not require such conversion, use an \*Lunsigned long\*O instead
of \*Lerror_status_t\*O.
.H 3 "International Characters"
.iX "international characters"
.iX "IDL" "international characters"
.P
The implicitly imported \*Lnbase.idl\*O 
provides predefined data types to support present and emerging
international standards for the representation of characters and strings:
.iS
ISO_LATIN_1
ISO_MULTI_LINGUAL
ISO_UCS
.iE
.P
Data of type \*Lchar\*O is subject to ASCII-EBCDIC conversion
when transmitted by the RPC mechanism.  The predefined international
character types are constructed from the base type \*Lbyte\*O and
are thereby protected from data representation format conversion.
.P
The \*LISO_LATIN_1\*O type is represented in 8 bits and is predefined
as follows:
.oS
typedef byte ISO_LATIN_1;
.oE
.P
The \*LISO_MULTI_LINGUAL\*O type is represented in 16 bits and
is predefined as follows:
.oS
typedef struct {
     byte row, column;
     } ISO_MULTI_LINGUAL;
.oE
.P
The \*LISO_UCS\*O type is represented in 32 bits and is predefined
as follows:
.oS
typedef struct {
     byte group, plane, row, column;
     } ISO_UCS;
.oE
.H 2 "Constructed Data Types"
.iX "IDL" "constructed types"
.iX "constructed data types"
.P
The following subsections describe the constructed data types that are 
provided by IDL.  The constructed types are built on the basic 
data types, which are described in Section 18.13.  
The constructed data types are as follows:
.ML
.LI
Structures
.LI
Unions
.LI
Enumerations
.LI
Pipes
.LI
Arrays
.LI
Strings
.LE
.P
In IDL, as in C, arrays and pointers are specified via 
declarator constructs.  The other constructed types are 
specified via type specifiers.
.H 3 "Structures"
.iX "structure member attributes"
.iX "IDL" "structures"
.iX "struct type"
.P
The \*Vtype_specifier\*O for a structure type can take the following
forms:
.iS
\*Lstruct \*V[tag]
 \*L{\*O
 \*Vstruct_member\*L;\*O
 ...
 \*L}

struct \*Vtag\*O
.iE
.P
A \*Vtag\*O, if supplied in a specifier of the first form, becomes
a shorthand form for the set of member declarations that follows it.  Such
a \*Vtag\*O can subsequently be used in a specifier of the second
form.
.P
A \*Vstruct_member\*O takes the following form:
.iS
\*V[\*O[\*Vstruct_member_attribute\*L,\*O ...]\*V] type_specifier declarator\*L,\*O ...\*L;\*O
.iE
.P
A \*Vstruct_member_attribute\*O can be any of the following:
.ML
.LI 
\*Varray_attribute\*O:
.iX "array" "attributes"
.iX "IDL" "array attributes"
.iX "array_attribute attribute"
.iX "attributes" "array_attribute"
.iX "-: arrays" "attributes" "array"
One of several attributes
that specify characteristics of arrays.
.LI 
\*Lignore\*O:
.iX "ignore attribute"
.iX "attributes" "ignore"
An attribute indicating
that the pointer member being declared is not to be transmitted
in remote procedure calls.
.LI 
\*Lref\*O:
.iX "ref attribute"
An attribute indicating that
the pointer member being declared is a reference pointer; it cannot
be NULL and cannot be an alias.
.LI 
\*Lptr\*O:
.iX "ptr attribute"
An attribute indicating that
the pointer member being declared is a full pointer; 
it can be NULL and can be an alias.
.LI 
\*Lunique\*O:
.iX "unique attribute"
An attribute indicating that
the pointer member being declared is a unique pointer.
.LI 
\*Lstring\*O:
.iX "string" "attribute"
An attribute indicating that
the array member being declared is a string.
.LI 
\*Lswitch_is\*O:
.iX "switch_is attribute"
.LE
.P
A structure can contain a conformant array (conformant structure) 
only as its last member.
And such a structure can be contained by another structure only as its
last member, and so on. 
A conformant structure cannot be returned by an operation as its value
and cannot be simply an \*Lout\*O parameter.
Note that a structure can contain any number of \*Epointer to\*O
conformant arrays.
Structure fields defined as pointers to an array base type and with
one or more of the array size attributes define pointers to conformant
arrays.  Since the size of the pointer field in the structure is
fixed, the structure itself is not conformant, although the array that
it points to is conformant.
.P
A structure cannot contain a pipe or context handle.
.P
.iX "ignore attribute"
The \*Lignore\*O attribute specifies that
the pointer is not to be transmitted in remote procedure calls.
Note that the \*Lignore\*O attribute can be applied only to a pointer that
is a member of a structure.  The \*Lignore\*O attribute is not allowed
in a type declaration that defines a pointer type.
.H 3 "Unions"
.iX "-]" "types" "IDL"
.iX "unions"
.iX "IDL" "unions"
.iX "union type"
.P
IDL provides two types of unions: encapsulated and nonencapsulated. 
An IDL union must be discriminated.  In an encapsulated union, the
discriminator is part of the union.  In a nonencapsulated union, the
discriminator is not part of the union.
.PP
The following \*Vtype_specifier\*O can be used to indicate either kind of
union.
.iS
\*Lunion \*V[tag]\*O 
.iE
.PP
A definition of the union identified by \*Vtag\*O must appear elsewhere in the
interface definition.
.H 4 "Encapsulated Unions"
.iX "encapsulated unions"
.PP
To define an encapsulated union, use the following syntax:
.iS
\*Lunion \*V[tag]\*O \*Lswitch\*O \*V(disc_type_spec discriminator)\*O \*V[union_name\*O]
\*L{\*O
 \*Vcase
 \*O...
 \*V[default_case]
 \*L}
.iE
.P
If a \*Vtag\*O is supplied, it can be used in a \*Vtype_specifier\*O of the form
shown in Section 18.14.2.
.P
The \*Vdisc_type_spec\*O indicates the type of the \*Vdiscriminator\*O,
which can be an integer, a character, a \*Lboolean\*O, or an enumeration.
.P
The \*Vunion_name\*O specifies a name to be used in C code generated
by the IDL compiler.  When the IDL compiler generates C code to represent
an IDL union, it embeds the union and its discriminator in a C structure.
The name of the IDL union becomes the name of the C structure.  If
you supply a \*Vunion_name\*O in your type declaration, the compiler
assigns this name to the embedded C union; otherwise, the compiler
assigns the generic name \*Ltagged_union\*O.
.P
A \*Vcase\*O contains one or more labels and may contain a member
declaration:
.iS
\*Lcase \*Vconstant\*L:
\*O...
\*V[union_member]\*L;\*O
.iE
.P
Each label in a \*Vcase\*O specifies a constant.  The \*Vconstant\*O can
take any of the forms accepted in an integer, character, or Boolean
constant declaration, each of which is described earlier 
in this chapter.
.P
A \*Vdefault_case\*O can be coded anywhere in the list of cases:
.iS
\*Ldefault\*L:
\*V[union_member]\*L;\*O
.iE
.P
A \*Vunion_member\*O takes the following form:
.iS
\*V[\*O[\*Vunion_member_attribute\*L,\*O ...]\*V] type_specifier declarator\*L;\*O
.iE
.P
A \*Vunion_member_attribute\*O can be any of the following:
.ML
.LI 
\*Lptr\*O:
.iX "ptr attribute"
An attribute indicating that
the pointer member being declared is a full pointer; 
it can be NULL and can be an alias.
.LI 
\*Lstring\*O:
.iX "string" "attribute"
An attribute indicating that
the character array member being declared is a string.
.LE
.P
In any union, the type of the discriminator and the type of all constants
in all case labels must resolve to the same type.  At the time the
union is used, the value of the discriminator selects a member, as
follows:
.ML
.LI
If the value of the discriminator matches the constant
in any label, the member associated with the label
is selected.
.LI
If there is no label whose constant matches the value
of the discriminator and there is a default case, the default member
is selected.
.LI
If there is no label whose constant matches the value
of the discriminator and there is no default case, no member is selected
and the exception \*Lrpc_x_invalid_tag\*O is raised.
.LE
.P
Note that IDL prohibits duplicate constant label values.
.P
A \*Vunion\*O_\*Vmember\*O can contain only one declarator.
If no \*Vunion_member\*O is supplied, the member is NULL; if
that member is selected when the union is used, no data is passed.  
But note that the discriminator is always passed.
.P
A union cannot contain a pipe, a conformant array, a varying array,
or any structure that contains a conformant or varying array.
A union also cannot contain a \*Lref\*O or \*Lunique\*O pointer or any 
structure that contains a \*Lref\*O or \*Lunique\*O pointer.
.PP
The following is an example of an encapsulated union.
.oS
/* IDL construct /*

   typedef
       union fred switch (long a) ralph {
            case 1: float b;
            case 2: long c;
       } bill;

/* becomes in the generated header file /*

  typedef
      struct fred {
          long a;
          union {
              float b;
              long c;
          } ralph;
      } bill;
.oE
.H 4 "Nonencapsulated Unions"
.iX "nonencapsulated union"
.iX "union" "nonencapsulated"
.PP
To define a nonencapsulated union, use the following syntax:
.iS
\*V[switch_type(datatype)]\*O \*Lunion\*O \*V[tag]\*O
\*L{\*O
 \*Vcase
 \*O...
 \*V[default_case]
 \*L}
.iE
.PP
If a \*Vtag\*O is supplied, it can be used in a \*Vtype_specifier\*O of the form
shown in Section 18.14.2.
.PP
A parameter or a structure field that is a nonencapsulated union must have an
attribute attached to it.  This attribute has the following form:
.iS
\*Lswitch_is\*O(\*Vattr_var\*O)
.iE
.PP
where \*Vattr_var\*O is the name of the parameter or structure field that is the
discriminator for the union.
.PP
If a nonencapsulated union is used as a structure field, the discriminator of
the union must be a field of the same structure.  If a nonencapsulated union is
used as a parameter of an operation, the discriminator must be another
parameter of the same operation.
.PP
The following example shows uses of a nonencapsulated union.
.PP
.iX "nonencapsulated union" "code example"
.oS
typedef 
  [switch_type(long)] union {
    [case (1,3)] float a_float;
    [case (2)] short b_short;
    [default] ; /* An empty arm.  Nothing is shipped. */
  } n_e_union_t;

typedef
  struct {
    long a; /* The discriminant for the    */
	    /* union later in this struct. */
    [switch_is (a)] n_e_union_t b;
  } a_struct;

/* Note switch can follow union in operation */
void op1 (
   [in] handle_t h,
   [in,switch_is (s)] n_e_union_t u,
   [in] long s  );
.oE
.nL
.ne 20
.zA "def,13492,R1.2.2,idl info missing from guide"
.H 3 "Enumeration"
.iX "enumeration"
.iX "IDL" "enumerations"
.PP
An IDL enumeration provides names for integers.  It is specified as
follows:
.oS
\*Lenum {\*O\*Videntifier[\*O= \*Vinteger], ...\*O\*L}\*O
.oE
.P
Each identifier in an enumeration is assigned an integer, either
explicitly in the interface or automatically by the IDL compiler.  If
all the identifiers are unassigned, the IDL compiler begins assigning
0 (zero) to the first identifier, 1 to the next identifier, and so on.
If an unassigned identifier follows an assigned one, the compiler
restarts number assignment with the next consecutive integer.  An
enumeration can have up to 32,767 identifiers.
.P
Assignments can be made in any order, and multiple identifiers can
have the same value. For example:
.oS
typedef  enum {
	SHOVEL = 9, AX, MATTOCK = 3, PITCHFORK, SPADE = 9
	} yard_tools;
/* values assigned: SHOVEL:9, AX:10, MATTOCK:3, PITCHFORK:4, SPADE:9 */
.oE
.zZ "def,13492,R1.2.2,idl info missing from guide"
.H 3 "Pipes"
.iX "-[" "pipes"
.iX "-[" "IDL" "pipes"
.P
IDL supports pipes as a mechanism for transferring large quantities of
typed data.  An IDL pipe is an open-ended sequence of elements of one
type.  A pipe permits application-level optimization of bulk data
transfer by allowing the overlap of communication and processing.
Applications that process a stream of data as it arrives, rather than
simply storing the data in memory, can make efficient use of the pipe
mechanism.
.P
A pipe is specified as follows:
.iS
\*Lpipe\*O \*Vtype_specifier\*O
.iE
.P
The \*Vtype_specifier\*O specifies the type for the elements of
the pipe.  This type cannot be a pointer type, a type
that contains a pointer, a conformant type, a context
handle, a \*Lhandle_t\*O element type, 
or a data type that is declared as \*Ltransmit_as\*O. 
.P
A pipe type can be used to declare only the type of an operation parameter.  
IDL recognizes three kinds of pipes, based on the three operation parameters:
.ML
.LI  
An \*Lin\*O pipe is for transferring data from a client to a server.  It 
allows the callee (server) to ``pull'' an open-ended stream of typed data 
from the caller (client).  
.LI
.ne 5
An \*Lout\*O pipe is for transferring data from a server to a client.  
It allows the callee (server) to ``push'' the stream of data to 
the caller (client).
.LI
An \*Lin,out\*O pipe provides for two-way data transfer between a client 
and server by combining the behavior of \*Lin\*O and \*Lout\*O pipes.
.LE
.P
A pipe can be defined only through a \*Ltypedef\*O 
declaration.  Anonymous pipe types are not supported.
.P
At the interface between the stub and the application-specific code
(for both the client and server), 
a pipe appears as a simple callback mechanism.  To the user
code, the processing of a pipe parameter appears to be synchronous.
The IDL implementation of pipes in the RPC stub and runtime allows the
apparent callbacks to occur without requiring actual remote callbacks.
As a result, pipes provide an efficient transfer mechanism for large
amounts of data.
.P
Note however, that pipe data communications occur at about the
same speed as arrays.  Pipes can improve latency and minimum memory
utilization, but not throughput.  Pipes are intended for use where the
receiver can process the data in some way as it arrives, for example
by writing it to a file or passing it to a consumer thread.  If the
intent is to store the data in memory for later processing, pipes
offer no advantage over arrays.
.H 4 "IDL Pipes Example"
.P
To illustrate the IDL implementation of pipes, consider the following 
IDL fragment:
.P 
.oS
typedef
   pipe element_t pipe_t;
.oE  
.P
When the code containing this fragment is compiled, the IDL compiler 
will generate the following declarations in the derived header file:
.P
.oS
.ne 20
typedef struct pipe_t {
    void (* pull)(
       rpc_ss_pipe_state_t state,
       element_t *buf,
       idl_ulong_int esize,
       idl_ulong_int *ecount
    );
   void (* push)(
      rpc_ss_pipe_state_t state,
      element_t *buf,
      idl_ulong_int  ecount
   );
   void (* alloc)(
      rpc_ss_pipe_state_t state,
      idl_ulong_int bsize,
      element_t **buf,
      idl_ulong_int *bcount
   );
   rpc_ss_pipe_state_t state;
} pipe_t;
.oE
.P
The pipe data structure specifies pointers to three separate routines and a
pipe state.
The client application has to implement these routines for the client
stub to call, and the server manager must call the associated
routines generated in the server stub.
.P
The \*Lpull\*O routine is used for an input pipe.  
It pulls the next chunk of data from the client application into the pipe.
The input parameters include the pipe \*Lstate\*O, 
the buffer (\*L*buf\*O) containing a chunk of data, 
and the size of the buffer (\*Lesize\*O) in terms of the number of
pipe data elements.
The output parameter is the actual count (\*L*ecount\*O) of the 
number of pipe data elements in the buffer.
.P
The \*Lpush\*O routine is used for an output pipe.  
It pushes the next chunk of data from the pipe to the client application.
The input parameters include the pipe \*Lstate\*O,
the buffer (\*L*buf\*O) containing a chunk of data,
and a count (\*Lecount\*O) of the number of pipe data elements in the buffer. 
.P
.ne 9
The \*Lalloc\*O routine allocates a buffer for the pipe data.
The input parameters include the pipe \*Lstate\*O and
the requested size of the buffer (\*Lbsize\*O) in bytes.
The output parameters include a pointer to the allocated buffer (\*L**buf\*O),
and the actual count (\*Lbcount\*O) of the number of bytes in the buffer.
The routine allocates memory from which pipe data 
can be marshalled or into which pipe data can be marshalled. 
If less memory is allocated than requested, 
the RPC runtime uses the smaller 
memory and makes more callbacks to the user.  If the routine allocates 
more memory than requested, the excess memory is not used.
.P
Finally, the \*Lstate\*O is used to coordinate between these routines.
.P
For more on how to write the code for the client and server manager,
see Chapter 17.
.H 4 "Rules for Using Pipes"
.iX "-]" "pipes"
.iX "-]" "IDL" "pipes"
.P
Observe the following rules when defining pipes in IDL:
.ML 
.LI
Pipe types must only be parameters.  In other words, 
pipes of pipes, arrays of pipes, and structures or unions containing 
pipes as members are illegal.
.LI
A pipe cannot be a function result.
.LI
The element type of a pipe cannot be a pointer or contain a pointer. 
.LI
The element type of a pipe cannot be a \*Lcontext_handle\*O or 
\*Lhandle_t\*O type. 
.LI
A pipe type cannot be used in the definition of another type.  
For example, the following code fragment is illegal:
.P
.oS
typedef
   pipe char pipe_t;

typedef
   pipe_t * pipe_p_t;
.oE
.LI
A pipe type cannot have the \*Ltransmit_as\*O attribute. 
.LI
The element type of a pipe cannot 
have the \*Ltransmit_as\*O attribute. 
.LI
.ne 3
A pipe parameter can be passed by value or by reference.  
A pipe that is passed by reference (that is, has an \*L*\*O (asterisk)) 
cannot have the \*Lptr\*O or \*Lunique\*O parameter 
attributes.
.LI
Pipes that pass data from the client to the server must be processed 
in the order in which they occur in an operation's signature.  All such 
pipes must be processed before data is sent from the server to the 
client.
.LI
Pipes that pass data from the server to the client must be processed 
in the order in which they occur in an operation's signature.  No such 
pipes must be processed until all data has been sent from the client to the 
server. 
.LI
Manager routines must reraise RPC pipe and communications
exceptions so that client stub code and server stub code
continue to execute properly.
.PP
For example, consider an interface that has an
\*Lout\*O pipe along with other \*Lout\*O
parameters.  Suppose that the following sequence of
events occurs:
.ML
.LI
The manager routine closes the pipe by writing an empty chunk whose
length is 0 (zero).
.LI
The manager routine attempts to write another chunk of data to the pipe.
.LI
The generated \*Lpush\*O routine raises the exception
\*Lrpc_\%x_\%fault_\%pipe_\%closed\*O.
.LI
The manager routine catches the exception and does not reraise it.
.LI
The manager routine exits normally.
.LI
The server stub attempts to marshall the \*Lout\*O parameters.
.LE
.PP
After this sequence, neither the server stub nor the client stub
can continue to execute properly.
.PP
To avoid this situation, you \*Vmust\*O reraise the exception. 
.LI
A pipe cannot be used in an operation that has the 
\*Lbroadcast\*O or \*Lidempotent\*O attribute. 
.LI
The element type of a pipe cannot be a conformant structure.
.LI
The maximum length of pipe type IDs is 29 characters. 
.LE
.H 3 "Arrays"
.iX "-: array" "IDL" "array"
.iX "array"
.P
IDL supports the following types of arrays:
.ML
.LI
Fixed: The size of the array is defined in IDL 
and all of the data in the array is transferred during the call.
...\" DCE 1.2 WRITER: changed "defined in the IDL"
...\" above to                "defined in IDL"
...\" should it be            "defined in the IDL file?"
...\" Pls verify this change
.iX "IDL" "array" "fixed"
.iX "array" "fixed"
.iX "fixed array"
.LI
Conformant: The size of the array is determined at runtime.
At least one bound of the array is determined at runtime by a value
referenced through a  
\*Lmin_is\*O, \*Lmax_is\*O, or \*Lsize_is\*O attribute.  All of the 
data in the array is transferred during the call.
.iX "IDL" "array" "conformant"
.iX "array" "conformant"
.iX "conformant array"
.LI
Varying: The size of the array is defined in IDL 
but the part of its contents transferred during the call is determined 
by the values of fields or parameters named in one or more data 
limit attributes.  The data limit attributes are \*Lfirst_is\*O, 
\*Llength_is\*O, and \*Llast_is\*O.
...\" DCE 1.2 WRITER: changed "defined in the IDL"
...\" above to                "defined in IDL"
...\" should it be            "defined in the IDL file?"
...\" Pls verify this change
.iX "IDL" "array" "varying"
.iX "array" "varying"
.iX "varying array"
.LE
.P
An array can also be both conformant and varying (or, as it is sometimes
termed, \*Eopen\*O).
.iX "IDL" "array" "conformant and varying"
.iX "array" "conformant and varying"
.iX "conformant and varying array"
.iX "varying and conformant array"
.iX "IDL" "array" "open"
.iX "array" "open"
.iX "open array"
In this case, the size of the array is determined at 
runtime by the value of the field or parameter referenced by the 
\*Lmin_is\*O, \*Lmax_is\*O or \*Lsize_is\*O attributes.  The part of its 
contents transferred during the call is determined by the values of fields
or parameters named in one or more of the data limit attributes.
.P
An IDL array is declared via an \*Varray_declarator\*O
construct whose syntax is as follows:
.iX "array" "array_declarator"
.iX "array_declarator"
.iS
\*Varray_identifier array_bounds_declarator \*O...
.iE
.P
An \*Varray_bounds_declarator\*O must be specified for each dimension
of an array.
.H 4 "Array Bounds"
.iX "array" "bounds"
.P
The \*Varray_bounds_declarator\*O for the first dimension of an
array can take any of the following forms:
.VL 1.25i
.LI "\*L[\*Vlower \*L.. \*Vupper\*L]\*O"
The lower bound
is \*Vlower\*O.  The upper bound is \*Vupper\*O.
.LI "\*L[\*Vsize\*L]\*O"
The lower bound is 0 (zero).  The upper
bound is \*Vsize\*O \-\ 1.
.LI "\*L[*]\*O"
The lower bound is 0 (zero).  The upper bound is determined by a
\*Lmax_is\*O or \*Lsize_is\*O attribute.
.LI "\*L[ ]\*O"
The lower bound is 0 (zero).  The upper bound is de\%ter\%mined by a
\*Lmax_is\*O or \*Lsize_is\*O attribute.
.LI "\*L[\*Vlower\*L .. ]\*O"
The lower bound
is \*Vlower\*O.  The upper bound is determined by a \*Lmax_is\*O
or \*Lsize_is\*O attribute.
.LI "\*L[* .. \*Vupper\*L]\*O"
The lower bound is determined by a \*Lmin_is\*O attribute.  The upper bound is
\*Vupper\*O.
.LI "\*L[* .. *\*L]\*O"
The lower bound is determined by a \*Lmin_is\*O attribute.  The upper bound is
determined by a \*Lsize_is\*O or \*Lmax_is\*O attribute.
.LE
.H 4 "Conformance in Dimensions Other Than the First"
.iX "conformance in dimensions other than the first"
If a multidimensional array is conformant in a dimension other than the first,
the C description for this array, which is located in the header 
(\*L.h\*O) file
generated by the IDL compiler, will be a one-dimensional conformant array of
the appropriate element type.  This occurs because there is no ``natural''
C binding for conformance in dimensions other than the first.
.PP
The following examples show how IDL type definitions and parameter
declarations that contain bounds in dimensions other than the first are
translated into their C equivalents at runtime.
.PP
.iX "conformance in dimensions other than the first" "code example"
\*LIDL Type Definition:\*O
.oS
typedef struct {
    long a;
    long e;
    [max_is(,,e),min_is(a)] long g7[*..1][2..9][3..*];
} t3;
.oE
.P
.iX "conformance in dimensions other than the first" "code example"
\*LC Translation:\*O
.oS
typedef struct  {
  idl_long_int a;
  idl_long_int e;
  idl_long_int g7[1];
.oE
.P
.iX "conformance in dimensions other than the first" "code example"
\*LIDL Parameter Declaration:\*O
.oS
[in,out,max_is(,,e),min_is(a)] long g7[*..1][2..9][3..*];
.oE
.P
\*LC Translation:\*O
.oS
/* [in, out] */ idl_long_int g7[]
.oE
.PP
Arrays that have a nonzero first lower bound and a first upper bound that is
determined at runtime are translated into the equivalent C
representation of a conformant array, as shown in the following IDL type
definition and parameter declaration examples:
.PP
.iX "conformance in dimensions other than the first" "code example"
\*LIDL Type Definition:\*O
.oS
typedef struct  {
           long s;
           [size_is(s)] long fa3[3..*][-4..1][-1..2];
} t1;
.oE
.P
\*LC Translation:\*O
.oS
typedef struct  {
  idl_long_int s;
  idl_long_int fa3[1][6][4];
} t1;
.oE
.P
.iX "conformance in dimensions other than the first" "code example"
\*LIDL Parameter Declaration:\*O
.oS
[in,out,size_is(s)] long fa3[3..*][-4..1][-1..2]
.oE
.P
\*LC Translation:\*O     				               
.oS
/* [in, out] */ idl_long_int fa3[][6][4]
.oE
...\" .cS
...\" The \*Varray_bounds_declarator\*O for each
...\" of these dimensions can therefore take only the following forms:
...\" .iX "array" "multidimensional"
...\" .VL 1.50i
...\" .LI "\*L[\*Vlower \*L.. \*Vupper\*L]\*O"
...\" The lower bound
...\" is \*Vlower\*O.  The upper bound is \*Vupper\*O.
...\" .LI "\*L[\*Vsize\*L]\*O"
...\" The lower bound is 0 (zero).  The upper
...\" bound is \*Vsize\*O \-\ 1.
...\" .LE
...\" .P
...\" In all forms of \*Varray_bounds_declarator\*O the \*Vlower\*O
...\" and \*Vupper\*O must resolve to integer constants.
...\" .cE
.H 4 "Array Attributes"
.iX "array" "attributes"
.P
Array attributes specify the size of an array or the part of an array that is
to be transferred during a call.  An array attribute specifies a 
variable that is either a field in the 
same structure as the array or a parameter in the same operation 
as the array.
.P
An \*Varray_attribute\*O can take the following forms:
.iS
\*Lmin_is (\*V[\*l*\*V] variable\*L)
max_is (\*V[\*L*\*V] variable\*L)
size_is (\*V[\*L*\*V] variable\*L)
last_is (\*V[\*L*\*V] variable\*L)
first_is (\*V[\*L*\*V] variable\*L)
length_is (\*V[\*L*\*V] variable\*L)
.iE
.P
where \*Vvariable\*O specifies a variable whose value at runtime will 
determine the bound or element count for the associated 
dimension.  A pointer variable is indicated by preceding the 
variable name with an \*L*\*O (asterisk).  
.P
If the array is a member of 
a structure, any referenced variables must be members of the same structure.  
If the array is a parameter of an operation, any referenced 
variables must be 
parameters of the same operation.
.P
Only the \*L..._is(\*Vvariable\*L)\*O form is allowed when
the array is a field of a structure.  In this case, the 
\*L..._is(*\*Vvariable\*L)\*O form is not allowed.
.P
Note that an array with an array attribute (that is, a conformant or varying 
array) is not allowed to have the \*Ltransmit_as\*O attribute.
.H 5 "The \*Lmin_is\*O Attribute"
.iX "min_is attribute"
.iX "array" "attributes" "min_is"
.PP
The \*Lmin_is\*O attribute is used to specify the
variable(s) from which the values of one or more lower bounds of the array
will be obtained at runtime.
If any dimension of an array has an unspecified lower bound, the array
must have a \*Lmin_is\*O attribute.  A variable must be identified
for each such dimension.
The following examples show the syntax of the \*Lmin_is\*O attribute:
.oS
.ps 10
.vs 12
.ne 12
/* Assume values of variables are as follows
    long a = -10;
    long b = -20;
    long c = -30;
*/

long [min_is(a)] g1[*..10];           /* g1[-10..10] */
long [min_is(a)] g2[*..10][4];        /* g2[-10..10[0..3] */
long [min_is(a,b)] g3[*..10][*..20];  /* g3[-10..10][-20..20] */
long [min_is(,b)] g4[2][*..20];       /* g4[0..1][-20..20] */
long [min_is(a,,c)] g5[*..7][2..9][*..8]; 
                                      /* g5[-10..7][2..9][-30..8] */
long [min_is(a,b,)] g6[*..10][*..20][3..8]; 
                                      /* g6[-10..10][-20..20][3..8] */
.ps 12
.vs 14
.oE  
.PP
The following examples show the \*Lmin_is\*O attribute being
applied to the first dimension of an array in an IDL type definition
and parameter declaration, and how the definition or parameter is translated
into its C equivalent:
.PP
.iX "array" "attributes" "min_is"
\*LIDL Type Definition:\*O
.oS
typedef struct {
         long n;
	 [min_is(n)] long fa3[*..10][-4..1][-1..2]
} t2;
.oE
.P
\*LC Translation:\*O
.oS
typedef struct  {
  idl_long_int n;
  idl_long_int fa3[1][6][4];
} t2;
.oE
.P
.iX "array" "attributes" "min_is"
\*LIDL Parameter Declaration:\*O
.oS
[in,out,min_is(n)] long fa3[*..10][-4..1][-1..2]
.oE
.P
\*LC Translation:\*O
.oS
/* [in, out] */ idl_long_int fa3[][6][4]
.oE     
.H 5 "The \*Lmax_is\*O Attribute"
.iX "max_is attribute"
.iX "array" "attributes" "max_is"
.P
The \*Lmax_is\*O attribute is used to specify the variables from which the
values of one or more upper bounds of the array are obtained at runtime.  If
any dimension of an array has an unspecified upper bound, the array must have
a \*Lmax_is\*O or \*Lsize_is\*O attribute.  A variable must be identified for
each dimension in which the upper bound is unspecified.  In a \*Lmax_is\*O
attribute, the value in the identified variable specifies the maximum array
index in that dimension.  An array with one or more unspecified upper bounds
may have a \*Lmax_is\*O attribute or a \*Lsize_is\*O attribute, but not both.
.PP
The \*Lmax_is\*O attribute is for use with conformant 
arrays. 
The following is an example of the \*Lmax_is\*O attribute:
.oS
.ps 10
.vs 12
/* Assume values of variables are as follows:
    long a = 10;
    long b = 20;
    long c = 30;
*/

long [max_is(a)] f1[];           /* f1[0..10] /*
long [max_is(a)] f2[][4];        /* f2[0..10][0..3]  */
long [max_is(a,b)] f3[][];       /* f3[0..10][0..20] */
long [max_is(,b)] f4[2][];       /* f4[0..1][0..20] */
long [max_is(a,,c)] f5[1..*][2..9][3..*];  /* f5[1..10][2..9][3..30] */
long [max_is(a,b,)] f6[1..*][2..*][3..8];  /* f6[1..10][2..20][3..8] */
.ps 12
.vs 14
.oE
.H 5 "The \*Lsize_is\*O Attribute"
.iX "size_is attribute"
.iX "array" "attributes" "size_is"
.P
The \*Lsize_is\*O attribute is used to specify the variables from which the
values of the element counts for one or more dimensions of the array are
obtained at runtime.  If any dimension of an array has an unspecified upper
bound, the array must have a \*Lmax_is\*O or \*Lsize_is\*O attribute.  A
variable must be identified for each dimension in which the upper bound is
unspecified.  In a \*Lsize_is\*O attribute, the value in the identified
variable specifies the number of elements in that dimension.
An array with one or more unspecified upper bounds may have a \*Lmax_is\*O
attribute or a \*Lsize_is\*O attribute, but not both.
.PP
The size of a dimension is defined as the upper bound, minus the 
lower bound, + 1.
.P
The \*Lsize_is\*O attribute is for use with conformant 
arrays.  The following is an example of the \*Lsize_is\*O attribute:
.oS
.ne 16
/* Assume the following values for the referenced variables:
   n3 = 5;
   x2 = 12;
   x3 = 14;
   z2 = 9;
   z3 = 10;
*/

/* The following declaration */

int [min_is(,,n3),max_is(,x2,x3)] hh[3..13,4..*,*..*];

/* specifies the same data to be  */
/* transmitted as the declaration */

int [min_is(,,n3),size_is(,z2,z3)] hh[3..13,4..*,*..*];
.oE
.H 5 "The \*Llast_is\*O Attribute"
.iX "last_is attribute"
.iX "array" "attributes" "last_is"
.P
The \*Llast_is\*O attribute is one of the attributes that can be used to allow
the amount of data in an array that will be transmitted to be determined at
runtime.  Each \*Llast_is\*O attribute specifies an upper data limit, which is
the highest index value in that dimension for the array elements to be
transmitted.  If the entry in a \*Llast_is\*O attribute for a dimension is
empty, the effect is as if the upper bound in that dimension had been
specified.
.P
An array can have either the \*Llast_is\*O attribute or the 
\*Llength_is\*O attribute, but not both.
.P
When an array with the \*Llast_is\*O attribute is used in a remote 
procedure call, the elements actually passed in the call can be a 
subset of the maximum possible.
.P
The \*Llast_is\*O attribute is for use with varying 
arrays.  The following is an example of the \*Llast_is\*O attribute:
.oS
.ps 10
.vs 12
.ne 17
/* Assume the following values for the referenced variables:
    long a = 1;
    long b = 2;
    long c = 3;
    long e = 25;
    long f = 35;
*/

long [last_is(a,b)] bb1[10][20]; /* transmit bb1[0..1][0..2] */
long [last_is(a,b)] bb2[-1..10][-2..20][-3..30];
                                 /* transmit bb2[-1..1][-2..2][-3..30] */
long [last_is(a,,c)] bb3[-1..10][-2..20][-3..30];
                                 /* transmit bb3[-1..1][-2..20][-3..3] */
long [last_is(,b,c),max_is(,e)] cc1[10][][30];
                                 /* transmit cc1[0..9][0..2][0..3] */
long [last_is(a,b),max_is(,e,f)] cc2[-4..4][][];
                                 /* transmit cc2[-4..1][0..2][0..35] */
.ps 12
.vs 14
.oE
.H 5 "The \*Lfirst_is\*O Attribute"
.iX "first_is attribute"
.iX "array" "attributes" "first_is"
.P
The \*Lfirst_is\*O attribute is one of the attributes that can be used to
allow the amount of data in an array that will be transmitted to be determined
at runtime.  Each \*Lfirst_is\*O attribute specifies a lower data limit,
which is the lowest index value in that dimension for the array elements to be
transmitted.  If the entry in a \*Lfirst_is\*O attribute for a dimension is
empty, the effect is as if the lower bound in that dimension had been
specified.
.P
When an array with the \*Lfirst_is\*O attribute is used in a remote 
procedure call, the elements actually passed in the call can be a 
subset of the maximum possible.
.P
The \*Lfirst_is\*O attribute is for use with varying 
arrays.  The following is an example of the \*Lfirst_is\*O attribute:
.oS
.ps 10
.vs 12
.ne 24
/* Assume the following values for the referenced variables:
    long p = -1;
    long q = -2;
    long r = -3;
    long t = -25;
    long u = -35;
    long x = 1;
    long y = 2;
    long z = 3;
*/

long [first_is(p)] dd1[-10..10];             /* transmit dd1[-1..10] */
long [first_is(p),last_is(x)] dd2[-10..10];  /* transmit dd2[-1..1] */
long [first_is(p,q)] ee1[-10..10][-20..20];
                          /* transmit ee1[-1..10][-2..20] */
long [first_is(p,q)] ee2[-10..10][-20..20][-30..30];
                          /* transmit ee2[-1..10][-2..20][-30..30] */
long [first_is(p,q,r),last_is(,,z)] ee3[-10..10][-20..20][-30..30]:
                          /* transmit ee3[-1..10][-2..20[-3..30] */ 
double [first_is(,q,r),min_is(,t)] ff1[10][*..2][-30..30];
                          /* transmit ff1[0..9][-2..2][-3..30] */
double [first_is(p,q),min_is(,t,u)] ff2[-4..4][*..2][*..35];
                          /* transmit ff2[-1..4][-2..2][-35..35] */
double [max_is(x,,z),min_is(,t,u),first_is(p,,r)] ff3[-20..*][*..30][*..*]
                          /* transmit ff3[-1..1][-25..30][-3..3] */
.ps 12
.vs 14
.oE
.H 5 "The \*Llength_is\*O Attribute"
.iX "length_is attribute"
.iX "array" "attributes" "length_is"
.P
The \*Llength_is\*O attribute is one of the attributes that can be used to
allow the amount of data in an array that will be transmitted to be determined
at runtime.  Each \*Llength_is\*O attribute specifies the number of elements in
that dimension to be transmitted.  If the entry in a \*Llength_is\*O attribute
for a dimension is empty, the effect is for the highest index value in that
dimension for the elements to be transmitted to be determined from the upper
bound in that dimension.
.P
An array can have either the \*Llast_is\*O 
attribute or the \*Llength_is\*O attribute, but not both.  
.P
When an array with the \*Llength_is\*O attribute is used in a remote 
procedure call, the elements actually passed in the call can be a 
subset of the maximum possible.
.P
The \*Llength_is\*O attribute is for use with varying 
arrays.  The following is an example of the \*Llength_is\*O attribute:
.oS
.ne 10
/* Assume the following values for the referenced variables:
    n3 = 5;
    f2 = 10;
    a1 = 11;
    a2 = 12;
    a3 = 14;
    e1 = 9;
    e2 = 3;
    e3 = 10;
*/

.ne 7
/* The following declaration: */

int [min_is(,,n3),first_is(,f2,),last_is(a1,a2,a3)] \\
  gg[3..13,4..14,*..15];

/* specifies the same data to be   */
/* transmitted as the declaration: */

int [min_is(,,n3),first_is(,f2,),length_is(e1,e2,e3)] \\
  gg[3..13,4..14,*..15];
.oE
.H 4 "Rules for Using Arrays"
.iX "array" "rules for"
.P
Observe the following rules when defining arrays in IDL:
.ML
.LI
A structure can contain only one conformant array, which must be 
the last member in the structure.
.LI
Conformant arrays are not valid in unions.
.LI
A structure parameter containing a conformant array can be passed only by 
reference.
.LI
Arrays that have the \*Ltransmit_as\*O attribute cannot be conformant 
or varying arrays.
.LI
The structure member or parameter referenced in an array attribute cannot 
be defined to have either the \*Lrepresent_as\*O or 
\*Ltransmit_as\*O attribute.
.LI
.ne 2
Array bounds must be integers.  Array attributes can reference only 
structure members or parameters of integer type.
.LI
A parameter that is referenced by an array 
attribute on a conformant array must have the \*Lin\*O attribute.
.LI
Array elements cannot be context handles or pipes, or conformant arrays or
conformant structures.
.LE
.H 3 "Strings"
.iX "IDL" "strings"
.iX "strings"
.iX "string" "attribute"
.P
IDL implements strings as one-dimensional arrays to which 
the \*Lstring\*O attribute is assigned.  The element type of 
the array must resolve to one of the following:
.P
.ML
.LI
Type \*Lchar\*O
.LI
Type \*Lbyte\*O
.LI
A structure all of whose members are of type \*Lbyte\*O or of 
a named type that resolves to \*Lbyte\*O
.LI
A named type that resolves to one of the previous three types
.LI
Type \*Lunsigned short\*O
.LI
Type \*Lunsigned long\*O
.LI
A named type that resolves to \*Lunsigned short\*O or \*Lunsigned long\*O
.LE
.P
Strings built from \*Lbyte\*O or \*Lchar\*O data types are referred to
as \*Ebyte-string types\*O while strings built from \*Lunsigned short\*O
or \*Lunsigned long\*O types are called \*Einteger-string types\*O.
Integer string types allow for multioctet character sets whose
characters are represented by 16-bit or 32-bit quantities,
rather than as groups of bytes, for example:
.oS
.ne 14
/* A structure that contains a fixed string */
/* and a conformant string */
typedef unsigned long PRIVATE_CHAR_32;
typedef struct {
   [string] PRIVATE_CHAR_32 fixed[27];
   [string] PRIVATE_CHAR_32 conf[];
} two_strings;
.oE
.P
.oS
/* A structure that contains pointers to two strings */
typedef unsigned short PRIVATE_CHAR_16;
typedef struct {
   [string] PRIVATE_CHAR_16 *astring;
   [string] PRIVATE_CHAR_16 *bstring;
} stringptrs;
.oE
.P
Integer-string types use the array element zero (0) to
specify the string terminator, while byte-string types
use the NULL character.  Both byte-type and
integer-type strings conform to the same usage rules.
...\" DCE 1.2 WRITERS: please check above paragraph
.P
An array with the \*Lstring\*O attribute represents a string
of characters.  The \*Lstring\*O attribute does not specify the
format of the string or the mechanism for determining its length.
Implementations of IDL provide string formats and mechanisms
for determining string lengths that are compatible with the programming
languages in which applications are written.
For DCE RPC IDL, the number of characters in a \*Lstring\*O array 
includes the NULL terminator (for byte-string types) or the
zero (0) terminator (for integer-string types), and the entire
terminated string is passed between stubs.
.P
The \*Varray_bounds_declarator\*O for a \*Lstring\*O array 
determines the maximum number of characters in the array.  
Note that, when you declare a string, you must allocate space 
for one more than the maximum number of characters the string is to 
hold.  For instance, if a string is to store 80 characters, the string 
must be declared with a size of 81:
.P
.oS
/* A string type that holds 80 characters */
typedef
   [string] char string_t [81];
.oE
.P
If an array has the \*Lstring\*O attribute or if the type of an
array has the \*Lstring\*O attribute, the array cannot have the 
\*Lfirst_is\*O, the \*Llast_is\*O, or the \*Llength_is\*O attribute.
.H 3 "Pointers"
.iX "-[" "pointers"
.PP
Use the following syntax to declare an IDL pointer:
.iS
\*L*\*V[\*L*\*V]...pointer_identifier\*O
.iE
.PP
The \*L*\*O (asterisk) is the pointer operator, and multiple asterisks indicate
multiple levels of indirection.
.H 4 "Pointer Attributes"
.iX "ref attribute"
.iX "ptr attribute"
.iX "unique attribute"
.PP
Pointers are used for several purposes, including implementing a 
parameter passing
mechanism that allows a data value to be returned, and  building complex
data structures.
.P
IDL offers three classes of pointers: reference pointers, full pointers, and
unique pointers.
The attributes that indicate these pointers are as follows:
.ML
.LI
\*Lref\*O: Indicates reference pointers.  This is the default for top-level
pointers used in parameters.
.LI
\*Lptr\*O: Indicates full pointers. 
.LI
\*Lunique\*O: Indicates unique pointers.
.LE
.PP
Pointer attributes are used in parameters, in structure and union members,
and in type definitions. 
In some instances, IDL infers the applicable pointer class from its usage.
However, most pointer declarations require that you specify a pointer
class by using one of the following methods:
.iX "pointer_default attribute"
.iX "default" "pointer semantics"
.ML
.LI
Use the \*Lref\*O, \*Lptr\*O, or \*Lunique\*O attribute in the pointer
declaration.
.LI
Use the \*Lpointer_default\*O attribute in the IDL interface heading.
The default pointer class is determined
by the \*Lpointer_default\*O attribute.
.LE
.PP
Pointer attributes are applied only to the top-level pointer within the
declaration.  If multiple pointers are declared in a single declaration,
the \*Lpointer_default\*O established applies to all but the top-level
pointer. (See Section 18.14.7.2, which
describes pointer attributes in parameters.)
.PP
Examples of pointers are shown at the end of this section.
.H 5 "Reference Pointers"
.PP
.iX "ref attribute"
.iX "reference pointer"
.iX "aliasing"
A reference pointer is the least complex form of pointer.  The most common use
for this class of pointer is as a passing mechanism; for example, passing
an integer by reference.  Reference pointers have significantly better
performance than full pointers, but are restrictive; you cannot create a
linked list by using a reference pointer because a reference pointer cannot
have a NULL value, and the list cannot be terminated.
.PP
A reference pointer has the following characteristics:
.ML
.LI
It always points to valid storage; it can never have a NULL value.
.LI
Its value does not change during a call; it always
points to the same storage on return from the call as it did 
when the call was made.
.LI
It does not support aliasing; it cannot point to a storage area that
is pointed to by any other pointer used in a parameter of 
the same operation.
.LE
.PP
When a manager routine is entered, all the reference pointers in its parameters
will point to valid storage, except those reference pointers that 
point neither to targets whose size can be determined at compile time nor 
to values that have been received from the client.
.PP
In the following example, the size of the targets of the reference
pointers can be calculated at compilation time:
.oS
typedef [ref] long *rpl;

void op1( [in] long f, 
          [in] long l, 
          [in,first_is(f),last_is(l)] rpl rpla[10] );
.oE
.PP
For this example, when the manager is entered,
all the pointers in \*Lrpla\*O will point to usable storage, although only
\*L*rpla[f]\*O through \*L*rpla[l]\*O 
will be the values received from the client.
.PP
.ne 8
Conversely, the size of the targets of the reference pointers cannot
be calculated at compile time in the following example:
.oS
typedef [ref,string] char *rps;

void op1( [in] long f, 
          [in] long l, 
          [in,first_is(f),last_is(l)] rps rpsa[10] );
.oE
.PP
In this case, only \*Lrpsa[f]\*O through \*Lrpsa[l]\*O, which point to
values received from the client, will point to usable storage.
.H 5 "Full Pointers"
.PP
.iX "ptr attribute"
.iX "full pointer"
.iX "aliasing"
A full pointer is the most complex form of pointer.  It supports 
all capabilities associated with pointers.  For example,
by using a full pointer you can build complex data structures such
as linked lists, trees, queues, or arbitrary graphs.
.PP
A full pointer has the following characteristics:
.ML
.LI
Its value can change during a call;
it can change from a NULL to non-NULL value, 
non-NULL to NULL, or
from one non-NULL value to another non-NULL value.
.LI
It supports aliasing; it can point to a storage area that
is also pointed to by any other full pointer used in a parameter of 
the same operation.  However, all such pointers must point to the beginning of
the structure.  There is no support for pointers to substructures or to
overlapping storage areas.  For example, if the interface definition code
contains the following:
.oS
.ne 14
[uuid(0e256080-587c-11ca-878c-08002b111685), version(1.0)]
interface overlap
{
  typedef struct {
          long bill;
          long charlie;
  } foo;
  typedef struct {
          long fred;
          foo ken;
  } bar;

  void op ( [in] foo *f, [in] bar *b );
}
.oE
and the client application code includes the following:
.oS
bar bb;
 .
 .
 .
op ( &bb.ken, &bb );
.oE
then the server stub treats these two separate parameters as distinct, 
and the manager application code does not see them as overlapping storage.
.LI
It allows dynamically allocated data to be returned from a call.
.LE
.zA "def, 13469, R1.2.2, document limit on linked-list marshalling"
.P
Note that you might need to take some extra steps if you use large
linked lists in your application.  Linked lists are marshalled and
unmarshalled using recursion which can cause the stack size to grow.
Linked lists usually do not cause problems in simple clients that do
not spawn threads for remote procedure calls. In this case, the stack
can grow as needed.
.P
Large linked lists can cause problems in servers because the server's
thread-stack usually cannot grow automatically.  Large lists can
overrun the stack, causing the server to crash.
.P
DCE offers several ways to avoid this server memory problem while
using large linked lists.
.P
.iX  "rpc_mgmt_set_server_stack_size(\|) routine"
One method is to increase the server stack size using the
\*Lrpc_mgmt_set_server_stack_size(\|)\*O routine.  This method is
useful when you suspect that the linked list is just slightly larger
than the server stack. For information about using the
\*Lrpc_mgmt_set_server_stack_size(\|)\*O routine, refer to the OSF DCE
Application Development Reference.
.P
.iX  "transmit_as idl attribute"
If you suspect that the list size is much greater than the stack, you
can convert the list to an array using the \*Ltransmit_as\*O idl
attribute.  Servers handle arrays by allocating memory from the heap
rather than from the stack. For information about using the
\*Ltransmit_as\*O idl attribute, refer to Chapter 19 in this guide.
.zZ "def, 13469, R1.2.2, document limit on linked-list marshalling"
.H 5 "Unique Pointers"
.iX "pointers"
.iX "unique pointers"
.PP
A unique pointer is more flexible than a reference pointer.  However,
both types of pointers share several important characteristics.
.PP
A unique pointer has the following characteristics:
.ML
.LI
It can have a NULL value.
.LI
It can change from NULL to non-NULL during a call.
This change 
results in memory being allocated on return from the call, whereby the 
result is stored in the allocated memory.
.LI
.ne 4
It can change from non-NULL to NULL during a call.  This
change can result in the orphaning of the memory pointed
to on return from the call.  Note that,
if a unique pointer changes from one
non-NULL value to another non-NULL value,
the change is ignored.
.LI
It does not identify particular extents of memory, but only extents of
memory that are suitable for storing the data.  If it is important
to know that the data is being stored in a specific memory location, then you
should use a full pointer.
.LI
If it has a value other than NULL, output data is placed
in existing storage.
.LE
.PP
Unique pointers are similar to reference pointers in the following ways:
.ML
.LI
No storage pointed to by a unique pointer can be reached from any other
name in the operation.  That is, a unique pointer does not allow aliasing
of data within the operation.
.LI
Data returned from the called subroutine is written into the existing storage
specified by the unique pointer, if the pointer did not have the value
NULL.
.LE
.PP
With regard to performance, unique pointers have an advantage over full
pointers because unique pointers do not support the referencing of
common data by more than one pointer (aliasing), and they are significantly
more flexible than reference pointers because they can have a value of
NULL.
.PP
Unique pointers are particularly suitable for creating optional parameters
(because you can specify them as NULL) and for simple tree
or singly linked-list data structures.  You specify the three different levels
of pointers by attributes, as follows:
.VL 7m
.LI "\*L[ref]\*O"
Reference pointers
.LI "\*L[unique]\*O"
Unique pointers
.LI "\*L[ptr]\*O"
Full pointers
.LE
.PP
.ne 16
The following example shows how a unique pointer can be used:
.iX "unique pointers" "example"
.oS
[
    uuid(D37A0E80-5D23-11C9-B199-08002B13D56D)
] interface Unique_ptrs
{
    typedef [ref]    long *r_ptr;
    typedef [unique] long *u_ptr;
    typedef [ptr]    long *f_ptr;

    void op1 (
      [ref,in,out,string]	 char *my_rname,
      [unique,in,out,string] char *my_uname,
      [ptr,in,out,string]	 char *my_pname
    	 );
}
.oE
.H 4 "Pointer Attributes in Parameters"
.PP
.iX "parameters"
A pointer attribute can be applied to a parameter only if the 
parameter contains an explicit pointer declaration (\*L*\*O).  
.PP
By default, a single pointer (\*L*\*O) operator in a parameter list
of an operation declaration is treated as a reference pointer.
To override this, specify 
a pointer attribute for the parameter. 
.iX "pointer levels"
When there is more than one pointer operator, or
multiple levels of indirection in the parameter list, the
rightmost pointer is the top-level pointer; all 
pointers to the left of the rightmost pointer
are of a lower level.  The top-level pointer
is treated as a reference pointer by default; the lower-level
pointers have the semantics specified by the 
\*Lpointer_default\*O attribute in the interface.
.P
The following example illustrates the use of top- and lower-level
pointers:
.oS
void op1 ([in] long **p_p_l)
.oE
In this example, \*Lp_p_l\*O is a pointer to a pointer to a long integer.
The first or leftmost pointer (\*L*\*O) signifies that the pointer to the
long integer is a lower-level pointer, and the second or rightmost pointer (*)
signifies that the
pointer to the pointer is a top-level pointer.
.P
.ne 4
Any pointer
attribute you specify for the parameter applies to the top-level pointer only.
Note that unless you specify a pointer attribute, the top-level explicit
pointer declaration in a parameter defaults to a reference pointer
even if the \*Lpointer_default(ptr)\*O interface
attribute is specified.
.P
Using a reference pointer improves performance but is 
more restrictive.  For example, the pointer declared in the following
operation, for the parameter \*Lint_value\*O, is a reference
pointer.  An application call to this operation can never specify NULL
as the value of \*Lint_value\*O. 
.oS
void op ([in] long *int_value);
.oE
.PP
To pass a NULL value, use a full pointer.  The following two
methods make \*Lint_value\*O into a full pointer:
.ML
.LI
Applying the \*Lptr\*O attribute to the declaration of
the parameter, \*Lint_value\*O:
.oS
void op ([in, ptr] long *int_value);
.oE
.LI
Using the \*Lpointer_default (ptr)\*O
attribute in an interface header :
.oS
[uuid(135e7f00-1682-11ca-bf61-08002b111685,
 pointer_default(ptr),
 version(1.0)] interface full_pointer
{
typedef long *long_ptr;
void op ([in] long_ptr int_value);
}
.oE
.LE
.P
A NULL pointer can also be passed via a unique pointer.
.H 4 "Array Attributes on Pointers"
.PP
.iX "pointers" "array attributes on"
To apply array attributes to pointers, use the
\*Lmax_is\*O or \*Lsize_is\*O attributes.
When applied to a pointer, the 
\*Lmax_is\*O and \*Lsize_is\*O attributes
convert the pointer from a single element of a certain type 
to a pointer to an array of elements of that type.
The number of elements in the array is determined by the 
variable in the  
\*Lmax_is\*O and \*Lsize_is\*O attributes.
.H 4 "Pointer Attributes in Function Results"
.PP
.iX "function results, pointers"
.iX "pointers" "in function results"
Function results that are pointers are always treated as full
pointers.  The \*Lptr\*O attribute is allowed on function results
but it is not mandatory.  The \*Lref\*O pointer attribute is never
allowed on function results.
.PP
A function result that is a pointer always indicates new storage.
A pointer parameter can reference storage that was allocated
before the function was called, but a function result cannot.
.H 4 "Pointers in Structure Fields and Union Case"
.PP
.iX "pointer_default attribute"
If a pointer is declared in a member of a structure or union, its default
is determined by the \*Lpointer_default\*O attribute you specify for the 
interface.  To
override this, specify a pointer attribute for the member.
.H 4 "Resolving a Possible Pointer Ambiguity"
A declaration of the following form
raises a possible ambiguity about the type of \*Vmyarray\*O:
.oS
.ps 11
void op ([in, out] long s, [in, out, size_is(s)] long **myarray);
.ps 12
.oE
.P
IDL defines \*Vmyarray\*O in this case to be an array of pointers to
\*Llongs\*O, not a pointer to an array of \*Llongs\*O.  The
\*Lmax_is\*O and \*Lsize_is\*O attributes always apply to the
top-level, or rightmost, * (asterisk) in the IDL signature of a
parameter.
.H 4 "Rules for Using Pointers"
.PP
.iX "-]" "pointers"
Use the following rules when developing code in IDL:
.ML
.LI
Do not use the full pointer attribute on the following: 
.ML
.LI
The parameter in the first parameter position, when that
parameter is of type \*Lhandle_t\*O or is of a type with the
\*Lhandle\*O attribute.
.LI
Context handle parameters.
.iX "context handle"
.iX "handle" "attribute"
.iX "first_is attribute"
.iX "last_is attribute"
.iX "length_is attribute"
.LI
A parameter that has the output attribute (\*Lout\*O), but not the input
attribute (\*Lin\*O).
.LE 
.LI
The element type of a pipe must not be a pointer or a structure
containing a pointer.  
.LI
A member of a union or a structure contained in a union 
cannot contain a reference pointer.
.LI
A reference pointer must point to valid storage at the time the call is made.
.LI
A parameter containing a varying array of reference pointers must 
have all array elements
initialized to point to valid storage even if only a portion of the array
is input, since the manager code (the application code supporting
an interface on a server) may use the remaining array
elements. (Recall that a varying array is one to which any of the
array attributes \*Lfirst_is, last_is, length_is\*O is
applied).
.LI
The type name in a declaration that defines a pointer type must have
no more than 28 characters.
.LE
.H 4 "Memory Management for Pointed-to Nodes"
.PP
.iX "memory" "management"
A full pointer can change its value across a call.  Therefore, stubs must be able
to manage memory for the pointed-to nodes.  Managing memory involves
allocating and freeing memory for user data structures. 
.H 5 "Allocating and Freeing Memory"
.P
.iX "allocating memory"
.iX "freeing memory"
.iX "memory" "freeing"
.iX "memory" "allocating"
.iX "-[" "memory" "routines"
.iX "routines" "RPC"
Manager code within RPC servers usually uses the
\*Lrpc_ss_allocate(\|)\*O routine to allocate storage.  Storage that is
allocated by \*Lrpc_ss_allocate(\|)\*O is released by the server stub after
any output parameters have been marshalled by the stubs.
Storage allocated by other allocators is not released automatically but
must be freed by the manager code. 
When the manager code makes a remote call, the default memory management 
routines are \*Lrpc_ss_allocate(\|)\*O and
\*Lrpc_ss_free(\|)\*O.
.P
.iX "idl_void_p_t type"
.ne 3
The syntax of the \*Lrpc_ss_allocate(\|)\*O routine is as follows:
.iS
\*Lidl_void_p_t rpc_ss_allocate (idl_size_t \*Vsize\*L);\*O
.iE
.PP
The \*Vsize\*O parameter specifies the size of the memory allocated.
.nS note
In ANSI standard C environments, \*Lidl_void_p_t\*O is defined
as \*Lvoid *\*O and in other environments is defined as \*Lchar *\*O.
.nE
.P
Use \*Lrpc_ss_free(\|)\*O
to release storage allocated by
\*Lrpc_ss_allocate(\|)\*O.  You can also use
the \*Lrpc_ss_free(\|)\*O routine to release storage pointed to by a
full pointer in an input parameter and have the freeing of the memory
reflected on return to the calling application by specifying the
\*Lreflect_deletions\*O attribute as an \*Voperation_attribute\*O.  See
Section 18.4.1 for more information.
.P
The syntax of the routine is as follows:
.iS
\*Lvoid rpc_ss_free (idl_void_p_t\*O \*Vnode_to_free\*L);\*O
.iE
.PP
The \*Vnode_to_free\*O parameter specifies the location 
of the memory to be freed.
.H 5 "Enabling and Disabling Memory Allocation"
.P
.iX "enabling memory"
.iX "disabling memory"
.iX "memory" "enabling"
.iX "memory" "disabling"
.iX "idl_void_p_t type"
.iX "routines" "RPC"
It may be necessary to call manager routines 
from different environments; for example, when the 
application is both a client and a server of the same interface.  In this
case, the same routine may be called both from server manager code and
from client code. 
The \*Lrpc_ss_allocate(\|)\*O routine, when used by the manager code
to allocate memory, must be initialized before its first use.
The stub performs the initialization automatically.  Code,
other than stub code, that calls 
a routine, which in turn calls \*Lrpc_ss_allocate(\|)\*O, first calls
the \*Lrpc_ss_enable_allocate(\|)\*O routine. 
.PP
The syntax of the routine is as follows:
.iS
\*Lvoid rpc_ss_enable_allocate (void);\*O
.iE
.P
.ne 5
The environment set up by the \*Lrpc_ss_enable_allocate(\|)\*O
routine is released by calling the \*Lrpc_ss_disable_allocate(\|)\*O
routine.  This routine releases all memory allocated by calls to
\*Lrpc_ss_allocate(\|)\*O since the
call to \*Lrpc_ss_enable_allocate(\|)\*O was made.  It also
releases memory that was used by the memory management mechanism for
internal bookkeeping.
.P
The syntax of the \*Lrpc_ss_disable_allocate(\|)\*O routine is as follows:
.iS
\*Lvoid rpc_ss_disable_allocate (void);\*O
.iE
.H 4 "Advanced Memory Management Support"
.P
.iX "memory" "advanced management support"
Memory management may also involve
setting and swapping the mechanisms used for allocating and
freeing memory.
The default memory management routines are \*Lmalloc(\|)\*O and 
\*Lfree(\|)\*O, except when the remote call occurs within manager code, in which
case the default memory
management routines are \*Lrpc_ss_allocate(\|)\*O and \*Lrpc_ss_free(\|)\*O.
.H 5 "Setting the Client Memory Mechanism"
.P
.iX "memory" "management" "client"
.iX "client" "memory management"
.iX "setting" "client memory"
.iX "memory" "setting client"
.iX "routines" "RPC"
Use the \*Lrpc_ss_set_client_alloc_free(\|)\*O 
routine to establish the routines used in
allocating and freeing memory.
.P
The syntax of the routine is as follows:
.iS
\*Lvoid rpc_ss_set_client_alloc_free (\*L
     idl_void_p_t (*\*Vp_allocate\*L) (\*L
        idl_size_t \*Vsize\*L), 
      void (*\*Vp_free\*L) (
         idl_void_p_t \*Vptr\*L)
      );\*O
.iE
.PP
The \*Vp_allocate\*O parameter points to a routine that has the same
procedure declaration as the \*Lmalloc(\|)\*O routine, and is
used by the client stub when performing memory allocation.
The \*Vp_free\*O parameter points to a routine that has the same
procedure declaration as the \*Lfree(\|)\*O routine, and is
used by the client stub to free memory.
.H 5 "Swapping Client Memory Mechanisms"
.P
.iX "client" "memory"
.iX "memory" "swapping memory"
.iX "swapping client memory"
.iX "routines" "RPC"
This routine exchanges the current client allocation and freeing mechanism
for one supplied in the call. 
The primary purpose of this routine is to simplify the
writing of modular routine libraries in which RPC calls are made.  To
preserve modularity, any dynamically allocated memory returned by a modular
routine library must be allocated with a specific memory allocator.  When
dynamically allocated memory is returned by an RPC call that is then returned
to the user of the routine library, use
\*Lrpc_ss_swap_client_alloc_free(\|)\*O, before making the RPC call, 
to make sure the desired memory allocator is used.  Prior to returning,
the modular routine library calls 
\*Lrpc_ss_set_client_alloc_free(\|)\*O
to restore the previous memory management mechanism.
.P
The syntax of the routine is as follows:
.iS 
\*Lvoid rpc_ss_swap_client_alloc_free (
      idl_void_p_t (*\*Vp_allocate\*L) (
         idl_size_t \*Vsize\*L),
      void (*\*Vp_free\*L) (
         idl_void_p_t \*Vptr\*L),
      idl_void_p_t (**\*Vp_p_old_allocate\*L) (
         idl_size_t \*Vsize\*L),
      void (**\*Vp_p_old_free\*L) (
         idl_void_p_t \*Vptr\*L)
      );
.iE
.PP
The \*Vp_allocate\*O parameter points to a routine that has the same
procedure declaration as the \*Lmalloc(\|)\*O routine, and is used by the
client stub when performing memory allocation.
The \*Vp_free\*O parameter points to a routine that has the same
procedure declaration as the \*Lfree(\|)\*O routine, and is used by the
client stub to free memory.
The \*Vp_p_old_allocate\*O parameter points to a pointer to a
routine that has the same
procedure declaration as the \*Lmalloc(\|)\*O routine, and is the
default routine used for memory allocation in the client stub.
The \*Vp_p_old_free\*O parameter points to a pointer to a
routine that has the same
procedure declaration as the \*Lfree(\|)\*O routine, and is used
for memory release in the client.
.H 4 "Use of Thread Handles in Memory Management"
.PP
.iX "memory" "management" "server threads"
.iX "server" "threads" 
.iX "-]" "memory" "routines"
.iX "thread" "memory management for"
There are two situations where control of memory
management requires the use of thread handles.  The more
common situation is when the manager thread spawns additional threads.
The less common situation is when a program transitions from being a
client to being a server, then reverts to being a client. 
.H 5 "Spawning Threads"
.PP
.iX "spawning server threads"
.iX "memory" "server threads"
When a remote procedure call invokes the manager code, 
the manager code may wish to spawn additional threads to complete the
task for which it was called.  To spawn additional threads that are
able to perform memory management, the manager code must first call
the \*Lrpc_\%ss_\%get_\%thread_\%handle(\|)\*O routine to get its thread handle
and then pass that thread handle to each spawned thread.  Each spawned
thread that uses the \*Lrpc_\%ss_\%allocate(\|)\*O and \*Lrpc_\%ss_\%free(\|)\*O
routines for memory management first calls the
\*Lrpc_\%ss_\%set_\%thread_\%handle(\|)\*O routine by using the handle obtained by
the original manager thread.
.PP
These routine calls allow the
manager and its spawned threads to share a common memory management
environment.  This common environment enables memory allocated by the
spawned threads to be used in returned parameters, and causes all
allocations in the common memory management environment to be released
when the manager thread returns to the server stub. 
.PP
The main manager thread must not return control to the server stub
before all the threads it spawned complete execution; otherwise,
unpredictable results may occur.
.PP
The listener thread can cancel the main manager thread if the
remote procedure call is orphaned or if a cancellation occurs on the
client side of the application.  You should code the main manager thread
to terminate any spawned threads before it exits.  The code should
anticipate exits caused by an unexpected exception or by being canceled.
.PP
.ne 9
Your code can handle all of these cases by 
including a \*LTRY/FINALLY\*O block to
clean up any spawned threads if a cancellation or other exception
occurs.  If unexpected exceptions do not concern you, then your code can
perform two steps.  They are
disabling cancelability before threads are spawned followed by enabling
cancelability after the join operation finishes and after testing for any
pending cancel operations.  Following this disable/enable sequence
prevents routine \*Lpthread_join(\|)\*O from producing a cancel point in a
manager thread that has spawned threads which, in turn, share thread
handles with the manager thread.
.H 5 "Transitioning from Client to Server to Client"
.PP
.iX "clients becoming servers"
Immediately before the program changes from a client to a
server, it must obtain a handle on its environment as a client by calling
\*Lrpc_\%ss_\%get_\%thread_\%handle(\|)\*O.  When it reverts from a server to
a client, it must reestablish the client environment by calling
the \*Lrpc_\%ss_\%set_\%thread_\%handle(\|)\*O routine, supplying the previously
obtained handle as a parameter.
.H 5 "Syntax for Thread Routines"
.PP
The syntax for the \*Lrpc_ss_get_thread_handle(\|)\*O routine is as follows:
.iS
\*Lrpc_ss_thread_handle_t  rpc_ss_get_thread_handle(void);\*O
.iE
.PP
The syntax for the \*Lrpc_ss_set_thread_handle(\|)\*O routine is as follows:
.iS
\*Lvoid rpc_ss_set_thread_handle (
     rpc_ss_thread_handle_t \*Vid\*L
     );
.iE
.PP
The \*Lrpc_ss_thread_handle_t(\|)\*O value identifies the thread to the
RPC stub support library.  The \*Vid\*O parameter indicates the thread
handle passed to the spawned thread by its creator, or the
thread handle returned by the previous call to 
\*Lrpc_ss_get_thread_handle(\|)\*O.
.H 4 "Rules for Using the Memory Management Routines"
.PP
.iX "memory" "management" "usage rules"
You can use the \*Lrpc_ss_allocate(\|)\*O routine in the following 
environments:
.ML
.LI
The manager code for an operation that has a full pointer in its
argument list
.LI
The manager code for an operation to which the \*Lenable_allocate\*O 
ACF attribute is applied
.LI
Code that is not called from a server stub but that has called
the \*Lrpc_ss_enable_allocate(\|)\*O routine
.LI
A thread, spawned by code of any of the previous three types, that has
made a call to the \*Lrpc_ss_set_thread_handle(\|)\*O routine using a
thread handle obtained by this code
.LE
.H 4 "Examples Using Pointers"
.PP
The examples in this subsection contain the following files, listed here with
the function of each file:
.VL 2.25i
.LI "\*LSTRING_TREE.IDL\*O"
Defines data types and interfaces
.LI "\*LCLIENT.C\*O"
User of the interface
.LI "\*LMANAGER.C\*O"
Server code that implements the procedure
.LI "\*LSERVER.C\*O"
Declares the server; enables the client code to find the interface it needs
.LI "\*LSTRING_TREE.OUTPUT\*O"
Shows the output
.LE
.PP
.ne 29
\*LThe STRING_TREE.IDL Example\*O
.oS
.ps 10
.vs 12
[uuid(0144d600-2d28-11c9-a812-08002b0ecef1), version(0)]
interface string_tree
{
  /*
   * Maximum length of a string in the tree
   */
  const long int st_c_name_len = 32;

  /*
   * Definition of a node in the tree.
   */
  typedef struct node
  {
      [string] char name[0..st_c_name_len];
      [ptr] struct node *left;
      [ptr] struct node *right;
  } st_node_t;

  /*
   * Operation that prunes the left subtree of the specified
   * tree and returns it as the value.
   */
  st_node_t *st_prune_left (
      [in, out] st_node_t *tree /* root of tree by ref */
      );
}
.ps 12
.vs 14
.oE
.P
\*LThe CLIENT.C Example\*O
.oS
.ps 10
.vs 12
#include <stdio.h>
#include "string_tree.h"

#include <stdlib.h>

/*
** Routine to print a depiction of the tree
*/
void st_print_tree (tree, indent)
  st_node_t *tree;
  int  indent;
{
  int i;
  if (tree == NULL) return;
  for (i = 0; i < indent; i++) printf("    ");
  printf("%s\\n",tree->name);
  st_print_tree(tree->left, indent + 1);
  st_print_tree(tree->right, indent + 1);
}

.ne 7
/*
** Create a tree with a few nodes
*/
st_node_t *st_make_tree(\|)
{
  st_node_t *root = (st_node_t *)malloc(sizeof(st_node_t));
  strcpy(root->name,"Root Node");

  /* left subtree node */
  root->left =  (st_node_t *)malloc(sizeof(st_node_t));
  strcpy(root->left->name,"Left subtree");    

  /* left subtree children */
  root->left->right = NULL;
  root->left->left = (st_node_t *)malloc(sizeof(st_node_t));
  strcpy(root->left->left->name,"Child of left subtree");    
  root->left->left->left = NULL;
  root->left->left->right = NULL;

  /* right subtree node */
  root->right =  (st_node_t *)malloc(sizeof(st_node_t));
  strcpy(root->right->name,"Right subtree");    
  root->right->left = NULL;
  root->right->right = NULL;

  return root;
}

main(\|)
{
  st_node_t *tree;
  st_node_t *subtree;

  /* setup and print original tree */
  tree = st_make_tree(\|);
  printf("Original Tree:\\n");
  st_print_tree(tree, 1);

  /* call the prune routine */
  subtree = st_prune_left (tree);

  /* print the resulting trees */
  printf("\\nPruned Tree:\\n");
  st_print_tree(tree, 1);

  printf("\\nPruned subtree:\\n");
  st_print_tree(subtree, 1);
  }
.ps 12
.vs 14
.oE
.P
.ne 6
\*LThe MANAGER.C Example\*O
.oS
.ps 10
.vs 12
#include <stdio.h>
#include "string_tree.h"

/*
** Prune the left subtree of the specified tree and return
** it as the function value.  
*/
st_node_t *st_prune_left (tree)
  /* [in,out] */  st_node_t *tree;
{
  st_node_t *left_sub_tree = tree->left;
  tree->left = (st_node_t *)NULL;
  return left_sub_tree;
}
.ps 12
.vs 14
.oE
.P
\*LThe SERVER.C Example\*O
.oS
.ps 10
.vs 12
#include <stdio.h>
#include "string_tree.h"  /* header created by idl compiler */
#define check_error(s, msg) if(s != rpc_s_ok) \\
  {fprintf(stderr, "%s", msg); exit(1);}

main (\|)
{
  unsigned32              status;            /* error status (nbase.h) */
  rpc_binding_vector_p_t  binding_vector;
                                     /* set of binding handles (rpc.h) */ 
                         
  rpc_server_register_if(       /* register interface with RPC runtime */
    string_tree_v0_0_s_ifspec, 
                            /* interface specification (string_tree.h) */ 
    NULL,                     
    NULL,                     
    &status                                            /* error status */
  );
  check_error(status, "Can't register interface\\n");

  rpc_server_use_all_protseqs(         /* establish protocol sequences */
    rpc_c_protseq_max_calls_default, 
                              /* concurrent calls server takes (rpc.h) */ 
    &status
  );
  check_error(status, "Can't establish protocol sequences\\n");

.ne 5
  rpc_server_inq_bindings( /* get set of this server's binding handles */
    &binding_vector,          
    &status
  ); 
  check_error(status, "Can't get binding handles\\n");

.ne 8
  rpc_ep_register(      /* register addresses in endpoint map database */
    string_tree_v0_0_s_ifspec,              /* interface specification */
    binding_vector,      /* (string_tree.h) the set of binding handles */
    NULL,                     
    "",                       
    &status 
  );
  check_error(status, "Can't add address to the endpoint database\\n");

  rpc_ns_binding_export(                  /* establish namespace entry */
    rpc_c_ns_syntax_dce,           /* syntax of the entry name (rpc.h) */
    "string_tree",                  /* entry name in directory service */
    &string_tree_v0_0_s_ifspec,             /* interface specification */
    binding_vector,      /* (string_tree.h) the set of binding handles */
    NULL,
    &status 
  );
  check_error(status, "Can't export to directory service\\n");

  rpc_binding_vector_free(              /* free set of binding handles */
    &binding_vector,
    status
  ); 
  check_error(status, "Can't free binding handles and vector\\n");

  rpc_server_listen(                        /* listen for remote calls */
    rpc_c_listen_max_calls_default, 
                           /* concurrent calls server executes (rpc.h) */
    &status
  );
  check_error(status, "rpc listen failed\\n");
}   
.ps 12
.vs 14
.oE
.P
.ne 13
\*LThe STRING_TREE.OUTPUT Example\*O
.oS
.ps 10
.vs 12
Original Tree:
    Root Node
       Left subtree
           Child of left subtree
       Right subtree
Pruned Tree:
    Root Node
        Right subtree
Pruned subtree:
    Left subtree
        Child of left subtree
.ps 12
.vs 14
.oE
.H 3 "Customized Handles"
.iX "customized handles"
.iX "IDL" "customized handles"
.iX "handle" "customized"
.iX "handle" "attribute"
.iX "types" "IDL"
.P
The \*Lhandle\*O attribute specifies that the type being declared
is a user-defined, nonprimitive handle type, and is to be used in
place of the predefined primitive handle type \*Lhandle_t\*O.
The term \*Ecustomized handle\*O is used to denote a nonprimitive handle.
.P
The following example declares a customized handle type 
\*Lfilehandle_t\*O, a structure containing the textual 
representations of a host and a pathname:
.oS
typedef [handle] struct {
     char host[256];
     char path[1024];
     } filehandle_t;
.oE
.P
If the handle parameter is the first parameter in the list,
then it is a customized handle that is used to determine the binding for the
call, and it must have the \*Lin\*O attribute or the \*Lin,out\*O attributes.
A handle parameter that 
is not the first parameter in the parameter list need not have the
\*Lin\*O or \*Lin,out\*O attributes.
.P
Note that a \*Lhandle_t\*O parameter that is the first parameter in the list
must not have the \*Ltransmit_as\*O attribute.
.P
.ne 6
To build an application that uses customized handles, you must write
custom binding and unbinding routines, and you must link those routines
with your application client code.  At runtime, each time the client
calls an operation that uses a customized handle, the client stub calls
the custom binding routine before it sends the remote procedure call
request, and the client stub calls the custom unbinding routine after
it receives a response.
.P
The following paragraphs specify C prototypes for customized binding
and unbinding routines; in these prototypes, \*VCUSTOM\*O is the
name of the customized handle type.
.P
The custom binding routine \*VCUSTOM\*O\*L_bind\*O generates a primitive 
binding handle from a customized handle and returns the primitive 
binding handle:
.iS
\*Lhandle_t\*O \*VCUSTOM\*O\*L_bind\*O (\*VCUSTOM c-handle\*L)\*O
.iE
.P
The custom unbinding routine \*VCUSTOM\*O\*L_unbind\*O takes two
inputs, a customized handle and the primitive 
binding handle that was generated from
it, and has no outputs:
.iS
\*Lvoid\*O \*VCUSTOM\*O\*L_unbind (
\*O\*V CUSTOM c-handle\*O\*L,
 handle_t \*O\*Vrpc-handle\*L)\*O
.iE
.P
A custom unbinding routine typically frees the primitive 
binding handle and any
unneeded resources associated with the customized handle, but it is not
required to do anything.
.P
Because the \*Lhandle\*O attribute can occur only in a 
type declaration, a customized handle must 
have a named type.  Because 
customized handle type names are used to construct 
custom binding and unbinding
routine names, these names cannot exceed 24 characters.
.P
A customized handle can be coded either in a 
parameter list as an explicit
handle or in an interface header as an implicit handle.
.nL
.ne 16
.H 3 "Context Handles"
.PP
.iX "handle" "context"
.iX "context handle"
.iX "context handle" "attribute"
.iX "context_handle attribute"
.iX "server" "state" 
.iX "saved server state"
.iX "opaque pointer"
.iX "pointers" "opaque"
.iX "address space association"
Manager code often maintains state information for a client. 
A handle to this state information is passed to the
client in an output parameter or as an operation result. 
The client passes the unchanged handle-to-the-state information as 
an input or input/output parameter of a subsequent manager
operation that the client
calls to manipulate that data structure.  This handle-to-the-state 
information is called a \*Econtext handle\*O.  A 
context handle is implemented as an untyped pointer or a pointer
to a structure by tag name.
.iX "pointers"
.PP
The manager causes the untyped pointer or the structure pointer
to point to the state information it will need the next time the
client asks the manager to manipulate the context.  For the
client, the context handle is an opaque pointer (\*Lidl_void_p_t\*O
or an opaque structure tag).
.iX "pointers"
The client receives or supplies the context handle by means
of the parameter list but does not perform any transformations on it.
.PP
The RPC runtime maintains the context handle, providing
.iX "runtime"
an association between the client and
the address space running the manager and the state information
within that address space.
.PP
If a manager supports multiple interfaces, and a
client obtains a context handle by performing an operation from one of
these interfaces, the client can then supply the context handle
to an operation from another of these interfaces.
.PP
A context handle can only be exchanged between the server process that
created it and the client process for which it was created.
No other client except the one that obtained the
context handle can use it without causing an application error. 
.H 4 "The context_handle Attribute"
.PP
.iX "context_handle attribute"
.iX "handle" "context"
Specify a context handle by one of the following methods:
.ML
.LI
Use the \*Lcontext_handle\*O attribute on a parameter of 
type \*Lvoid *\*O.
.LI
Use the \*Lcontext_handle\*O attribute on a type that is defined
as \*Lvoid *\*O.
.LI
Use the \*Lcontext_handle\*O attribute on a type that is defined as
a pointer to a structure by tag name.
.LE
.PP
.ne 4
For example, in the IDL file, you
can define a context handle within a type declaration as follows:
.oS
typedef [context_handle] void * my_context;\*O
.oE
.PP
or within a parameter declaration as follows:
.oS
[in, context_handle] void * my_context;\*O
.oE
.PP
You can also define a context handle within a type declaration
as a forward reference to a structure type by tag, as follows:
.oS
typedef [context_handle] struct opaque_struct * opaque_ch_t;\*O
.oE
.PP
Note that you do not need to define the structure type in the IDL file;
it is a forward reference to a structure whose definition can be
included into the server code, either from a private \*L.h\*O file
or from a server IDL file.  As a result, the structure type is opaque
to the client.  This method of defining a context handle provides
type checking and permits the server code to avoid extensive
casting when manipulating the context handle.
.PP
A structure type in a context handle type definition must be
referenced by tag name and not by type name.  So, for example, the
first of the following declarations is valid, while the second
is not:
.oS
typedef [context_handle] struct struct_tag * valid_ch_t; 
                                                  /* valid */

typedef [context_handle] struct_type * invalid_ch_t; 
                                                  /* error */
.oE
.PP
The following example illustrates context handles defined as untyped
pointers and as pointers to structures by tag name.
.oS
.ne 19
/* A context handle implemented as untyped pointer */
typedef [context_handle] void * void_ch_t;

/* A context handle implemented as a  */
/* pointer to a structure by tag name */
typedef [context_handle] struct opaque_struct * opaque_ch_t;

/* Operations using both types of context handles */
void ch_oper(
     [in] void_ch_t v1,
     [in,out] void_ch_t *v2,
     [out] void_ch_t *v3,
     [in] opaque_ch_t *o2,
     [out] opaque_ch_t *o3
);

void_ch_t void_ch_oper ([in] handle_t h);

opaque_ch_t opaque_ch_oper([in] handle_t h);
.oE
.P
It is possible to define a structure type in a context handle in the IDL
file; for example, the following structure definition
can either precede or follow the definition of \*Lvalid_ch_t\*O
in the example previously shown:  
.oS
typedef struct struct_tag {long l;} struct_type;\*O
.oE
.PP
This practice is not recommended, however,
since it violates the opaqueness of the context handle type.
.PP
The type name in a context handle declaration must be no longer than 23
characters.
.PP
The first operation on a context creates a context handle that the
server procedure passes to the client.  
The client then passes the unmodified handle back to the server in a
subsequent remote call.  The called procedure interprets the context
handle.  For example, to specify a procedure that a client can use to
obtain a context handle, you can define the following:
.oS
typedef [context_handle] void * my_context;
void op1(
   [in]handle_t h,
   [out] my_context * this_object);
.oE
.PP
.ne 4
To specify a procedure that a client can call to make use of a previously
obtained context handle, you can define the following:
.oS
void op2([in] my_context this_object);\*O
.oE
.PP
To close a context, and to clean the context on the client side, you
can define the following:
.oS
[in, out, context_handle] void * my_context;\*O
.oE
.PP
The resources associated with a context handle are reclaimed when, and
only when, the manager changes the value of the \*Lin,out\*O context
handle parameter from non-NULL to NULL.
.H 4 "The Context Rundown Procedure"
.PP
.iX "context rundown procedure"
.iX "-: context rundown procedure" "rundown"
.iX "routines" "context rundown"
Some uses of context handles may require you to write a 
context rundown procedure in the application code
for the server.  If communications between the client and server are
.iX "communication failure" "context rundown"
.iX "context handle" "resource recovery"
broken while the server is maintaining context for the client, RPC
invokes the context rundown procedure on the server to recover the
resources represented by the context handle.  If you declare a context
handle as a named type, you must supply a rundown procedure for
that type.
.PP
When a context requires a context rundown procedure, you must define a
named type that has the \*Lcontext_handle\*O attribute. 
For each different
context handle type, you must provide a context rundown procedure as
part of the manager code.
.PP
The format for the rundown procedure name is as follows:
.iS
\*Vcontext_type_name\*O\*L_rundown\*O
.iE
.PP
A rundown procedure takes one parameter, the handle of the context to be
run down, and delivers no result.  For example, if you declare the following:
.oS
typedef [context_handle] void * my_context;\*O
.oE
.P
.ne 3
then the rundown procedure is as follows:
.oS
void my_context_rundown (my_context this_object);\*O
.oE
.PP
Server application code that uses a certain context handle may be
executing in one or more server threads at the time that RPC detects that
communications between the server and the client that is using that context
have broken.  The context rundown routine will not be invoked until a return
of control to the server stub has happened in each of the threads that were
using the context handle.
.PP
If application code in any of these threads destroys the context before
returning control to the server stub from which it was called, your context
rundown procedure will not be executed.
.H 4 "Creating New Context"
.iX "context handle" "creating new"
.iX "creating" "context"
When a client makes its first request to the manager to manipulate 
context, the manager creates context information and
returns this information to the client through a 
parameter of the type \*Lcontext_handle\*O.  This parameter 
must be an output parameter or an
input/output parameter whose value is NULL when the call is made.
A context handle can also be a function result.
.H 4 "Reclaiming Client Memory Resources for the Context Handle"
.PP
In the event that a communications error causes the context handle 
to be unusable, the resources that maintain the context handle must
be reclaimed.  Use the \*Lrpc_ss_destroy_client_context(\|)\*O routine
in the client application to reclaim the client-side resources and
to set the context handle value to NULL.
.PP
The syntax of the routine is as follows:
.iS
\*Lvoid rpc_ss_destroy_client_context(
     void *\*Vp_unusable_context_handle);\*O
.iE
.H 4 "Relationship of Context Handles and Binding"
.iX "context handle" "and binding"
.iX "binding" "context handle"
For the client, the context handle specifies 
the state within a server and also contains binding
information.  If an operation has an input context handle or 
input/output context handle that is not NULL, it is not necessary
to supply any
other binding information.  A context handle that has only the \*Lin\*O
attribute cannot be NULL. If an operation has 
\*Lin,out\*O context handle parameters
but no \*Lin\*O context handle parameters, at least one of the
\*Lin,out\*O context handle parameters cannot be NULL.
However, if the only context handle
parameters in an operation are output, they carry
no binding information.  In this case, you must use another method to
bind the client to a server.
.PP
If you specify multiple context handles in an operation, all active
context handles must map to the same remote address space on the same
server or the call fails.  (A context handle is active while it
represents context information that the server maintains for the
client.  It is inactive if no context has yet been created, or if the
context is no longer in use.)
.H 4 "Rules for Using Context Handles"
.iX "context handle" "usage rules"
.PP
The following rules apply to using context handles:
.ML 
.LI
A context handle can be a parameter or a function result. 
You cannot use context handles
as an array element, as a structure or union member, or as 
the element type of a pipe.
.LI                         
A context handle cannot have the \*Ltransmit_as\*O or \*Lptr\*O 
attributes.
.LI
An input-only context handle cannot be NULL.
.LI
A context handle cannot be pointed to, except by a top-level reference
pointer.
.LE
.H 4 "Examples Using Context Handles"
.PP
The following examples show a sample IDL file that uses
context handles and a sample context rundown procedure
file.
.P
\*LExample of an IDL File That Uses a Context Handle\*O
.oS
/*
 * Filename: context_handle.idl
 */
[uuid(f38f5080-2d27-11c9-a96d-08002b0ecef1),
 pointer_default(ref), version (1.0)] 
interface files
{
/* File context handle type */
typedef [context_handle] void * file_handle_t;  
/* File specification type */
typedef [string] char * filespec_t;             
/* File read buffer type */
typedef [string] char buf_t[*];                 

 /*
  * The file_open call requires that the client has located a 
  * file server interface files and that an RPC handle that is 
  * bound to that server be passed as the binding parameter h.
  *
  * Operation to OPEN a file; returns context handle for that 
  * file.
  */
file_handle_t file_open         
(                               
 /* RPC handle bound to file server */
    [in] handle_t h,            
 /* File specification of file to open */
    [in] filespec_t fs          
);

.ne 20
 /*
  * The file_read call is able to use the context handle 
  * obtained from the file_open as the binding parameter, 
  * thus an RPC handle is not necessary.
  *
  * Operation to read from an opened file; returns true if
  * not end-of-file 
  */
boolean file_read               
(
 /* Context handle of opened file */
    [in] file_handle_t fh,      
 /* Maximum number of characters to read */
    [in] long buf_size,         
 /* Actual number of characters of data read */
    [out] long *data_size,      
 /* Buffer for characters read */
    [out, size_is(buf_size), length_is(*data_size)] \\
      buf_t buffer
);
 /* Operation to close an opened file */
void file_close                 
(                               
 /* Valid file context handle goes [in]. On successful close, 
  * null is returned.
  */
    [in,out] file_handle_t *fh  
);
}
.oE
.P
.ne 32
\*LExample of a Context Rundown Procedure\*O
.oS
/*
 * fh_rundown.c:  A context rundown procedure.
 */

#include <stdio.h>
#include "context_handle.h"   /* IDL-generated header file */

void file_handle_t_rundown
(
    file_handle_t file_handle   /* Active context handle */
                                 * (open file handle)    */
)

{
    /*
     * This procedure is called by the RPC runtime on the 
     * SERVER side when communication is broken between the 
     * client and server.  This gives the server the 
     * opportunity to reclaim resources identified by the 
     * passed context handle.  In this case, the passed 
     * context handle identifies a file, and simply closing 
     * the file cleans up the state maintained by the context 
     * handle, that is "runs down" the context handle.  Note 
     * that the file_close manager operation is not used here; 
     * perhaps it could be, but it is more efficient to use 
     * the underlying file system call to do the close.
     *
     * File handle is void*, it must be cast to FILE*
     */
    fclose((FILE *)file_handle);
}
.oE
.H 2 "IDL Support for C++"
.P
.iX "IDL support for C++"
.iX "C++ support in IDL"
Most of the IDL features apply to both C and C++ applications.  
However,
just as C++ is an extension to C, this section describes additional IDL
features required to use IDL effectively with C++.
.P
When the IDL compiler compiles an interface definition, it typically
generates a header file and one or more intermediate stub files in C
or C++, and then it invokes the appropriate compiler to generate
object stub files.  The IDL Compiler generates C language intermediate
...\" COMMENTED OUT FOR AIX:
...\" .iX "-lang cxx option"
.iX "generating C++ files"
.iX "C++" "generating from IDL"
stub files by default, but you can use the \*L-lang cxx\*O option to
cause it to generate C++ files instead.
.P
This section describes the following topics:
.ML
.LI
The \*Lidl\*O-generated class hierarchy
.P
This is important for a basic understanding of how to integrate 
the interface into an object-oriented application.
.LI
Interface inheritance
.P
One interface can be derived from another, just as classes are derived 
from other classes.
.LI
Static operations
.P
Static operations specify member functions that are called 
independently from an object.  All other operations specify 
nonstatic member functions which are only invoked with respect to 
an existing object.
.LI
Reference parameters
.P
Reference parameters are passed by reference instead of being passed by value. 
.LI
\*Lidl\*O-generated member functions
.P
Several member functions are generated by IDL and made part of the interface class.  
These functions perform useful operations for all interfaces.
.LE
.H 3 "The idl-generated Class Hierarchy"
.P
.iX "idl-generated class hierarchy"
For C++ applications, the interface definition specifies a public
interface class.  This means that IDL data types specify public data
members of the interface class, and IDL operations specify member
functions.  The IDL compiler generates this\*V interface class\*O
within C++ class hierarchies for both the client and server.  The RPC
network mechanisms are encapsulated in a class above the interface
class.  Clients use (and servers implement) the objects of
classes below the interface class.

.H 4 "The rpc_object_reference Base Class"
.P
.iX "\*Lrpc_object_reference\*O base class"
.iX "base class \*Lrpc_object_reference\*O"
.iX "RPC encapsulation"
.iX "encapsulating RPCs"
Because C++ makes it easy to hide information, the IDL compiler
generates an \*Lrpc_object_reference\*O \*Vbase class\*O for
identifying, distributing, and tracking objects.  All interface
classes inherit the \*Lrpc_object_reference\*O class, 
which encapsulates the following information:
.ML
.LI
Object binding information, including server binding information 
and an object UUID representing the object on the particular server
.LI
Transport protocol information for the server
.LI
A name identifying an optional location in the namespace for
the object's binding information
.LI
A location flag indicating whether the object is on the
local system or a remote system
.LI
A reference count to keep track of how many clients
currently access the object
.LE
.H 4 "The Interface Class"
.P
.iX "interface class"
For each interface, the IDL compiler generates and places in the
header file the interface class derived from the
\*Lrpc_object_reference\*O class.  The class name generated is the
interface name specified in the interface definition.  For example,
the compiler generates the following class:
.iS
\*Lclass \*O \*Vinterface_name\*O\*L : public  virtual   rpc_object_reference\*O
.iE
.P
This is an abstract class that contains public functions for all the
operations specified in the IDL interface.  The member functions that
are not static object creator functions are defined as pure virtual
functions.  In C++, an abstract class contains at least one pure
virtual function, which means that the implementation is postponed
until a later, derived class.  Therefore, object instances cannot be
created for abstract classes, and thus the interface class is not
implemented but is only a declaration.  Other classes must be derived
from the interface class so that objects can be created for clients
and servers.
.P
.iX "constructor"
.iX "destructor"
No constructor operations are allowed in the interface definition, and
the IDL compiler does not generate one because no objects are created
for the interface class.  No destructor operations are allowed in the
interface definition, but the compiler generates one automatically for
the interface class.

.H 4 "The Client's Proxy Class"
.P
.iX "client proxy class"
.iX "proxy class for client"
.iX "object reference"
The IDL compiler places in the header file a\*V proxy class\*O derived
from the interface class.  An instance of a proxy class is also known
as an \*Vobject reference\*O, which clients use to access a remote
object.  This class provides proxy (or surrogate) objects on the
client whose member functions (or methods) transparently perform the
RPCs that invoke the actual remote object's member functions on the
server.  The proxy class name is generated from the interface name and
the word \*LProxy\*O, as follows:
.iS
\*Lclass\*O \*Vinterface_name\*O\*LProxy : public\*O \*Vinterface_name\*O
.iE
.P
Implementations of the proxy class's member functions are automatically
generated in the client stub and represent the client's implementation
of the interface's operations.

.H 4 "The Server's Manager Class"
.P
.iX "server manager class"
.iX "manager class for server"
A \*Vmanager class\*O is required for servers to implement the interface.
The class is generated by the IDL compiler and derived from the 
interface class as follows:
.oS
class  \*Vinterface_name\*O\*L_Mgr\*O : public \*V interface_name \*O {
public:
    .
    .
    .
}
.oE
.P
The class is placed in a header file whose name is based on the 
IDL file and an \*L_mgr\*O suffix. 
When generated, the manager class contains empty
functions of all the nonstatic member functions of the interface class.  
The member function implementations and other
implementation details of this class are called \*Vmanager code\*O.

.H 3 "The Interface Inheritance Operator"
.P
.iX "interface inheritance"
.iX "inheritance of interfaces"
An interface definition can inherit properties of a previously defined
interface, just as a C++ class can inherit properties of previously
defined classes.  You can modify an interface
definition to inherit an interface by using the inheritance operator
(\*L:\*O) in the interface header, as follows:
.iS
[\*Vinterface_attribute, ...\*O\*L] interface\*O \*Vinterface_name\*O \*V[ : inherited_interface ]\*O
.iE
.P
This \*Lidl\*O-genrated header file contains the inherited interface's data 
types and interface class.  The interface definition must also declare the
information in the inherited interface's header file by using an
\*Limport\*O declaration in the body of the interface.  The following
.iX "derived interface"
example shows how the \*Lderived\*O interface inherits another
interface and imports that interface's definition file. The inherited
interface definition file is named\*L inherit.idl\*O, and the
interface it contains is named \*Linherit\*O.
.oS
interface derived : inherit
{
	import "inherit.idl";
	.
	.
	.
}
.oE
.P
A interface may inherit only one interface; 
that is, multiple interface inheritance is not allowed.

.H 3 "The static Keyword for Operations"
.P
.iX "static keyword"
.iX "IDL" "static keyword"
In C++ applications, the interface definition operations specify the
member functions of the interface class.  The majority of the member
functions are invoked by an existing object, but some operations are
intended to work regardless of whether an object invokes them or not.
Static member functions are invoked independently from any object and
are good for such things as object creator functions and for obtaining
a class's static data; that is, data that is class-wide and
independent from a specific object.
.P
Static member functions may be specified in an interface definition by
using the \*Lstatic\*O keyword in front of the operation, 
in one of the following ways:
.iS
\*Lstatic \*O \*Vreturn_type operation_identifier\*O\*L(...);\*O

\*L[\*O\*Voperation_attribute\*O, ...\*L] static\*O  \*Vreturn_type operation_identifier\*O\*L(...);\*O
.iE
.P
Instead of using the \*Lstatic\*O keyword in the interface definition,
you can use the \*Lcxx_static\*O attribute in an ACF.
.P
Since non-static member functions are invoked by an object for which
the application must already have a binding, nonstatic operations
cannot have a binding handle parameter.  If you want to use explicit
binding for an interface, only static operations can have a binding
handle as the first parameter.

.H 3 "The C++ Reference Operator (&) on Parameters"
.P
.iX "C++ reference operator, &"
.iX "reference operator, &"
C++ passes arguments by value; however, to override this and cause a
member function argument to be passed by reference, apply the
reference operator (\*L&\*O) to the parameter in the interface definition.
Specify a reference parameter as follows:
.iS
[\*Vparameter_attribute,...\*O]  \*Vparameter_type \*O &\*Vparameter\*O
.iE
.P
.iX "ref attribute"
Using the reference operator on a parameter is the same as applying
the reference pointer attribute (\*L[ref]\*O) to a pointer parameter.

.H 3 "Functions Generated by IDL"
.P
.iX "idl-generated functions for C++"
.iX "functions generated by IDL"
The IDL compiler generates some additional member functions for an
interface class.  For clients, these functions include overloaded
static member functions to bind to remote named objects in various
ways and a member function to set security information.  For servers,
additional member functions exist to advertise named objects and get
the binding handle on which a member function was called from within
the member function implementation.
.P
.iX "overloaded functions"
.iX "object reference"
Four overloaded functions for binding clients to known objects are
named\*L bind(\|)\*O.  The functions otherwise differ by the type of
parameter passed in.  Three of these functions are intended for use
with named objects and one is used to swap between interfaces when an
object supports more than one interface.  
Each \*Lbind(\|)\*O function obtains an \*Vobject reference\*O
(instance of a proxy class) by returning a pointer to the interface class.
These functions are described in the following sections.

.H 4 "The bind(\|) Function for Binding by an Object's Name"
.P
.iX "binding by object name"
.iX "\*Lbind(\|)\*O by object name"
A client can bind to a named object (an object whose name is
advertised in a name service) by calling the \*Lidl\*O-generated \*Lbind(
)\*O static member function with the name service name as an argument.
The function's prototype is as follows:
.iS
\*Vinterface_class\*O * \*Vinterface_class\*L::bind( unsigned_char_t  *)\*O
.iE
.P
This function takes a pointer argument of type \*Lunsigned_char_t\*O
that points to a name service name.  The function returns a pointer to
the interface class.  For example:
.oS
char *CDS_name = "/.:/object_name";
IF_class * object = IF_class::bind( (unsigned_char_t *) CDS_name);
.oE
.P
If the entry contains more than one binding, one is returned at
random. The function obtains a full binding (the binding information
includes a server's endpoint.)
.P
Before a client uses this function, a persistent object on a server
typically places its name and binding information in the name service
by using the \*Lidl\*O-generated \*Lregister_named_object(\|)\*O member
function.

.H 4 "The bind(\|) Function for Binding by an Object's UUID"
.P
.iX "binding by object UUID"
.iX "\*Lbind(\|)\*O by object UUID"
A client can bind to a named object by using the object's UUID as an
argument to the \*Lidl\*O-generated \*L bind(\|)\*O static member
function.  This function's prototype is as follows:
.iS
\*Vinterface_class\*O \*L* \*V\*Ointerface_class\*O\*L::bind( uuid_t &)\*O
.iE
.P
This function takes an argument of type\*L uuid_t\*O that is the UUID
of a named object.  The function returns a pointer to the interface
class.  For example:
.oS
uuid_t objectUUID;
.
.
.
interface_class * object = interface_class::bind(objectUUID);
.oE
.P
.iX "RPC_DEFAULT_ENTRY"
The search in the namespace for an entry that contains the matching
UUID begins with the default entry named in the
\*LRPC_DEFAULT_ENTRY\*O environment variable. The binding obtained is
fully bound.

.H 4 "The bind(\|) Function for Binding by Binding Handle"
.P
.iX "binding by object binding handle"
.iX "\*Lbind(\|)\*O by object binding handle"
A client can bind to a known object directly by using a binding handle
as an argument to the \*Lidl\*O-generated \*Lbind(\|)\*O static member
function.  This function's prototype is as follows:
.iS
\*Vinterface_class\*O * \*Vinterface_class\*O\*L::bind( rpc_binding_handle_t)\*O
.iE
.P
This function takes an argument of type \*Lrpc_binding_handle_t\*O
that is a binding handle to an object.  The function returns a pointer
to the interface class.  For example:
.oS
rpc_binding_handle_t bindingHandle;
.
.
.
interface_class * object = interface_class::bind(bindingHandle);
.oE
.P
This function does not use the name service because the client obtains
the binding information and binding handle prior to the call.  The
binding handle can be either partially or fully bound. If the binding
handle is partially bound, it becomes fully bound when the object
calls a member function.

.H 4 "The bind(\|) Function for Binding by Object Reference"
.P
.iX "binding by object reference"
.iX "\*Lbind(\|)\*O by object reference"
Depending on the application, objects can have the behavior of more
than one interface class.  However, your code can access only one
interface's member functions at a time.  A client uses the
\*Lidl\*O-generated \*Lbind(\|)\*O static member function with an existing
object reference as an argument to bind to a different interface.
This function's prototype is as follows:
.iS
\*Vdifferent_interface_class\*O * \*Vdifferent_interface_class\*O\*L::bind( rpc_object_reference *)\*O
.iE
.P
This function takes a pointer argument of type
\*Lrpc_object_reference\*O that is an existing object reference to an
interface class.  The function returns a pointer to a different
interface class that the object also supports.  The original object is
obtained through a previous \*Lbind()\*O call, an object creator
function, or an output parameter of a member function. For example:
.oS
rpc_binding_handle_t bindingHandle;
.
.
.
interface_class * object = interface_class::bind(bindingHandle);
.
.
.
diff_if_class * new_object = diff_if_class::bind(object);
.oE
.P
.H 4 "The secure(\|) Function for Setting Object Security"
.P
.iX "\*Lsecure(\|)\*O function"
.iX "security for objects"
.iX "object security"
Objects use the \*Lidl\*O-generated \*Lsecure(\|)\*O member function to set
their authorization and authentication information from the client.
This sets the information for all the binding handles encapsulated in
the client proxy object.  The \*Lsecure(\|)\*O function is a public 
member function of the \*Lrpc_object_reference\*O class. 
This function's prototype is as follows:
.oS
\*Lvoid\*O \*V interface_class\*O\*L::secure(\*O
   \*V[\*O\*Lunsigned_char_t\*O *	\*Vserver_principal_name	= \*O\*L0\*O,\*V]\*O
   \*V[\*O\*Lunsigned32\*O		\*Vprotection_level\*O		= \*Lrpc_c_protect_level_default\*O,\*V]\*O
   \*V[\*O\*Lunsigned32\*O		\*Vauthentication_protocol	= \*O\*Lrpc_c_authn_default\*O,\*V]\*O
   \*V[\*O\*Lrpc_auth_identity_handle_t\*O \*Vauthorization_identity	= \*O\*LNULL\*O,\*V]\*O
   \*V[\*O\*Lunsigned32\*O		\*Vauthorization_policy		= \*Lrpc_c_authz_name\*V]\*O
)
.oE
.P
The following code shows an example of how to use the \*Lsecure(\|)\*O 
member function: 
.oS
Matrix         *m;

cout << "creating a remote matrix" << endl;
m = Matrix::createMatrix(1, 2, 3, 4);

cout << "calling set() operation without authorization" << endl;
m->set(0,0,99);
// Without authorization, operation should have not changed anything.
assert(m->get(0,0) == 1);

cout << "setting security privileges on object" << endl;
m->secure(
	(unsigned_char_t *) "refmon_test",	// server principal name
	rpc_c_protect_level_pkt_integ,	// protection level
	rpc_c_authn_dce_secret,		// authentication protocol
	NULL,				// inherited login context
	rpc_c_authz_name		// authorization policy
);

// since we now have set security flags, the set() operation should work
m->set(0,0,99);
assert(m->get(0,0) == 99);
.oE
.P
The example shows that unauthorized use of a matrix's member function
will not change values (\*Lm->get(0,0,99);\*O).
However, after setting the appropriate authorization and authentication 
information with \*Lsecure(\|)\*O, the member function will work as expected.
All parameters to the \*Lsecure(\|)\*O function are optional, 
but it is recommended that you specify values rather than depend on the 
default values.

.H 4 "The SetRebind( ) Function"
.P
.iX "\*LSetRebind(\|)\*O function"
.iX "objects" "automatic rebinding"
A client can automatically rebind to an object if the client first sets a 
rebind policy by using the \*LSetRebind(\|)\*O function.  
This allows a degree of fault tolerance in an application.  
For example, if a server goes down and is restarted, 
the client can re-establish communications with the new server.  
In another example, if a server provides access over multiple 
protocols or addresses and one of those links fails,
the client can choose another link automatically. 
Finally, if multiple servers support the same object and one 
server exits, clients can still access the object via another server.
.P
The format of the function is as follows:
.oS
void \*V interface_class\*O::\*LSetRebind(
	\*LDCERebindPolicy\*O	\*Vpolicy\*O,
	\*V[\*O \*Lunsigned32\*O *	\*Vn\*O = 0 \*V]\*O
)
.oE
.P
The second argument is optional and only used when the 
rebind policy is \*Lattempt_rebind_n\*O.  
The valid policies include the following:
.P
.VL
.LI "\*Lattempt_rebind_n\*O"
.br
.iX "\*Lattempt_rebind_n\*O"
If a communication fails, try to communicate with the object
by selecting another binding until successful or until \*Vn\*O 
attempts have been tried.
.LI "\*Lwait_on_rebind\*O"
.br
.iX "\*Lwait_on_rebind\*O"
If a communication fails, try to communicate with the object
by selecting another binding until successful or until the calling 
thread is canceled.
.LI "\*Lattempt_rebind\*O"
.br
.iX "\*Lattempt_rebind\*O"
If a communication fails, try to communicate with the object
by selecting another binding, if possible.  
If all handles have been tried, return an error.
This is the default policy.
.LI "\*Lnever_rebind\*O"
.iX "\*Lnever_rebind\*O"
If a communication fails, return an error.  
.LE
.P

.H 4 "The register_named_object(\|) Function"
.P
.iX "\*Lregister_named_object(\|)\*O"
.iX "objects" "registering"
Persistent objects can name and register themselves from the server by 
using the \*Lidl\*O-generated \*Lregister_named_object(\|)\*O 
member function.   This function performs the following tasks:
.ML
.LI
Creates the name service entry (if it doesn't already exist) 
and adds the server's binding information so clients can find 
the server's host
.LI
Replaces or adds the object's binding information in this host's 
endpoint map so clients can find this server
.LE
.P
This function's prototype is as follows:
.oS
void \*V interface_class\*O::\*Lregister_named_object(
	\*Lunsigned_char_t\*O *	\*Vname_service_name
	\*V[\*O\*L, boolean32\*O	\*Vreplace_endpoint	=\*L \*OTRUE\*O \*V]\*O
)
.oE
.P
The function takes a pointer argument of type \*Lunsigned_char_t\*O,
representing the name to use for the name service entry.  The function
has an optional second argument of type\*L boolean32\*O to indicate
whether to replace or add the object's binding information to the
host's endpoint map.  If the second argument is not used (or is set to
\*LTRUE\*O) and the object's binding information already exists, this
function replaces the information.  If the second argument is set to
\*LFALSE\*O, the object's binding information is added to the endpoint
map (not replaced).  You should add the binding information rather
than replace it in circumstances where a single host has more than one
server that offers the same interface.  The function does not return a
value.

.H 4 "The get_binding_handle(\|) Function"
.P
.iX "\*Lget_binding_handle(\|)\*O function "
Server manager code uses the \*Lidl\*O-generated 
\*Lget_binding_handle(\|)\*O function to obtain the binding handle 
used to invoke the call.  The function's prototype is as follows:
.iS
\*Lrpc_binding_handle_t   get_binding_handle(\|);\*O
.iE
.P
Member functions (that are not static) cannot have an explicit binding
handle argument since the handle is encapsulated in the
\*Lrpc_object_reference\*O base class.  A member function
implementation uses this function to obtain the binding handle to
verify security information, among other things.

.H 2 "Associating a Data Type with a Transmitted Type"
.iX "transmit_as attribute"
.iX "-]" "IDL" "attributes"
.P
The \*Ltransmit_as\*O attribute associates a transmitted type
that stubs pass over the network with a presented type that
clients and servers manipulate.  The specified transmitted type 
must be a named type defined previously in another type declaration.
.P
There are two primary uses for this attribute:
.ML
.LI
To
.iX "types"
.iX "complex types"
pass complex data types for which the IDL compiler cannot generate
marshalling and unmarshalling code.
.LI
To pass data more efficiently.  An application can
provide routines to convert a data type between a sparse representation
(presented to the client and server programs) and a compact one (transmitted
over the network).
.LE
.P
To build an application that uses presented and transmitted types,
you must write routines to perform conversions between the types and
to manage storage for the types, and you must link those routines
with your application code.  At runtime, the client and server stubs
call these routines before sending and after receiving data of these
types.
.P
The following paragraphs specify C prototypes for generic binding
and unbinding routines; in these prototypes, \*VPRES\*O is the
name of the presented type and \*VTRANS\*O is the name of the transmitted
type.
.P
The \*VPRES\*O\*L_to_xmit(\|)\*O routine allocates storage for the
transmitted type and converts from the presented type to the transmitted
type:
.iS
\*Lvoid \*VPRES\*L_to_xmit (\*VPRES \*L*\*Vpresented\*L,\*V TRANS \*L**\*Vtransmitted\*L)\*O
.iE
.P
The \*VPRES\*O\*L_from_xmit(\|)\*O routine converts from the transmitted
type to the presented type and allocates any storage referenced by
pointers in the presented type:
.iS
\*Lvoid \*VPRES\*L_from_xmit\*O (\*VTRANS \*L*\*Vtransmitted\*L,\*V PRES \*L*\*Vpresented\*L)\*O
.iE
.P
.ne 6
The \*VPRES\*O\*L_free_inst(\|)\*O routine frees any storage referenced 
by pointers in the presented type by \*VPRES\*O\*L_from_xmit(\|)\*O:
.iS
\*Lvoid \*VPRES\*L_free_inst\*O (\*VPRES \*L*\*Vpresented\*L)\*O
.iE
.P
Suppose that the \*Ltransmit_as\*O attribute appears either on the type of
a parameter or on a component of a parameter and that the parameter
has the \*Lout\*O or \*Lin,out\*O attribute.  Then, the
\*VPRES\*L_free_inst(\|)\*O
routine will be called automatically for the data item that
has the \*Ltransmit_as\*O attribute.
.P
Suppose that the \*Ltransmit_as\*O attribute appears
on the type of a parameter and that the parameter has only the \*Lin\*O
attribute.  Then, the \*VPRES\*L_free_inst(\|)\*O routine will be called
automatically.
.P
Finally, suppose that the \*Ltransmit_as\*O
attribute appears on a component of a parameter and that the
parameter has only the \*Lin\*O attribute.  Then, the \*VPRES\*L_free_inst(\|)\*O
routine will not be called automatically for the component; the
manager application code must release any resources that the
component uses, possibly by explicitly calling the \*VPRES\*L_free_inst(\|)\*O
routine.
.P
The \*VPRES\*O\*L_free_xmit(\|)\*O routine frees any storage that
has been allocated for the transmitted type by \*VPRES\*O\*L_to_xmit(\|)\*O:
.iS
\*Lvoid \*VPRES\*L_free_xmit\*O (\*VTRANS \*L*\*Vtransmitted\*L)\*O
.iE
.P
A type with the \*Ltransmit_as\*O attribute cannot have other type
attributes, specifically the following:
.ML
.LI
A pipe type.
.LI
A pipe element type.
.LI
A type with the \*Lcontext_handle\*O attribute.
.LI
A type of which any instance has the \*Lcontext_handle\*O attribute.
.LI
A type that includes the \*Lhandle\*O attribute in its definition
cannot be used, directly or indirectly, in the definition of a type
with the \*Ltransmit_as\*O attribute.  Nor can a type that 
includes the \*Ltransmit_as\*O attribute in its definition be
used, directly or indirectly, in the definition of a type with the
\*Lhandle\*O attribute.
.LI
A conformant array type.
.LI
A varying array type.
.LI
A structure type containing a conformant array.
.LI
An array type of which any instance is varying.
.LI
A type with the \*Lrepresent_as\*O attribute.
.LE
.P
The type name in a declaration for a \*Ltransmit_as\*O attribute
is restricted to 21 characters.
.P
A transmitted type specified by the \*Ltransmit_as\*O attribute
must be either a base type, a predefined type, or a named type defined
via \*Ltypedef\*O.  A transmitted type cannot be a conformant array
type or a conformant structure type if any instance of that type is
an \*Lin\*O parameter or an \*Lin, out\*O parameter.
.P
The following is an example of \*Ltransmit_as\*O.
Assuming the following declarations:
.P
.oS
typedef
   struct tree_node_t {
      data_t data;
      struct tree_node_t * left;
      struct tree_node_t * right;
   } tree_node_t;

typedef
   [transmit_as(tree_xmit_t)] tree_node_t *tree_t;
.oE
.P
The application code must include routines that
match the prototypes:
.P
.oS
void tree_t_to_xmit ( tree_t *, (tree_xmit_t **) );
void tree_t_from_xmit ( (tree_xmit_t *), (tree_t *) );
void tree_t_free_inst ( tree_t *);
void tree_t_free_xmit ( (tree_xmit_t *) );
.oE
.nL
.ne 20
.H 2 "IDL Grammar Synopsis"
.P
This section summarizes IDL syntax,
in extended Backus-Naur Format (BNF) notation.
.iX "IDL" "grammar synopsis"
.zA "def,13428,R1.2.2,removed align attribute"
.oS
.ps 10
.vs 12
<interface> ::= <interface_header> "{" <interface_body> "}"

<interface_header> ::=
    "[" <interface_attributes> "]" "interface" <identifier> [ ":" <identifier> ]

<interface_attributes> ::=
 <interface_attribute> [ "," <interface_attribute> ] ...

<interface_attribute> ::= "uuid" "(" <uuid_rep> ")"
 | "version" "(" <major> [ "." <minor> ] ")"
 | "endpoint" "(" <endpoint_spec> [ "," <endpoint_spec> ] ... ")"
 | "pointer_default" "(" <pointer_attribute> ")"
 | "local"
 | "exceptions" "(" <excep_name> ["," <excep_name>] ... ")"

<excep_name> ::= <Identifier>

<major> ::= <integer>

<minor> ::= <integer>

<endpoint_spec> ::=
 """ <family_string> ":" "[" <endpoint_string> "]" """

<family_string> ::= <identifier>

<endpoint_string> ::= <identifier>

<interface_body> ::= [ <import> ] ... [ <export> ] ...

<export> ::= <const_declaration> ";"
 | <type_declaration> ";"
 | <op_declaration> ";"

<import> ::= import <import_files> ";"

<import_files> ::= <filename> [ "," <filename> ] ... ";"

<filename> ::= """ <character> ... """

<const_declaration> ::=
 "const" <const_type_spec> <identifier> "=" <const_exp>

<const_type_spec> ::=
 <integer_type> | "char" | "char" "*" | "boolean" | "void" "*"

<const_exp> ::=
 <integer_const_exp> | <character_const> | <string_const> 
 | <identifier> | "TRUE" | "FALSE" | "NULL"

<integer_const_exp> ::= <conditional_exp>

<conditional_exp> ::= <logical_or_exp> 
 | <logical_or_exp> "?" <integer_const_exp> ":" <conditional_exp>

<logical_or_exp> ::= <logical_and_exp> 
 | <logical_or_exp> "||" <logical_and_exp> 

<logical_and_exp> ::= <inclusive_or_exp>
 | <logical_and_exp> "&&" <inclusive_or_exp>

<inclusive_or_exp> ::= <exclusive_or_exp>
 | <inclusive_or_exp> "|" <exclusive_or_exp>

<exclusive_or_exp> ::= <and_exp> 
 | <and_exp> "^" <and_exp> 

<and_exp> ::= <equality_exp> 
 | <and_exp> "&" <equality_exp>

<equality_exp> ::= <relational_exp>
 | <equality_exp> "==" <relational_exp>
 | <equality_exp> "!=" <relational_exp>

<relational_exp> ::= <shift_exp>
 | <relational_exp> "<" <shift_exp>
 | <relational_exp> ">" <shift_exp>
 | <relational_exp> "<=" <shift_exp>
 | <relational_exp> ">=" <shift_exp>

<shift_exp> ::= <additive_exp>
 | <shift_exp> "<<" <additive_exp>
 | <shift_exp> ">>" <additive_exp>

<additive_exp> ::= <multiplicative_exp>
 | <additive_exp> "+" <multiplicative_exp>
 | <additive_exp> "-" <multiplicative_exp>

<multiplicative_exp> ::= <unary_exp>
 | <multiplicative_exp> "*" <unary_exp>
 | <multiplicative_exp> "/" <unary_exp>
 | <multiplicative_exp> "%" <unary_exp>

.ne 5
<unary_exp> ::= <primary_exp>
 | "+" <primary_exp>
 | "-" <primary_exp>
 | "~" <primary_exp>
 | "!" <primary_exp>

<primary_exp> ::= <integer_literal> 
 | <identifier>

<character_const> ::= "'" <character> "'"

<string_const> ::= """ [ <character> ] ... """

<type_declaration> ::=
 "typedef" [ <type_attributes> ] <type_spec> <declarators>

<type_spec> ::= <simple_type_spec> 
 | <constructed_type_spec>

<simple_type_spec> ::= <base_type_spec>
 | <predefined_type_spec>
 | <identifier>

<declarators> ::= <declarator> [ "," <declarator> ] ...

<declarator> ::= <simple_declarator>
 | <complex_declarator>

<simple_declarator> ::= <identifier>

<complex_declarator> ::= <array_declarator>
 | <function_ptr_declarator>
 | <ptr_declarator>
 | <ref_declarator>

<ref_declarator> ::= "&" <identifier>

<tagged_declarator> ::= <tagged_struct_declarator>
 | <tagged_union_declarator>

<base_type_spec> ::= <integer_type>
 | <floating_type>
 | <char_type>
 | <boolean_type>
 | <byte_type>
 | <void_type>
 | <handle_type>

<floating_type> ::= "float" | "double"

<integer_type> ::= <signed_int> | <unsigned_int>

<signed_int> ::= <int_size> [ "int" ]

.ne 2
<unsigned_int> ::= <int_size> "unsigned" [ "int" ]
 | "unsigned" <int_size> [ "int" ]

<int_size> ::= "hyper" | "long" | "short" | "small"

<char_type> ::= [ "unsigned" ] "char"

<boolean_type> ::= "boolean"

<byte_type> ::= "byte"

<void_type> ::= "void"

<handle_type> ::= "handle_t"

<constructed_type_spec> ::= <struct_type>
 | <union_type>
 | <tagged_declarator>
 | <enumeration_type>
 | <pipe_type>

<tagged_struct_declarator> ::= "struct" <tag>
 | <tagged_struct>

<struct_type> ::= "struct" "{" <member_list> "}"

<tagged_struct> ::= "struct" <tag> "{" <member_list> "}"

<tag> ::= <identifier>

<member_list> ::= <member> [ <member> ] ...

<member> ::= <field_declarator> ";"

<field_declarator> ::= [ <field_attribute_list> ]
 <type_spec> <declarators>

<field_attribute_list> ::= "[" <field_attribute> [ ","
 <field_attribute>] ... "]" 

<tagged_union_declarator> ::= "union" <tag>
 | <tagged_union>

<union_type> ::= "union" <union_switch> "{" <union_body> "}"
 | "union" "{" <union_body_n_e> "}"

<union_switch> ::= "switch" "(" <switch_type_spec> <identifier> ")"
 [ <union_name> ]

.ne 6
<switch_type_spec> ::= <integer_type>
 | <char_type>
 | <boolean_type>
 | <enumeration_type>
<tagged_union_declarator> ::= "union" <tag> 
 | <tagged_union>

<union_type> ::= "union" <union_switch> "{" <union_body> "}" 
 | "union" "{" <union_body_n_e> "}"

<union_switch> ::= "switch" "(" <switch_type_spec> <Identifier> ")" \\
      [ <union_name> ]

<switch_type_spec> ::= <primitive_integer_type> 
 | <char_type>
 | <boolean_type>
 | <enumeration_type>

<tagged_union> ::= "union" <tag> <union_switch> "{" <union_body> "}"
 | "union" <tag> "{" <union_body_n_e> "}"

<union_name> ::= <Identifier>

<union_body> ::= <union_case> [  <union_case> ] ... 

<union_body_n_e> ::=  <union_case_n_e> [ <union_case_n_e> ] ...

<union_case> ::= <union_case_label> [ <union_case_label> ] ... <union_arm>
 | <default_case>

<union_case_n_e> ::= <union_case_label_n_e> <union_arm>
 | <default_case_n_e> 

<union_case_label> ::= "case" <const_exp> ":" 

<union_case_label_n_e> ::= "[" "case" "(" <const_exp> \\
      [ , <const_exp>] ...")" "]"

<default_case> ::= "default" ":" <union_arm>

<default_case_n_e> ::= "[" "default" "]" <union_arm>

<union_arm> ::= [ <field_declarator> ] ";"

<union_type_switch_attr> ::= "switch_type" "(" <switch_type_spec> ")"

<union_instance_switch_attr> ::= "switch_is" "(" <attr_var> ")"

<enumeration_type> ::=
."enum" "{" <enum_identifier> [ "," <enum_identifier> ] ... "}"

<enum_identifier> ::= <identifier> [ "=" <const_exp> ]

<pipe_type> ::= "pipe" <type_spec> <pipe_declarators>

<array_declarator> ::= <identifier> <array_bounds_list>

<array_bounds_list> ::= <array_bounds_declarator> 
 [ <array_bounds_declarator> ] ...

<array_bounds_declarator> ::= "[" [ <array_bound> ] "]"
 | "[" <array_bounds_pair> "]"

<array_bounds_pair> ::= <array_bound> ".." <array_bound>

<array_bound> ::= "*" 
 | <integer_literal>
 | <identifier>

<type_attribute> ::= "transmit_as" "(" <xmit_type> ")"
 | "handle"
 | <usage_attribute>
 | <union_type_switch_attr>
 | <ptr_attr>

<usage_attribute> ::= "string"
 | "context_handle"

<xmit_type> ::= <simple_type_spec>

<field_attribute> ::= "first_is" "(" <attr_var_list> ")"
 | "last_is" "(" <attr_var_list> ")"
 | "length_is" "(" <attr_var_list> ")"
 | "max_is" "(" <attr_var_list> ")"
 | "min_is" "(" <attr_var_list> ")"
 | "size_is" "(" <attr_var_list> ")"
 | <usage_attribute>
 | <union_instance_switch_attr>
 | "ignore"
 | <ptr_attr>

<attr_var_list> ::= <attr_var> [ "," <attr_var> ] ...

<attr_var> ::= [ ["*"]<identifier> ]

<ptr_declarator> ::= "*"<identifier>

<ptr_attr> ::= "ref"
 | "unique"
 | "full"

<op_declarator> ::= [ <operation_attributes> ]
 <simple_type_spec> <identifier> <parameter_declarators>

.ne 2
<operation_attributes> ::=  "[" <operation_attribute> [ "static" ]
 [ "," <operation_attribute> ] ... "]"

.ne 6
<operation_attribute> ::= "idempotent"
 | "broadcast"
 | "maybe"
 | "reflect_deletions"
 | <usage_attribute>
 | <ptr_attr>

<param_declarators> ::= "(" "void" ")"
 | "(" [ <param_declarator> [ "," <param_declarator> ] ... ] ")"

<param_declarator> ::= <param_attributes> <type_spec> <declarator>

<param_attributes> ::=
 "[" <param_attribute> [ "," <param_attribute> ] ... "]"

<param_attribute> ::= <directional_attribute>
 | <field_attribute>

<directional_attribute> ::= "in" [ "(" "shape" ")" ]
 | "out" [ "(" "shape" ")" ] 

<function_ptr_declarator> ::= <simple_type_spec>
 "(" "*"<identifier> ")" <param_declarators>

<predefined_type_spec> ::= "error_status_t"
 | <international_character_type>

<international_character_type> ::= ISO_LATIN_1
 | ISO_MULTI_LINGUAL
 | ISO_UCS

<pipe_declarators> ::= <pipe_declarator> [ "," <pipe_declarator> ] ...

<pipe_declarator> ::= <simple_declarator>
 | <ptr_declarator>
 | <ref_declarator> 
.ps 12
.vs 14
.oE
.zZ "def,13428,R1.2.2,removed align attribute"

