...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" 
...\" HISTORY
...\" $Log: 6_convenience.gpsml,v $
...\" Revision 1.1.4.1  1996/09/03  18:14:38  wardr
...\" 	{enh,R1.2.2}
...\" 	Update for sgml conversion
...\" 	[1996/09/03  18:13:35  wardr]
...\"
...\" Revision 1.1.2.12  1995/06/15  16:29:31  rcb
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/13  19:27:03  rcb]
...\" 
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/08  19:01:51  rcb]
...\" 
...\" Revision 1.1.2.11  1994/11/03  23:33:45  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:38:50  neilson]
...\" 
...\" 	Substituted macros for book names in cross refs.
...\" 
...\" Revision 1.1.2.10  1994/10/20  17:13:16  rnollman
...\" 	final checkin to be safe
...\" 	[1994/10/20  17:13:01  rnollman]
...\" 
...\" Revision 1.1.2.9  1994/10/18  20:00:05  rnollman
...\" 	fixed formatting
...\" 	[1994/10/18  19:59:51  rnollman]
...\" 
...\" Revision 1.1.2.8  1994/10/18  17:42:34  rnollman
...\" 	changes for Dave Treff
...\" 	[1994/10/18  17:42:10  rnollman]
...\" 
...\" Revision 1.1.2.7  1994/10/14  15:38:25  rnollman
...\" 	incorporated technical changes from Dublin
...\" 	[1994/10/14  15:38:10  rnollman]
...\" 
...\" Revision 1.1.2.6  1994/10/14  14:34:28  rnollman
...\" 	incorporated technical changes from Dublin
...\" 	[1994/10/14  14:34:17  rnollman]
...\" 
...\" Revision 1.1.2.5  1994/08/12  20:07:52  weir
...\" 	Corrected several formatting errors
...\" 	[1994/08/12  20:07:21  weir]
...\" 
...\" Revision 1.1.2.4  1994/08/05  14:02:26  rnollman
...\" 	completed osf edits
...\" 	[1994/08/05  13:59:58  rnollman]
...\" 
...\" Revision 1.1.2.3  1994/06/13  18:30:08  devobj
...\" 	cr10872 - fix copyright
...\" 	[1994/06/13  18:29:51  devobj]
...\" 
...\" Revision 1.1.2.2  1994/05/14  22:33:28  rnollman
...\" 	last submittal for beta
...\" 	[1994/05/14  22:31:09  rnollman]
...\" 
...\" Revision 1.1.2.1  1994/05/12  15:10:29  rnollman
...\" 	added new chapter
...\" 	[1994/05/12  15:09:57  rnollman]
...\" 
...\" $EndLog$
...\"
...\" /*****************************************************************
...\" *                                                                *
...\" * COPYRIGHT   (C)  SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1994   *
...\" *                  ALL RIGHTS RESERVED                           *
...\" *                                                                *
...\" *****************************************************************/
.H 1 "XDS/XOM Convenience Routines"
.P
This chapter describes functions which are available to XDS/XOM programmers
to help simplify and speed up the development of XDS applications.  The
convenience functions target two main areas, as follows:
.ML
.LI
Filling, comparing, and extracting objects
.LI
Converting objects to and from strings
.LE
.P
The following six convenience functions are provided:
.P
.ML
.LI 
\*LdsX_extract_attr_values(\|)\*O
.LI
\*LomX_fill(\|)\*O
.LI
\*LomX_fill_oid(\|)\*O
.LI
\*LomX_extract(\|)\*O
.LI
\*LomX_string_to_object(\|)\*O
.LI
\*LomX_object_to_string(\|)\*O
.LE
.P
Refer to the \*V*\*L(3xds)\*O and \*V*\*L(3xom)\*O reference pages 
for a detailed description of these functions.
.P
To demonstrate the power of the convenience functions, the \*Lacl.c\*O sample 
program from Chapter 7 is presented again here, after modification
to make use of these functions.  The modified sample program is
called \*Lacl2.c\*O.
.H 2 "String Handling"
.P
The convenience functions provide the ability to specify OM objects 
in string format by means of abbreviations.  These abbreviations are 
defined in the XOM object information file \*Lxoischema\*O.
...\" DCE 1.2 WRITER: comment from DCT: "xoischema.WHAT?  No filetype
...\" suffix.  Feh!"
.P
X.500 attribute types can be specified either as abbreviations or object 
identifier strings.  The mapping of the attribute abbreviations and object 
identifier strings to BER encoded object identifiers and the associated 
attribute syntaxes is determined by the XOM object information module 
with the help of the \*Lxoischema\*O file.  For valid attribute
abbreviations, please refer to the \*Lxoischema\*O file in the following
directory:
.iS
dce_local_path>/var/adm/directory/gds/adm
.iE
.P
It is important that any schema changes to the DSA are reflected in the
\*Lxoischema\*O file.
.P
The convenience functions are able to handle strings with special
syntax.  The strings can be broadly classified into the following:
.ML
.LI
Strings representing GDS attribute information
.LI
Strings representing structured GDS attribute information
.LI
Strings representing a structured GDS attribute value
.LI
Strings representing a distinguished name (DN)
.LI
Strings representing expressions
.LE
.H 3 "Strings Representing GDS Attribute Information"
.P
Strings that represent GDS attribute information are used to associate the attributes with their values. 
They are of the form:
.iS
\*Vattribute_type\*L = \*Vattribute_value
.iE
.P
.ne 4
The attribute types can either be specified as abbreviations or object 
identifier strings.  An object identifier string is defined as a series 
of digits separated by the \*L.\*O (dot) character.  
If attribute abbreviations are used, they are case insensitive.  
For example, \*Lcn=schmid\*O or \*L85.4.3=schmid\*O.
.P
In the case of attributes with \*LOM_S_OBJECT_IDENTIFIER\*O syntax, the 
attribute value can also be specified as an abbreviation string.  For example,
an object class for \*LResidential Person\*O can be specified as
\*LOCL=REP\*O or \*LOCL='\ex55\ex06\ex0A'\*O
.P
All leading and trailing whitespace (surrounding the attribute type, the 
= (equal sign), and the attribute value) is ignored.
.P
The following are the reserved characters for such strings:
.VL
.LI "\*L'\*O"
Used to enclose the attribute values.  
If this character is used, all other reserved characters
within the quoted string except the \e (backslash) are not interpreted.
For example, \*Lcn=henry mueller\*O
.LI "\*L;\*O"
Separates multiple values of a recurring attribute.
All leading and trailing whitespace 
(surrounding the semicolon) is ignored.  For example, \*LTN=899898;979779\*O
.LI "\*L=\*O"
Associates the attribute with its value.
.LI "\*L\ex\*Vnn\*O"
Specifies hexadecimal data.  The two characters \*Vnn\*O
are read as the hexadecimal value.
.LI "\*L\e\*O"
Used to escape any of the other reserved characters.	
.LE
.H 3 "Strings Representing Structured GDS Attribute Information"
.P
Strings that represent structured GDS attribute information are used to 
associate the structured attribute and its components with their values.  
They are of the form:
.iS
\*Vstructured_attribute_type \*L= {\*VComp1\*L = \*VValue\*L, \*VComp2\*L = \*VValue\*L, ..}
.iE
.P
.ne 6
The structured attribute type can either be specified as abbreviations or 
object identifier strings.  An object identifier string is defined as a series 
of digits separated by dots.  If attribute abbreviations are 
used, they are case insensitive.  \*VComp1\*O, \*VComp2\*O, and so on 
are the components of the structured attribute.  They should be specified 
as abbreviations, as in the following example:
.iS
TXN={TN=977999, CC=345, AB=8444}
.iE
.P
Recurring values for structured attributes can be specified with the help
of the semicolon.  An example follows:
.iS
TXN={TN=977999, CC=345, AB=8444};{TN=123444,CC=345, AB=8444}
.iE
.P
Recurring values for the components should be specified as follows:
.iS
TXN={TN=977999; 274424, CC=345, AB=8444}
.iE
.P
If any of the components are further structured, they should be enclosed
within braces as follows:
.iS
FTN={PA={FR=1,TD=1}, PN=67899}
.iE
.P
All leading and trailing whitespace (surrounding the structured attribute 
type, the component abbreviation, the equal sign, the { (left brace), 
the \*L,\*O (comma), and the } (right brace)) is ignored.
.P
Attributes and components with DN syntax should be specified as follows:
.iS
AON={/c=de/o=sni/ou=ap11/cn=mueller}
ACL={MPUB={INT=0, USR={/c=de/o=sni/cn=mueller, sn=schmid}}}
.iE
.P
In the case of attributes with \*LOM_S_OBJECT_IDENTIFIER\*O syntax, the 
attribute value can also be specified as an abbreviation string, as
shown in the following:
.iS
SG={OCL=REP} 
SG={OCL='\ex55\ex06\ex0A'}
.iE
.P
.ne 5
Attributes of type presentation address 
(OM Class \*LDS_\%C_\%PRESENTATION_\%ADDRESS\*O)
are handled specially, using the PSAP macro utility.  The value for such
an attribute can be specified as follows:
.iS
PSA={TS=Server, NA='TCP/IP!internet=127.0.0.1+port=12345'}
.iE
.P
The \*Vlocal_string\*O parameter should be set to \*LOM_TRUE\*O in the
convenience function being used.  Here, the network address (NA) is
specified with a special syntax.  Refer to \*(Ax for further information.
.P
The following are the reserved characters for strings with structured
attribute information:
.VL
.LI "\*L'\*O"
Used to enclose the attribute values.
If this character is used, all other reserved characters
within the quoted string except the backslash are not 
interpreted.  For example, \*Lcn='henry mueller'\*O
.LI "\*L/\*O"
Specifies an attribute value with DN Syntax.  For example, \*LAON = {/c=de/o=sni/ou=ap22/cn=mayer}\*O
.LI "\*L{\*O"
Indicates the start of a structured attribute value block.
.LI "\*L}\*O"
Indicates the end of a structured attribute value block.
.LI "\*L,\*O"
Separates the components of a structured attribute.  For example, \*LTN=977999, CC=345, AB=8444\*O   
.P
It can also be used to specify multiple AVAs in the case of
attributes with DN syntax.
.LI "\*L;\*O"
Separates multiple values of a recurring attribute or the
recurring components of the structured attribute.
All leading and trailing whitespace 
(surrounding the attribute type, the equal sign, the left and right braces,
the component abbreviation, the component value 
and the semicolon) is ignored.  The following is an example:
.iS
.ps -2
TXN={TN=977999,CC=345,AB=8444};{TN=53533,CC=242,AB=44242}
.ps +2
.iE
.P
.LI "\*L=\*O"
Associates the components with their value, and associates
the components to the structured attribute.
.LI "\*L\ex\*Vnn\*O"
.ne 4
Used to specify hexadecimal data.  The two characters \*Vnn\*O
are read as the hexadecimal value.
.LI \e
Used to escape any of the other reserved characters.	
.LE
.H 3 "Strings Representing a Structured GDS Attribute Value"
.P
Strings are used to represent the structured GDS attribute value. Only
one structured attribute value can be specified.
.P
They are of the form:
.iS
\*VComp1 = Value\*L, \*VComp2 = Value\*L, ....
.iE
.P
\*VComp1\*O, \*VComp2\*O, and so on 
are the components of the structured attribute.  They 
should be specified as abbreviations.  
For example, to specify a value for \*LDS_C_TELEX_NBR\*O class, the string 
format is the following: 
.iS
TN=977999, CC=345, AB=8444
.iE
.P
Recurring values for the components can be specified as shown in the
following:
.iS
TN=977999; 274424, CC=345, AB=8444
.iE
.P
If any of the components are further structured, they should be enclosed
within braces as follows:
.iS
FTP={FR=1,TD=1}, PN=67899
.iE
.P
Components with DN syntax can be specified as follows:
.iS
MPUB={INT=0, USR={/c=de/o=sni/cn=mueller, sn=schmid}}
.iE
.P
Components of type presentation address (OM Class 
\*LDS_\%C_\%PRESENTATION_\%ADDRESS\*O) are handled specially, using the PSAP 
macro utility.  The value for the components can be specified as
follows:
.iS
TS=Server, NA='TCP/IP!internet=127.0.0.1+port=12345'
.iE
.P
.ne 4
The \*Vlocal_string\*O parameter should be set to \*LOM_TRUE\*O in the
convenience function being used.
Here, the NA is specified with a special syntax.  Refer to
the \*(Ax for further information.
.P
The reserved characters for such strings are the same as those for strings
representing structured attribute information (Section 9.1.2).
.H 3 "Strings Representing a Distinguished Name"
.P
Strings are used to represent the DN of the object. 
They are of the form:
.iS
/\*Vattribute_type\*L = \*Vnaming_attribute_value\*L ....
.iE
or 
.iS
/\*Vattribute_value\*L/\*Vattribute_value\*L ....
.iE
.P
The attribute types can either be specified as abbreviations or object 
identifier strings.  An object identifier string is defined as a series of 
digits separated by dots.  If attribute abbreviations are used, 
they are case insensitive.  Multiple AVAs are represented by separating the 
naming attribute values with commas.
.P
The first RDN can also be specified as the DCE global root string \*L/...\*O,
which is a sequence of the slash followed by three dots.
In this case, the \*L/...\*O string is simply ignored and the rest of the
string is processed.  Three examples follow:
.iS
/c=de/o=sni/ou=ap11, l=munich/85.4.3=schmid
/c=us/o=osf/ou=abc/subsystems/server/xyz
/.../c=us/o=osf/ou=abc/subsystems/server/xyz
.iE
.P
The first nonspace character should always be the slash.
All leading and trailing whitespace (surrounding the slash, 
the attribute type, the equal sign and the attribute value) is ignored.
.P
.ne 5
The following are the reserved characters:
.VL
.LI "\*L'\*O"
Used to enclose the naming attribute values.
If this character is used, all other reserved characters
within the quoted string except the backslash are not 
interpreted.  For example, \*Lcn='henry mueller'\*O.
.LI "\*L/\*O"
Used as a delimiter between RDNs.
.LI "\*L,\*O"
Specifies multiple AVAs.
All leading and trailing whitespace surrounding the comma
is ignored.  An example follows:
.iS
/c=de/o=dbp/ou=dap11/cn=schmid, ou=ap11
.iE
.LI "\*L=\*O"
Associates the object with its naming attribute value.
.LI "\*L\ex\*Vnn\*O"
Used to specify hexadecimal data.  The two characters \*Vnn\*O
are read as the hexadecimal value.
.LI "\*L\e\*O"
Used to escape any of the other reserved characters.	
.LE
.H 3 "Strings Representing Expressions"
.P
Strings are used to specify an SQL-like expression in a search operation. 
For example, consider the following:
.iS
(CN~=schmid) && (OCL=ORP || OCL=REP) && !(SN=ronnie)
.iE
This is used to search for anybody who is an organizational person or
a residential person, whose name approximately matches \*Lschmid\*O
but whose surname is not \*Lronnie\*O.
.P
Object identifiers can also be used instead of attribute abbreviations.  The 
object identifier string is a series of numbers separated by dots.
.P
All leading and trailing whitespace (surrounding the attribute types, the 
operators, and the attribute values) is ignored.
.P
If spaces are part of the attribute value, then the complete attribute value
must be enclosed in quotes.
.P
.ne 5
Additionally, the presence of an attribute can also be tested in either of 
the following ways:
.iS
c = de && cn
c = de && cn = *
.iE
.P
The following are the reserved characters:
.VL
.LI "\*L'\*O"
Used to indicate the start/end of an attribute value string.  Can
be used when spaces are part of the data.
If this character is used, all other reserved characters
within the quoted string except the backslash are not 
interpreted.  An example follows:
.iS
OU=sni && cn='Henri Mueller' && tn=89989
.iE
.LI "\*L/\*O"
Used to specify an attribute value with DN syntax.  An example follows:
.iS
AON = {/c=de/o=sni/ou=ap22/cn=mayer}
.iE
.LI "\*L=\*O"
Used to associate the attribute with its value.
.LI "\*L&&\*O"
Used to logically AND two conditions.
.LI "\*L||\*O"
Used to logically OR two conditions.
.LI "\*L!\*O"
Used to logically NEGATE a condition.
.LI "\*L~=\*O"
Used to specify phonetic matching during a search operation.
.LI "\*L>\*O"
Used to match values greater than a specified value.
.LI "\*L>=\*O"
Used to match values greater than or equal to a specified value.
.LI "\*L<\*O"
Used to match values less than a specified value.
.LI "\*L<=\*O"
Used to match values less than or equal to a specified value.
.LI "\*L*\*O"
Used to specify substrings during search.
.LI "\*L(\*O"
Used for nesting of filters.
.LI "\*L)\*O"
Used for nesting of filters.
.LI "\*L{\*O"
Indicates the start of a structured attribute value block.
.LI "\*L}\*O"
Indicates the end of a structured attribute value block.
.LI "\*L,\*O"
.ne 4
Separates the components of a structured attribute.  For example, \*LTN=977999, CC=345, AB=8444\*O
It can also be used to specify multiple AVAs in the case of
attributes with DN syntax.
.LI "\*L\ex\*Vnn\*O"
Used to specify hexadecimal data.  The two characters \*Vnn\*O
are read as the hexadecimal value.
.LI "\*L\e\*O"
Used to escape any of the other reserved characters.	
.LE
.P	
While evaluating complex expressions during search operations, the following 
precedence of operators prevail:
.P
.AL
.LI
\*L(\|)\*O
.LI
\*L!\*O
.LI
\*L&&\*O
.LI
\*L||\*O
.LE
.P
The (\|) operators have the highest precedence, and || the lowest.
.H 2 "The acl2.c Program"
.iX "\*Lacl2.c\*O"
The \*Lacl2.c\*O file is a program that
performs the same functionality as \*Lacl.c\*O described in Chapter 7.
Please refer to Chapter 7 for a complete description of the
program's functionality, including outputs.  The purpose of \*Lacl2.c\*O
and \*Lacl2.h\*O is to show how the XDS/XOM convenience functions
can be used to reduce the complexity of a real application.
.P
The program consists of the following steps:
.AL
.LI
Export the required object identifiers (see the \*Lacl2.h\*O description in
Section 9.2.2).
.LI
Define the string expressions for the directory entry names and their
attributes (see the \*Lacl2.h\*O description in Section 9.2.2).
.LI
Initialize a workspace.
.LI
Negotiate use of the basic directory contents and GDS
packages.
.LI
Build the name objects for the entries to be added to the directory.
.LI
Build the attribute objects for the entries to be added to the directory.
.LI
Add the fixed tree of entries to the directory in order
to permit an authenticated bind.
.LI
Create a default session object.
.LI
Alter the default session object to include the credentials of the requestor
(\*L/C=de/O=sni/OU=ap/CN=norbert\*O).
.LI
Bind with credentials to the default GDS server.
.LI
Create a default context object and alter it to include shadow entries.
.LI
Build filter, name, and entry information selection objects to be used
for the search process.
.LI
Search the whole subtree below \*Lroot\*O and extract the ACL attribute from
each selected entry.
.LI
Close the connection to the GDS server.
.LI
Remove the user's credentials from the directory.
.LI
Release the memory used for application-created objects.
.LI
Extract the components from the search result.
.LI
Examine each entry and print the entry details.
.LI
Close the XDS workspace.
.LE
.P
In comparison to the \*Lacl.c\*O program in Chapter 7, the following points
should be noted:
.ML
.LI
Step 1 hasn't changed too much.  The number of object identifiers, which
the \*Lacl2.c\*O needs to be exported, has been reduced.
.LI
Step 2 has been completely revised.  In fact, the header file has been
reduced substantially.  This is as a result
of removing all the static descriptor lists for the directory names and
attributes and replacing them with string expressions.
.LI
Steps 3 and 4 are the same as before.
.LI
.ne 10
Steps 5 and 6 are new steps that make use of the convenience 
functions \*LomX_string_to_object(\|)\*O, \*LomX_fill_oid(\|)\*O, and
\*LomX_fill(\|)\*O.
.LI
Steps 7 through 10 are the same as Steps 5 through 8
previously.
.LI
Step 11 is the same as Step 9 previously, but with an
additional call to build an object to specify the use of shadow entries.
A convenience function is used for this purpose.  This replaces a static
descriptor list definition from the old header file.
.LI
Step 12 is new.  It calls several convenience functions to create
objects that are used by \*Lds_search(\|)\*O.  These objects were
previously statically declared in the header file.
.LI
Steps 13 through 15 are the same as Steps 10 through
12 from the old code.
.LI
Step 16 is a new step to release memory that has been allocated
by the convenience functions when creating objects.
.LI
Step 17 replaces Step 13 from the old program with a call
to the convenience function \*LomX_extract(\|)\*O to extract the
required components from the search result.
.LI
Step 18 is the same as Step 14 in the old program, but with
an additional call to free the memory allocated by \*LomX_extract(\|)\*O in
the previous step.
.LI
Step 19 is the same as Step 15 in the old code.
.LE
.H 3 "The acl2.c Code"
.P
The following code is a listing of the \*Lacl2.c\*O program:
.nL
.ps 11
.vs 13
.oS
.ne 20
/***************************************************************
*                                                              *
*  COPYRIGHT (C) SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1991   *
*                ALL RIGHTS RESERVED                           *
*                                                              *
***************************************************************/

/*
 * This sample program displays the access permissions (ACL) on each 
 * entry in the directory for a specific user.  The permissions are 
 * presented in a form similar to the UNIX file permissions.  In 
 * addition, each entry is flagged as either a master or a shadow copy.
 *
 * The distinguished name of the user performing the check is:
 *
 *     /C=de/O=sni/OU=ap/CN=norbert
 *
 * The results are presented in the following format: 
 *
 *     [ABCD] <entry's distinguished name>
 *
 *     A:  'm' master copy
 *         's' shadow copy
 *
 *     B:  'r' read access to public attributes
 *         'w' write access to public attributes
 *         '-' no access to public attributes
 *
 *     C:  'r' read access to standard attributes
 *         'w' write access to standard attributes
 *         '-' no access to standard attributes
 *
 *     D:  'r' read access to sensitive attributes
 *         'w' write access to sensitive attributes
 *         '-' no access to sensitive attributes
 *
 * For example, the following result means that the entry 
 * '/C=de/O=sni' is a master copy and that the requesting user 
 * (/C=de/O=sni/OU=ap/CN=norbert) has write access to its public 
 * attributes, read access to its standard attributes and no access 
 * to its sensitive attributes.
 *
 *      [mwr-] /C=de/O=sni
 * 
.ne 20
 * The program requires that the specific user perform an authenticated 
 * bind to the directory.  In order to achieve this the user's 
 * credentials must already exist in the directory.  Therefore the 
 * following tree of 6 entries is added to the directory each time the 
 * program runs, and removed again afterwards.
 *
 *              O  C=de
 *              |  (objectClass=Country,
 *              |   ACL=(mod-pub: *
 *              |        read-std:*
 *              |        mod-std: *
 *              |        read-sen:*
 *              |        mod-sen: *))
 *              |
 *              |
 *              O  O=sni
 *              |  (objectClass=Organization,
 *              |   ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *              |        read-std:/C=de/O=sni/OU=ap/CN=stefanie
 *              |        mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *              |        read-sen:/C=de/O=sni/OU=ap/CN=stefanie
 *              |        mod-sen: /C=de/O=sni/OU=ap/CN=stefanie))
 *              |
 *              O  OU=ap
 *              |  (objectClass=OrganizationalUnit,
 *              |   ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *              |        read-std:/C=de/O=sni/OU=ap/CN=stefanie
 *              |        mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *              |        read-sen:/C=de/O=sni/OU=ap/CN=stefanie
 *              |        mod-sen: /C=de/O=sni/OU=ap/CN=stefanie))
 *              |
 *      +-------+-------+
 *      |       |       |
 *      |       |       O  CN=ingrid
 *      |       |         (objectClass=OrganizationalPerson,
 *      |       |          ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *      |       |               read-std:/C=de/O=sni/OU=ap/*
 *      |       |               mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *      |       |               read-sen:/C=de/O=sni/OU=ap/*
 *      |       |               mod-sen: /C=de/O=sni/OU=ap/CN=stefanie),
 *      |       |          surname="Schmid",
 *      |       |          telephone="+49 89 636 0",
 *      |       |          userPassword="secret")
.ne 20
 *      |       |
 *      |       O  CN=norbert
 *      |          (objectClass=OrganizationalPerson,
 *      |           ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *      |                read-std:/C=de/O=sni/OU=ap/*
 *      |                mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *      |                read-sen:/C=de/O=sni/OU=ap/*
 *      |                mod-sen: /C=de/O=sni/OU=ap/CN=stefanie),
 *      |           surname="Schmid",
 *      |           telephone="+49 89 636 0",
 *      |           userPassword="secret")
 *      |
 *      O  CN=stefanie
 *         (objectClass=OrganizationalPerson,
 *          ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *               read-std:/C=de/O=sni/OU=ap/*
 *               mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *               read-sen:/C=de/O=sni/OU=ap/*
 *               mod-sen: /C=de/O=sni/OU=ap/CN=stefanie),
 *          surname="Schmid",
 *          telephone="+49 89 636 0",
 *          userPassword="secret")
 *
 *
 * In this version of the program, instead of providing client-generated 
 * public objects, the XOM Convenience Functions are used for creating
 * objects.  They are also used for extracting information from service
 * generated objects.
 */

#ifdef THREADSAFE
#include <pthread.h>
#endif

#include <stdio.h>
#include <xom.h>
#include <xds.h>
#include <xdsbdcp.h>
#include <xdsgds.h>
#include <xdscds.h>
#include <xdsext.h>         /* convenience functions header file  */
#include <xomext.h>         /* convenience functions header file  */
#include "acl2.h"

.ne 20
void
main(
    int  argc,
    char *argv[]
)
{
  OM_workspace       workspace;     /* Workspace for objects          */
  OM_private_object  session;       /* Session object.                */
  OM_private_object  bound_session; /* Holds the Session object which */
                                    /* is returned by ds_bind()       */
  OM_private_object  context;       /* Context object.                */
  OM_private_object  result;        /* Holds the search result object.*/
  OM_sint            invoke_id;     /* Integer for the invoke id      */
                                    /* returned by ds_search().       */
                                    /* (this parameter must be present*/
                                    /* even though it is ignored).    */
  OM_type            navigation_path[] = { DS_SEARCH_INFO, 0 };
                                    /* List of OM types to the target */
				    /* object - of the search result  */
    OM_type            entry_list[] = { DS_ENTRIES, 0 };
                                    /* List of types to be extracted  */
  OM_public_object   entry;         /* Entry object from search info. */
  OM_value_position  total_num;     /* Number of descriptors returned.*/
  OM_return_code     rc;            /* XOM function return code.      */
  register int       i;
  char               user_name[MAX_DN_LEN] = DN_NORBERT;
                                    /* Holds the requestor's name -   */
                                    /* "/C=de/O=sni/OU=ap/CN=norbert" */
  char               entry_string[MAX_DN_LEN + 7] = "[?r??] ";
                                    /* Holds entry details.           */
  struct entry       entry_array[6];/* List of entry names and attrs  */
  OM_object	       credentials; /* Credentials part of session obj*/
  OM_object	       use_copy;    /* Specifies whether to use shadow*/
		      		    /* entries, in context object     */
  OM_object	       filter;      /* Filter - for search operation  */
  OM_object	       dn_root;	    /* Name object for "/"	      */
  OM_object	       selection_acl;   /* Entry Information          */
				        /* Selection obj              */

  static char	       *name_list[] = 
		 { DN_DE, DN_SNI, DN_AP, DN_STEFANIE,
                       	       DN_NORBERT, DN_INGRID };
				      /* Array of names to be added   */

.ne 6
  static char        *C_attr_list[]  = { OBJ_CLASS_C };
  static char        *O_attr_list[]  = { OBJ_CLASS_O, ATT_ACL1 }; 
  static char        *OU_attr_list[] = { OBJ_CLASS_OU };
  static char        *OP_attr_list[] = { OBJ_CLASS_OP, ATT_ACL2, 
                           ATT_SURNAME, ATT_PHONE_NUM, ATT_PASSWORD };
				    /* Attribute lists, in string fmt */

  static char	       *dn_root_str    = DN_ROOT;
  static char	       *filter_str     = FILTER;

  /* Step 3
   *
   * Initialize a directory workspace for use by XOM.
   */
  if ((workspace = ds_initialize()) == (OM_workspace)0)
      printf("ds_initialize() error\en");

  /* Step 4
   *
   * Negotiate the use of the BDC and GDS packages.
   */
  if (ds_version(features, workspace) != DS_SUCCESS)
      printf("ds_version() error\en");

  /* Step 5
   *
   * Build name objects for entries to be added to the directory.
   */
  for (i = 0; i < NO_OF_ENTRIES; i++) 
      if (! build_name_object(workspace,name_list[i], 
                              &(entry_array[i].name)))
      printf("build_name_object() error\en");

  /* Step 6
   *
   * Build attribute objects for entries to be added to the directory
   */
  if ((! build_attr_list_object(workspace, NO_C_ATTRS, C_attr_list, 
				&entry_array[0].attr_list)) ||
      (! build_attr_list_object(workspace, NO_O_ATTRS, O_attr_list, 
				&entry_array[1].attr_list)) ||
      (! build_attr_list_object(workspace, NO_OU_ATTRS, OU_attr_list, 
				&entry_array[2].attr_list)) ||
      (! build_attr_list_object(workspace, NO_OP_ATTRS, OP_attr_list, 
				&entry_array[3].attr_list)))
      printf("build_attr_list_object() error\en");

.ne 5
  /* 
   * These entries also have the OP attribute list.
   */
  entry_array[4].attr_list = entry_array[3].attr_list;
  entry_array[5].attr_list = entry_array[3].attr_list;

  /* Step 7
   *
   * Add a fixed tree of entries to the directory in order to permit
   * an authenticated bind by:   /C=de/O=sni/OU=ap/CN=norbert
   */
  if (! add_tree(workspace, entry_array, NO_OF_ENTRIES))
      printf("add_tree() error\en");

  /* Step 8
   *
   * Create a default session object.
   */
  if ((rc = om_create(DSX_C_GDS_SESSION,OM_TRUE,workspace,&session))
                                                      != OM_SUCCESS)
      printf("om_create() error %d\en", rc);

  /*  Step 9
   *
   * Build an object with the following credentials:
   *  requestor:  /C=de/O=sni/OU=ap/CN=norbert
   *  password:   "secret"
   *  authentication mechanism: simple
   */
  if (! build_credentials_object(entry_array[4].name,&credentials))
      printf("build_credentials_object() error\en");

  /*
   * Alter the default session object to include the credentials
   */
  if ((rc = om_put(session, OM_REPLACE_ALL, credentials, 0 ,0, 0))
                                                    != OM_SUCCESS)
      printf("om_put() error %d\en", rc);

  /* Step 10
   *
   * Bind with credentials to the default GDS server.  The
   * returned session object is stored in the private object variable
   * bound_session and is used for all further XDS function calls.
   */
  if (ds_bind(session, workspace, &bound_session) != DS_SUCCESS)
      printf("ds_bind() error\en");

  /* Step 11
   *
   * Create a default context object.
   */
  if ((rc = om_create(DSX_C_GDS_CONTEXT,OM_TRUE,workspace,&context))
                                                      != OM_SUCCESS)
      printf("om_create() error %d\en", rc);

  /* 
   * Build an object specifying that shadow entries should be used.
   */
  if (! build_use_copy_object(&use_copy))
      printf("build_use_copy_object() error\en");

  /*
   * Alter the default context object to include 'shadow' entries.
   */
  if ((rc = om_put(context, OM_REPLACE_ALL, use_copy, 0 ,0, 0)) 
                   != OM_SUCCESS) printf("om_put() error %d\en", rc);

  /* Step 12
   *
   * Build a filter object, specifying presence of object class attr.
   */
  if (! build_filter_object(workspace, filter_str, &filter))
      printf("build_filter_object() error\en");

  /* 
   * Build a root name object, name = "/"
   */
  if (! build_name_object(workspace, dn_root_str, &dn_root))
      printf("build_name_object() error\en");

  /* 
   * Build an entry information selection object, 
   * selecting acl attributes.
   */
  if (! build_selection_object(&selection_acl))
      printf("build_selection_object() error\en");

.ne 11
  /* Step 13
   *
   * Search the whole subtree below root.  The filter selects entries 
   * with an object-class attribute.  The selection extracts the ACL 
   * attribute from each selected entry.  The results are returned in 
   * the private object 'result'.
   *
   * NOTE: Since every entry contains an object-class attribute the
   *       filter performs no function other than to demonstrate how
   *       filters may be used.
   */

  if (ds_search(bound_session, context, dn_root, DS_WHOLE_SUBTREE, filter,
          OM_FALSE, selection_acl, &result, &invoke_id) != DS_SUCCESS)
      printf("ds_search() error\en");

  /* Step 14
   *
   * Close the connection to the GDS server.
   */
  if (ds_unbind(bound_session) != DS_SUCCESS)
      printf("ds_unbind() error\en");

  /* Step 15
   *
   * Remove the user's credentials from the directory.
   */
  if (! remove_tree(workspace, session, entry_array, NO_OF_ENTRIES))
      printf("remove_tree() error\en");

  /* Step 16
   *
   * Free the name and attribute objects 
   * which make up the directory entries.
   */
  if (! free_entry_list(entry_array))
      printf("free_entry_list() error\en");

.ne 10
  /*
   * Free public objects which were created.
   */
  free(selection_acl);
  free(use_copy);
  free(credentials);

  if ((om_delete(filter) != OM_SUCCESS) ||
      (om_delete(dn_root) != OM_SUCCESS))
      printf("om_delete() error\en");

  /* Step 17
   *
   * Extract components from the search result by means of the XOM
   * Convenience Function, omX_extract()
   */
  if ((rc = omX_extract(result, navigation_path,
              OM_EXCLUDE_ALL_BUT_THESE_TYPES + OM_EXCLUDE_SUBOBJECTS,
              entry_list, OM_FALSE, 0, 0, &entry, &total_num))
                                                != OM_SUCCESS)
      printf("omX_extract(Search-Result) error %d\en", rc);

  /*
   * Requestor's name = "/C=de/O=sni/OU=ap/CN=norbert"
   */
  printf("User:  %s\enTotal: %d\en", user_name, total_num);

  /* Step 18
   *
   * Examine each entry and print the entry details.
   */
  for (i = 0; i < total_num; i++) {
      if (process_entry_info((entry+i)->value.object.object,
                         entry_string, user_name))
          printf("%s\en", entry_string);
  }

  /*
   * Now free the entry object (returned from omX_extract() ).
   */
  if (om_delete(entry) != OM_SUCCESS)
      printf("om_delete() error\en");

.ne 7
  /* Step 19
   *
   * Close the directory workspace.
   */
  if (ds_shutdown(workspace) != DS_SUCCESS)
      printf("ds_shutdown() error\en");
}

/*
 * Add the tree of entries described above.
 */
int
add_tree(
    OM_workspace workspace,
    struct entry elist[],
    int		 no_entries
)
{
  OM_private_object  session;       /* Holds the Session object which */
                                    /* is returned by ds_bind()       */
  OM_sint            invoke_id;     /* Integer for the invoke id      */
  int                error = 0;
  int                i;

  /* 
   * Bind (without credentials) to the default GDS server.
   */
  if (ds_bind(DS_DEFAULT_SESSION, workspace, &session) != DS_SUCCESS)
      error++;

  /* 
   * Add entries to the GDS server.
   */
  for (i = 0; i < no_entries; i++) 
      if (ds_add_entry(session, DS_DEFAULT_CONTEXT, elist[i].name, 
		elist[i].attr_list, &invoke_id) != DS_SUCCESS) {
      /* Ignore error if adding country - possibly already there      */
          if (i != 0) error++;
      }

.ne 8
  /*
   * Close the connection to the GDS server.
   */
  if (ds_unbind(session) != DS_SUCCESS)
      error++;

  return (error?0:1);
}

/*
 * Remove the tree of entries described above.
 */
int
remove_tree(
    OM_workspace       workspace,
    OM_private_object  session,
    struct entry       elist[],
    int		       no_entries
)
{
  OM_private_object bound_session;  /* Holds the Session object which */
                                    /* is returned by ds_bind()       */
  OM_sint           invoke_id;      /* Integer for the invoke id      */
  int		      i;
  int               error = 0;

  /* 
   * Bind (without credentials) to the default GDS server.
   */
  if (ds_bind(session, workspace, &bound_session) != DS_SUCCESS)
      error++;

  /* 
   * Remove entries from the GDS server.
   */
  for (i = no_entries-1; i >= 0; i--) 
  	if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, 
                elist[i].name, &invoke_id) != DS_SUCCESS) {
         /* Ignore error if removing country - possibly has entries  */
         /* below it						     */
         if (i != 0) error++;
      }

.ne 8
  /*
   * Close the connection to the GDS server.
   */
  if (ds_unbind(bound_session) != DS_SUCCESS)
      error++;

  return (error?0:1);
}

/*
 * Extract information about an entry from the Entry-Info object: whether
 * the entry is a master-copy, its ACL permissions and its distinguished 
 * name.  Build up a string based on this information.
 */
int
process_entry_info(
  OM_private_object  entry,
  char              *entry_string,
  char              *user_name
)
{
  OM_return_code     rc;            /* Return code from XOM function. */
  OM_public_object   ei_attrs;      /* Components from Entry-Info.    */
  OM_public_object   attr;          /* Directory attribute.           */
  OM_public_object   acl;           /* ACL attribute parts.           */
  OM_public_object   acl_vals;      /* ACL attribute value.           */
  OM_public_object   acl_item;      /* ACL item component.            */
  OM_value_position  total_attrs;   /* Number of attributes returned. */
  OM_value_position  total_acls;    /* Number of acl values returned. */
  register int       i;
  register int       interp;
  register int       error = 0;
  register int       found_acl = 0;
  static OM_type     ei_attr_list[] = { DS_FROM_ENTRY,
                                        DS_OBJECT_NAME,
                                        0 };
                                    /* Attributes to be extracted.    */
  OM_string	       entry_str;

.ne 12
  /*
   * Extract occurrences of DS_FROM_ENTRY, and DS_OBJECT_NAME 
   * from each Entry-Info object.
   */
  if ((rc = om_get(entry, OM_EXCLUDE_ALL_BUT_THESE_TYPES,
                 ei_attr_list, OM_FALSE, 0, 0, &ei_attrs, &total_attrs))
                                                        != OM_SUCCESS) {
      error++;
      printf("om_get(Entry-Info) error %d\en", rc);
  }

  for (i = 0; ((i < total_attrs) && (! error)); i++, ei_attrs++) {

      /*
       * Determine if current entry is a master-copy or a shadow-copy.
       */
      if ((ei_attrs->type == DS_FROM_ENTRY) &&
          ((ei_attrs->syntax & OM_S_SYNTAX) == OM_S_BOOLEAN))
          if (ei_attrs->value.boolean == OM_TRUE) 
              entry_string[1] = 'm';
          else if (ei_attrs->value.boolean == OM_FALSE) 
                   entry_string[1] = 's';
              else 
                   entry_string[1] = '?';

      /*
       * Convert the entry's distinguished name to a string format.
       */
      entry_str.elements = &entry_string[7];
      entry_str.length = MAX_DN_LEN;
      if ((ei_attrs->type == DS_OBJECT_NAME) &&
          ((ei_attrs->syntax & OM_S_SYNTAX) == OM_S_OBJECT)) 
          if ((rc = omX_object_to_string(ei_attrs->value.object.object, 
			OM_FALSE, &entry_str)) != OM_SUCCESS) {
              error++;
              printf("omX_object_to_string() error\en");
          }
  }

.ne 15
  /*
   * Now extract occurences of attributes, where the attribute 
   * type is ACL from the Entry-Info object.
   */
  dsX_extract_attr_values(entry, DSX_A_ACL, OM_TRUE, 
    &acl_vals, &total_acls);

  for (i = 0; ((i < total_acls) && (! error)); i++) {
      acl = acl_vals[i].value.object.object;

      /*
       * Examine the ACL. Check each permission for the current user.
       */

      entry_string[2] = 'r';
      entry_string[3] = '-';
      entry_string[4] = '-';

      while (acl->type != OM_NO_MORE_TYPES) {

          if ((acl->syntax & OM_S_SYNTAX) == OM_S_OBJECT)
              acl_item = acl->value.object.object;

          switch (acl->type) {

              case OM_CLASS:
                  break;

              case DSX_MODIFY_PUBLIC:
                  if (permitted_access(user_name, acl_item))
                      entry_string[2] = 'w';
                  break;

              case DSX_READ_STANDARD:
                  if (permitted_access(user_name, acl_item))
                      entry_string[3] = 'r';
                  break;

              case DSX_MODIFY_STANDARD:
                  if (permitted_access(user_name, acl_item))
                      entry_string[3] = 'w';
                  break;

.ne 4
              case DSX_READ_SENSITIVE:
                  if (permitted_access(user_name, acl_item))
                      entry_string[4] = 'r';
                  break;

              case DSX_MODIFY_SENSITIVE:
                  if (permitted_access(user_name, acl_item))
                      entry_string[4] = 'w';
                  break;
          }
          acl++;
      }
  }
  /* 
   * Now free acl_vals.
   */
  if (total_acls > 0) 
  	if ((rc = om_delete(acl_vals)) != OM_SUCCESS) {
          error++;
	  printf("om_delete() error, rc = %d\en", rc);
   }
 
  return (error?0:1);
}

/*
 * Check if a user is permitted access based on the ACL supplied.
 */
int
permitted_access(
    char             *user_name,
    OM_public_object  acl_item
)
{
  char  	       acl_name[MAX_DN_LEN];
  OM_string 	       acl_name_str;
  int   	       interpretation;
  int   	       acl_present = 0;
  int   	       access = 0;
  int   	       acl_name_length;
  OM_return_code     rc;

  while (acl_item->type != OM_NO_MORE_TYPES) {

      switch (acl_item->type) {
      case OM_CLASS:
          break;
        
.ne 3
      case DSX_INTERPRETATION:
          interpretation = acl_item->value.boolean; 
          break;

      case DSX_USER:
          acl_name_str.elements = acl_name;
          if ((rc = omX_object_to_string(acl_item->value.object.object, 
                  OM_FALSE, &acl_name_str)) == OM_SUCCESS) {
                if (interpretation == DSX_SINGLE_OBJECT) {
                if (strcmp(acl_name, user_name) == 0)
                      access = 1;
           }
           else if (interpretation == DSX_ROOT_OF_SUBTREE) {
                     if ((acl_name_length = strlen(acl_name)) == 0)
                         access = 1;
                     else if (strncmp(acl_name,user_name,acl_name_length) 
								  == 0)
                         access = 1;
              }
	  }
          break;
      }
      acl_item++;
  }

  return (access);
}

/*
 * Build a name object from a name string using the XOM 
 * Convenience Function omX_string_to_object().
 */
int
build_name_object(
  OM_workspace 	workspace,
  char	 	*name,
  OM_private_object   *name_obj
)
{
  OM_integer        err_pos;
  OM_integer        err_type;
  OM_return_code    rc;
  OM_string	      name_str;
  int               error = 0;

.ne 8
  name_str.length = strlen(name);
  name_str.elements = name;
  if ((rc = omX_string_to_object(workspace, &name_str, DS_C_DS_DN, 
                 OM_TRUE, name_obj, &err_pos, &err_type)) != OM_SUCCESS)
      error++;

  return (error?0:1);
}


/*
 * Build an attribute list object given a list of attribute strings.
 * Use the XOM Convenience Function omX_string_to_object() to build 
 * an attribute object from an attribute string, and omX_fill() to 
 * create the other OM descriptor required.
 */
int
build_attr_list_object(
  OM_workspace 	workspace,
  OM_integer	 	no_attrs,
  char	 	*attr_str_array[],
  OM_object	 	*attr_list_obj
)
{
  OM_integer        err_pos;
  OM_integer        err_type;
  OM_object	      attr;
  OM_object	      alist;
  OM_string	      attr_str;
  OM_return_code    rc;
  OM_descriptor     null_desc = OM_NULL_DESCRIPTOR;
  int               error = 0;
  int		      i;

  /* 
   * Allocate space for class descriptor, null descriptor and 
   * one descriptor for each attribute.
   */
  if ((alist = 
    (OM_descriptor *)malloc((2+no_attrs) * sizeof(OM_descriptor))) 
							== 0)
      error++;

  if ((rc = omX_fill_oid(OM_CLASS, DS_C_ATTRIBUTE_LIST, &alist[0]))
						!= OM_SUCCESS)
      error++;

.ne 12
  for (i = 1; i <= no_attrs; i++) {

      attr_str.length = strlen(attr_str_array[i-1]);
      attr_str.elements = attr_str_array[i-1];
      if ((rc = omX_string_to_object(workspace, &attr_str, DS_C_ATTRIBUTE,
		      OM_TRUE, &attr, &err_pos, &err_type)) != OM_SUCCESS)
      error++;

      if ((rc = omX_fill(DS_ATTRIBUTES, OM_S_OBJECT, 0, attr, &alist[i]))
							!= OM_SUCCESS)
      error++;
  }

  alist[i] = null_desc;

  *attr_list_obj = alist;
  return (error?0:1);
}


/*
 * Build an entry info selection object using the XOM Convenience 
 * Functions omX_fill() and omX_fill_oid() to fill the OM descriptors.
 */
int
build_selection_object(
  OM_object	 *selection_obj
)
{
  OM_integer        err_pos;
  OM_integer        err_type;
  OM_object	      desc;
  OM_object	      sel;
  OM_return_code    rc;
  OM_descriptor     null_desc = OM_NULL_DESCRIPTOR;
  int               error = 0;

  /* 
   * Allocate space for class descriptor, null descriptor and one 
   * descriptor for each attribute. 
   */
  if ((sel = (OM_descriptor *)malloc((5) * sizeof(OM_descriptor))) == 0)
      error++;

.ne 3
  if ((rc = omX_fill_oid(OM_CLASS, DS_C_ENTRY_INFO_SELECTION, &sel[0]))
						 != OM_SUCCESS)
      error++;

  if ((rc = omX_fill(DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, OM_FALSE, 0, 
          				&sel[1])) != OM_SUCCESS)
      error++;

  if ((rc = omX_fill_oid(DS_ATTRIBUTES_SELECTED, DSX_A_ACL, 
                                        &sel[2])) != OM_SUCCESS)
      error++;

  if ((rc = omX_fill(DS_INFO_TYPE, OM_S_ENUMERATION, DS_TYPES_AND_VALUES,
				     0, &sel[3])) != OM_SUCCESS)
    error++;

  sel[4] = null_desc;

  *selection_obj = sel;
  return (error?0:1);
}

/*
 * Build a credentials object using the XOM Convenience Function 
 * omX_fill().
 */
int
build_credentials_object(
  OM_object	 name,
  OM_object	 *credentials_obj
)
{
  OM_integer        err_pos;
  OM_integer        err_type;
  OM_object	      cred;
  OM_return_code    rc;
  OM_descriptor     null_desc = OM_NULL_DESCRIPTOR;
  int               error = 0;

  /* 
   * Just allocate space for a null descriptor and two other descriptors,
   * no class descriptor required.
   */
  if ((cred = (OM_descriptor *)malloc((4) * sizeof(OM_descriptor))) == 0)
      error++;

.ne 3
  if ((rc = omX_fill(DS_REQUESTOR, OM_S_OBJECT, 0, name, &cred[0]))
                                                     != OM_SUCCESS)
      error++;

  if ((rc = omX_fill(DSX_PASSWORD, OM_S_OCTET_STRING, (sizeof(PASSWD)-1), 
                                  PASSWD, &cred[1])) != OM_SUCCESS)

  if ((rc = omX_fill(DSX_AUTH_MECHANISM, OM_S_ENUMERATION, DSX_SIMPLE, 
                                       0, &cred[2])) != OM_SUCCESS)
      error++;

  cred[3] = null_desc;

  *credentials_obj = cred;
  return (error?0:1);
}

/*
 * Build an object setting DS_DONT_USE_COPY to FALSE, using the 
 * XOM Convenience Function omX_fill().
 */
int
build_use_copy_object(
  OM_object	 *use_copy_obj
)
{
  OM_integer        err_pos;
  OM_integer        err_type;
  OM_object	      desc;
  OM_object	      copy;
  OM_return_code    rc;
  OM_descriptor     null_desc = OM_NULL_DESCRIPTOR;
  int               error = 0;

  /* 
   * Just allocate space for a null descriptor and one other 
   * descriptor, no class descriptor required.
   */
  if ((copy = (OM_descriptor *)malloc((2) * sizeof(OM_descriptor))) == 0)
  error++;

  if ((rc = omX_fill(DS_DONT_USE_COPY, OM_S_BOOLEAN, OM_FALSE, 0, 
					&copy[0])) != OM_SUCCESS)
      error++;

  copy[1] = null_desc;

.ne 3
  *use_copy_obj = copy;
  return (error?0:1);
}


/*
 * Build a filter object from a filter string using the XOM Convenience
 * Function omX_string_to_object().
 */
int
build_filter_object(
  OM_workspace workspace,
  char 	 *filter,
  OM_object	 *filter_obj
)
{
  OM_integer        err_pos;
  OM_integer        err_type;
  OM_string	      filter_str;
  OM_return_code    rc;
  int               error = 0;

  filter_str.length = strlen(filter);
  filter_str.elements = filter;
  if ((rc = omX_string_to_object(workspace, &filter_str, DS_C_FILTER, 
              OM_TRUE, filter_obj, &err_pos, &err_type)) != OM_SUCCESS)
      error++;

  return (error?0:1);
}


/*
 * Free the name and attribute list objects in the entry list.  Objects 
 * which have been created using the XOM Convenience Function 
 * omX_string_to_object() must be deleted using om_delete().
 */
int
free_entry_list(
  struct entry       entry_array[]
)
{
  OM_object	      attr_list_obj;
  int		      i, j;
  int		      error = 0;

.ne 7
  for (i = 0; i < NO_OF_ENTRIES; i++)  {

      /* 
       * Delete the service generated public name object .
       */
      if (om_delete(entry_array[i].name) != OM_SUCCESS)
          error++;

      /*
       * The last two attribute lists were the same as the 4th one.
       */
      if (i < NO_OF_ENTRIES-2) {
          attr_list_obj = entry_array[i].attr_list;
          for (j = 0; attr_list_obj[j].type != OM_NO_MORE_TYPES; j++) {
              if (attr_list_obj[j].type == DS_ATTRIBUTES)

.ne 7
      	    /* 
      	     * Delete the service generated public attribute object.
      	     */
      	    if (om_delete(attr_list_obj[j].value.object.object) 
      						!= OM_SUCCESS)
      	        error++;
          }

          /* 
           * Free the whole attribute list object.
           */
            free(attr_list_obj);
      }
  }

  return (error?0:1);
}
.oE
.ps 12
.vs 14
.H 3 "The acl2.h Header File"
.P
.iX "\*Lacl2.h\*O" "header file"
The \*Lacl2.h\*O header file performs the following:
.AL
.LI
It exports the object identifiers that \*Lacl2.c\*O requires.
.LI
It declares a structure to contain the name and attributes of directory
entries.
.LI
It defines abbreviated names for the directory entries.
.LI
.ne 4
It defines abbreviated names for the directory attributes.
.LI
It builds the descriptor list for optional packages that are
to be negotiated.
.LE
.P
The following code is a listing of the \*Lacl2.h\*O file:
.nL
.ps 11
.vs 13
.oS
.ne 20
/***************************************************************
*                                                              *
*  COPYRIGHT (C) SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1991   *
*                ALL RIGHTS RESERVED                           *
*                                                              *
***************************************************************/

#ifndef _ACL2_H
#define _ACL2_H

#define MAX_DN_LEN 100  /* max length of a distinguished name in  */
                        /* string format.                         */

/* Step 1 */

/* The application must export the object identifiers it requires. */

OM_EXPORT (DS_C_DS_DN)
OM_EXPORT (DS_C_ENTRY_INFO_SELECTION)
OM_EXPORT (DS_C_ATTRIBUTE)
OM_EXPORT (DS_C_ATTRIBUTE_LIST)
OM_EXPORT (DS_C_FILTER)
OM_EXPORT (DSX_C_GDS_SESSION)
OM_EXPORT (DSX_C_GDS_CONTEXT)
OM_EXPORT (DSX_A_ACL)

/* Structure to contain the name and attribute list               */
/* of a directory entry.                                          */

struct entry {
    OM_private_object   name;
    OM_object           attr_list;
} Entry;

.ne 11
/* Step 2  */
/*
 * Names of directory entries, in string format.
 */
#define DN_ROOT         "/"
#define DN_DE           "/C=de"
#define DN_SNI          "/C=de/O=sni"
#define DN_AP           "/C=de/O=sni/OU=ap"
#define DN_STEFANIE     "/C=de/O=sni/OU=ap/CN=stefanie"
#define DN_NORBERT      "/C=de/O=sni/OU=ap/CN=norbert"
#define DN_INGRID       "/C=de/O=sni/OU=ap/CN=ingrid"

/* 
 * Attributes, in string format.
 */
#define OBJ_CLASS_C     "OCL = TOP; C"
#define OBJ_CLASS_O     "OCL = TOP; ORG"
#define OBJ_CLASS_OU    "OCL = TOP; OU"
#define OBJ_CLASS_OP    "OCL = TOP; PER; ORP"
#define ATT_PHONE_NUM   "TN = '+49 89 636 0' "
#define ATT_PASSWORD    "UP = secret"
#define ATT_SURNAME     "SN = Schmid"
#define ATT_ACL1  "ACL={MPUB = {INT = 1,USR = {/}}, \e
          RSTD = {INT = 0,USR = {/C=de/O=sni/OU=ap/CN=stefanie}},\e
          MSTD = {INT = 0,USR = {/C=de/O=sni/OU=ap/CN=stefanie}},\e
          RSEN = {INT = 0,USR = {/C=de/O=sni/OU=ap/CN=stefanie}},\e
          MSEN = {INT = 0,USR = {/C=de/O=sni/OU=ap/CN=stefanie}}}"
#define ATT_ACL2  "ACL={MPUB = {INT = 1,USR = {/C=de/O=sni/OU=ap}},\e
          RSTD = {INT = 1,USR = {/C=de/O=sni/OU=ap}},\e
          MSTD = {INT = 0,USR = {/C=de/O=sni/OU=ap/CN=stefanie}},\e
          RSEN = {INT = 1,USR = {/C=de/O=sni/OU=ap}},\e
          MSEN = {INT = 0,USR = {/C=de/O=sni/OU=ap/CN=stefanie}}}"

/* Other strings.                                                 */ 
#define PASSWD          "secret"
#define FILTER          "OCL"

#define NO_OF_ENTRIES   6   /* 6 entries to be added              */
#define NO_C_ATTRS      1   /* 1 attr in Country attribute list   */
#define NO_O_ATTRS      2   /* 2 attr in Org attribute list       */
#define NO_OU_ATTRS     1   /* 1 attr in Org-Unit attribute list  */
#define NO_OP_ATTRS     5   /* 5 attr in Org-Person attribute list*/

.ne 7
/* Build up an array of object identifiers for the optional       */
/* packages to be negotiated.                                     */
DS_feature features[] = {
    { OM_STRING(OMP_O_DS_BASIC_DIR_CONTENTS_PKG), OM_TRUE },
    { OM_STRING(OMP_O_DSX_GDS_PKG), OM_TRUE },
    { 0 }
};

#endif /* _ACL2_H */
.oE
.ps 12
.vs 14
.H 3 "Example Strings"
.P
This section contains examples of input strings to
\*LomX_string_to_object(\|)\*O and some examples of strings that can
be returned by \*LomX_object_to_string(\|)\*O.
.H 4 "Input Strings to \*LomX_string_to_object(\|)\*O"
.P
The following are examples of strings that can be handled by 
the \*LomX_string_to_object(\|)\*O function.
.H 5 "Example 1"
.P
To create a \*LDS_C_DS_DN\*O object (Root), use strings like the
following:
.iS
/
/...
.iE
.nL
.ne 20
.H 5 "Example 2"
.P
To create other \*LDS_C_DS_DN\*O objects, use strings like the
following:
.iS
/c=de/o=sni/ou=ap11/cn=naik,sn=naik
/c=de/o=sni/ou=ap11/85.4.3=naik,sn=naik
/c=de/o=sni/ou=ap11/cn=naik,sn=na\ex69k
/c=de/o=sni/ou=ap11/cn=naik,loc=Muenchen\e,8000
/c=de/o=sni/ou=ap11/cn=naik,loc='Muenchen,8000'
/ C = de / O = sni / Ou = ap11/CN=naik, SN=naik
.iE
.H 5 "Example 3"
.P
To create a \*LDS_C_DS_DN\*O object (DCE name), use a string like the
following:
.iS
/.../c=us/o=osf/ou=abc/subsystems/server/xyz
.iE
.H 5 "Example 4"
.P
To create a \*LDS_C_DS_RDN\*O object, use strings like the following:
.iS
cn=naik,sn=naik
cn=naik,sn=na\ex69k
CN = naik, SN = naik\*O
.iE
.H 5 "Example 5"
.P
To create a \*LDS_C_DS_RDN\*O object (DCE name), use a string like 
the following:
.iS
server
.iE
.H 5 "Example 6"
.P
To create a \*LDS_C_ATTRIBUTE\*O object (containing, 
for example, \*LCommon-Name\*O), use strings like the following:
.iS
cn=bhavesh naik
CN = bhavesh naik
85.4.3=bhavesh nai\ex69k\*O
.iE
.H 5 "Example 7"
.P
To create a \*LDS_C_ATTRIBUTE\*O object (containing an object class 
with multiple values of \*LResidential-Person\*O and 
\*LOrganizational-Person\*O), use strings like the following:
.iS
OCL=REP;ORP
OCL = '\ex55\ex06\ex0a' ; '\ex55\ex06\ex07'\*O
.iE
.H 5 "Example 8"
.P
To create a \*LDS_C_ATTRIBUTE\*O object (containing a GDS structured attribute 
like \*LTelex-Number\*O or \*LOwner\*O), use strings like the following:
.iS
TXN={TN=12345,CC=678,AB=90}
TXN = { TN = 12345, CC = 678, AB = 90}
own={/c=de/o=sni/ou=ap11};{/c=de/o=sni/ou=ap22}
pa={pa='Wilhelm Riehl Str.85';'Munich'}\*O
.iE
.H 5 "Example 9"
.P
To create a \*LDSX_C_GDS_ACL\*O object, use a string like the following:
.iS
MPUB={INT=0, USR={/c=de/o=sni/cn=naik, sn=bhavesh}}\*O
.iE
.H 5 "Example 10"
.P
To create a \*LDS_C_PRESENTATION_ADDRESS\*O object, use a string like the following:
.iS
TS=Server,NA='TCP/IP!internet=127.0.0.1+port=25015'\*O
.iE
.H 5 "Example 11"
.P
To create a \*LDS_C_FILTER\*O object, use strings like the following:
.iS
c
!c
C = de && CN = 'bha\ex76esh naik'
c=de&&cn~=mueller
c = de && (cn = 'a*' || cn = b* || cn = c* )
ACL={MPUB={INT=0,USR={/c=de/o=sni/cn=naik, sn=bhavesh}}}
c = de || cn = *aa*bb*cc*
(cn ~=naik)&&((OCL=ORP)||(OCL=REP))&& !(SN='bhavesh naik')&&(L=*)\*O
.iE
.H 5 "Example 12"
.P
The following is an
example of the error return when an erroneous string is supplied:
.iS
/c=de/o=sni,=de\*O
.iE
.P
The \*LOM_return_code\*O would be \*LOM_WRONG_VALUE_MAKEUP\*O.
.P
The \*Lerror_type\*O would be \*LOMX_MISSING_ABBRV\*O.
.P
The \*Lerror_position\*O would be 13.
.H 4 "Strings Returned by \*LomX_object_to_string(\|)\*O"
The following are examples of strings returned by the
\*LomX_object_to_string(\|)\*O function.
.H 5 "Example 1"
.P
If a \*LDS_C_DS_DN\*O object is supplied, the following might be returned:
.oS
/
/C=de/O=sni/OU=ap11/CN=naik,SN=naik
/C=de/O=sni/OU=ap11/CN=naik,LOC=Muenchen\e,8000\*O
.oE
.H 5 "Example 2"
.P
If a \*LDS_C_DS_RDN\*O object is supplied, the following might be returned:
.oS
CN=naik,SN=naik
server
.oE
.H 5 "Example 3"
.P
If a \*LDS_C_ATTRIBUTE\*O object is supplied, the following might be returned:
.oS
CN=bhavesh naik
OCL=REP;ORP
TXN={AB=90,CC=678,TN=12345}
OWN={/C=de/O=sni/OU=ap11};{/C=de/O=sni/OU=ap22}\*O
.oE
.H 5 "Example 4"
.P
If a \*LDSX_C_GDS_ACL\*O object is supplied, the following might be returned:
.oS
MPUB={INT=0,USR={/C=de/O=sni/CN=naik,SN=bhavesh}}\*O
.oE
.H 5 "Example 5"
.P
If a \*LDS_C_NAME_ERROR\*O object is supplied with \*LDS_PROBLEM\*O of
\*LDS_E_NO_SUCH_OBJECT\*O, the following might be returned:
.oS
The specified name does not match the name of any object 
in the directory
.oE
.H 5 "Example 6"
.P
If a \*LDS_C_ATTRIBUTE_ERROR\*O object is supplied with 
\*LDS_C_ATTRIBUTE_PROBLEM\*O containing 
\*LDS_\%E_\%ATTRIBUTE_\%OR_\%VALUE_\%EXISTS\*O,
the following might be returned:
.oS
An attempt is made to add an attribute or value that already 
exists.  Violating Attribute - Telephone-Number
.oE
