...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
...\" src directory for the full copyright text.
...\" 
...\" HISTORY
...\" $Log: 4_sample_apps.gpsml,v $
...\" Revision 1.1.10.1  1996/09/03  18:14:29  wardr
...\" 	{enh,R1.2.2}
...\" 	Update for sgml conversion
...\" 	[1996/09/03  18:13:30  wardr]
...\"
...\" Revision 1.1.8.15  1995/06/15  16:29:06  rcb
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/13  19:26:45  rcb]
...\" 
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/08  14:51:15  rcb]
...\" 
...\" Revision 1.1.8.14  1994/10/18  18:02:07  rnollman
...\" 	dublin edits
...\" 	[1994/10/18  18:01:48  rnollman]
...\" 
...\" Revision 1.1.8.13  1994/10/17  21:33:19  rnollman
...\" 	incorporated editorial changes from Dublinx
...\" 	[1994/10/17  21:33:01  rnollman]
...\" 
...\" Revision 1.1.8.12  1994/10/14  14:30:00  rnollman
...\" 	incorporated technical changes from Dublin
...\" 	[1994/10/14  14:29:43  rnollman]
...\" 
...\" Revision 1.1.8.11  1994/08/05  14:01:38  rnollman
...\" 	completed osf edits
...\" 	[1994/08/05  13:58:43  rnollman]
...\" 
...\" Revision 1.1.8.10  1994/05/14  22:32:41  rnollman
...\" 	last submittal for beta
...\" 	[1994/05/14  22:29:48  rnollman]
...\" 
...\" Revision 1.1.8.9  1994/05/12  15:21:58  rnollman
...\" 	final udpate for beta
...\" 	[1994/05/12  15:21:24  rnollman]
...\" 
...\" Revision 1.1.8.8  1994/03/14  22:00:32  rom
...\" 	{enh, 10129, R1.1}
...\" 	Fix pathnames of included files for new three-book organization.
...\" 	[1994/03/14  21:20:07  rom]
...\" 
...\" Revision 1.1.8.7  1994/03/14  15:20:21  rnollman
...\" 	no changes - submitting for reorg of book
...\" 	[1994/03/14  15:19:58  rnollman]
...\" 
...\" Revision 1.1.8.6  1993/11/11  21:23:52  rnollman
...\" 	update SNI copyright
...\" 	[1993/11/11  21:23:36  rnollman]
...\" 
...\" Revision 1.1.8.5  1993/10/27  19:52:02  rnollman
...\" 	fixed Pic pathnames
...\" 	[1993/10/27  19:51:38  rnollman]
...\" 
...\" Revision 1.1.8.4  1993/10/27  18:46:21  rnollman
...\" 	replaced old version with new version from Dublin
...\" 	[1993/10/27  18:46:02  rnollman]
...\" 
...\" Revision 1.1.8.3  1993/08/17  21:51:16  buckler
...\" 	{edit, R1.0.3}
...\" 	Fixed incorrect Release number in change markers for CR 8400
...\" 	(changed "1.1.1" to "1.0.2a").
...\" 	[1993/08/17  19:07:28  buckler]
...\" 
...\" Revision 1.1.8.2  1993/08/02  20:01:33  lmk
...\" 	{def, 8400, R1.0.2a}
...\" 	Fixed include statements in Sections 28.2.1 and 28.3.1 by deleting
...\" 	"dce" from the statements.
...\" 	[1993/08/02  19:21:16  lmk]
...\" 
...\" Revision 1.1.6.5  1993/02/22  18:24:59  rnollman
...\" 	fix to example.c sample program
...\" 	[1993/02/22  18:24:20  rnollman]
...\" 
...\" Revision 1.1.6.4  1993/02/08  18:39:48  rnollman
...\" 	fixed software bug 7060; changed code in sample program: example.c
...\" 	[1993/02/08  18:38:57  rnollman]
...\" 
...\" Revision 1.1.6.3  1993/01/28  18:41:31  cjd
...\" 	Embedded copyright notice
...\" 	[1993/01/28  18:01:02  cjd]
...\" 
...\" Revision 1.1.6.2  1992/11/20  16:23:22  weir
...\" 	Moved into 1.0.2doc tree
...\" 	[1992/11/20  16:18:25  weir]
...\" 
...\" Revision 1.1.4.6  1992/11/11  23:47:09  buckler
...\" 	Corrected index entries
...\" 	[1992/11/11  22:50:33  buckler]
...\" 
...\" Revision 1.1.4.5  1992/10/29  17:11:35  lmk
...\" 	Prentice-Hall index entries only
...\" 	[1992/10/29  16:58:28  lmk]
...\" 
...\" Revision 1.1.4.4  1992/10/27  21:12:37  lmk
...\" 	Prentice Hall edits only
...\" 	[1992/10/27  21:10:42  lmk]
...\" 
...\" Revision 1.1.4.3  1992/10/15  21:17:50  steiner
...\" 	Second P-H pass - mostly moving code to left margin.
...\" 	[1992/10/15  21:17:19  steiner]
...\" 
...\" Revision 1.1.4.2  1992/09/24  13:48:03  steiner
...\" 	First editing pass for P-H (Eddie).
...\" 	[1992/09/24  13:47:17  steiner]
...\" 
...\" Revision 1.1.2.23  1992/07/21  14:25:19  rnollman
...\" 	fixed typos from Brian Keane list.
...\" 	[1992/07/21  14:19:58  rnollman]
...\" 
...\" 	rev comments
...\" 	[1992/07/09  15:24:17  rnollman]
...\" 
...\" Revision 1.1.2.22  1992/07/17  19:06:30  weir
...\" 	Fixed various typos, etc.
...\" 	[1992/07/17  18:59:38  weir]
...\" 
...\" Revision 1.1.2.21  1992/06/22  20:47:02  rnollman
...\" 	review comments
...\" 	[1992/06/22  20:45:53  rnollman]
...\" 
...\" Revision 1.1.2.20  1992/06/19  15:26:00  rnollman
...\" 	rev comments
...\" 	[1992/06/19  15:25:04  rnollman]
...\" 
...\" Revision 1.1.2.19  1992/06/19  15:18:51  rnollman
...\" 	rev comments
...\" 	[1992/06/19  15:17:53  rnollman]
...\" 
...\" Revision 1.1.2.18  1992/06/18  17:53:56  rnollman
...\" 	rev comments
...\" 	[1992/06/18  17:53:11  rnollman]
...\" 
...\" Revision 1.1.2.17  1992/06/18  17:39:06  rnollman
...\" 	rev comments
...\" 	[1992/06/18  17:38:03  rnollman]
...\" 
...\" Revision 1.1.2.16  1992/06/17  21:45:40  rnollman
...\" 	rev comments
...\" 	[1992/06/17  21:44:43  rnollman]
...\" 
...\" Revision 1.1.2.15  1992/06/17  19:06:06  rnollman
...\" 	rev comments
...\" 	[1992/06/17  19:05:22  rnollman]
...\" 
...\" Revision 1.1.2.14  1992/06/17  12:24:16  rnollman
...\" 	rev comments
...\" 	[1992/06/17  12:23:31  rnollman]
...\" 
...\" Revision 1.1.2.13  1992/06/16  14:44:49  rnollman
...\" 	rev comments
...\" 	[1992/06/16  14:43:15  rnollman]
...\" 
...\" 	rev comments
...\" 	[1992/06/12  18:48:10  rnollman]
...\" 
...\" Revision 1.1.2.12  1992/06/12  15:53:12  rnollman
...\" 	rev comments
...\" 	[1992/06/12  15:51:59  rnollman]
...\" 
...\" Revision 1.1.2.11  1992/06/11  19:38:04  rnollman
...\" 	rev comments
...\" 	[1992/06/11  19:36:53  rnollman]
...\" 
...\" Revision 1.1.2.10  1992/06/11  16:05:41  rnollman
...\" 	rev comments
...\" 	[1992/06/11  16:04:33  rnollman]
...\" 
...\" Revision 1.1.2.9  1992/06/09  15:07:21  rnollman
...\" 	rev comments
...\" 	[1992/06/09  15:06:20  rnollman]
...\" 
...\" Revision 1.1.2.8  1992/06/09  14:04:06  rnollman
...\" 	rev comments
...\" 	[1992/06/09  14:02:49  rnollman]
...\" 
...\" Revision 1.1.2.7  1992/06/08  21:08:52  rnollman
...\" 	inc comments
...\" 	[1992/06/08  21:08:13  rnollman]
...\" 
...\" Revision 1.1.2.6  1992/06/08  12:57:48  rnollman
...\" 	inc comments.
...\" 	[1992/06/08  12:57:01  rnollman]
...\" 
...\" Revision 1.1.2.5  1992/06/08  11:43:28  rnollman
...\" 	rev comments
...\" 	[1992/06/08  11:42:53  rnollman]
...\" 
...\" Revision 1.1.2.4  1992/06/05  22:36:16  rnollman
...\" 	inc rev comments.
...\" 	[1992/06/05  22:35:43  rnollman]
...\" 
...\" Revision 1.1.2.3  1992/05/10  20:51:23  weir
...\" 	New version.
...\" 	[1992/05/10  20:51:00  weir]
...\" 
...\" Revision 1.1.2.2  1992/05/08  21:27:37  weir
...\" 	Initial check-in.
...\" 	[1992/05/08  21:27:04  weir]
...\" 
...\" $EndLog$
...\"
...\" /*****************************************************************
...\" *                                                                *
...\" * COPYRIGHT   (C)  SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1994   *
...\" *                  ALL RIGHTS RESERVED                           *
...\" *                                                                *
...\" *****************************************************************/
.H 1 "Sample Application Programs"
.P
This chapter contains three sample programs and the header files that are
included in them (in parentheses), as follows:
.iX "XDS" "sample programs"
.iX "XDS" "API" "\*Lexample.c\*O"
.iX "XDS" "API" "\*Lacl.c\*O"
.ML
.LI
\*Lexample.c\*O (\*Lexample.h\*O)
.LI
\*Lacl.c\*O (\*Lacl.h\*O)
.LI
\*Lteldir.c\*O 
.LE
.P
Most of the concepts that you will need to know to understand and use these
programs are discussed in previous chapters in this guide.
The programs are arranged so that the simplest program (\*Lexample.c\*O)
is presented first and the most complex program (\*Lteldir.c\*O) is
presented last.  The three programs demonstrate basic XDS and XOM API
principles and concepts in operation.  The \*Lteldir.c\*O program
is considerably more
complex and uses a more sophisticated approach.  It allows the user to
enter values dynamically; for example, a surname and phone number.
.P
For a sample XDS application that uses threads, please refer to Chapter 8.
The \*Lacl.c\*O sample program is presented again in Chapter 9, this time 
using the XDS/XOM convenience routines.
.H 2 "General Programming Guidelines"
.P
.iX "XDS" "programming guidelines"
Writing an application program by using XDS and XOM APIs involves the
following general steps before you begin coding:
.AL
.LI
Select the interface functions that you will need for your application and
determine the parameters for the function calls.
.LI
Check for abstract OM classes and superclasses of objects that you will
manipulate for inherited OM attributes in Part 4.
.LI
Find the correct symbolic constants of the appropriate packages; these can
be found in the header files included with the GDS API, such
as \*Lxdsbdcp.h\*O.
.LI
Determine the error handling required.
.LE
.H 2 "The example.c Program"
.P
.iX "\*Lexample.c\*O"
The \*Lexample.c\*O program
uses XDS API in synchronous mode to read a telephone number
or numbers of a distinguished name.  The program consists of the
following general steps:
.AL
.LI
Define the required object identifier constants.
.LI
Declare the variables involved with directory service
operations (Steps 3, 4, 7,
8, and 9).
.LI
Build the distinguished name of \*LPeter Piper\*O as a public object for the
input parameter to \*Lds_read(\|)\*O.
.LI
Build a public object for the \*Vselection\*O parameter to \*Lds_read(\|)\*O.
.LI
Declare the variables to extract the telephone numbers by using \*Lom_get(\|)\*O.
.LI
Initialize the directory service and get an OM workspace.
.LI
Pull in the required packages.
.LI
Bind to a default directory session.
.LI
Perform the read operation to extract the telephone number of a
distinguished name from the directory.
.LI
Terminate the directory service session.
.LI
Extract the telephone number(s) by using a series of \*Lom_get(\|)\*O calls.
.LI
Release the storage occupied by private and public objects that are no
longer needed.
.LI
Print the telephone number string.
.LI
Release the storage occupied by
public objects containing telephone numbers.
.LI
Continue processing and exit.
.LE
.P
Step 1 uses the \*LOM_EXPORT\*O macro to allocate memory for the
object identifier constants that represent an OM class or OM attribute.
These constants are the OM attribute values that are used to build
the public objects that are required as input to \*Lds_read(\|)\*O.
.P
Step 2 declares the variables for directory service operations and error
handling.  The \*Vsession\*O and \*Vworkspace\*O variables
are required for binding
a session to a server and creating a workspace into which
\*Lds_read(\|)\*O can deposit the results of the read operation on the
directory.
.P
The \*Vresult\*O variable is a pointer that is returned by \*Lds_read(\|)\*O
to the workspace.  The information stored in \*Vresult\*O is in
implementation-specific private format that is
not accessible directly by the
application program.  Subsequent \*Lom_get(\|)\*O calls extract the telephone
number(s) requested by the program from \*Vresult\*O and store the
information in the variable \*Vtelephones\*O (declared in Step 5).
.P
The \*Verror\*O and \*Vreturn_code\*O variables
are used by the program for error
handling.  The \*Verror\*O variable
is used for processing the return code from
XDS API function calls.  The \*Vreturn_code\*O variable
is used by the error handling
header file \*Lexample.h\*O for processing return codes from \*Lom_get(\|)\*O
function calls.
.P
Step 3 builds the public object representing the distinguished
name of \*LPeter Piper\*O.  The program uses statically defined public objects
to demonstrate the basic principles of building public objects.  However,
a more sophisticated approach is presented in the last sample program
in this chapter, \*Lteldir.c\*O.  The \*Lteldir.c\*O program
dynamically defines
a public object from a user-supplied name in DCE string format.
.P
.ne 7
In this program (\*Lexample.c\*O), the process starts with the definition of
an array of descriptor lists as AVAs.  These AVAs are public objects that
are included in the definition of RDNs.  The RDNs, in turn, are included
in the distinguished name of \*LPeter Piper\*O stored in \*Lname\*O.  Using the
same method of static definition, Step 4 defines the
\*LDS_\%C_\%ENTRY_\%INFO_\%SELECTION\*O public object and stores it in the
variable \*Vselection\*O.  The \*Vname\*O and \*Vselection\*O variables
are required as input parameters to \*Lds_read(\|)\*O.  
This process is described in detail in Chapter 6.
.P
Step 5 declares the variables required by \*Lom_get(\|)\*O to extract
the telephone number(s) from \*Vresult\*O.  The \*Ventry_list\*O,
\*Vattributes_list\*O, and \*Vtelephone_list\*O variables
are of type \*LOM_type\*O
and are initialized to the values of the OM attribute types \*LDS_ENTRY\*O,
\*LDS_ATTRIBUTES\*O, and \*LDS_\%ATTRIBUTE_\%VALUES\*O, respectively.
\*LDS_ENTRY\*O contains the selected list of entries,
\*LDS_ATTRIBUTES\*O contains the selected list of attribute types, and
\*LDS_ATTRIBUTE_VALUES\*O contains the actual values of the telephone
numbers.
.P
The \*Ventry\*O, \*Vattributes\*O, and \*Vtelephones\*O variables
are of type
\*LOM_public_object\*O because they store the output parameters
of \*Lom_get(\|)\*O.  The \*Lom_get(\|)\*O call
makes these objects available to the
application program as public object data types.  The program must
remove layers of objects and subobjects to get at
the actual string data values of the telephone numbers.
.P
The \*Vtelephones\*O variable
contains the actual string values of the telephone
number(s).  It is a descriptor in the array of descriptors that make
up the public object that contains the actual string data that the
program wants to extract from the directory.
.P
Step 6 initializes the directory service and gets an OM workspace
in which \*Lds_read(\|)\*O deposits the result of the read operation.
.P
Step 7 pulls the basic directory contents package into
the program because it contains features that are required by the program
not included in the default package (the directory service package).
.P
.ne 10
Step 8 binds the session to the default session.  An application
program can bind with a specifically tailored session object, by using an
instance of OM class \*LDS_C_SESSION\*O.  In most cases, however, it
is sufficient to use the constant \*LDS_DEFAULT_SESSION\*O.
\*LDS_DEFAULT_SESSION\*O uses the default values of \*LDS_C_SESSION\*O
and the values of specific OM attributes that are set locally in the
cache.  These OM attributes are \*LDS_\%DSA_\%ADDRESS\*O (the address of
the default DSA) and \*LDS_\%DSA_\%NAME\*O (the distinguished name of the
default DSA).  It is the responsibility of local administrators to
make sure that these default values are set correctly in the cache.
.P
Step 9 performs the read operation and deposits the result in the
workspace in \*Vresult\*O.  The \*VSresult\*O variable
is one of the input parameters
for the \*Lom_get(\|)\*O function call.  The \*Lsession\*O variable and
the \*LDS_\%DEFAULT_\%CONTEXT\*O constant
are the \*Vsession\*O and \*Vcontext\*O parameters
required to be present in the \*Lds_read(\|)\*O function call.
.P
The \*Vname\*O variable
holds the public object representing the distinguished name of
\*LPeter Piper\*O; the \*Vselection\*O variable
contains the public object indicating which
attributes and values are selected by the read operation from the entry.
The \*Vinvoke_id\*O parameter
is not used by the DCE implementation of XDS and is
ignored.
.P
Step 10 terminates the directory session.
.P
Step 11 uses a series of \*Lom_get(\|)\*O calls
to extract the telephone
number(s).
The first \*Lom_get(\|)\*O extracts the information about the entry
from \*Vresult\*O and puts it in \*Ventry\*O.  The second \*Lom_get(\|)\*O
extracts the attribute types from \*Ventry\*O and puts them in
\*Vattributes\*O.  The third \*Lom_get(\|)\*O extracts the actual values of the
telephone numbers from \*Vattributes\*O and puts them in \*Vtelephones\*O.
The \*Vtelephones\*O variable contains the string data values of the telephone
number(s).
.P
Step 12 releases the storage occupied by the private and public
objects that are no longer needed.  The program has the data values in
\*Vtelephone\*O that it needs to continue processing.  A \*Lds_shutdown(\|)\*O
call is issued to shut down the interface established by
\*Lds_initialize(\|)\*O.
.P
.ne 7
Step 13 prints out each telephone number associated with the
distinguished name \*LPeter Piper\*O in the directory, or returns
an error message
if the number is not in the correct format.   It checks for
an attribute with type \*LDS_ATTRIBUTE_VALUES\*O and a syntax of
\*LOM_\%S_\%PRINTABLE_\%STRING\*O, the proper syntax for a telephone number.
The constant \*LOM_S_SYNTAX\*O is used to mask the six high-order bits
in the syntax because they are used internally by the XOM service.
.P
Step 14 releases the storage occupied by \*Vtelephones\*O because
it is no longer needed.
.P
Step 15 continues processing and exits.
.H 3 "The example.c Code"
.P
The following code is a listing of the \*Lexample.c\*O program:
.nL
.ps 11
.vs 13
.oS
/*
 * sample application that uses XDS in synchronous mode
 *
 * This program reads the telephone number(s) of a given target name.
 */

#ifdef THREADSAFE
#include <pthread.h>
#endif

#include <stdio.h>

#include <xom.h>
#include <xds.h>
#include <xdsbdcp.h>

#include "example.h"          /* possible Error Handling header */

.ne 13
/* Step 1 */
 *
 * Define necessary Object Identifier constants
 */
OM_EXPORT(DS_A_COMMON_NAME)
OM_EXPORT(DS_A_COUNTRY_NAME)
OM_EXPORT(DS_A_ORG_NAME)
OM_EXPORT(DS_A_ORG_UNIT_NAME)
OM_EXPORT(DS_A_PHONE_NBR)
OM_EXPORT(DS_C_AVA)
OM_EXPORT(DS_C_DS_DN)
OM_EXPORT(DS_C_DS_RDN)
OM_EXPORT(DS_C_ENTRY_INFO_SELECTION)

/* Step 2 */

int main(void)
{
  DS_status          error;       /* return value from DS functions   */
  OM_return_code     return_code; /* return value from OM functions   */
  OM_workspace       workspace;   /* workspace for objects            */
  OM_private_object  session;     /* session for directory operations */
  OM_private_object  result;      /* result of read operation         */
  OM_sint            invoke_id;   /* Invoke-ID of the read operation  */
  OM_value_position  total_num;   /* Number of Attribute Descriptors  */

  static DS_feature	bdcp_package[] = {
     { OM_STRING(OMP_O_DS_BASIC_DIR_CONTENTS_PKG), OM_TRUE },
     { { (OM_uint32)0, (void *)0 }, OM_FALSE },
     };

/* Step 3 */
 *
 * Public Object ("Descriptor List") for Name parameter to ds_read().
 * Build the Distinguished-Name of Peter Piper.
 */

  static OM_descriptor	country[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COUNTRY_NAME),
    { DS_ATTRIBUTE_VALUES,OM_S_PRINTABLE_STRING,OM_STRING("US") },
    OM_NULL_DESCRIPTOR
    };
.ne 7
  static OM_descriptor	organization[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_NAME),
    { DS_ATTRIBUTE_VALUES,OM_S_TELETEX_STRING,
    OM_STRING("Acme Pepper Co") },
    OM_NULL_DESCRIPTOR
    };
  static OM_descriptor	organizational_unit[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_UNIT_NAME),
    { DS_ATTRIBUTE_VALUES,OM_S_TELETEX_STRING,OM_STRING("Research") },
    OM_NULL_DESCRIPTOR
    };
  static OM_descriptor	common_name[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COMMON_NAME),
    { DS_ATTRIBUTE_VALUES,OM_S_TELETEX_STRING,OM_STRING("Peter Piper") },
    OM_NULL_DESCRIPTOR
    };

  static OM_descriptor	rdn1[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    { DS_AVAS, OM_S_OBJECT, { 0, country } },
    OM_NULL_DESCRIPTOR
    };
  static OM_descriptor	rdn2[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    { DS_AVAS, OM_S_OBJECT, { 0, organization } },
    OM_NULL_DESCRIPTOR
    };
  static OM_descriptor	rdn3[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    { DS_AVAS, OM_S_OBJECT, { 0, organizational_unit } },
    OM_NULL_DESCRIPTOR
    };
  static OM_descriptor	rdn4[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    { DS_AVAS, OM_S_OBJECT, { 0, common_name } },
    OM_NULL_DESCRIPTOR
    };

.ne 8
  OM_descriptor    name[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_DN),
    { DS_RDNS, OM_S_OBJECT, { 0, rdn1 } },
    { DS_RDNS, OM_S_OBJECT, { 0, rdn2 } },
    { DS_RDNS, OM_S_OBJECT, { 0, rdn3 } },
    { DS_RDNS, OM_S_OBJECT, { 0, rdn4 } },
    OM_NULL_DESCRIPTOR
    };

/* Step 4 */

/*	
 *
 * Public Object ("Descriptor List") for
 * Entry-Information-Selection parameter to ds_read().
*/
  OM_descriptor selection[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ENTRY_INFO_SELECTION),
    { DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, { OM_FALSE, NULL } },
    OM_OID_DESC(DS_ATTRIBUTES_SELECTED, DS_A_PHONE_NBR),
    { DS_INFO_TYPE,OM_S_ENUMERATION, { DS_TYPES_AND_VALUES,NULL } },
    OM_NULL_DESCRIPTOR
    };

/* Step 5 */

/*
 * variables to extract the telephone number(s)
 */
  OM_type           entry_list[]      = { DS_ENTRY, 0 };
  OM_type           attributes_list[] = { DS_ATTRIBUTES, 0 };
  OM_type           telephone_list[]  = { DS_ATTRIBUTE_VALUES, 0 };
  OM_public_object  entry;
  OM_public_object  attributes;
  OM_public_object  telephones;
  OM_descriptor     *telephone;   /* current phone number  */

/*
 * Perform the directory service operations:
 * (1) Initialize the directory service and get a workspace
 * (2) bind a default directory session.
 * (3) read the telephone number of "name".
 * (4) terminate the directory session.
 */

.ne 3
/* Step 6 */

  CHECK_DS_CALL((OM_object) !(workspace=ds_initialize()));

/* Step 7 */

  CHECK_DS_CALL(ds_version(bdcp_package, workspace));

/* Step 8 */

  CHECK_DS_CALL(ds_bind(DS_DEFAULT_SESSION, workspace, &session));

/* Step 9 */

  CHECK_DS_CALL(ds_read(session, DS_DEFAULT_CONTEXT, name,
                         selection, &result, &invoke_id));
/*
 * NOTE: should check here for Attribute-Error (no-such-attribute)
 * in case the "name" doesn't have a telephone.
 * Then for all other cases call error_handler
 */

/* Step 10 */

  CHECK_DS_CALL(ds_unbind(session));

/* Step 11 */

/*
 * extract the telephone number(s) of "name" from the result
 *
 * There are 4 stages:
 * (1) get the Entry-Information from the Read-Result.
 * (2) get the Attributes from the Entry-Information.
 * (3) get the list of phone numbers.
 * (4) scan the list and print each number.
 */

  CHECK_OM_CALL(om_get(result,
                        OM_EXCLUDE_ALL_BUT_THESE_TYPES
                        + OM_EXCLUDE_SUBOBJECTS,
                        entry_list, OM_FALSE, 0, 0, &entry,
                        &total_num));

.ne 5
  CHECK_OM_CALL(om_get(entry->value.object.object,
                        OM_EXCLUDE_ALL_BUT_THESE_TYPES
                        + OM_EXCLUDE_SUBOBJECTS,
                        attributes_list, OM_FALSE, 0, 0, 
                        &attributes, &total_num));

.ne 5
  CHECK_OM_CALL(om_get(attributes->value.object.object,
                        OM_EXCLUDE_ALL_BUT_THESE_TYPES
                        + OM_EXCLUDE_SUBOBJECTS,
                        telephone_list, OM_FALSE, 0, 0, 
                        &telephones, &total_num));

/* Step 12 */

/*  We can now safely release all the private objects
 *  and the public objects we no longer need
 */
  CHECK_OM_CALL(om_delete(session));
  CHECK_OM_CALL(om_delete(result));
  CHECK_OM_CALL(om_delete(entry));
  CHECK_OM_CALL(om_delete(attributes));
  CHECK_DS_CALL(ds_shutdown(workspace));
/* Step 13 */

  for (telephone = telephones;
       telephone->type == DS_ATTRIBUTE_VALUES;
       telephone++)
     {
     if (telephone->type   != DS_ATTRIBUTE_VALUES
       || (telephone->syntax & OM_S_SYNTAX) != OM_S_PRINTABLE_STRING)
        {
        (void) fprintf(stderr, "malformed telephone number\en");
         exit(EXIT_FAILURE);
        }

     (void) printf("Telephone number: %.*s\en",
                   telephone->value.string.length,
                   telephone->value.string.elements);
     }

/* Step 14 */

  CHECK_OM_CALL(om_delete(telephones));

.ne 8
/* Step 15 */

/*  more application-specific processing can occur here...
 */

/* ... and finally exit. */
   exit(EXIT_SUCCESS);
}
.oE
.ps 12
.vs 14
.H 3 "Error Handling"
.P
The \*Lexample.c\*O program
includes the header file \*Lexample.h\*O for error
handling of XDS and XOM function calls.
The \*Lexample.h\*O program contains
two error handling functions: \*LCHECK_DS_CALL\*O for handling XDS
API errors, and \*LCHECK_OM_CALL\*O for handling XOM API errors.
Note that \*LCHECK_DS_CALL\*O and \*LCHECK_OM_CALL\*O are created
specifically for \*Lexample.c\*O and are not part of the XDS or XOM
APIs.  They are included to demonstrate a possible method for error
handling.
.P
XDS and XOM API functions return a status code.  In \*Lexample.c\*O,
\*Verror\*O contains the status code for XDS API functions.  If the
call is successful, the function returns \*LDS_SUCCESS\*O.  Otherwise,
one of the error codes described in Chapter 11 is returned.
.P
The \*Vreturn_code\*O variable
contains the status code for XOM API functions.  If the
call is successful, the function returns \*LOM_SUCCESS\*O.  Otherwise,
one of the error codes described in Chapter 18 is returned.
.P
The contents of \*Lexample.h\*O are as follows:
.nL
.ps 11
.vs 13
.oS
/*
 * define some convenient exit codes
 */

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

.ne 6
/*
 * declare an error handling function and 
 * an error checking macro for DS
 */

void handle_ds_error(DS_status error);

.ne 4
#define CHECK_DS_CALL(function_call)		
               error = (function_call);	
               if (error != DS_SUCCESS)	
                  handle_ds_error(error);

/*
 * declare an error handling function and 
 * an error checking macro for OM
 */

void handle_om_error(OM_return_code return_code);

#define CHECK_OM_CALL(function_call)		
               return_code = (function_call);	
               if (return_code != OM_SUCCESS)	
                  handle_om_error(return_code);

/*
 * the error handling code
 *
 * NOTE: any errors arising in these functions are ignored.
 */

void handle_ds_error(DS_status error)
{
   (void) fprintf(stderr, "DS error has occurred\en");

   (void) om_delete((OM_object) error);

/* At this point, the error has been reported and storage cleaned up, 
 * so the handler could return to the main program now for it to take 
 * recovery action.  But we choose the simple option ...
 */

   exit(EXIT_FAILURE);
}

.ne 11
void handle_om_error(OM_return_code return_code)
{
   (void) fprintf(stderr, "OM error %d has occurred\en", return_code);

/* At this point, the error has been reported and storage cleaned up, 
 * so the handler could return to the main program now for it to take 
 * recovery action.  But we choose the simple option ...
 */

   exit(EXIT_FAILURE);
}
.oE
.ps 12
.vs 14
.H 2 "The acl.c Program"
.iX "\*Lacl.c\*O"
The \*Lacl.c\*O file is a program that displays the ACLs on each entry in
the directory for a specific user.  The permissions are presented in a
form similar to UNIX file permissions.  In addition, each entry is
flagged as either a master or a shadow copy.
.P
The distinguished name of the user requesting the access
permissions is \*L/C=de/O=sni/OU=ap/CN=norbert\*O.  The results of the
request are presented in the following format:
.iS
\*O[\*VABCD\*O] <\*Ventry's distinguished name\*O>
.iE
where:
.P
.VL .5i
.LI "\*VA\*O"
is one of the following:
.ML
.LI
\*Lm\*O (master copy)
.LI
\*Ls\*O (shadow copy)
.LE
.LI "\*VB\*O"
is one of the following:
.ML
.LI
\*Lr\*O (read access to public attributes)
.LI
\*Lw\*O (write access to public attributes)
.LI
\*L-\*O (no access to public attributes)
.LE
.LI "\*VC\*O"
.ne 7
is one of the following:
.ML
.LI
\*Lr\*O (read access to standard attributes)
.LI
\*Lw\*O (write access to standard attributes)
.LI
\*L-\*O (no access to standard attributes))
.LE
.LI "\*VD\*O"
is one of the following:
.ML
.LI
\*Lr\*O (read access to sensitive attributes)
.LI
\*Lw\*O (write access to sensitive attributes)
.LI
\*L-\*O (no access to sensitive attributes)
.LE
.LE
.P
For example, the following result means that the entry \*L/C=de/O=sni\*O
is a master copy, and that the user who is making the request
(\*L/C=de/O=sni/OU=ap/CN=norbert\*O) has write access to its public
attributes, read access to its standard attributes, and no accesss to
its sensitive attributes:
.iS
[mwr-] /C=de/O=sni
.iE
.P
The program requires that the user perform an authenticated bind to
the directory service.  The user's credentials must already exist in the
directory.  For this reason, the tree of six entries shown in Figure 7-1
is added to the directory each time the program runs, and is removed
again afterward.
.P
.ne 5.5i
.FG "Entries with User Credentials Added to the Directory Tree"
.dI ../directory/xds_gds/Pics/fig04.entries.pic
.P
The program consists of the following steps:
.AL
.LI
Export the required object identifiers (see \*Lacl.h\*O in Section 7.3.2).
.LI
Build the descriptor lists for objects required by the program
(see \*Lacl.h\*O in Section 7.3.2).
.LI
Initialize a workspace.
.LI
Negotiate use of the basic directory contents and GDS
packages.
.LI
Add a fixed tree of entries to the directory
to permit an authenticated bind.
.LI
Create a default session object.
.LI
Alter the default session object to include the credentials of the requestor
(\*L/C=de/O=sni/OU=ap/CN=norbert\*O).
.LI
Bind with credentials to the default GDS server.
.LI
Create a default context object and alter it to include shadow entries.
.LI
Search the whole subtree below \*Lroot\*O and extract the ACL attribute from
each selected entry.
.LI
Close the connection to the GDS server.
.LI
Remove the user's credentials from the directory.
.LI
Extract the components from the search result.
.LI
Examine each entry and print the entry details.
.LI
Close the XDS workspace.
.LE
.P
Step 1 through Step 4, Step 6 through Step 8,
Step 12, and Step 15 are similar to those performed for the
previous sample application \*Lexample.c\*O.
.P
Step 5 is included so that the appropriate entries will exist in
the directory when the program attempts to access the access
permissions.
.P
The default session object created in Step 9 uses
\*Lom_create(\|)\*O to create an instance of a default session object, and
it uses
\*Lom_put(\|)\*O to put in the appropriate user credentials.
The \*Vcredentials\*O parameter
is a descriptor list defined in \*Lacl.h\*O header
file.
.P
Step 10 used the same method as Step 9 to alter the default context to
include shadow entries.  Using \*Lom_create(\|)\*O and \*Lom_put(\|)\*O, the OM
attribute \*LDS_DONT_USE_COPY\*O is set to a value of \*LOM_FALSE\*O
to indicate that copies of entries maintained in other DSAs and copies
cached locally (that is, shadow copies) can be used.
The \*Vuse_copy\*O parameter
is a descriptor list defined in the \*Lacl.h\*O header file.
.P
.ne 4
Step 11 uses \*Lds_search(\|)\*O to search the subtree below
\*Lroot\*O to find and extract the ACL attributes from the selected
entries defined in the \*Vselection_acl\*O parameter.
The \*Vselection_acl\*O variable
is a descriptor list defined in \*Lacl.h\*O.  The
results are returned to the workspace in \*Vresult\*O.
.P
.ne 3
Step 13 and Step 14 extract the components from
\*Vresult\*O and examine each entry by using a series of \*Lom_get(\|)\*O
calls, as described in the previous section for \*Lexample.c\*O.
.H 3 "The acl.c Code"
.P
The following code is a listing of the \*Lacl.c\*O program.
.nL
.ps 11
.vs 13
.oS
/***************************************************************
*                                                              *
*  COPYRIGHT (C) SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1991   *
*                ALL RIGHTS RESERVED                           *
*                                                              *
***************************************************************/

/*
 *
 * This sample program displays the access permissions (ACL) on each
 * entry in the directory for a specific user.  The permissions are
 * presented in a form similar to the UNIX file permissions. 
 * In addition, each entry is flagged as either a master
 * or a shadow copy.
 *
 * The distinguished name of the user performing the check is:
 *
 *     /C=de/O=sni/OU=ap/CN=norbert
 *
 * The results are presented in the following format : 
 *
 *     [ABCD] <entry's distinguished name>
 *
 *     A:  'm' master copy
 *         's' shadow copy
 *
 *     B:  'r' read access to public attributes
 *         'w' write access to public attributes
 *         '-' no access to public attributes
 *
.ne 3
 *     C:  'r' read access to standard attributes
 *         'w' write access to standard attributes
 *         '-' no access to standard attributes
 *
 *     D:  'r' read access to sensitive attributes
 *         'w' write access to sensitive attributes
 *         '-' no access to sensitive attributes
 *
 * For example, the following result means that the entry '/C=de/O=sni' 
 * is a master copy and that the requesting user
 * (/C=de/O=sni/OU=ap/CN=norbert) has write access to its public
 * attributes, read access to its standard
 * attributes and no access to its sensitive attributes.
 *
 *      [mwr-] /C=de/O=sni
 * 
 * The program requires that the specific user perform an authenticated
 * bind to the directory.  In order to achieve this the user's 
 * credentials must already exist in the directory.
 * Therefore the following tree of 6 entries is added to the directory
 * each time the program runs, and removed again afterwards.
 *
 *              O  C=de
 *              |  (objectClass=Country,
 *              |   ACL=(mod-pub: *
 *              |        read-std:*
 *              |        mod-std: *
 *              |        read-sen:*
 *              |        mod-sen: *))
 *              |
 *              |
 *              O  O=sni
 *              |  (objectClass=Organization,
 *              |   ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *              |        read-std:/C=de/O=sni/OU=ap/CN=stefanie
 *              |        mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *              |        read-sen:/C=de/O=sni/OU=ap/CN=stefanie
 *              |        mod-sen: /C=de/O=sni/OU=ap/CN=stefanie))
 *              |
 *              O  OU=ap
 *              |  (objectClass=OrganizationalUnit,
 *              |   ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *              |        read-std:/C=de/O=sni/OU=ap/CN=stefanie
 *              |        mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *              |        read-sen:/C=de/O=sni/OU=ap/CN=stefanie
 *              |        mod-sen: /C=de/O=sni/OU=ap/CN=stefanie))
 *              |
.ne 12
 *              |
 *      +-------+-------+
 *      |       |       |
 *      |       |       O  CN=ingrid
 *      |       |         (objectClass=OrganizationalPerson,
 *      |       |          ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *      |       |               read-std:/C=de/O=sni/OU=ap/*
 *      |       |               mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *      |       |               read-sen:/C=de/O=sni/OU=ap/*
 *      |       |               mod-sen: /C=de/O=sni/OU=ap/CN=stefanie),
 *      |       |          surname="Schmid",
 *      |       |          telephone="+49 89 636 0",
 *      |       |          userPassword="secret")
 *      |       |
 *      |       O  CN=norbert
 *      |          (objectClass=OrganizationalPerson,
 *      |           ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *      |                read-std:/C=de/O=sni/OU=ap/*
 *      |                mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *      |                read-sen:/C=de/O=sni/OU=ap/*
 *      |                mod-sen: /C=de/O=sni/OU=ap/CN=stefanie),
 *      |           surname="Schmid",
 *      |           telephone="+49 89 636 0",
 *      |           userPassword="secret")
 *      |
 *      O  CN=stefanie
 *         (objectClass=OrganizationalPerson,
 *          ACL=(mod-pub: /C=de/O=sni/OU=ap/*
 *               read-std:/C=de/O=sni/OU=ap/*
 *               mod-std: /C=de/O=sni/OU=ap/CN=stefanie
 *               read-sen:/C=de/O=sni/OU=ap/*
 *               mod-sen: /C=de/O=sni/OU=ap/CN=stefanie),
 *          surname="Schmid",
 *          telephone="+49 89 636 0",
 *          userPassword="secret")
 *
 *
 */

#ifdef THREADSAFE
#include <pthread.h>
#endif

.ne 6
#include <xom.h>
#include <xds.h>
#include <xdsbdcp.h>
#include <xdsgds.h>
#include <xdscds.h>
#include "acl.h"       /* static initialization of data structures. */

void
main(
    int  argc,
    char *argv[]
)
{
  OM_workspace       workspace;     /* workspace for objects           */
  OM_private_object  session;       /* Session object.                 */
  OM_private_object  bound_session; /* Holds the Session object which  */
                                    /* is returned by ds_bind()        */
  OM_private_object  context;       /* Context object.                 */
  OM_private_object  result;        /* Holds the search result object. */
  OM_sint            invoke_id;     /* Integer for the invoke id       */
                                    /* returned by ds_search().        */
                                    /* (this parameter must be present */
                                    /* even though it is ignored).     */
  OM_type            sinfo_list[] = { DS_SEARCH_INFO, 0 };
  OM_type            entry_list[] = { DS_ENTRIES, 0 };
                                    /* Lists of types to be extracted  */
  OM_public_object   sinfo;         /* Search-Info object from result. */
  OM_public_object   entry;         /* Entry object from search info.  */
  OM_value_position  total_num;     /* Number of descriptors returned. */
  OM_return_code     rc;            /* XOM function return code.       */
  register int       i;
  char               user_name[MAX_DN_LEN];
                                    /* Holds requestor's name.         */
  char               entry_string[MAX_DN_LEN + 7] = "[?r??] ";
                                    /* Holds entry details.            */


    /* Step 3 (see acl.h program code for Steps 1 and 2)
     *
     * Initialise a directory workspace for use by XOM.
     */
    if ((workspace = ds_initialize()) == (OM_workspace)0)
        printf("ds_initialize() error\en");

.ne 6
    /* Step 4
     *
     * Negotiate the use of the BDCP and GDS packages.
     */
    if (ds_version(features, workspace) != DS_SUCCESS)
        printf("ds_version() error\en");

.ne 7
    /* Step 5
     *
     * Add a fixed tree of entries to the directory in order to permit
     * an authenticated bind by:  /C=de/O=sni/OU=ap/CN=norbert
     */
    if (! add_tree(workspace))
        printf("add_tree() error\en");

    /* Step 6
     *
     * Create a default session object.
     */
    if ((rc = om_create(DSX_C_GDS_SESSION,OM_TRUE,workspace,&session))
           != OM_SUCCESS)
        printf("om_create() error %d\en", rc);

    /* Step 7
     *
     * Alter the default session object to include the following 
     * credentials: requestor:  /C=de/O=sni/OU=ap/CN=norbert
     *  password:   "secret"
     * authentication mechanism: simple
     */
    if ((rc = om_put(session, OM_REPLACE_ALL, credentials, 0 ,0, 0))
           != OM_SUCCESS)
        printf("om_put() error %d\en", rc);

    /* Step 8
     *
     * Bind with credentials to the default GDS server.  The returned
     * session object is stored in the private object variable
     * bound_session and is used for all further XDS function calls.
     */
    if (ds_bind(session, workspace, &bound_session) != DS_SUCCESS)
        printf("ds_bind() error\en");

.ne 7
    /* Step 9
     *
     * Create a default context object.
     */
    if ((rc = om_create(DSX_C_GDS_CONTEXT,OM_TRUE,workspace,&context))
           != OM_SUCCESS)
        printf("om_create() error %d\en", rc);

    /*
     * Alter the default context object to include 'shadow' entries.
     */
    if ((rc = om_put(context, OM_REPLACE_ALL, use_copy, 0 ,0, 0))
           != OM_SUCCESS)
        printf("om_put() error %d\en", rc);

    /* Step 10
     *
     * Search the whole subtree below root.  The filter selects 
     * entries with an object-class attribute.  The selection 
     * extracts the ACL attribute from each selected entry.
     * The results are returned in the private object 'result'.
     *
     * NOTE: Since every entry contains an object-class attribute the
     *       filter performs no function other than to demonstrate how
     *       filters may be used.
     */
    if (ds_search(bound_session, context, dn_root, DS_WHOLE_SUBTREE,
           filter, OM_FALSE, selection_acl, &result, &invoke_id)
	   != DS_SUCCESS)
        printf("ds_search() error\en");

    /* Step 11
     *
     * Close the connection to the GDS server.
     */
    if (ds_unbind(bound_session) != DS_SUCCESS)
        printf("ds_unbind() error\en");

    /* Step 12
     *
     * Remove the user's credentials from the directory.
     */
    if (! remove_tree(workspace, session))
        printf("remove_tree() error\en");

.ne 9
    /* Step 13
     *
     * Extract components from the search result by means of om_get().
     */
    if ((rc = om_get(result,
              OM_EXCLUDE_ALL_BUT_THESE_TYPES + OM_EXCLUDE_SUBOBJECTS,
              sinfo_list, OM_FALSE, 0, 0, &sinfo, &total_num))
           != OM_SUCCESS)
        printf("om_get(Search-Result) error %d\en", rc);


    if ((rc = om_get(sinfo->value.object.object,
              OM_EXCLUDE_ALL_BUT_THESE_TYPES + OM_EXCLUDE_SUBOBJECTS,
              entry_list, OM_FALSE, 0, 0, &entry, &total_num))
           != OM_SUCCESS)
         printf("om_get(Search-Info) error %d\en", rc);

    /*
     * Convert the requestor's distinguished name to string format.
     */
    if (! xds_name_to_string(dn_norbert, user_name))
        printf("xds_name_to_string() error\en");

    printf("User:  %s\enTotal: %d\en", user_name, total_num);

    /* Step 14
     *
     * Examine each entry and print the entry details.
     */
    for (i = 0; i < total_num; i++) {
        if (process_entry_info((entry+i)->value.object.object,
                           entry_string, user_name))
            printf("%s\en", entry_string);
    }

    /* Step 15
     *
     * Close the directory workspace.
     */
    if (ds_shutdown(workspace) != DS_SUCCESS)
        printf("ds_shutdown() error\en");
}

.ne 12
/*
 * Add the tree of entries described above.
 */
int
add_tree(
    OM_workspace workspace
)
{
    OM_private_object session;    /* Holds the Session object which */
                                  /* is returned by ds_bind()       */
    OM_sint           invoke_id;  /* Integer for the invoke id      */
    int               error = 0;

/* Bind (without credentials) to the default GDS server.            */

    if (ds_bind(DS_DEFAULT_SESSION, workspace, &session) != DS_SUCCESS)
        error++;

/* Add entries to the GDS server.                                   */

    ds_add_entry(session, DS_DEFAULT_CONTEXT, dn_de, alist_C,
                  &invoke_id);

    if (ds_add_entry(session, DS_DEFAULT_CONTEXT, dn_sni, alist_O,
                                             &invoke_id) != DS_SUCCESS)
        error++;

    if (ds_add_entry(session, DS_DEFAULT_CONTEXT, dn_ap, alist_OU,
                                             &invoke_id) != DS_SUCCESS)
        error++;

    if (ds_add_entry(session, DS_DEFAULT_CONTEXT, dn_stefanie, alist_OP,
                                             &invoke_id) != DS_SUCCESS)
        error++;

    if (ds_add_entry(session, DS_DEFAULT_CONTEXT, dn_norbert, alist_OP,
                                             &invoke_id) != DS_SUCCESS)
        error++;

    if (ds_add_entry(session, DS_DEFAULT_CONTEXT, dn_ingrid, alist_OP,
                                             &invoke_id) != DS_SUCCESS)
        error++;

.ne 7
/* Close the connection to the GDS server.                          */

    if (ds_unbind(session) != DS_SUCCESS)
        error++;

    return (error?0:1);
}

.ne 13
/*
 * Remove the tree of entries described above.
 */
int
remove_tree(
    OM_workspace workspace,
    OM_private_object  session
)
{
    OM_private_object bound_session;  /* Holds Session object which */
                                      /* is returned by ds_bind()   */
    OM_sint           invoke_id;      /* Integer for the invoke id  */
    int               error = 0;

/* Bind (with credentials) to the default GDS server.               */

    if (ds_bind(session, workspace, &bound_session) != DS_SUCCESS)
        error++;

/* Remove entries from the GDS server.                              */

    if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, dn_ingrid,
                                            &invoke_id) != DS_SUCCESS)
        error++;

    if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, dn_stefanie,
                                            &invoke_id) != DS_SUCCESS)
        error++;

    if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, dn_norbert,
                                            &invoke_id) != DS_SUCCESS)
        error++;

    if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, dn_ap,
                                            &invoke_id) != DS_SUCCESS)
        error++;

.ne 3
    if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, dn_sni,
                                            &invoke_id) != DS_SUCCESS)
        error++;

    ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, dn_de,
                     &invoke_id);

/* Close the connection to the GDS server.                  */

    if (ds_unbind(bound_session) != DS_SUCCESS)
        error++;

    return (error?0:1);
}

/*
 * Convert a distinguished name in XDS format (OM_descriptor 
 * lists) to string format.
 */
int
xds_name_to_string(
    OM_public_object  name,     /* Xds distinguished name.    */
    char             *string    /* String distinguished name. */
)
{
    register OM_object  dn = name;
    register OM_object  rdn;
    register OM_object  ava;
    register char      *sp = string;
             int        error = 0;

    while ((dn->type != OM_NO_MORE_TYPES) && (! error)) {
        if ((dn->type == DS_RDNS) &&
            ((dn->syntax & OM_S_SYNTAX) == OM_S_OBJECT)) {
            rdn = dn->value.object.object; 

            while ((rdn->type != OM_NO_MORE_TYPES) && (! error)) {
                if ((rdn->type == DS_AVAS) &&
                    ((rdn->syntax & OM_S_SYNTAX) == OM_S_OBJECT)) {
                    ava = rdn->value.object.object; 

                    while ((ava->type != OM_NO_MORE_TYPES) &&
                             (! error)) {
                        if ((ava->type == DS_ATTRIBUTE_TYPE) &&
                            ((ava->syntax & OM_S_SYNTAX) == 
                                      OM_S_OBJECT_IDENTIFIER_STRING)) {

.ne 5
                            *sp++ = '/';
                            if (strncmp(ava->value.string.elements,
                                        DS_A_COUNTRY_NAME.elements,
                                        ava->value.string.length) == 0)
                                *sp++ = 'C';

                            else if (strncmp(ava->value.string.elements,
                                        DS_A_ORG_NAME.elements,
                                        ava->value.string.length) == 0)
                                *sp++ = 'O';

                            else if (strncmp(ava->value.string.elements,
                                        DS_A_ORG_UNIT_NAME.elements,
                                        ava->value.string.length) == 0)
                                *sp++ = 'O', *sp++ = 'U';

                            else if (strncmp(ava->value.string.elements,
                                        DS_A_COMMON_NAME.elements,
                                        ava->value.string.length) == 0)
                                *sp++ = 'C', *sp++ = 'N';

                            else if (strncmp(ava->value.string.elements,
                                        DS_A_LOCALITY_NAME.elements,
                                        ava->value.string.length) == 0)
                                *sp++ = 'L';

                            else if (strncmp(ava->value.string.elements,
                                     DSX_TYPELESS_RDN.elements,
                                     ava->value.string.length) != 0) {
                                error++;
                                continue;
                            }

                            if (*(sp-1) != '/'); /* no '=' if typeless*/
                                *sp++ = '=';
                        }
                        if (ava->type == DS_ATTRIBUTE_VALUES) {
                            switch(ava->syntax & OM_S_SYNTAX) {
                                case OM_S_PRINTABLE_STRING : 
                                case OM_S_TELETEX_STRING : 
                                 strncpy(sp, ava->value.string.elements,
                                         ava->value.string.length);
                                 sp += ava->value.string.length;
                                 break;

.ne 4
                                default:
                                 error++;
                                 continue;
                            }

                        }
                        ava++;
                    }
                }
                rdn++;
            }
        }
        dn++;
    }
    *sp = '\e0';

    return (error?0:1);
}

/*
 * Extract information about an entry from the Entry-Info object:
 * whether the entry is a master-copy, its ACL permissions and
 * its distinguished name.
 * Build up a string based on this information.
 */
int
process_entry_info(
    OM_private_object  entry,
    char              *entry_string,
    char              *user_name
)
{
    OM_return_code     rc;           /* Return code from XOM function. */
    OM_public_object   ei_attrs;     /* Components from Entry-Info.    */
    OM_public_object   attr;         /* Directory attribute.           */
    OM_public_object   acl;          /* ACL attribute value.           */
    OM_public_object   acl_item;     /* ACL item component.            */
    OM_value_position  total_attrs;  /* Number of attributes returned. */
    register int       i;
    register int       interp;
    register int       error = 0;
    register int       found_acl = 0;
    static OM_type     ei_attr_list[] = { DS_FROM_ENTRY,
                                          DS_OBJECT_NAME,
                                          DS_ATTRIBUTES,
                                          0 };
                                      /* Attributes to be extracted.   */

.ne 9
    /*
     * Extract three attributes from each Entry-Info object.
     */
    if ((rc = om_get(entry, OM_EXCLUDE_ALL_BUT_THESE_TYPES,
                 ei_attr_list, OM_FALSE, 0, 0, &ei_attrs, &total_attrs))
                 != OM_SUCCESS) {
        error++;
        printf("om_get(Entry-Info) error %d\n", rc);
    }

    for (i = 0; ((i < total_attrs) && (! error)); i++, ei_attrs++) {

        /*
         * Determine if current entry is a master-copy or a shadow-copy.
         */
        if ((ei_attrs->type == DS_FROM_ENTRY) &&
            ((ei_attrs->syntax & OM_S_SYNTAX) == OM_S_BOOLEAN))
            if (ei_attrs->value.boolean == OM_TRUE)
                entry_string[1] = 'm';
            else if (ei_attrs->value.boolean == OM_FALSE)
                     entry_string[1] = 's';
                 else
                     entry_string[1] = '?';

        if ((ei_attrs->type == DS_ATTRIBUTES) &&
            ((ei_attrs->syntax & OM_S_SYNTAX) == OM_S_OBJECT)) {
            attr = ei_attrs->value.object.object; 

            while ((attr->type != OM_NO_MORE_TYPES) && (! error)) {

                /*
                 * Check that the attribute is an ACL attribute.
                 */
                if ((attr->type == DS_ATTRIBUTE_TYPE) &&
                    ((attr->syntax & OM_S_SYNTAX) ==
                                     OM_S_OBJECT_IDENTIFIER_STRING)) {
                    if (strncmp(attr->value.string.elements,
                                DSX_A_ACL.elements,
                                attr->value.string.length) == 0)
                        found_acl++;
                }

.ne 7
                /*
                 * Examine the ACL. Check each permission for
                 * the current user.
                 */
                if ((found_acl) &&
                    (attr->type == DS_ATTRIBUTE_VALUES) &&
                    ((attr->syntax & OM_S_SYNTAX) == OM_S_OBJECT)) {

                    acl = attr->value.object.object;

                    entry_string[2] = 'r';
                    entry_string[3] = '-';
                    entry_string[4] = '-';

                    while (acl->type != OM_NO_MORE_TYPES) {

                        if ((acl->syntax & OM_S_SYNTAX) == OM_S_OBJECT)
                            acl_item = acl->value.object.object;

                        switch (acl->type) {

                        case OM_CLASS:
                            break;

                        case DSX_MODIFY_PUBLIC:
                            if (permitted_access(user_name, acl_item))
                                entry_string[2] = 'w';
                            break;

                        case DSX_READ_STANDARD:
                            if (permitted_access(user_name, acl_item))
                                entry_string[3] = 'r';
                            break;

                        case DSX_MODIFY_STANDARD:
                            if (permitted_access(user_name, acl_item))
                                entry_string[3] = 'w';
                            break;

                        case DSX_READ_SENSITIVE:
                            if (permitted_access(user_name, acl_item))
                                entry_string[4] = 'r';
                            break;

.ne 11
                        case DSX_MODIFY_SENSITIVE:
                            if (permitted_access(user_name, acl_item))
                                entry_string[4] = 'w';
                            break;
                        }
                        acl++;
                    }
                }
                attr++;
            }
        }

        /*
         * Convert the entry's distinguished name to a string format.
         */
        if ((ei_attrs->type == DS_OBJECT_NAME) &&
            ((ei_attrs->syntax & OM_S_SYNTAX) == OM_S_OBJECT))
            if (! xds_name_to_string(ei_attrs->value.object.object,
                                     &entry_string[7])) {
                error++;
                printf("xds_name_to_string() error\en");
            }

    }

    return (error?0:1);
}

/*
 * Check if a user is permitted access based on the ACL supplied.
 *
 */
int
permitted_access(
    char             *user_name,
    OM_public_object  acl_item
)
{
    char  acl_name[MAX_DN_LEN];
    int   interpretation;
    int   acl_present = 0;
    int   access = 0;
    int   acl_name_length;

.ne 6
    while (acl_item->type != OM_NO_MORE_TYPES) {

        switch (acl_item->type) {
        case OM_CLASS:
            break;
        
        case DSX_INTERPRETATION:
            interpretation = acl_item->value.boolean; 
            break;

        case DSX_USER:
            xds_name_to_string(acl_item->value.object.object, acl_name);

            if (interpretation == DSX_SINGLE_OBJECT) {
                if (strcmp(acl_name, user_name) == 0)
                    access = 1;
            }
            else if (interpretation == DSX_ROOT_OF_SUBTREE) {
                     if ((acl_name_length = strlen(acl_name)) == 0)
                         access = 1;
                     else if (strncmp(acl_name,user_name,
                               acl_name_length) == 0)
                         access = 1;
            }
            break;
        }
        acl_item++;
    }

    return (access);
}
.oE
.ps 12
.vs 14
.H 3 "The acl.h Header File"
.P
.iX "\*Lacl.h\*O" "header file"
.iX "XDS" "header files"
.iX "header files"  "XDS API"
The \*Lacl.h\*O header file performs the following:
.AL
.LI
It exports the object identifiers that \*Lacl.c\*O requires.
.LI
.ne 9
It builds the descriptor lists for the following
distinguished names:
.iS
root
C=de
C=de/O=sni
C=de/O=sni/OU=ap
C=de/O=sni/OU=ap/CN=stefanie
C=de/O=sni/OU=ap/CN=norbert
C=de/O=sni/OU=ap/CN=ingrid\*O
.P
.LI
It builds the object identifiers for attributes to be added to
the directory.
.LI
It builds a descriptor list for the attribute types and values that
are to be selected.
.LI
It builds the descriptor list for bind credentials.
.LI
It builds the descriptor list for context.
.LI
It builds the descriptor list for optional packages that are
to be negotiated.
.LI
It builds the descriptor list for search filters.
.LE
.H 3 "The acl.h Code"
.P
The following code is a listing of the \*Lacl.h\*O file:
.nL
.ps 11
.vs 13
.oS
/***************************************************************
*                                                              *
*  COPYRIGHT (C) SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1991   *
*                ALL RIGHTS RESERVED                           *
*                                                              *
***************************************************************/

#ifndef ACL_HEADER
#define ACL_HEADER

#define MAX_DN_LEN 100
/* max length of a distinguished name in string format*/

.ne 14
/* The application must export the object identifiers it requires.   */

OM_EXPORT (DS_C_AVA)
OM_EXPORT (DS_C_DS_RDN)
OM_EXPORT (DS_C_DS_DN)
OM_EXPORT (DS_C_ENTRY_INFO_SELECTION)
OM_EXPORT (DS_C_ATTRIBUTE)
OM_EXPORT (DS_C_ATTRIBUTE_LIST)
OM_EXPORT (DS_C_FILTER)
OM_EXPORT (DS_C_FILTER_ITEM)
OM_EXPORT (DSX_C_GDS_SESSION)
OM_EXPORT (DSX_C_GDS_CONTEXT)
OM_EXPORT (DSX_C_GDS_ACL)
OM_EXPORT (DSX_C_GDS_ACL_ITEM)

OM_EXPORT (DS_A_COUNTRY_NAME)
OM_EXPORT (DS_A_ORG_NAME)
OM_EXPORT (DS_A_ORG_UNIT_NAME)
OM_EXPORT (DS_A_COMMON_NAME)
OM_EXPORT (DS_A_LOCALITY_NAME)
OM_EXPORT (DS_A_OBJECT_CLASS)
OM_EXPORT (DS_A_USER_PASSWORD)
OM_EXPORT (DS_A_PHONE_NBR)
OM_EXPORT (DS_A_SURNAME)
OM_EXPORT (DSX_A_ACL)
OM_EXPORT (DSX_TYPELESS_RDN)

OM_EXPORT (DS_O_TOP)
OM_EXPORT (DS_O_COUNTRY)
OM_EXPORT (DS_O_ORG)
OM_EXPORT (DS_O_ORG_UNIT)
OM_EXPORT (DS_O_PERSON)
OM_EXPORT (DS_O_ORG_PERSON)


/* Build up descriptor lists for the following distinguished names: */
/*     root                                                         */
/*     /C=de                                                        */
/*     /C=de/O=sni                                                  */
/*     /C=de/O=sni/OU=ap                                            */
/*     /C=de/O=sni/OU=ap/CN=stefanie                                */
/*     /C=de/O=sni/OU=ap/CN=norbert                                 */
/*     /C=de/O=sni/OU=ap/CN=ingrid                                  */

.ne 6
static OM_descriptor    ava_de[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COUNTRY_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("de")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_sni[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("sni")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_ap[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_UNIT_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("ap")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_stefanie[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COMMON_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("stefanie")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_norbert[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COMMON_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("norbert")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_ingrid[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COMMON_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("ingrid")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_de[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_de}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_sni[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_sni}},
    OM_NULL_DESCRIPTOR
};
.ne 5
static OM_descriptor    rdn_ap[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_ap}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_stefanie[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_stefanie}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_norbert[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_norbert}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_ingrid[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_ingrid}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_root[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_de[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_de}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_sni[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_de}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_ap[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_de}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ap}},
    OM_NULL_DESCRIPTOR
};
.ne 8
static OM_descriptor dn_stefanie[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_de}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ap}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_stefanie}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_norbert[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_de}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ap}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_norbert}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_ingrid[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_de}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ap}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ingrid}},
    OM_NULL_DESCRIPTOR
};


/* Build up an array of object identifiers for the attributes to be */
/* added to the directory.                                          */

static OM_descriptor    obj_class_C[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_TOP),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_COUNTRY),
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    obj_class_O[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_TOP),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_ORG),
    OM_NULL_DESCRIPTOR
};
.ne 7
static OM_descriptor    obj_class_OU[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_TOP),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_ORG_UNIT),
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    obj_class_OP[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_TOP),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_PERSON),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_ORG_PERSON),
    OM_NULL_DESCRIPTOR
};

static OM_descriptor    att_phone_num[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_PHONE_NBR),
    {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING,
      OM_STRING("+49 89 636 0")},
    OM_NULL_DESCRIPTOR
};
 
static OM_descriptor    att_password[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_USER_PASSWORD),
    {DS_ATTRIBUTE_VALUES, OM_S_OCTET_STRING, OM_STRING("secret")},
    OM_NULL_DESCRIPTOR
};

static OM_descriptor    att_surname[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_SURNAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("Schmid")},
    OM_NULL_DESCRIPTOR
};
 
static OM_descriptor    acl_item_root[] = {
    OM_OID_DESC(OM_CLASS, DSX_C_GDS_ACL_ITEM),
    {DSX_INTERPRETATION, OM_S_ENUMERATION, {DSX_ROOT_OF_SUBTREE, 0}},
    {DSX_USER, OM_S_OBJECT, {0, dn_root}},
    OM_NULL_DESCRIPTOR
};
 
.ne 6
static OM_descriptor    acl_item_ap[] = {
    OM_OID_DESC(OM_CLASS, DSX_C_GDS_ACL_ITEM),
    {DSX_INTERPRETATION, OM_S_ENUMERATION, {DSX_ROOT_OF_SUBTREE, 0}},
    {DSX_USER, OM_S_OBJECT, {0, dn_ap}},
    OM_NULL_DESCRIPTOR
};
 
static OM_descriptor    acl_item_stefanie[] = {
    OM_OID_DESC(OM_CLASS, DSX_C_GDS_ACL_ITEM),
    {DSX_INTERPRETATION, OM_S_ENUMERATION, {DSX_SINGLE_OBJECT, 0}},
    {DSX_USER, OM_S_OBJECT, {0, dn_stefanie}},
    OM_NULL_DESCRIPTOR
};
 
static OM_descriptor    acl1[] = {
    OM_OID_DESC(OM_CLASS, DSX_C_GDS_ACL),
    {DSX_MODIFY_PUBLIC, OM_S_OBJECT, {0, acl_item_root}},
    {DSX_READ_STANDARD, OM_S_OBJECT, {0, acl_item_stefanie}},
    {DSX_MODIFY_STANDARD, OM_S_OBJECT, {0, acl_item_stefanie}},
    {DSX_READ_SENSITIVE, OM_S_OBJECT, {0, acl_item_stefanie}},
    {DSX_MODIFY_SENSITIVE, OM_S_OBJECT, {0, acl_item_stefanie}},
    OM_NULL_DESCRIPTOR
};

static OM_descriptor    acl2[] = {
    OM_OID_DESC(OM_CLASS, DSX_C_GDS_ACL),
    {DSX_MODIFY_PUBLIC, OM_S_OBJECT, {0, acl_item_ap}},
    {DSX_READ_STANDARD, OM_S_OBJECT, {0, acl_item_ap}},
    {DSX_MODIFY_STANDARD, OM_S_OBJECT, {0, acl_item_stefanie}},
    {DSX_READ_SENSITIVE, OM_S_OBJECT, {0, acl_item_ap}},
    {DSX_MODIFY_SENSITIVE, OM_S_OBJECT, {0, acl_item_stefanie}},
    OM_NULL_DESCRIPTOR
};

static OM_descriptor    att_acl1[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_A_ACL),
    {DS_ATTRIBUTE_VALUES, OM_S_OBJECT, {0, acl1} },
    OM_NULL_DESCRIPTOR
};

static OM_descriptor    att_acl2[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DSX_A_ACL),
    {DS_ATTRIBUTE_VALUES, OM_S_OBJECT, {0, acl2} },
    OM_NULL_DESCRIPTOR
};

.ne 5
static OM_descriptor    alist_C[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, obj_class_C} },
    OM_NULL_DESCRIPTOR
};
 
static OM_descriptor    alist_O[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, obj_class_O} },
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, att_acl1} },
    OM_NULL_DESCRIPTOR
};

static OM_descriptor    alist_OU[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, obj_class_OU} },
    OM_NULL_DESCRIPTOR
};
 
static OM_descriptor    alist_OP[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, obj_class_OP} },
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, att_acl2} },
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, att_surname} },
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, att_phone_num} },
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, att_password} },
    OM_NULL_DESCRIPTOR
};
 

/* The following descriptor list specifies what to return from    */
/* the entry.  The ACL attribute's types and values are selected. */

static OM_descriptor selection_acl[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ENTRY_INFO_SELECTION),
    {DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, OM_FALSE},
    OM_OID_DESC(DS_ATTRIBUTES_SELECTED, DSX_A_ACL),
    {DS_INFO_TYPE, OM_S_ENUMERATION, DS_TYPES_AND_VALUES},
    OM_NULL_DESCRIPTOR
};

.ne 8
/* The following descriptor list specifies the bind credentials   */

static OM_descriptor credentials[] = {
    {DS_REQUESTOR, OM_S_OBJECT, {0, dn_norbert} },
    {DSX_PASSWORD, OM_S_OCTET_STRING, OM_STRING("secret")},
    {DSX_AUTH_MECHANISM, OM_S_ENUMERATION, {DSX_SIMPLE,0}},
    OM_NULL_DESCRIPTOR
};

/* The following descriptor list specifies part of the context    */

static OM_descriptor use_copy[] = {
    {DS_DONT_USE_COPY, OM_S_BOOLEAN, {OM_FALSE, 0} },
    OM_NULL_DESCRIPTOR
};

/* Build up an array of object identifiers for the optional       */
/* packages to be negotiated.                                     */

DS_feature features[] = {
    { OM_STRING(OMP_O_DS_BASIC_DIR_CONTENTS_PKG), OM_TRUE },
    { OM_STRING(OMP_O_DSX_GDS_PKG), OM_TRUE },
    { 0 }
};

/* The following descriptor list specifies a filter for search :  */
/*     (Present: objectClass)                                     */

static OM_descriptor filter_item[] = {
    OM_OID_DESC(OM_CLASS, DS_C_FILTER_ITEM),
    {DS_FILTER_ITEM_TYPE, OM_S_ENUMERATION, {DS_PRESENT, 0} },
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
    OM_NULL_DESCRIPTOR
};

static OM_descriptor filter[] = {
    OM_OID_DESC(OM_CLASS, DS_C_FILTER),
    {DS_FILTER_ITEMS, OM_S_OBJECT, {0, filter_item} },
    {DS_FILTER_TYPE, OM_S_ENUMERATION, {DS_AND, 0} },
    OM_NULL_DESCRIPTOR
};


#endif  /* ACL_HEADER */
.oE
.ps 12
.vs 14
.H 2 "The teldir.c Program"
.P
.iX "\*Lteldir.c\*O"
.iX "XDS" "API" "\*Lteldir.c\*O"
.iX "XDS" "API" "sample programs"
The sample program \*Lteldir.c\*O permits a user to add, read, or delete
entries in a CDS or GDS namespace in any local or remote DCE cell, assuming
that permissions are granted by the ACLs.  The entry consists of a person's
surname and phone number.  Each entry is of class \*LOrganizational-Person\*O.
.P
The program uses predefined static XDS public objects that are never altered
and partially defined static XDS public objects so that values for the
surname and phone number can be entered dynamically by a user.  
It also uses dynamic XDS public objects that are created and 
filled only as needed by using the \*LstringToXdsName\*O function.  These
techniques are a departure from those used in the first two sample
programs where all objects are predefined.
.H 3 "Predefined Static Public Objects"
.P
.iX "object" "predefined static public"
.iX "XDS" "predefined static public objects"
.iX "public object" "predefined static"
The predefined static object classes and attributes are shown in the
following code fragment:
.nL
.ps 11
.vs 13
.oS
/*
 * To hold the attributes we want to attach to the name being added.
 * One attribute is the class of the object (DS_O_ORG_PERSON), the
 * rest of the attributes are the surname (required for all objects
 * of class DS_O_ORG_PERSON) and phone number.  In addition, we need
 * an object to hold all this information to pass it into 
 * ds_add_entry().
 */
static OM_descriptor xdsObjectClass[] = {

    /* This object is an attribute--an object class. */
    OM_OID_DESC( OM_CLASS,            DS_C_ATTRIBUTE ),
    OM_OID_DESC( DS_ATTRIBUTE_TYPE,   DS_A_OBJECT_CLASS ),

.ne 10
    /* Not only must the class be listed, but also all */
    /* its superclasses.                               */
    OM_OID_DESC( DS_ATTRIBUTE_VALUES, DS_O_TOP ),
    OM_OID_DESC( DS_ATTRIBUTE_VALUES, DS_O_PERSON ),
    OM_OID_DESC( DS_ATTRIBUTE_VALUES, DS_O_ORG_PERSON ),
    
    /* Null terminator */
    OM_NULL_DESCRIPTOR
};
static OM_descriptor xdsAttributesToAdd[] = {

    /* This object is an attribute list. */
    OM_OID_DESC( OM_CLASS, DS_C_ATTRIBUTE_LIST ),

    /* These are "pointers" to the attributes in the list. */
    { DS_ATTRIBUTES, OM_S_OBJECT, { 0, xdsObjectClass } },
    { DS_ATTRIBUTES, OM_S_OBJECT, { 0, xdsSurname } },
    { DS_ATTRIBUTES, OM_S_OBJECT, { 0, xdsPhoneNum } },

    /* Null terminator */
    OM_NULL_DESCRIPTOR
};

/*
 * To hold the list of attributes we want to read.
 */
static OM_descriptor xdsAttributeSelection[] = {

    /* This is an entry information selection. */
    OM_OID_DESC( OM_CLASS, DS_C_ENTRY_INFO_SELECTION ),

    /* No, we don't want all attributes. */
    { DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, OM_FALSE },

    /* These are the ones we want to read. */
    OM_OID_DESC( DS_ATTRIBUTES_SELECTED, DS_A_SURNAME ),
    OM_OID_DESC( DS_ATTRIBUTES_SELECTED, DS_A_PHONE_NBR ),

    /* Give us both the types and their values. */
    { DS_INFO_TYPE, OM_S_ENUMERATION, { DS_TYPES_AND_VALUES, NULL } },

    /* Null terminator */
    OM_NULL_DESCRIPTOR
};

.oE
.ps 12
.vs 14
.H 3 "Partially Defined Static Public Objects"
.P
.iX "object" "partially-defined static public"
.iX "XDS" "partially-defined static public objects"
.iX "public object" "partially-defined static"
The program partially defines static XDS objects with placeholders
so that values for the surname
and telephone number entered by the user can be added later,
as shown in the following code fragment:
.nL
.ps 11
.vs 13
.oS
static OM_descriptor xdsSurname[] = {

    /* This object is an attribute--a surname. */
    OM_OID_DESC( OM_CLASS,          DS_C_ATTRIBUTE ),
    OM_OID_DESC( DS_ATTRIBUTE_TYPE, DS_A_SURNAME ),

    /* No default--so we need a placeholder for the actual surname.   */
    OM_NULL_DESCRIPTOR,

    /* Null terminator */
    OM_NULL_DESCRIPTOR
};

static OM_descriptor xdsPhoneNum[] = {

    /* This object is an attribute--a telephone number. */
    OM_OID_DESC( OM_CLASS,          DS_C_ATTRIBUTE ),
    OM_OID_DESC( DS_ATTRIBUTE_TYPE, DS_A_PHONE_NBR ),

    /* By default, phone numbers are unlisted.  If the user specifies */
    /* an actual phone number, it will go into this position.         */
    { DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING,
       OM_STRING( "unlisted" ) },

    /* Null terminator */
    OM_NULL_DESCRIPTOR
};
.oE
.ps 12
.vs 14
.P
.ne 18
The program prompts the user for the surname of the person whose number
will be changed and uses the \*LFILL_OMD_STRING\*O macro to
fill in values, as shown in the following code fragment:
.nL
.ps 11
.vs 13
.oS
    if ( operation == 'a' ) {
        /* add operation requires additional input */
        /*
         * Get the person's real name from the user and place it in the
         * XDS object already defined at the
         * top of the program (xdsSurname).
         * We are requiring a name, so we will loop until we get one.
         */
        do {
	    printf( "What is this person's surname? " );
	    gets( newSurname );
        } while ( *newSurname == '\e0' );
        FILL_OMD_STRING( xdsSurname, 2, DS_ATTRIBUTE_VALUES,
		         OM_S_TELETEX_STRING, newSurname )
.oE
.ps 12
.vs 14
.H 3 "Dynamically Defined Public Objects"
.P
.iX "object" "dynamically-defined static public"
.iX "XDS" "dynamically-defined static public objects"
.iX "public object" "dynamically-defined static"
The program uses the function \*LstringToXdsName\*O to convert the DCE name
entered by a user into an XDS name object of OM class \*LDS_C_DS_DN\*O,
which is the
representation of a distinguished name.  In the other two sample
programs, arrays of descriptor lists are statically declared to represent
the AVAs and RDNs that make up the public object that represents a
distinguished name.  The function \*LstringToXdsName\*O parses the DCE
name and dynamically converts it to a public object.
.P
.ne 22
For example, the following code fragment shows how space for a
\*LDS_C_AVA\*O object is allocated and its entries are filled by using the
\*LFILL_OMD_XOM_STRING\*O and \*LFILL_OMD_NULL\*O macros:
.nL
.ps 11
.vs 13
.oS
/*
 * Allocate space for a DS_C_AVA object and fill in its entries:
 *	DS_C_AVA class identifier
 *	AVA's type
 *	AVA's value
 *	null terminator
 */
ava = (OM_descriptor *)malloc( sizeof(OM_descriptor) * 4 );
if( ava == NULL )			/* malloc() failed */
    return OM_MEMORY_INSUFFICIENT;
FILL_OMD_XOM_STRING( ava, 0, OM_CLASS, OM_S_OBJECT_IDENTIFIER_STRING, 
		     DS_C_AVA )
splitNamePiece( start, &type, &value );
FILL_OMD_XOM_STRING( ava, 1, DS_ATTRIBUTE_TYPE,
                     OM_S_OBJECT_IDENTIFIER_STRING, type )
FILL_OMD_STRING( ava, 2, DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING,
		 value )
FILL_OMD_NULL( ava, 3 )
.oE
.ps 12
.vs 14
.P
The program uses the same method to build the RDNs that make up the
the distinguished name.  The distinguished name is NULL terminated
by using
the \*LFILL_OMD_NULL\*O macro and the location of the new public object
is provided for the calling routine (main) in the pointer \*LxdsNameObj\*O,
as shown in the following code fragment:
.nL
.ps 11
.vs 13
.oS
	/* Add the DS_C_RDN object to the DS_C_DS_DN object. */
	FILL_OMD_STRUCT( dsdn, index, DS_RDNS, OM_S_OBJECT, rdn )
    }

    /*
     * Null terminate the DS_C_DS_DN, tell the calling routine
     * where to find it, and return.
     */
    FILL_OMD_NULL( dsdn, index )
    *xdsNameObj = dsdn;
    return( OM_SUCCESS );

} /* end stringToXdsName() */
.oE
.ps 12
.vs 14
.nL
.ne 20
.H 3 "Main Program Procedural Steps"
.P
The program consists of the following general steps:
.AL
.LI
Examine the command-line argument to determine the type of operation (read,
add, or delete entry) that the user wants to perform.
.LI
Initialize a workspace.
.LI
Pull in the packages with the required XDS features.
.LI
Prompt the user for the name entry on which the
operation will be performed.
.LI
Convert the DCE-formatted user input string to an XDS object name.
.LI
Bind (without credentials) to the default server.
.LI
Perform the requested operation (read, add, or delete entry).
.LI
Perform error handling.
.LI
Unbind from the server.
.LI
Shut down the workspace, releasing resources back to the system.
.LE
.P
Step 1 simply involves determining which of the three 
options\(em\*Lr\*O (read), \*La\*O (add), or \*Ld\*O 
(delete)\(emthe user has entered.
Step 2 initializes a workspace, an operation required by XDS API for
every application program.  Step 3 is required because
additional features not present in the directory service package need
to be used by the application program.  An additional package, the
basic directory contents package, is defined in \*VfeatureList\*O as
a static XDS object earlier in the program.
.P
In Step 4, the user is prompted for the DCE-formatted name, which
is the distinguished name of the person on whose telephone number the
operation is to be performed.  The name must be a fully or
partially qualified name that begins with either the
\*L/...\*O or \*L/.:\*O prefix.  An example of a fully qualified, or
global, name is
\*L/.../C=de/O=sni/OU=ap/CN=klaus\*O.  An example of a partially qualified,
or cell,
name is \*L/.:/brad/sni/com\*O.  Additional information is requested in
Step 5 if the user requests an add operation.
.P
.ne 7
Step 5 converts the DCE-formatted name to an XDS object name
(public object) by using the \*LstringToXdsName(\|)\*O function call.
This function builds an XDS
public object that represents the distinguished name entered by the
user.
.P
Step 6 binds the session to the default server without
credentials; username and password are not required.
.P
In Step 7, the requested operation is performed by using XDS API
functions calls.  For an add operation, \*Lds_add_entry(\|)\*O is
performed; for a read operation, \*Lds_read(\|)\*O is performed; and for a
delete operation, \*Lds_remove_entry(\|)\*O is performed.  The read
operation requires a series of XOM API \*Lom_get(\|)\*O function calls to
extract the surname and phone number from the workspace.  (For a
detailed description of the XDS and XOM API function calls, refer to
Chapters 5 and 6.)
.P
Step 8 and Step 9 are required for every XDS API
application program in order to clean up before the program exits.  The
session is unbound from the server, and the public and private objects
are released to the system that provided the memory allocated for
them.
.H 3 "The teldir.c Code"
.P
The following is a listing of the file \*Lteldir.c\*O:
.nL
.ps 11
.vs 13
.oS
/*
 * This sample program behaves like a simple telephone directory.
 * It permits a user to add, read or delete entries in a GDS
 * namespace or to a CDS namespace in any local or remote DCE cell
 * (assuming that permissions are granted by the ACLs).
 *
 * Each entry is of class Organizational-Person and simply contains 
 * a person's surname and their phone number.
 *
 * The addition of an entry is followed by a read to verify that the
 * information was entered properly.
 *
 * All valid names should begin with one of the following symbols:
 *     /...     Fully qualified name (from global root).
 *              such as  /.../C=de/O=sni/OU=ap/CN=klaus
 *
 *     /.:      Partially qualified name (from local cell root).
 *              such as  /.:/brad/sni/com
.ne 16
 * This program demonstrates the following techniques:
 * - Using completely static XDS public objects (predefined at the top
 *   of the program and never altered).  See xdsObjectClass,
 *   xdsAttributesToAdd, and xdsAttributeSelection below.
 * - Using partially static XDS public objects (predefined at the top
 *   of the program but altered later).  See xdsSurname and xdsPhoneNum
 *   below.  See also the macros whose names begin with "FILL_OMD_".
 * - Using dynamic XDS public objects (created and filled in only as
 *   needed).  See the function stringToXdsName() below.
 * - Parsing DCE-style names and converting them into XDS objects.  See
 *   the function stringToXdsName() below.
 * - Getting the value of an attribute from an object read from the
 *   namespace using ds_read().  See the function extractValue() below.
 * - Getting the numeric value of an error (type DS_status) returned by
 *   one of the XDS calls.  See the function handleDSError() below.
 */

#ifdef THREADSAFE
#include <pthread.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <xom.h>
#include <xds.h>
#include <xdsbdcp.h>
#include <xdsgds.h>
#include <xdscds.h>

OM_EXPORT( DS_A_COMMON_NAME )
OM_EXPORT( DS_A_COUNTRY_NAME )
OM_EXPORT( DS_A_LOCALITY_NAME )
OM_EXPORT( DS_A_OBJECT_CLASS )
OM_EXPORT( DS_A_ORG_UNIT_NAME )
OM_EXPORT( DS_A_ORG_NAME )
OM_EXPORT( DS_A_SURNAME )
OM_EXPORT( DS_A_PHONE_NBR )
OM_EXPORT( DS_A_TITLE )
OM_EXPORT( DS_C_ATTRIBUTE )
OM_EXPORT( DS_C_ATTRIBUTE_LIST )
OM_EXPORT( DS_C_AVA )
OM_EXPORT( DS_C_DS_DN )
OM_EXPORT( DS_C_DS_RDN )
OM_EXPORT( DS_C_ENTRY_INFO_SELECTION )
OM_EXPORT( DS_O_ORG_PERSON )
OM_EXPORT( DS_O_PERSON )
OM_EXPORT( DS_O_TOP )
OM_EXPORT( DSX_TYPELESS_RDN ) /* For "typeless" pieces of a name, as */
                              /* found in cells with bind-style names*/
                              /* and in the CDS namespace.           */

#define	MAX_NAME_LEN	1024

/* These values can be found in                                      */
/* the "Directory Class Definitions" chapter.                        */ 
/* (One byte must be added for the null terminator.)                 */
#define MAX_PHONE_LEN	33
#define MAX_SURNAME_LEN	66

/*********************************************************************
 * Macros for help filling in static XDS objects.
 *********************************************************************/
/* Put NULL value (equivalent to OM_NULL_DESCRIPTOR) in object */
#define FILL_OMD_NULL( desc, index ) 
	desc[index].type = OM_NO_MORE_TYPES; 
	desc[index].syntax = OM_S_NO_MORE_SYNTAXES; 
	desc[index].value.object.padding = 0; 
	desc[index].value.object.object = OM_ELEMENTS_UNSPECIFIED;

/* Put C-style (null-terminated) string in object */
#define FILL_OMD_STRING( desc, index, typ, syntx, val ) 
	desc[index].type = typ; 
	desc[index].syntax = syntx; 
	desc[index].value.string.length = (OM_string_length)
            strlen( val ); 
	desc[index].value.string.elements = val;

/* Put XOM string in object */
#define FILL_OMD_XOM_STRING( desc, index, typ, syntx, val ) 
	desc[index].type = typ; 
	desc[index].syntax = syntx; 
	desc[index].value.string.length = val.length; 
	desc[index].value.string.elements = val.elements;

/* Put other value in object */
#define FILL_OMD_STRUCT( desc, index, typ, syntx, val ) 
	desc[index].type = typ; 
	desc[index].syntax = syntx; 
	desc[index].value.object.padding = 0; 
        desc[index].value.object.object = val;

.ne 12
/*********************************************************************
 * Static XDS objects.
 ********************************************************************/
/*
 * To identify which packages we need for this program.  We only need
 * the basic package because we are not doing anything fancy with
 * session parameters, etc.
 */
DS_feature featureList[] = {
        { OM_STRING(OMP_O_DS_BASIC_DIR_CONTENTS_PKG), OM_TRUE },
        { 0 }
};

/*
 * To hold the attributes we want to attach to the name being added.
 * One attribute is the class of the object (DS_O_ORG_PERSON), the
 * rest of the attributes are the surname (required for all objects
 * of class DS_O_ORG_PERSON) and phone number.  In addition, we need
 * an object to hold all this information to pass it
 * into ds_add_entry().
 */
static OM_descriptor xdsObjectClass[] = {

    /* This object is an attribute--an object class. */
    OM_OID_DESC( OM_CLASS,            DS_C_ATTRIBUTE ),
    OM_OID_DESC( DS_ATTRIBUTE_TYPE,   DS_A_OBJECT_CLASS ),

    /* Not only must the class be listed, but also all */
    /* its superclasses.                               */
    OM_OID_DESC( DS_ATTRIBUTE_VALUES, DS_O_TOP ),
    OM_OID_DESC( DS_ATTRIBUTE_VALUES, DS_O_PERSON ),
    OM_OID_DESC( DS_ATTRIBUTE_VALUES, DS_O_ORG_PERSON ),
    
    /* Null terminator */
    OM_NULL_DESCRIPTOR
};

static OM_descriptor xdsSurname[] = {

    /* This object is an attribute--a surname. */
    OM_OID_DESC( OM_CLASS,          DS_C_ATTRIBUTE ),
    OM_OID_DESC( DS_ATTRIBUTE_TYPE, DS_A_SURNAME ),

.ne 6
    /* No default--so we need a placeholder for the actual surname. */
    OM_NULL_DESCRIPTOR,

    /* Null terminator */
    OM_NULL_DESCRIPTOR
};

static OM_descriptor xdsPhoneNum[] = {

    /* This object is an attribute--a telephone number. */
    OM_OID_DESC( OM_CLASS,          DS_C_ATTRIBUTE ),
    OM_OID_DESC( DS_ATTRIBUTE_TYPE, DS_A_PHONE_NBR ),

    /* By default, phone numbers are unlisted.  If the user specifies */
    /* an actual phone number, it will go into this position.         */
    { DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING,
      OM_STRING( "unlisted" ) },

    /* Null terminator */
    OM_NULL_DESCRIPTOR
};

static OM_descriptor xdsAttributesToAdd[] = {

    /* This object is an attribute list. */
    OM_OID_DESC( OM_CLASS, DS_C_ATTRIBUTE_LIST ),

    /* These are "pointers" to the attributes in the list. */
    { DS_ATTRIBUTES, OM_S_OBJECT, { 0, xdsObjectClass } },
    { DS_ATTRIBUTES, OM_S_OBJECT, { 0, xdsSurname } },
    { DS_ATTRIBUTES, OM_S_OBJECT, { 0, xdsPhoneNum } },

    /* Null terminator */
    OM_NULL_DESCRIPTOR
};

/*
 * To hold the list of attributes we want to read.
 */
static OM_descriptor xdsAttributeSelection[] = {

    /* This is an entry information selection. */
    OM_OID_DESC( OM_CLASS, DS_C_ENTRY_INFO_SELECTION ),

    /* No, we don't want all attributes. */
    { DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, OM_FALSE },

.ne 10
    /* These are the ones we want to read. */
    OM_OID_DESC( DS_ATTRIBUTES_SELECTED, DS_A_SURNAME ),
    OM_OID_DESC( DS_ATTRIBUTES_SELECTED, DS_A_PHONE_NBR ),

    /* Give us both the types and their values. */
    { DS_INFO_TYPE, OM_S_ENUMERATION, { DS_TYPES_AND_VALUES, NULL } },

    /* Null terminator */
    OM_NULL_DESCRIPTOR
};


/*********************************************************************
 * dce_cf_get_cell_name()
 *	Use this dummy function if CDS is not available.
 ********************************************************************/
void 
dce_cf_get_cell_name(
    char **		cellname,
    unsigned long *	status
)
{
    fprintf( stderr, "CDS unavailable: dce_cf_get_cell_name() error\en" );
    *status = 1;

} /* end dce_cf_get_cell_name() */


/*********************************************************************
 * showUsage()
 *	Display "usage" information.
 ********************************************************************/
void 
showUsage(
    char *	cmd     	/* In--Name of command being called */
)
{
    fprintf( stderr, "\enusage:  %s [option]\en\en", cmd );
    fprintf( stderr, "option:  -a : add an entry\en" );
    fprintf( stderr, "         -r : read an entry\en" );
    fprintf( stderr, "         -d : delete an entry\en" );

} /* end showUsage() */


.ne 15
/*********************************************************************
 * numNamePieces()
 *	Returns the number of pieces in a string name.
 ********************************************************************/
int
numNamePieces(
    char *	string   /* In--String whose pieces are to be counted*/
)
{
    int		count;   /* Number of pieces found */
    char *	currSep; /* Pointer to separator between pieces */

    if( string == NULL ) /* If nothing there, no pieces */
	return( 0 );
    count = 1;           /* Otherwise, there's at least one */

    /*
     * If the first character is a /, it's not really separating
     * two pieces so we want to ignore it here.
     */
    if( *string == '/' )
	currSep = string + 1;
    else
	currSep = string;

    /* How many pieces are there? */
    while( (currSep = strchr( currSep, '/' )) != NULL ) {
	count++;
	currSep++;	/* Begin at next character */
    }

    return( count );

} /* end numNamePieces() */


.ne 13
/*********************************************************************
 * splitNamePiece()
 *	Divides a piece of a name (string) into its XDS attribute type
 *	and value.
 ********************************************************************/
void
splitNamePiece(
    char *      string, /* In--String to be broken down */
    OM_string * type,   /* Out--XDS type of this piece of the name */
    char **     value   /* Out--Pointer to beginning of the value */
)                       /* part of string                         */
{
    char *	equalSign;	/* Location of the = within string */
 
.ne 6
    /*
     * If the string contains an equal sign, this is probably a
     * typed name.  Check for all the attribute types allowed by
     * the default schema.
     */
    if( (equalSign = strchr( string, '=' )) != NULL ) {

	*value = equalSign + 1;
	
	if(( strncmp( string, "C=", 2 ) == 0 ) ||
	   ( strncmp( string, "c=", 2 ) == 0 ))
	    *type = DS_A_COUNTRY_NAME;

	else if(( strncmp( string, "O=", 2 ) == 0 ) ||
                ( strncmp( string, "o=", 2 ) == 0 ))
	    *type = DS_A_ORG_NAME;

	else if(( strncmp( string, "OU=", 3 ) == 0 ) ||
	        ( strncmp( string, "ou=", 3 ) == 0 ))
	    *type = DS_A_ORG_UNIT_NAME;

	else if(( strncmp( string, "LN=", 3 ) == 0 ) ||
	        ( strncmp( string, "ln=", 3 ) == 0 ))
	    *type = DS_A_LOCALITY_NAME;

	else if(( strncmp( string, "CN=", 3 ) == 0 ) ||
	        ( strncmp( string, "cn=", 3 ) == 0 ))
	    *type = DS_A_COMMON_NAME;

.ne 10
	/*
	 * If this did not appear to be a type allowed by the
	 * default schema, consider the whole string as the
	 * value (whose type is "typeless").
	 */
	else {
	    *type = DSX_TYPELESS_RDN;
	    *value = string;
	}
    }

    /*
     * If the string does not contain an equal sign, this is a
     * typeless name.
     */
    else {
	*type = DSX_TYPELESS_RDN;
	*value = string;
    }

} /* end splitNamePiece() */


/*********************************************************************
 * extractValue()
 *   Pulls the value of a particular attribute from a private object
 *   that was received using ds_read().
 *   Returns:
 *     OM_SUCCESS               If successful.
 *     OM_NO_SUCH_OBJECT        If no values for the attribute
 *                              were found.
 *     other                    Any value returned by one of the
 *                              om_get() calls.
 *********************************************************************/
OM_return_code
extractValue(
    OM_private_object   object,    /* In--Object to extract from */
    OM_string *         attribute, /* In--Attribute to extract   */
    char *              value      /* Out--Value found           */
)
.ne 11
{
    OM_public_object    attrList;
    OM_public_object    attrType;
    OM_public_object    attrValue;
    OM_public_object    entry;
    int                 i;
    OM_return_code      omStatus;
    OM_value_position   total;
    OM_value_position   totalAttributes;
    OM_type             xdsIncludedTypes[] = { 0,   /* Place holder   */
                                               0 }; /* Null terminator*/

    /*
     * Get the entry from the object returned by ds_read().
     */
    xdsIncludedTypes[0] = DS_ENTRY;
    omStatus = om_get( object,             /* Object to extract from */
                   OM_EXCLUDE_ALL_BUT_THESE_TYPES+OM_EXCLUDE_SUBOBJECTS,
                                           /* Only want what is in   */
                                           /* xdsIncludedTypes, don't*/
                                           /* include subobjects     */
                       xdsIncludedTypes,   /* What to get            */
                       OM_FALSE,           /* Currently ignored      */
                       OM_ALL_VALUES,      /* Start with first value */
                       OM_ALL_VALUES,      /* End with last value    */
                       &entry,             /* Put the entry here     */
                       &total );           /* Put number of attribut */
                                           /* descriptors here       */
    if( omStatus != OM_SUCCESS ) {
	fprintf( stderr, "om_get( entry ) returned error %d\en",
                 omStatus );
	return( omStatus );
    }
    if( total <= 0 ) {	/* Make sure something was returned */
	fprintf( stderr,
                 "Number of descriptors returned by om_get( entry )
	          was %d\en", total );
	return( OM_NO_SUCH_OBJECT );
    }

.ne 19
    /*
     * Get the attribute list from the entry.
     */
    xdsIncludedTypes[0] = DS_ATTRIBUTES;
    omStatus = om_get( entry->value.object.object,
                  OM_EXCLUDE_ALL_BUT_THESE_TYPES+OM_EXCLUDE_SUBOBJECTS,
                  xdsIncludedTypes, OM_FALSE, OM_ALL_VALUES,
                  OM_ALL_VALUES, &attrList, &totalAttributes );
    if( omStatus != OM_SUCCESS ) {
	fprintf( stderr, "om_get( attrList ) returned error %d\en",
                 omStatus );
	return( omStatus );
    }
    if( total <= 0 ) {	/* Make sure something was returned */
	fprintf( stderr,
	      "Number of descriptors returned by om_get( attrList )
               was %d\en", total );
	return( OM_NO_SUCH_OBJECT );
    }

    /*
     * Search the list for the attribute with the proper type.
     */
    for( i = 0; i < totalAttributes; i++ ) {
        xdsIncludedTypes[0] = DS_ATTRIBUTE_TYPE;
	omStatus = om_get( (attrList+i)->value.object.object,
                    OM_EXCLUDE_ALL_BUT_THESE_TYPES+OM_EXCLUDE_SUBOBJECTS,
                    xdsIncludedTypes, OM_FALSE, OM_ALL_VALUES,
                    OM_ALL_VALUES, &attrType, &total );
	if( omStatus != OM_SUCCESS ) {
	    fprintf( stderr, "om_get( attrType ) [i = %d] returned
		      error %d\en", i, omStatus );
	    return( omStatus );
	}
	if( total <= 0 ) {  /* Make sure something was returned */
	    fprintf( stderr,
	    "Number of descriptors returned by om_get( attrType )
		      [i = %d] was %d\en", i, total );
	    return( OM_NO_SUCH_OBJECT );
	}
	if( strncmp( attrType->value.string.elements,
                     attribute->elements,
		     attribute->length ) == 0 )
	    break;	   /* If we found a match, quit looking. */
    }
.ne 5
    if( i == totalAttributes ) {   /* Verify that we found a match. */
	fprintf( stderr, 
	    "%s: extractValue() could not find requested attribute\en" );
	return( OM_NOT_PRESENT );
    }

    /*
     * Get the attribute value from the corresponding item in the
     * attribute list.
     */
    xdsIncludedTypes[0] = DS_ATTRIBUTE_VALUES;
    omStatus = om_get( (attrList+i)->value.object.object,
                 OM_EXCLUDE_ALL_BUT_THESE_TYPES+OM_EXCLUDE_SUBOBJECTS,
                 xdsIncludedTypes, OM_FALSE, OM_ALL_VALUES,
                 OM_ALL_VALUES, &attrValue, &total );
    if( omStatus != OM_SUCCESS ) {
	fprintf( stderr, "om_get( attrValue ) returned error %d\en",
		 omStatus );
	return( omStatus );
    }
    if( total <= 0 ) {	/* Make sure something was returned */
	fprintf( stderr,
	  "Number of descriptors returned by om_get( attrValue )
		 was %d\en", total );
	return( OM_NO_SUCH_OBJECT );
    }

    /*
     * Copy the value into the buffer for return to the caller.
     */
    strncpy( value, attrValue->value.string.elements,
	     attrValue->value.string.length );
    value[attrValue->value.string.length] = '\e0';

    /*
     * Free up the resources we don't need any more and return.
     */
    om_delete( attrValue );
    om_delete( attrType );
    om_delete( attrList );
    om_delete( entry );
    return( OM_SUCCESS );

} /* end extractValue() */


.ne 21
/**********************************************************************
 * stringToXdsName()
 *    Converts a string that is a DCE name to an XDS name object (class 
 *    DS_C_DS_DN).  Returns one of the following:
 *       OM_SUCCESS             If successful.
 *       OM_MEMORY_INSUFFICIENT If a malloc fails.
 *       OM_PERMANENT_ERROR     If the name is not in a valid format.
 *       OM_SYSTEM_ERROR        If the local cell's name cannot
 *                              be determined.
 *
 *    Technically, the space obtained here through malloc() needs
 *    to be returned to the system when it is no longer needed.
 *    If this was a more complex application, this function would
 *    probably malloc all the space it needs at once and require
 *    calling routines to free the space when finished with it.
 *********************************************************************/
OM_return_code
stringToXdsName(
    char *	origString,	/* In--String name to be converted */
    OM_object *	xdsNameObj	/* Out--Pointer to XDS name object */
)
{
    OM_descriptor * ava;	    /* DS_C_AVA object */
    char *	    cellName;       /* Name of this cell */
    OM_object	    dsdn;	    /* DS_C_DS_DN object */
    char *	    end;	    /* End of name piece */
    int		    index;	    /* Index into DS_C_DS_DN object */
    int		    numberOfPieces; /* Number of pieces in the name */
    unsigned long   rc; 	    /* Return code for some functions*/
    OM_descriptor * rdn;	    /* DS_C_RDN object */
    char *	    start;	    /* Beginning of piece of name */
    char *	    string;	/* Copy of origString that we can use*/
    OM_string	    type;	/* Type of one piece of the name */
    char *	    value;	/* Piece of the name */

.ne 19
    /*
     * A DS_C_AVA object only contains pointers to the strings that
     * represent the pieces of the name, not the contents of the
     * strings themselves.  So we'll make a copy of the string passed
     * in to guarantee that these pieces survive in case the programmer
     * alters or reuses the original string.
     *
     * In addition, all valid names should begin with one of the
     * following symbols:
     *     /...        Fully qualified name (from global root).  For
     *                 these, we need to ignore the /...
     *     /.:         Partially qualified name (from local cell root).
     *                 For these, we must replace the /.: with the name
     *                 of the local cell name
     * If we see anything else, we'll return with an error.  (Notice
     * that /: is a valid DCE name, but refers to the file system's
     * namespace.  Filenames cannot be accessed through
     * CDS, GDS, or XDS.)
     */
    if( strncmp( origString, "/.../", 5 ) == 0 ) {
	string = (char *)malloc( strlen(origString+5) + 1 );
	if( string == NULL )             /* malloc() failed */
	    return OM_MEMORY_INSUFFICIENT;
	strcpy( string, origString+5 );
    }
    else if( strncmp( origString, "/.:/", 4 ) == 0 ) {
	dce_cf_get_cell_name( &cellName, &rc );
	if( rc != 0 )            /* Could not get cell name */
	    return OM_SYSTEM_ERROR;
	
	/*
	 * The cell name will have /.../ on the front, so we will
	 * skip over it as we add it to the string (by always
	 * starting at its fifth character).
	 */
	string = (char *)malloc( strlen
                    (origString+4) + strlen(cellName+5) + 2 );
	if( string == NULL )               /* malloc() failed */
	    return OM_MEMORY_INSUFFICIENT;
	strcpy( string, cellName+5 );
	strcat( string, "/" );
	strcat( string, origString+4 );
    }
    else		                /* Invalid name format */
	return OM_PERMANENT_ERROR;

.ne 5
    /*
     * Count the number of pieces in the name that will have to
     * be dealt with.
     */
    numberOfPieces = numNamePieces( string );

    /*
     * Allocate memory for the DS_C_DS_DN object.  We will need an
     * OM_descriptor for each name piece, one for the class
     * identifier, and one for the null terminator.
     */
    dsdn = (OM_object)malloc(
             (numberOfPieces + 2) * sizeof(OM_descriptor) );
    if( dsdn == NULL )                     /* malloc() failed */
	return OM_MEMORY_INSUFFICIENT;

    /*
     * Initialize it as a DS_C_DS_DN object by placing that class
     * identifier in the first position.
     */
    FILL_OMD_XOM_STRING( dsdn, 0, OM_CLASS, 
                         OM_S_OBJECT_IDENTIFIER_STRING, DS_C_DS_DN )

    /*
     * For each piece of string, do the following:
     *     Break off the next piece of the string
     *     Build a DS_C_AVA object to show the type and value
     *         of this piece of the name
     *     Wrap the DS_C_AVA up in a DS_C_RDN object
     *     Add the DS_C_RDN to the DS_C_DS_DN object
     */
    for( start=string, index=1 ; index <= numberOfPieces ;
          index++, start=end+1 ) {

	/*
	 * Find the next delimiter and replace it with a null byte
	 * so the piece of the name is effectively separated from
	 * the rest of the string.
	 */
        end = strchr( start, '/' );
        if( end != NULL )
            *end = '\e0';
        else            /* If this is the last piece, there won't be */
                        /* a '/' at the end, just a null byte.       */
	    end = strchr( start, '\e0' );

.ne 18
	/*
	 * Allocate space for a DS_C_AVA object and fill in its entries:
	 *	DS_C_AVA class identifier
	 *	AVA's type
	 *	AVA's value
	 *	null terminator
	 */
	ava = (OM_descriptor *)malloc( sizeof(OM_descriptor) * 4 );
	if( ava == NULL )                  /* malloc() failed */
	    return OM_MEMORY_INSUFFICIENT;
	FILL_OMD_XOM_STRING( ava, 0, OM_CLASS, 
		   OM_S_OBJECT_IDENTIFIER_STRING, DS_C_AVA )
	splitNamePiece( start, &type, &value );
	FILL_OMD_XOM_STRING( ava, 1, DS_ATTRIBUTE_TYPE,
		   OM_S_OBJECT_IDENTIFIER_STRING, type )
	FILL_OMD_STRING( ava, 2, DS_ATTRIBUTE_VALUES,
                         OM_S_PRINTABLE_STRING, value )
	FILL_OMD_NULL( ava, 3 )

	/*
	 * Allocate space for a DS_C_RDN object and fill in its entries:
	 *	DS_C_RDN class identifier
	 *	AVA it contains
	 *	null terminator
	 */
	rdn = (OM_descriptor *)malloc( sizeof(OM_descriptor) * 3 );
	if( rdn == NULL )                     /* malloc() failed */
	    return OM_MEMORY_INSUFFICIENT;
	FILL_OMD_XOM_STRING( rdn, 0, OM_CLASS, 
                             OM_S_OBJECT_IDENTIFIER_STRING, DS_C_DS_RDN )
	FILL_OMD_STRUCT( rdn, 1, DS_AVAS, OM_S_OBJECT, ava )
	FILL_OMD_NULL( rdn, 2 )

	/* Add the DS_C_RDN object to the DS_C_DS_DN object. */
	FILL_OMD_STRUCT( dsdn, index, DS_RDNS, OM_S_OBJECT, rdn )
    }

    /*
     * Null terminate the DS_C_DS_DN, tell the calling routine
     * where to find it, and return.
     */
    FILL_OMD_NULL( dsdn, index )
    *xdsNameObj = dsdn;
    return( OM_SUCCESS );

} /* end stringToXdsName() */


.ne 17
/***********************************************************************
 * handleDSError()
 *     Extracts the error number from a DS_status return code, prints it
 *     in an error message, then terminates the program.
 **********************************************************************/
void 
handleDSError(
    char *      header,     /* In--Name of function whose return code */
                            /*     is being checked                   */
    DS_status   returnCode  /* In--Return code to be checked */
)
{
    OM_type             includeDSProblem[] = { DS_PROBLEM,
                                              0 };
    OM_return_code      omStatus;
    OM_public_object    problem;
    OM_value_position   total;

    /*
     * A DS_status return code is an object.  It will be one of the
     * subclasses of the class DS_C_ERROR.  What we want from it is
     * the value of the attribute DS_PROBLEM.
     */
    omStatus = om_get( returnCode,
                   OM_EXCLUDE_ALL_BUT_THESE_TYPES+OM_EXCLUDE_SUBOBJECTS,
                   includeDSProblem,
                   OM_FALSE,
                   OM_ALL_VALUES,
                   OM_ALL_VALUES,
                   &problem,
                   &total );

    /*
     * Make sure we successfully extracted the problem number and print
     * the error message before quitting.
     */
    if( (omStatus == OM_SUCCESS) && (total > 0) )
	printf( "%s returned error %d\en", header,
                problem->value.enumeration );
    else
	printf( "%s failed for unknown reason\en", header );

    exit( 1 );
}


.ne 23
/********************************************************************
 * Main program
 */
void
main(
    int		argc,
    char *	argv[]
)
{
    DS_status		dsStatus;
    OM_sint		invokeID;
    char		newName[MAX_NAME_LEN];
    char		newPhoneNum[MAX_PHONE_LEN];
    char		newSurname[MAX_SURNAME_LEN];
    OM_return_code	omStatus;
    char		phoneNumRead[MAX_PHONE_LEN];
    int			rc = 0;
    OM_private_object	readResult;
    OM_private_object	session;
    char		surnameRead[MAX_SURNAME_LEN];
    OM_object		xdsName;
    OM_workspace	xdsWorkspace;
    int			operation;

    /* Step 1
     *
     * Examine command-line argument.
     */
     operation = getopt( argc, argv, "rad" );
     if ( (operation == '?') || (operation == EOF) ) {
         showUsage( argv[0] );
         exit( 1 );
     }

    /* Step 2
     *
     * Initialize the XDS workspace.
     */
    xdsWorkspace = ds_initialize( );
    if( xdsWorkspace == NULL ) {
	fprintf( stderr, "ds_initialize() failed\en" );
	exit( 1 );
    }

.ne 7
    /* Step 3
     *
     * Pull in the packages that contain the XDS features we need.
     */
    dsStatus = ds_version( featureList, xdsWorkspace );
    if( dsStatus != DS_SUCCESS )
	handleDSError( "ds_version()", dsStatus );

    /* Step 4
     *
     * Find out what name the user wants to use in the namespace and
     * convert it to and XDS object.  We do this conversion dynamically
     * (not using static structures defined at the top of the program)
     * because we don't know how long the name will be.
     */
    switch( operation ) {
    case 'r' :
        printf( "What name do you want to read? " );
        break;
    case 'a' :
        printf( "What name do you want to add? " );
        break;
    case 'd' :
        printf( "What name do you want to delete? " );
        break;
    }

    /* Step 5 */

    gets( newName );
    omStatus = stringToXdsName( newName, &xdsName );
    if( omStatus != OM_SUCCESS ) {
       fprintf( stderr, "stringToXdsName() failed with OM error %d\en",
		 omStatus );
	exit( 1 );
    }

.ne 14
    if ( operation == 'a' ) {
        /* add operation requires additional input */
        /*
         * Get the person's real name from the user and place it in
         * the XDS object already defined at the top of the program
         * (xdsSurname).  We are requiring a name, so we will loop
         * until we get one.
         */
        do {
	    printf( "What is this person's surname? " );
	    gets( newSurname );
        } while ( *newSurname == '\e0' );
        FILL_OMD_STRING( xdsSurname, 2, DS_ATTRIBUTE_VALUES,
		         OM_S_TELETEX_STRING, newSurname )

        /*
         * Get the person's phone number from the user and place it
         * in the XDS object already defined at the top of the
         * program (xdsPhoneNum).  A phone number is not required,
         * so if none is given we will use the default already
         * stored in the structure.
         */
        printf( "What is this person's phone number? " );
        gets( newPhoneNum );
        if( *newPhoneNum != '\e0' ) {
	    FILL_OMD_STRING( xdsPhoneNum, 2, DS_ATTRIBUTE_VALUES,
		     OM_S_PRINTABLE_STRING, newPhoneNum )
        }
    }

    /* Step 6
     *
     * Open the session with the namespace:
     *  bind (without credentials) to the default server.
     */
    dsStatus = ds_bind( DS_DEFAULT_SESSION, xdsWorkspace, &session );
    if( dsStatus != DS_SUCCESS )
	handleDSError( "ds_bind()", dsStatus );


    /* Step 7 */

    switch( operation ) {   /* perform the requested operation */

.ne 10
    /*
     * Add entry to the namespace.  The xdsSurname and xdsPhoneNum
     * objects are already contained within an attribute list object
     * (xdsAttributesToAdd).
     */
    case 'a' :
        dsStatus = ds_add_entry( session, DS_DEFAULT_CONTEXT, xdsName,
	         xdsAttributesToAdd, &invokeID );
        if( dsStatus != DS_SUCCESS )
	    handleDSError( "ds_add_entry()", dsStatus );

        /* FALL THROUGH */

    /*
     * Read the entry of the name supplied.
     */
    case 'r' :
        dsStatus = ds_read( session, DS_DEFAULT_CONTEXT, xdsName,
	       xdsAttributeSelection, &readResult, &invokeID );
        if( dsStatus != DS_SUCCESS )
	    handleDSError( "ds_read()", dsStatus );
		        
        /*
         * Get each attribute from the object read and print them.
         */
        omStatus = extractValue( readResult, &DS_A_SURNAME,
                   surnameRead );
        if( omStatus != OM_SUCCESS ) {
	    printf( "** Surname could not be read\en" );
	    strcpy( surnameRead, "(unknown)" );
	    rc = 1;
        }
        omStatus = extractValue( readResult, &DS_A_PHONE_NBR,
                   phoneNumRead );
        if( omStatus != OM_SUCCESS ) {
	    printf( "** Phone number could not be read\en" );
    	    strcpy( phoneNumRead, "(unknown)" );
	    rc = 1;
        }
        printf( "The phone number for %s is %s.\en", surnameRead,
                 phoneNumRead );

        break;

.ne 12
    /*
     * delete the entry from the namespace.
     */
    case 'd' :
        dsStatus = ds_remove_entry( session, DS_DEFAULT_CONTEXT,
			          xdsName, &invokeID );
        if( dsStatus != DS_SUCCESS )
	    handleDSError( "ds_remove_entry()", dsStatus );
        else
            printf( "The entry has been deleted.\en" );
        break;
    }

    /*
     * Clean up and exit.
     */
    /* Step 8 */
    dsStatus = ds_unbind( session );
    if( dsStatus != DS_SUCCESS )
	handleDSError( "ds_unbind()", dsStatus );

    /* Step 9 */
    dsStatus = ds_shutdown( xdsWorkspace );
    if( dsStatus != DS_SUCCESS )
	handleDSError( "ds_shutdown()", dsStatus );

    exit( rc );

} /* end main() */
.oE
