...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
...\" src directory for the full copyright text.
...\" 
...\" HISTORY
...\" $Log: 1_intro_gds.gpsml,v $
...\" Revision 1.1.12.1  1996/09/03  18:14:11  wardr
...\" 	{enh,R1.2.2}
...\" 	Update for sgml conversion
...\" 	[1996/09/03  18:13:19  wardr]
...\"
...\" Revision 1.1.10.1  1996/03/19  15:22:06  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/19  15:21:24  wardr]
...\" 
...\" Revision 1.1.8.17  1995/06/15  16:28:25  rcb
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/13  19:26:16  rcb]
...\" 
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/05  19:00:55  rcb]
...\" 
...\" Revision 1.1.8.16  1994/11/15  20:47:50  neilson
...\" 	Converted book title references to macro form.
...\" 	[1994/11/15  18:57:55  neilson]
...\" 
...\" Revision 1.1.8.15  1994/11/03  23:33:06  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:38:39  neilson]
...\" 
...\" 	Substituted macros for book names in cross refs.
...\" 
...\" Revision 1.1.8.14  1994/10/19  16:31:03  rnollman
...\" 	fixed format errors
...\" 	[1994/10/19  16:30:43  rnollman]
...\" 
...\" Revision 1.1.8.13  1994/10/19  15:47:33  rnollman
...\" 	formatting fixes
...\" 	[1994/10/19  15:47:19  rnollman]
...\" 
...\" Revision 1.1.8.12  1994/10/18  17:57:00  rnollman
...\" 	incorporate Dave Treff's comments
...\" 	[1994/10/18  17:55:44  rnollman]
...\" 
...\" Revision 1.1.8.11  1994/10/14  14:12:12  rnollman
...\" 	incorporated Dublin technical changes
...\" 	[1994/10/14  14:11:57  rnollman]
...\" 
...\" Revision 1.1.8.10  1994/08/05  14:00:22  rnollman
...\" 	completed osf edits
...\" 	[1994/08/05  13:56:31  rnollman]
...\" 
...\" Revision 1.1.8.9  1994/05/14  22:31:27  rnollman
...\" 	last submission for beta
...\" 	[1994/05/14  22:27:25  rnollman]
...\" 
...\" Revision 1.1.8.8  1994/05/12  15:52:03  rnollman
...\" 	final update for beta
...\" 	[1994/05/12  15:51:27  rnollman]
...\" 
...\" Revision 1.1.8.7  1994/03/14  22:00:24  rom
...\" 	{enh, 10129, R1.1}
...\" 	Fix pathnames of included files for new three-book organization.
...\" 	[1994/03/14  21:19:57  rom]
...\" 
...\" Revision 1.1.8.6  1994/03/14  15:15:02  rnollman
...\" 	no changes -- Bob Matthews updating file references for reorganization of
...\" 	book
...\" 	[1994/03/14  15:14:26  rnollman]
...\" 
...\" Revision 1.1.8.5  1993/11/11  21:28:49  rnollman
...\" 	minor editorial fix
...\" 	[1993/11/11  21:28:34  rnollman]
...\" 
...\" Revision 1.1.8.4  1993/11/11  21:06:55  rnollman
...\" 	update SNI copyright
...\" 	[1993/11/11  21:06:37  rnollman]
...\" 
...\" Revision 1.1.8.3  1993/11/08  20:13:01  rnollman
...\" 	fixed table formats (changed .TS to .TS H)
...\" 	[1993/11/08  20:12:44  rnollman]
...\" 
...\" Revision 1.1.8.2  1993/10/27  19:47:44  rnollman
...\" 	fixed pic pathnames
...\" 	[1993/10/27  19:47:21  rnollman]
...\" 
...\" Revision 1.1.8.1  1993/10/27  18:25:09  rnollman
...\" 	[rnollman] - replaced old version with new version from Dublin
...\" 	[1993/10/27  18:24:45  rnollman]
...\" 
...\" 	replaced old version with new version from Dublin
...\" 
...\" Revision 1.1.6.6  1993/01/28  18:40:55  cjd
...\" 	Embedded copyright notice
...\" 	[1993/01/28  18:00:26  cjd]
...\" 
...\" Revision 1.1.6.5  1993/01/10  16:28:09  rnollman
...\" 	minor editorial change
...\" 	[1993/01/10  16:27:37  rnollman]
...\" 
...\" Revision 1.1.6.4  1993/01/08  12:24:38  marrek
...\" 	Changes from SSE Dublin.
...\" 	[1993/01/08  12:23:09  marrek]
...\" 
...\" Revision 1.1.6.3  1992/12/21  16:07:26  rnollman
...\" 	added Helmut Volper's comments
...\" 	[1992/12/21  16:06:40  rnollman]
...\" 
...\" 	added section on accessing the DUA cache without a GDS server
...\" 	[1992/12/16  21:53:04  rnollman]
...\" 
...\" Revision 1.1.6.2  1992/11/20  16:21:13  weir
...\" 	Moved into 1.0.2doc tree
...\" 	[1992/11/20  16:17:48  weir]
...\" 
...\" Revision 1.1.4.10  1992/11/12  22:24:32  rom
...\" 	Correct index entries.
...\" 	[1992/11/12  22:20:41  rom]
...\" 
...\" Revision 1.1.4.9  1992/11/11  23:46:10  buckler
...\" 	Corrected index entries
...\" 	[1992/11/11  22:49:35  buckler]
...\" 
...\" Revision 1.1.4.8  1992/11/06  16:09:05  lmk
...\" 	Prentice-Hall index edits only
...\" 	[1992/11/06  16:04:23  lmk]
...\" 
...\" Revision 1.1.4.7  1992/11/02  21:37:54  lmk
...\" 	Prentice-Hall index entries only
...\" 	[1992/11/02  21:37:24  lmk]
...\" 
...\" Revision 1.1.4.6  1992/10/29  17:16:42  lmk
...\" 	Prentice-Hall index edits only
...\" 	[1992/10/29  17:15:51  lmk]
...\" 
...\" Revision 1.1.4.5  1992/10/28  21:33:47  lmk
...\" 	Prentice-Hall index entries only
...\" 	[1992/10/28  17:38:52  lmk]
...\" 
...\" Revision 1.1.4.4  1992/10/20  15:28:43  steiner
...\" 	3rd P-H edit - nits and making tables smaller.
...\" 	[1992/10/20  15:28:15  steiner]
...\" 
...\" Revision 1.1.4.3  1992/10/14  19:44:14  steiner
...\" 	Second P-H edit pass.
...\" 	[1992/10/14  19:43:47  steiner]
...\" 
...\" Revision 1.1.4.2  1992/09/09  22:21:10  steiner
...\" 	First PH editing pass.
...\" 	[1992/09/09  22:20:41  steiner]
...\" 
...\" Revision 1.1.2.40  1992/07/17  19:04:37  weir
...\" 	Fixed various typos, etc.
...\" 	[1992/07/17  18:56:49  weir]
...\" 
...\" Revision 1.1.2.39  1992/07/09  15:10:21  rnollman
...\" 	fixed figure 25-8, font for figure title too large, added .S 12
...\" 	[1992/07/09  15:09:41  rnollman]
...\" 
...\" Revision 1.1.2.38  1992/06/22  20:10:24  rnollman
...\" 	rev comments
...\" 	[1992/06/22  20:09:35  rnollman]
...\" 
...\" Revision 1.1.2.37  1992/06/16  14:03:33  rnollman
...\" 	rev comments
...\" 	[1992/06/16  14:02:20  rnollman]
...\" 
...\" Revision 1.1.2.36  1992/06/15  21:13:28  rnollman
...\" 	rev comments
...\" 	[1992/06/15  21:12:44  rnollman]
...\" 
...\" Revision 1.1.2.35  1992/06/15  19:59:49  rnollman
...\" 	inc comments
...\" 	[1992/06/15  19:58:54  rnollman]
...\" 
...\" Revision 1.1.2.34  1992/06/12  20:04:48  rnollman
...\" 	rev comments
...\" 	[1992/06/12  20:04:03  rnollman]
...\" 
...\" Revision 1.1.2.33  1992/06/12  17:28:19  rnollman
...\" 	rev comments
...\" 	[1992/06/12  17:27:36  rnollman]
...\" 
...\" Revision 1.1.2.32  1992/06/12  16:52:29  rnollman
...\" 	rev comments
...\" 	[1992/06/12  16:51:28  rnollman]
...\" 
...\" Revision 1.1.2.31  1992/06/12  16:09:43  rnollman
...\" 	rev comments
...\" 	[1992/06/12  16:08:47  rnollman]
...\" 
...\" Revision 1.1.2.30  1992/06/11  18:55:12  rnollman
...\" 	rev comments
...\" 	[1992/06/11  18:54:24  rnollman]
...\" 
...\" Revision 1.1.2.29  1992/06/09  20:27:29  rnollman
...\" 	rev comments
...\" 	[1992/06/09  20:26:48  rnollman]
...\" 
...\" Revision 1.1.2.28  1992/06/09  20:12:35  rnollman
...\" 	rev comments
...\" 	[1992/06/09  20:11:52  rnollman]
...\" 
...\" Revision 1.1.2.27  1992/06/09  20:04:23  rnollman
...\" 	rev comments
...\" 	[1992/06/09  20:03:43  rnollman]
...\" 
...\" Revision 1.1.2.26  1992/06/08  20:32:09  rnollman
...\" 	inc comments
...\" 	[1992/06/08  20:31:33  rnollman]
...\" 
...\" Revision 1.1.2.25  1992/06/08  20:14:06  rnollman
...\" 	adding index
...\" 	[1992/06/08  20:13:32  rnollman]
...\" 
...\" Revision 1.1.2.24  1992/06/08  15:13:19  rnollman
...\" 	rev comments
...\" 	[1992/06/08  15:12:43  rnollman]
...\" 
...\" Revision 1.1.2.23  1992/06/06  20:09:33  rnollman
...\" 	rev comments.
...\" 	[1992/06/06  20:09:05  rnollman]
...\" 
...\" Revision 1.1.2.22  1992/06/06  13:56:18  rnollman
...\" 	rev comments
...\" 	[1992/06/06  13:55:28  rnollman]
...\" 
...\" 	inc review comments
...\" 	[1992/06/06  12:27:46  rnollman]
...\" 
...\" Revision 1.1.2.21  1992/06/05  22:30:16  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  22:29:35  rnollman]
...\" 
...\" Revision 1.1.2.20  1992/06/05  15:58:49  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  15:58:03  rnollman]
...\" 
...\" Revision 1.1.2.19  1992/06/05  08:36:46  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  08:36:10  rnollman]
...\" 
...\" Revision 1.1.2.18  1992/06/05  07:50:18  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  07:49:38  rnollman]
...\" 
...\" Revision 1.1.2.17  1992/06/04  00:42:45  rnollman
...\" 	incorpor comments.
...\" 	[1992/06/04  00:42:09  rnollman]
...\" 
...\" 	inc comments.
...\" 	[1992/06/03  23:26:37  rnollman]
...\" 
...\" Revision 1.1.2.16  1992/06/03  15:24:15  rnollman
...\" 	inc review comments.
...\" 	[1992/06/03  15:23:20  rnollman]
...\" 
...\" 	inc review comments.
...\" 	[1992/06/03  14:43:43  rnollman]
...\" 
...\" Revision 1.1.2.15  1992/06/03  02:24:46  rnollman
...\" 	incorporated review comments.
...\" 	[1992/06/03  02:24:12  rnollman]
...\" 
...\" Revision 1.1.2.14  1992/06/02  20:22:14  rnollman
...\" 	small fix...
...\" 	[1992/06/02  20:21:19  rnollman]
...\" 
...\" Revision 1.1.2.13  1992/06/02  19:47:54  rnollman
...\" 	more review comments incorporated...
...\" 	[1992/06/02  19:47:12  rnollman]
...\" 
...\" Revision 1.1.2.12  1992/06/02  13:48:06  rnollman
...\" 	still trying to make sure that I did not screw up the file...
...\" 	[1992/06/02  13:47:35  rnollman]
...\" 
...\" Revision 1.1.2.11  1992/06/02  13:41:30  rnollman
...\" 	just checking to see if I screwed something up...
...\" 	[1992/06/02  13:40:01  rnollman]
...\" 
...\" 	more edits incorporating comments
...\" 	[1992/06/01  20:32:20  rnollman]
...\" 
...\" Revision 1.1.2.10  1992/06/01  18:09:18  rnollman
...\" 	continuing to incorporate Teo's review comments
...\" 	[1992/06/01  18:08:32  rnollman]
...\" 
...\" Revision 1.1.2.9  1992/05/28  21:29:13  rnollman
...\" 	continued incorporating Teo's comments
...\" 	[1992/05/28  21:28:32  rnollman]
...\" 
...\" Revision 1.1.2.8  1992/05/28  13:52:59  rnollman
...\" 	no work done. not sure if bco done correctly
...\" 	[1992/05/28  13:52:13  rnollman]
...\" 
...\" Revision 1.1.2.7  1992/05/27  20:37:10  rnollman
...\" 	copied to BKDIR directory so that I could print out copy.
...\" 	[1992/05/27  20:36:22  rnollman]
...\" 
...\" Revision 1.1.2.6  1992/05/27  20:18:50  rnollman
...\" 	updated after Dublin trip with Teo's comments from file rich.1
...\" 	[1992/05/27  20:17:36  rnollman]
...\" 
...\" Revision 1.1.2.5  1992/05/12  15:40:00  rnollman
...\" 	*** empty log message ***
...\" 	[1992/05/12  15:39:10  rnollman]
...\" 
...\" 	*** empty log message ***
...\" 	[1992/05/12  15:34:38  rnollman]
...\" 
...\" Revision 1.1.2.4  1992/05/12  15:32:05  rnollman
...\" 	*** empty log message ***
...\" 	[1992/05/12  15:31:14  rnollman]
...\" 
...\" Revision 1.1.2.3  1992/05/10  20:47:45  weir
...\" 	New version.
...\" 	[1992/05/10  20:47:22  weir]
...\" 
...\" Revision 1.1.2.2  1992/05/08  21:06:49  weir
...\" 	Initial check-in
...\" 	[1992/05/08  21:06:14  weir]
...\" 
...\" $EndLog$
...\" 
...\" /*****************************************************************
...\" *                                                                *
...\" * COPYRIGHT   (C)  SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1994   *
...\" *                  ALL RIGHTS RESERVED                           *
...\" *                                                                *
...\" *****************************************************************/
.H 1 "GDS API: Concepts and Overview"
.P
The Global Directory Service (GDS) is a distributed, replicated
directory service.  It is distributed because information is stored
in different places in the network.  Requests for information may be
routed by the GDS to directory servers throughout
the network.  It is replicated because information can be stored in
more than one location for easier and more efficient access by its
users.
.P
GDS is based on the CCITT X.500/ISO 9594
(1988) international standard.  The aim of this standard, also
referred to as the OSI Directory standard, is to provide a global
directory that supports network users and applications with
information required for communications.  The directory plays a
significant role in allowing the interconnection of information
processing systems from different manufacturers, under different
managements, of different levels of complexity, and of different ages.
.P
GDS is the DCE implementation of the OSI Directory standard.  Together
with the Cell Directory Service (CDS), it provides its users with a
centralized place to store information required for communications,
which can be retrieved from anywhere in a distributed system.  GDS
maintains information describing objects such as people,
organizations, applications, distribution lists, network hardware, and
other distributed services dispersed over a large geographical area.
.P
CDS stores names and attributes of resources
located in a DCE cell.  A DCE cell consists of various combinations of
DCE machines connected by a network.  Each DCE cell contains its own
cell directory server, which provides access to local resource
information.  The CDS is optimized for local
information access by its users.  For a more detailed description of
cells and their resource services, see the \*(In.
.P
GDS serves as a general-purpose information
repository.  It provides information about resources outside a DCE
cell.  It ties together the various cells by helping to find remote
cells.  A detailed discussion of the DCE namespace and its various
servers and their interaction is provided in Chapter 1.
.H 2 "Directory Service Interfaces"
.P
.iX "GDS" "XOM API"
.iX "GDS" "XDS API"
.iX "-: GDS" "Global Directory Service"
.iX "XDS" "API"
.iX "XOM" "API"
.iX "-: XDS" "X/Open" "Directory Service"
.iX "-: XOM" "X/Open" "OSI-Abstract-Data Manipulation"
X/Open Directory Service
(XDS) and X/Open OSI-Abstract-Data Manipulation (XOM) are application
programming interfaces.  XOM and XDS application interfaces are based on X/Open
standards specifications.  Together these interfaces provide the application
programmer with a library of functions with which to develop
applications that access the directory service.
.P
The XOM application programming interface 
(XOM API) is an interface for creating,
deleting, and accessing information objects.  The XOM API defines an
object-oriented information model.  Objects belong to classes and have
attributes associated with them.  The XOM API also defines basic data
types, such as Boolean, string, object, and so on.  The representation
of these objects are transparent to the programmer.  Objects can only
be manipulated through the XOM interface, not directly.  
.P
DCE programmers use the XDS API to make directory service calls.  In
DCE, XDS API directs the calls it receives to either GDS or CDS
by examining the names
of the information objects to be looked up as shown in Figure 4-1.
It uses the XOM interface for defining and handling information
objects.  These objects are passed as
parameters and return values to the XDS routines.  The XDS API
contains functions for managing connections with a directory server:
reading, comparing, adding, removing, modifying, listing, and
searching for directory entries.  The GDS package provides
additional information objects that provide for security and cache
management when using GDS.
.P
GDS supports additional functions, called \*Vconvenience functions\*O, at the
XDS/XOM API. These functions, described in Chapter 9, provide GDS
programmers with a ``toolkit'' to allow more efficient production of
XDS/XOM based applications.
.P
.FG "XDS: Interface to GDS and CDS"
.dI ../directory/xds_gds/Pics/fig1.03.pic
.H 2 "The X.500 Directory Information Model"
.P
.iX "directory" "information model"
.iX "X.500" "directory information model"
This section describes the directory information model of X.500,
which GDS is based on.
A directory is a collection of information about some part of the
world.  The most familiar type of directory is the list of names and
numbers that make up a city telephone directory.  A name is provided
with some information about the named object, such as an address and
telephone number.  The ISO and CCITT standards define a \*Edirectory
information model\*O that defines the abstract structure of directory
information, services, and protocols for a computer network
environment, such as DCE.
.H 3 "Directory Objects"
.P
.iX "directory" "objects"
.iX "object" "directory"
The directory contains information about objects.  The standard
defines an object very broadly as ``anything in some `world,' generally
the world of telecommunications and information processing or some
part thereof, which is identifiable (can be named).''  Some examples of
objects include people, corporations, and application processes.
.P
.iX "-: DIB" "Directory Information Base"
.iX "DIB" 
Each object known to the directory is represented by an entry.  The
set of all entries is called the Directory Information Base (DIB), which
is a hierarchical tree.  Each entry
consists of a set of attributes representing specific information
about the object.  Each attribute, in turn, has a type and one or more
values of that type.  Attributes with more than one value are referred
to as \*Emultivalued\*O or \*Erecurring\*O attributes.
.P
.iX "directory" "structure of the DIB"
.iX "DIB" "structure of"
Figure 4-2 shows the structure of the DIB.
.P
.FG "The Structure of the DIB"
.dI ../directory/xds_gds/Pics/fig1.04.pic
.P
The attributes that constitute a single entry can be of various types.
For example, an entry for a person may contain that person's name,
address, and phone number.  If the person has a second telephone number, the
attribute of type telephone number may have two values, one for each telephone number.
.P
Object entries are composed of mandatory and optional attributes.
Mandatory and optional attributes are discussed in Section 4.4.3.
.H 3 "Attribute Types"
.P
.iX "directory" "attribute types"
.iX "attribute" "type" "directory"
All attributes in a particular entry must be of different attribute
types.  Each attribute type is assigned a unique object identifier
value.  The directory standard assigns object identifiers for several
commonly used attribute types, including surname, country name,
telephone number, and presentation address.  Other international
standards may define additional attribute types.  For example, the
X.400 Message Handling standard defines mail-specific attributes like
O/R address.  It is expected that various national and private
organizations will also define attribute types of their own.  The CDS
attributes (defined in the \*Lxdscds.h\*O header file) and the
GDS package attributes (defined
in the \*Lxdsgds.h\*O header file) are examples of additional attribute
definitions.
.H 3 "Object Identifiers"
.P
.iX "object" "identifier" "directory"
.iX "directory" "object identifiers"
Objects in a network environment, such as DCE, require unique names to
distinguish them from one another.  To provide these names, object
identifiers are allocated by an administrative organization, such as a
standards body.  An object identifier is a hierarchical sequence of
numbers uniquely identifying an object.  Associated with each object
identifier is a character string to make it easier to document.
.P
The possible values of object identifiers are defined in a tree.  Part
of this tree is shown in Figure 4-3.  It begins with three numbered
branches coming from the root: branch 0 (assigned to CCITT), branch 1
(assigned to ISO), and branch 2 (a joint ISO-CCITT branch).  Below each
of these branches are other numbered branches assigned to various
standards such as the directory service (\*Lds(5)\*O) and electronic mail
service (\*Lmhs-motis(6)\*O) with each ending in a named object.
Thus, the name
of any of these objects is a series of integers describing a
path down this tree to the leaf node.
.P
.ne 3.5i
.FG "Object Identifiers"
.sp .5
.dI ../directory/xds_gds/Pics/fig01.tree.pic
.sp
.P
The object identifier associated with the XDS package is defined
as follows:
.iX "object" "identifier, XDS package"
.iS
{iso(1) identified-organization(3) icd-ecma(12) member-company(2) 
dec(1011) xopen(28) dsp(0)}  
.iE
.P
All object classes and object attributes in the directory service
package have these numbered branches associated with them.  The
classes and attributes, in turn, have their own unique numbers.
These object identifiers are defined in header
files included as part of the XDS and XOM API software.  For example,
the attribute type \*LCommon-Name\*O is identified by the object
identifier 2.5.4.3.
.P
Table 4-1 contains a sample list of object identifiers for selected
attributes.  The complete list is provided in Chapter 12.
.P
.ne  3i
.TB "Object Identifiers for Selected Attribute Types"
.TS 
center,box,tab(#);
lB | lB
lB | l.
Attribute Type#Object Identifier
_
Aliased-Object-Name#2.5.4.1
Business-Category#2.5.4.15
Common-Name#2.5.4.3
Country-Name#2.5.4.6
Description#2.5.4.13
.TE
.nS note
The object identifiers in Table 4-1 stem from the root \*L{joint-iso-ccitt(2) ds(5) attributeType(4)}\*O.
.nE
.H 3 "Object Entries"
.P
.iX "object" "entries"
.iX "directory" "object entries"
Entries are grouped into generic object classes based on the type of
object they represent.  Examples of object classes are \*LCountry\*O,
\*LOrganizational-Person\*O, and \*LApplication-Entity\*O.  All entries contain a
special attribute, the object class attribute, indicating to which object
class (or classes) they belong.  
.iX "object" "class attribute"
.P
Entries that model a certain object and contain information about the
object in terms of attributes are called \*Eobject entries\*O.  The
directory contains a second type of entry, which is a pointer to an
object entry, called an \*Ealias entry\*O.  Alias entries are discussed
in Section 4.3.4.
.P
In summary (as shown previously in Figure 4-2), the
DIB is made up of entries, each of which contains information about
objects.  Entries consist of attributes; each attribute has a type and
one or more values.
.P
Section 4.3 describes how objects are organized in the DIB.
Figure 4-4 shows an example of an
entry describing \*LOrganizational-Person\*O	.
.iX "directory" "example of entry"
.P
.ne 6i
.FG "A Directory Entry Describing Organizational Person"
.sp .5
.dI ../directory/xds_gds/Pics/fig01.ditentry.pic 
.H 2 "X.500 Naming Concepts"
.P
.iX "X.500" "naming concepts"
Large amounts of information need to be organized in some way to make
efficient retrieval possible and ensure that names are unique.  
Information in the DIB
is organized into a hierarchical structure known as the Directory
Information Tree (DIT).  The structure and naming of the nodes in the
DIT are specified by registration authorities for a standardized set
of X.500 names and by implementors of the directory service (such as OSF)
for implementation-specific names.  The DIT hierarchy is described by
a schema.  Schemas are described in more detail in Section 4.4.
.iX "DIB"
.P
Although the X.500 standard does not mandate a specific schema, it
does make general recommendations.  For example, countries and
organizations should be named close to the root of the DIT; people,
applications, and devices should be named further down in the
hierarchy.  GDS supplies a default schema that complies with these
recommendations.
.H 3 "Distinguished Names"
.P
.iX "directory" "distinguished name"
.iX "distinguished name"
.iX "distinguished name" "example of distinguished name"
.iX "DIT"
A hierarchical path exists from the root of the DIT to any entry in
the DIB.  To access information stored in an entry, a name that
uniquely describes that entry must be given.  An RDN distinguishes an
entry from other entries with the same superior node in the DIT.  A
sequence of RDNs, starting from the root of the tree, can identify a
unique path down the tree, and thus a unique entry.  This sequence of
RDNs, each of which identifies a particular entry,
is the distinguished name of
that entry.  Each entry in the DIB can be referred to by its
distinguished name.
.P
Figure 4-5 shows an example of a distinguished name.  The
shaded boxes in the DIT represent the entries that are named in the
column labeled RDN.  The schema dictates that
countries are named directly below the root, followed by
organizations, organization units, and people.
.P
.ne 4.5i
.FG "A Distinguished Name in a Directory Information Tree"
.sp .5
.dI ../directory/xds_gds/Pics/fig1.06a.pic
.sp .5
.P
Every entry in the DIB has a distinguished name, not just the leaf
nodes.  For example, the entry for the organization, Acme
Enterprises (shown in Figure 4-5) is represented by the shaded box
in the \*LOrganizations\*O subtree.  Its distinguished name is the
concatenation of the distinguished name of the previous entry above with its
relative distinguished name.  The entry for \*LPeople\*O, Alfred
Schmidt, is represented by the shaded box in the \*LPeople\*O subtree.
.H 3 "Relative Distinguished Names and Attribute Value Assertions"
.P
.iX "RDN"
.iX "directory" "relative distinguished name"
.iX "distinguished name" "relative"
Each entry has a unique relative distinguished name (RDN), which
distinguishes it from all other entries with a particular immediate
superior in the DIT.
.P
.ne 6
.iX "AVA"
An RDN consists of one or more assertions of the type and value of an
attribute.  A pair consisting of an attribute type and a value of that
type is known as an Attribute Value Assertion (AVA).  All attribute
types in an RDN must be different.  The attribute value of an
attribute in an RDN's AVA is called the \*Vdistinguished value\*O of
that attribute, as opposed to the other possible values of that
attribute.
.P
The assertion is TRUE if the entry contains an attribute of the
specified type, and if one of that attribute's values matches the
AVA's distinguished attribute value.  An entry commonly has an
RDN that consists of a single AVA.  In some cases, however, more
than one AVA may be required to distinguish an entry.  (Multiple AVAs
are discussed in Section 4.3.3.)
.P
The entry shown in Figure 4-4 contains the RDN \*LCommon-Name = Alfred
Schmidt\*O.  The attribute consists of two values: \*LAlfred Schmidt\*O
and \*LAl Schmidt\*O.  The AVA \*LCommon-Name = Alfred Schmidt\*O
contains the value \*LAlfred Schmidt\*O, which has been designated as the
distinguished value in the AVA.
.H 3 "Multiple AVAs"
.P
.iX "-: AVA" "Attribute Value Assertion" 
.iX "AVA"
Frequently, as shown in the previous section, an entry contains a
single distinguished value; therefore, the RDN comprises a single
AVA.  However, under certain circumstances, additional values (and
hence multiple AVAs) can be used.
.P
Figure 4-4 shows the contents of an entry describing
\*LOrganizational-Person\*O.  The RDN of an
\*LOrganizational-Person\*O entry is usually composed of a single AVA,
such as the \*LCommon-Name\*O attribute type with a distinguished
value (in Figure 4-5, the AVA \*LCN = Alfred Schmidt\*O).  Depending
on the schema, the RDN of an \*LOrganizational-Person\*O entry may
contain more than one AVA.  For example, the RDN in Figure 4-5 could
contain the AVAs \*LCN = Alfred Schmidt\*O and \*LOU = New York
Sales\*O, with Alfred Schmidt and New York Sales as distinguished
values.
.P
.ne 5
In summary:
.ML
.LI
A DIT consists of a collection of distinguished names.
.LI
Distinguished names result from a concatenation of RDNs.
.LI
.ne 2
RDNs consist of an unordered collection of attribute type and
value pairs (AVAs).
.LE
.H 3 "Aliases"
.P
.iX "alias entries"
.iX "directory" "alias entries"
An alternative name or alias is supported in the DIT by the use of special
pointer entries called \*Valias entries\*O.  Alias entries do not contain
any other attributes beyond their distinguished attributes, the object
class attribute, and the aliased object name attribute; that is, the
distinguished name of the aliased object entry.  Furthermore, an
alias entry has no subordinate entries, making it, by definition, a
leaf entry of the DIT as shown in Figure 4-6.  Alias entries point to
object entries and provide the basis for alternative names for the
corresponding objects.
.P
Aliases are used to do such things as provide more user-friendly
names, direct the search for a particular entry, reduce the
scope of a search, provide for common alternate abbreviations and
spellings, or provide continuity after a name change.
.P
Figure 4-6 demonstrates how an alias name provides continuity after a
name change.  The ABC company's branch office located originally in
Osaka has moved to Tokyo.  To make the transition easier for directory
service
users and to guarantee that a search based on the old information
finds its target, an alias for \*LO=ABC\*O has been added to the directory
beneath \*LL=Osaka\*O.  This alias entry points to the object entry
\*LO=ABC\*O.
A search for ABC under \*LL=Osaka\*O in the DIT finds the entry
\*L/C=Japan/L=Tokyo/O=ABC\*O.
.P
.ne 2.5i
.FG "An Alias in the Directory Information Tree"
.sp .5
.dI ../directory/xds_gds/Pics/fig1.06aa.pic
.sp .5
.P
Another use of alias entries is as an alternative to \*Efiltering\*O;
that is, by using assertions about particular attributes to search through the
DIT.  Although this approach does not require any special information
to be set up in the DIT, it can be expensive to search where there is
a large population of entries and attributes.  An alternative approach
is to set up special subtrees whose naming structures are designed
for ``Yellow Pages'' type searching.  Figure 4-7 shows an example of such a
subtree populated by alias entries only.  In reality, the entries
within these subtrees can be a mixture of object and alias entries, as
long as there exists only one object entry for each object stored in
the directory.
.P
.sp .5
.FG "A Subtree Populated by Aliases"
.dI ../directory/xds_gds/Pics/fig1.06aaa.pic
.sp .5
.P
An object with an entry in the DIT can have zero or more aliases.
Several alias entries can point to the same object entry.  An alias
entry can point to an object that is not a leaf entry.  Only object
entries can have aliases.  Thus, aliases of aliases are not permitted.
.H 3 "Name Verification"
.P
.iX "directory" "name verification"
A directory user identifies an entry by supplying an ordered set of
RDNs (each of which consists of an unordered set of AVAs) that form
a purported
name.  The purported name is mapped onto the desired entry by the
process of name verification, which performs a distributed tree walk
through the DIT.  When a purported name is a valid name, a distinguished
name exists with the same number of RDNs and matching AVAs within the RDNs.
.H 2 "Schemas"
.P
The structure of directory information is governed by a set of rules called
a \*Eschema\*O.  Schemas specify rules for the following:
.ML
.LI
The structure of the DIT
.LI
The contents of entries in terms of attributes
.LI
The syntax of attribute values and rules for comparing and matching them
.LE
.H 3 "The GDS Standard Schema"
.P
.iX "GDS" "standard schema"
.iX "-: DIT" "Directory Information Tree" 
.iX "DIT" "GDS Standard Schema"
.iX "directory" "GDS Standard Schema"
When the DCE software package is shipped to a customer, it includes a
default or \*Vstandard\*O schema for GDS.  This is the GDS proprietary
interpretation of the X.500 schema. 
.P
Each attribute in the schema is assigned a unique object identifier
and the syntax of its value.  In addition, the schema specifies the
mechanism by which attributes of this type are compared with one
another.  Each entry in the DIT belongs to an object class governed by
the schema.  Object class definitions can be used to derive
subclasses, supporting the inheritance and refinement of the attribute
types defined for the super-class.
.P
Included with the GDS standard schema are the following tables that
define the structure of the directory:
.ML 
.ne 5
.LI 
Structure rule table (SRT)  
.LI 
Object class table (OCT)  
.LI 
Attribute table (AT)  
.LE
.H 3 "The Structure Rule Table"
.P 
.iX "GDS" "standard schema" "SRT"
.iX "-: SRT" "Structure Rule Table"
.iX "SRT"
.iX "directory" "SRT"
The SRT specifies the relationship of object
classes in the structure of the directory.  The SRT supplied with the
GDS standard schema contains the entries shown in Table 4-2.
.P
.TB "Structure Rule Table Entries"
.TS 
center,box,tab(@);
lB | lB | lB | lB
lB | lB | lB | lB
lB | lB | lB | lB
n | n | lB | lB .
@@@Acronym of
Rule@Superior@Acronym of@Structural
Number@Rule Number@Naming Attribute@Object Class
=
1@0@CN@SCH
2@0@C@C
3@2@O@ORG
4@3@OU@OU
5@4@CN@ORP
6@4@CN, OU@ORP
7@4@CN@ORR
8@4@CN@MDL
9@4@CN@APP
10@9@CN@APE
11@9@CN@DSA
12@9@CN@MMS
13@9@CN@MTA
14@9@CN@MUA
15@2@L@LOC
16@15@CN@REP
17@15@CN, STA@REP
.TE
.sp .5
.P
The SRT determines how the object classes are laid out in the DIT by
assigning rule numbers to each object class.  An object class's
Superior Rule Number specifies the object class directly above it in
the DIT.
.P
For example, the object class \*LOrganization\*O (abbreviated with the
acronym \*LORG\*O in the SRT) has a superior rule number of 2,
indicating that it is located in the DIT beneath the object class
\*LCountry\*O (\*LC\*O), which has a rule number of 2.
\*LOrganization Unit\*O (\*LOU\*O) is located beneath
\*LOrganization\*O because it has a superior rule number of 3 and so
forth.
.P
.iX "structured object classes"
.iX "GDS" "Standard Schema" "structured object classes"
The SRT only contains structured object classes; that is, classes
that form branches in the DIT.  Other object classes, such as abstract
and alias classes, are not included.
.P
.iX "naming" "attributes"
.iX "SRT"
.iX "GDS" "Standard Schema" "naming attributes"
.iX "directory" "naming attributes"
The SRT specifies the attribute(s) used to name entries belonging to
each object class.  These attributes, called \*Enaming attributes\*O,
are used to define the RDN and therefore the distinguished name of
directory entries.
.P
Figure 4-8 shows the structure of the DIT as defined by the SRT of the
GDS standard schema.
.P
.FG "SRT DIT Structure for the GDS Standard Schema"
.dI ../directory/xds_gds/Pics/fig1.06c.pic
.H 3 "The Object Class Table" 
.P
.iX "GDS" "standard schema" "OCT"
.iX "OCT"
.iX "directory" "OCT"
.iX "-: OCT" "object" "class table"
The object classes that make up the GDS standard schema are defined in
the OCT.  Table 4-3 contains a partial listing of the OCT (refer to the
\*(Ax for a
complete listing of the OCT for the GDS standard schema).  Each column
in Table 4-3 contains information about an object class entry in the schema.
.P
.TB "Object Class Table Entries"
.na
.ps 10
.vs 12
.TS 
center,box,tab(@);
cB s s | l l l l l
lB | lB | lB | lB | lB | lB | lB | lB
lB | lB | lB | lB | lB | lB | lB | lB
lB | lB | l | lB | lB | n | lB | lB.
Object Class
_
Acro-@@@Super-@@File@Mandatory@Optional
nym@Name@Kind@class@OID@No.@Attributes@Attributes
=
TOP@Top@Abstract@None@85.6.0@-1@OCL@None
_
ALI@Alias@Alias@TOP@85.6.1@-1@AON@None
_
C@Country@Structural@GTP@85.6.2@1@C@T{
DSC SG CDC CDR
T}
_
LOC@Locality@Structural@GTP@85.6.3@4@None@T{
DSC L SPN STA SEA SG CDC CDR
T}
_
ORG@Organization@Structural@GTP@85.6.4@1@O@T{
DSC L SPN STA
PDO PA PC POB
FTN IIN TN TTI
TXN X1A PDM DI
RA SEA UP BC
SG CDC CDR
T}
.TE
.ps 12
.vs 14
.ad
.nS "note"
The object identifiers in Table 4-3 stem from the root \*L{joint-iso-ccitt(2)
ds(5) objectClass(6)}\*O.
.nE
.P
.iX "OCT" "acronyms of super class"
.iX "OCT" "partial representation of"
Column 4, Superclass acronyms, provides the class from which an
object class inherits its attributes.  Using the information in Column
4, it is possible to derive a graphical representation of the
inheritance properties of object classes in the DIT as shown in Figure
4-9.
.P
In the figure, the object class \*LTop\*O is the root of the tree,
with \*LAlias\*O and \*LGDS-Top\*O as the main branches.  \*LTop\*O
contains the attribute type object class, which is inherited by all
the other object classes.
.P
Do not confuse the information in the OCT with that presented in the
SRT.  There is no direct relationship between the relative location of
branches and leaves in the DIT structure and the inheritance
properties of classes with their superclasses and subclasses.
For example, when a directory service request is made by a directory
user, such as a read operation, the SRT is used by the directory
service to indicate its position in the DIT.  The directory service
uses the information defined in the SRT for tree traversal so that
the requested object can be located in the directory.  Figure 4-8 shows
the object class \*LOrganization\*O located beneath \*LCountry\*O in the DIT.
.P
.iX "OCT" "class inheritance"
On the other hand,
the OCT defines, among other things, the
attributes of an object class along with its inherited attributes from
its superclass.  The superclass, in turn, inherits the attributes from 
its superclass, and so on until the root, \*LTop\*O, is reached (from
which all classes derive their attributes).  Figure 4-9 shows the
object class \*LOrganization\*O as a subclass of \*LGDS-Top\*O.  As such, it
inherits its attributes from \*LGDS-Top\*O, which in turn inherits from its
superclass, \*LTop\*O.
.FG "A Partial Representation of the Object Class Table"
.dI ../directory/xds_gds/Pics/fig1.07.pic
.P
.iX "object" "identifier" "OCT"
The OCT also contains the unique object identifier of each class in
the DIT.  These numbers are defined by various standards authorities
and in the X.500 standards documents mentioned previously.  The AT also
contains the predefined object identifiers for each attribute in the
directory.  These object identifiers are defined in the header files
that are included as part of the GDS API.  Table 4-4 shows
some examples of object identifiers for directory classes as defined
in the X.500 standard.
.P
.ne 5i
.TB "Object Identifiers for Selected Directory Classes"
.TS 
center,box,tab(#);
lB | lB
lB | l.
Object Class Type#Object Identifier
=
Alias#85.6.1               
Application-Entity#85.6.12        
Application-Process#85.6.11      
Country#85.6.2             
Device#85.6.14               
DSA#85.6.13                 
Group-of-Names#85.6.9       
Locality#85.6.3             
Organization#85.6.4                 
Organizational-Person#85.6.7           
Organizational-Role#85.6.8             
Organizational-Unit#85.6.5             
Person#85.6.6               
Residential-Person#85.6.10   
Top#85.6.0                 
.TE
.nS note
The object identifiers in Table 4-4 stem from the root \*L{joint-iso-ccitt(2)
ds(5) objectClass(6)}\*O.
.nE
.P
.iX "OCT" "attributes"
.iX "directory" "attribute types"
.iX "attribute" "type" "optional"
.iX "attribute" "type" "mandatory"
Another important feature of the OCT is the distinction made between
mandatory and optional attributes for each object class.  This
distinction is based on recommendations from X.500 standards
documents.  These documents (Recommendations X.520 and X.521) define
selected object classes and associated attribute types by using ASN.1
notation.  Most object classes have one or more mandatory attributes
associated with them for use by implementors who want to comply with the
X.500 standards recommendations.  In addition, optional attributes are
defined.
.P
.iX "ASN.1" "sample definition"
The following example provides a flavor of ASN.1
notation; it shows how the object class \*Lcountry\*O is described in
Recommendation X.520 (\*EThe Directory: Selected Object Classes\*O).
.oS
country OBJECT-CLASS
     SUBCLASS of top
     MUST CONTAIN {
         countryName}
     MAY CONTAIN {
         description,
         searchGuide}
     ::= {objectClass 2}
.oE
.P
This ASN.1 definition defines \*LCountry\*O as a subclass of superclass
\*LTop\*O.  The class, \*LCountry\*O, must contain the mandatory attribute
\*LcountryName\*O (or \*LCountry-Name\*O as defined in the GDS standard schema)
and can contain the optional attributes \*LDescription\*O and
\*LSearch-Guide\*O.  In addition, the DCE implementation adds two more
attributes, \*LCDS-Cell\*O and \*LCDS-Replica\*O,
to incorporate other aspects of
the DCE environment that are implementation specific.
.P
\*LCountry\*O is assigned the object identifier \*L2.5.6.2\*O.  This
number distinguishes it from the other object classes defined by the
standard.  The \*LTop\*O superclass is designated as \*L2.5.6.0\*O.
The first three numbers, \*L2.5.6\*O, identify the object class as a
member of a discrete set of object classes defined by X.500.  The last
number in the object identifier distinguishes objects within that
discrete set.  Alias, a subclass of \*LTop\*O, is assigned the number
\*L2.5.6.1\*O.  \*LCountry\*O is assigned the number \*L2.5.6.2\*O,
and so on.  \*LGDS-Top\*O has no object identifier because it is
implementation specific and thus not identified by the standard.
.H 3 "The Attribute Table"
.P
.iX "GDS" "Standard Schema" "attribute table"
.iX "attribute" "table"
.iX "directory" "attribute table"
The attributes that make up the entries in the GDS standard schema are
defined in the AT.  (Refer to the \*(Ax for a complete listing of the AT.)  The object
identifiers are in the range from \*L85.4.0\*O through \*L85.4.35\*O
as defined by the X.500 standard, \*L86.5.2.0\*O through
\*L86.5.2.10\*O as defined by the X.400 standard, and there are
additional object identifiers for GDS specific attributes.
.P
Table 4-5 shows a partial listing of the AT for the GDS
standard schema.
.nS "note"
The access class for every attribute listed in Table 4-5 is 0 (zero).
.nE
.P
.ne 4i
.TB "Attribute Table Entries"
.ps 10
.vs 12
.TS 
center,box,tab(@);
l2B | l2B | l2B | l2B | l2B | l2B | l2B | l2B | l2B
l2B | l2B | l2B | l2B | l2B | l2B | l2B | l2B | l2B
l2B | l2B | l2B | n2B | n2B | n2B | n2B | n2B | n2B.
Acr. of@Obj.@Name of@Lower@Upper@Max. No.@@Phon.@Index
Attr.@ID@Attribute@Bound@Bound@of Val.@Syntax@Flag@Level
_
OCL@85.4.0@Object-Class@1@28@0@2@0@0
AON@85.4.1@T{
Aliased- Object-Name
T}@1@1024@1@1@0@0
KNI@85.4.2@T{
Knowledge- Information
T}@1@1024@0@4@0@0
CN@85.4.3@T{
Common- Name
T}@1@64@2@4@1@1
SN@85.4.4@Surname@1@64@2@4@1@0
SER@85.4.5@Serial-Number@1@64@2@5@0@0
C@85.4.6@Country-Name@2@2@1@1010@1@1
L@85.4.7@Locality-Name@1@128@2@4@1@1
SPN@85.4.8@T{
State-or- Province- Name
T}@1@128@2@4@1@0
.TE
.ps 12
.vs 14
.P
The columns with the headings Lower Bound and Upper Bound specify the
range of the number of bytes (or octets) that the value of an
attribute can contain.  The schema puts constraints on the number of
values that an attribute can contain in the Maximum Number of Values
column.  
.P
The Syntax column describes how the data is represented and relates to
ASN.1 syntax definitions for attributes.  For example, a sample of
ASN.1 notation for the \*LCommon-Name\*O attribute follows:
.oS
commonName ATTRIBUTE
   WITH ATTRIBUTE-SYNTAX
       caseignoreStringSyntax
           (SIZE(1..ub-common-name))
   ::= (attributeType 3)
.oE
.P
The \*LCommon-Name\*O attribute is defined as case insensitive.  The size of
the string is from 1 to the upper bound defined by the schema for the
\*LCommon-Name\*O attribute in the Upper Bound column (in this case, 64
bytes or octets).
.P
Note also that the \*LCommon-Name\*O attribute is assigned the number 3 by
the standard.  This corresponds to the \*L3\*O in the object identifier
\*L85.4.3\*O.
.P
The other columns in the AT refer to the phonetic matching flag, security
access classes, and index level.  
.P
As mentioned previously for object classes, object identifier values
specified in the AT are defined as constants in the GDS header files.
.H 3 "Defining Subclasses" 
.P
.iX "directory" "defining subclasses"
.iX "directory" "relationship between schemas and the DIT"
.iX "DIT"
The ability to define subclasses is a powerful feature of the
directory.  Structure rules govern which object classes can be children
of which others in the DIT and therefore determine possible name
forms.
.P
The directory standard defines a number of standard attribute types
and object classes.  For example, the attribute types \*LCommon-Name\*O
and \*LDescription\*O, and the object classes \*LCountry\*O
and \*LOrganizational-Person\*O are defined.
Implementations of the directory standard, such
as DCE, define their own schemas following rules stated in the
standard with additional attribute types and object classes.
.P
Figure 4-10 shows the relationship between schemas and the directory
information model.
.P
.FG "The Relationship Between Schemas and the DIT"
.sp .5
.dI ../directory/xds_gds/Pics/fig1.08.pic
.H 2 "Abstract Syntax Notation 1"
.P
.iX "ASN.1" "relating to Basic Encoding Rules"
.iX "ASN.1" "abstract syntaxes"
.iX "ASN.1" "transfer syntaxes"
.iX "-: ASN.1" "Abstract Syntax Notation 1"
.iX "-: ASN.1" "abstract syntaxes"
.iX "transfer syntax"
The need for Abstract Syntax Notation 1 (ASN.1) arises because
different computer systems represent information in different ways.
For example, one computer can use EBCDIC character representation
while another can use ASCII.  To transfer a file of characters from
one system to another, common representation must be used during the
transfer.  This transfer can be one representation or the other, or
some mutually agreed upon representation negotiated by the two
systems.  Similarly, floating-point values, integers, and other types
of data can be stored internally in different ways.  To exchange
information, a common format must be agreed to before information can
be exchanged.
.P
The translation of EBCDIC to ASCII characters can seem like a trivial
problem, but that leaves the larger issue of mapping between the many
diverse representations that can exist within a network environment.
To address this need, the ISO standards committee defined ASN.1 and
Basic Encoding Rules.
.P
ASN.1 is based on the idea that the aspects of transferred information
that are preserved are type, length, and value.  Data types are
collections of values distinguished for some reason, such as
characters, integers, and floating-point values.
Records and structure types become more complex when they
combine several types into a single
structure.  
.P
ASN.1 provides a way to group types into abstract syntaxes.  An
abstract syntax is a named group of types.  The standard defines
abstract syntax as the notation rules that are independent of the
encoding technique used to represent them.  Abstract syntax does not
specify how to represent values of types, but merely defines the types
that make up the group of types.
.P
Abstract syntaxes are not enough to define how values of the data
types in a specific abstract syntax are to be represented during
communications.  For this reason, ISO further defines a \*Vtransfer syntax\*O
for each abstract syntax.  A transfer syntax is a set of rules for
encoding values of some specified group of types.  
.H 3 "ASN.1 Types"
.P
.iX "ASN.1" "types"
ASN.1 is similar to a high-level programming language.  Unlike other
high-level languages, ASN.1 has no executable statements.  It includes
only language constructs required to define types and values.
.P
ASN.1 defines a number of built-in types.  Users of ASN.1 can then
define their own types based on the built-in types provided by the
language.  The ASN.1 standard defines four categories of types that
are commonly used in defining application interfaces such as XOM and
XDS:
.ML 
.LI 
ASN.1 Simple Types 
.LI 
ASN.1 Useful Types 
.LI
ASN.1 Character String Types 
.LI 
ASN.1 Type Constructors 
.LE
.P
.iX "ASN.1" "simple types"
ASN.1 simple types are Bit String, Boolean, Integer, Null, Object
Identifier, Octet String, and
Real.  Table 4-6 shows the relationship of OM syntaxes (syntaxes defined
in XOM API) to ASN.1 simple types.  (Refer to Chapter 17
for the complete set of tables for the four
categories of ASN.1 types.)  As shown in the table, for every ASN.1
type except Real, there is an OM syntax that is functionally
equivalent to it.  The simple types are listed in the first column of
the table; the corresponding syntaxes are listed in the second column.
.P
.TB "Syntax for the Simple ASN.1 Types"
.TS 
center,box,tab(#);
lB | lB
l | l.
ASN.1 Type#OM Syntax
=
Bit String#String\*L(OM_S_BIT_STRING)\*O
Boolean#\*LOM_S_BOOLEAN\*O
Integer#\*LOM_S_INTEGER\*O
Null#\*LOM_S_NULL\*O
Object Identifier#String\*L(OM_S_OBJECT_IDENTIFIER_STRING\*O)\*O
Octet String#String\*L(OM_S_OCTET_STRING)\*O
Real#None\s-2\u1\d\s+2
.TE
.VL .2i
.LI "\s-11\s+1"
A future edition of XOM can define a syntax
corresponding to this type.
.LE
.P
.ne 11
An example will
illustrate how OM syntaxes are used to define the
syntax of values for various attributes.  
One of the simplest of the ASN.1 types is Boolean.  There are only two
possible values for a Boolean type: TRUE and FALSE. The 
\*LDS_FROM_ENTRY\*O
OM attribute of the \*LDS_\%C_\%ENTRY_\%INFO\*O object class has a value
syntax of \*LOM_\%S_\%BOOLEAN\*O.  \*LOM_\%S_\%BOOLEAN\*O is the C 
language representation
for the OM syntax that corresponds to the ASN.1 Boolean type.  The
value of the \*LDS_\%FROM_\%ENTRY\*O OM attribute indicates whether 
information from the directory was extracted from the specified object's 
entry (TRUE), or from a copy of the entry (FALSE).  The actual C language
definition for \*LOM_\%S_\%BOOLEAN\*O is made in the XOM API header file
\*Lxom.h\*O.
.H 3 "Basic Encoding Rules"
.P
.iX "BER"
.iX "-: BER" "Basic Encoding Rules"
It is possible to define a single transfer syntax that is powerful
enough to encode values drawn from a number of abstract syntaxes. 
ISO defines a set of rules for encoding values of many
different types for ASN.1.  This set of encoding rules is called Basic
Encoding Rules (BER).  It is so powerful that values from any
abstract syntax described by using ASN.1 can be encoded by using the
transfer syntax defined by BER.
.P 
Although other transfer syntaxes could be used for representing 
values from ASN.1, BER is used most often.  
.H 2 "GDS as a Distributed Service" 
.P
.iX "GDS" "as distributed service"
When present in a DCE cell, GDS can serve two basic functions.
First, it can provide a high-level, worldwide directory service
by tying together independent DCE cells.  Second, it can be used as an
additional directory service to CDS for storing object names and
attributes in a central place.
.P
The GDS database contains information that can be distributed over
several GDS servers.  In addition, copies of information can be stored
in multiple GDS servers, and the information can also be cached locally.  The
unit of replication in GDS is the directory entry; whole subtrees can
be also replicated.
.P
The information belonging to the DIB is shared between
several Directory Service Agents (DSAs).  A DSA is a process that runs
on a GDS server machine and manages the GDS database.  DSAs cooperate
to perform directory service operations, with each DSA knowing a
fraction of the total directory information, as shown in Figure 4-11.
DSAs are a combination of local database functions and a remote
interface to the clients of users and other DSAs.  DSAs can cooperate
to execute operations.  This cooperation often involves the navigation
of operations through the network.  
.iX "GDS" "DSA-DUA relationship"
.iX "DSA"
.iX "DUA"
.iX "-: DSA" "Directory Service Agent"
.iX "-: DUA" "Directory User Agent"
.P
.FG "The Relationship Between the DSA and the DUA"
.sp .5
.dI ../directory/xds_gds/Pics/fig1.15.pic
.sp .5
.P
Users access the directory via Directory User Agents (DUAs).  DUAs
make requests of DSAs on behalf of users requesting directory service
operations.  The manner in which DUAs communicate with DSAs is defined by the
X.500 standard.  For communications between DUAs and DSAs, the
directory access protocol (DAP) is defined.  For communications between
DSAs in a distributed directory, the standard defines the directory
system protocol (DSP).
.H 3 "The Directory Access Protocol"
.P
.iX "GDS" "DAP"
.iX "DAP" 
.iX "-: DAP" "Directory Access Protocol"
The directory standard defines directory functions in the DAP.
The directory functions can be divided into
three general categories: read, search, and modify.
.P
Read operations involve the retrieval of information from specific
named entries.  This allows a general name-to-attributes mapping
analogous to the ``White Pages'' phone directory.
.P
Search operations involve the general browsing and relational
searching of information.  Search operations support human interaction
with the directory service and is analogous to that of the ``Yellow Pages''
telephone directory.
.P
Modify operations involve the modification of information in the
directory.
.H 3 "The Directory System Protocol"
.P
.iX "GDS" "DSP"
.iX "DSP"
.iX "-: DSP" "Directory System Protocol"
The DSA can interact with other DSAs to provide services by using the
DSP. DSP is a protocol defined by the
directory standard to allow DSAs to communicate with one another.  DSP
provides two methods of distributed request resolution: referral and
chaining.
.H 3 "Referral" 
.P
.iX "GDS" "referral"
.iX "referral"
In some cases, a DSA may not be able to provide service to a DUA
because the required information is held elsewhere in the network.  A
DSA can simply choose to inform the DUA or the calling DSA where the
information can be found.  This is called \*Ereferral\*O and can occur
because of the user's preference or the DSA's circumstances.
.P
Referrals are possible because the distinguished name provided by the
DUA identifies where in the DIT the requested entry is located.  DSAs
use their knowledge of the DIT to inform the DUA of the DSA that
holds the requested information.
.P
Figure 4-12 shows an example of a referral.  \*LDSA1\*O passes a referral to
\*LDSA2\*O back to the DUA.  The DUA then makes a request to \*LDSA2\*O.
.FG "An Example of a Referral"
.dI ../directory/xds_gds/Pics/fig1.16.pic
.H 3 "Chaining" 
.P
.iX "GDS" "chaining"
.iX "chaining"
If a request received from a DUA cannot be fulfilled by the
receiving DSA, that DSA can send a referral back to the initiating DUA
over DAP.  Alternatively, the DSA can chain the request over DSP,
asking another DSA to perform the requested function.  That DSA can
perform the function or can send back a referral of its own.  In
either case, the first DSA eventually responds to the originating DUA
with either the results of the completed operation or a referral.
.P
Chaining can go deeper than one level.  To prevent lengthy searches, a
user can request no chaining or specify a limit on the total
elapsed time for an operation.
.P
Figure 4-13 shows an example of chaining.  The DUA makes a request of
\*LDSA1\*O. \*LDSA1\*O is unable to service the request and passes it
to \*LDSA2\*O.  \*LDSA2\*O services the request, passes the result
back to \*LDSA1\*O, and \*LDSA1\*O passes the result back to the DUA.
.FG "An Example of Chaining"
.dI ../directory/xds_gds/Pics/fig1.17.pic
.H 3 "The Directory User Agent Cache"
.P
.iX "GDS" "DUA cache"
.iX "DUA" "cache"
.iX "-: DUA" "GDS" "Directory User Agent cache"
The DUA cache is a process that keeps a cache of
information obtained from DSAs.  One DUA cache runs on each client
machine and is used by all users on that client.  The DUA cache
contains copies of recently accessed object entries and information
about DSAs.  The user specifies which information should be
cached.  It is also possible to bypass the DUA Cache to obtain
information directly from a DSA.  This is desirable, for example, when
the user wants to make sure the information obtained is up-to-date.
.P
.iX "shadow update process"
.iX "cache update process"
The shadow update and cache update are processes that update replicated 
information in DSAs and DUA caches.  These processes run as needed and then
terminate.  The shadow update process runs on the GDS server machine;
the cache update process runs on GDS client machines.
.P
When an application program makes a directory service call by using XDS
API, the call is handed to the DUA library.  The DUA first looks in
the DUA cache (if requested by the user) to see if the requested information is
already available on the local machine.  If it is not, the DUA queries a
DSA.  If the DSA has the requested information, it
returns the results to the DUA.  If it does not, the query can proceed
either by using chaining or a referral.  In either case, different DSAs are
queried until the information is found.  It is cached (if requested by the 
user) in the DUA cache and the results are returned to the application program.
.P
Figure 4-14 shows the interaction between an application program, via
the XDS interface, and the GDS client and server.  The GDS client and
server use DAP to communicate.  GDS
servers use the DSP to communicate with
one another.  DAP and DSP perform functions similar to the functions
that DCE RPC protocols perform in other DCE services.
.P
.FG "GDS Components"
.sp .5
.dI ../directory/xds_gds/Pics/fig01.GDScomponents.pic
.iX "DUA" "cache""
.H 4 "Placing Entries in the Local DUA Cache"
.P 
A special object OM class, \*LDSX_C_GDS_CONTEXT\*O, is provided in the
GDS package to allow an application program to manage the
placement of entries in the local DUA cache as a result of a directory
request.  
.P
\*LDSX_C_GDS_CONTEXT\*O inherits the OM attributes of its superclasses
\*LOM_C_OBJECT\*O and \*LDS_C_CONTEXT\*O.  To enable caching entries,
the \*LDS_DONT_USE_COPY\*O OM attribute of \*LDS_C_CONTEXT\*O must be
set to a value of \*LOM_FALSE\*O, indicating that a directory request
can access copies of directory entries maintained in other DSAs or
copies cached locally.
.P
\*LDSX_C_GDS_CONTEXT\*O has the following private extension OM attributes in
addition to the OM attributes inherited from \*LDS_C_CONTEXT\*O:
.ML
.LI
\*LDSX_DUAFIRST\*O
.LI
\*LDSX_DONT_STORE\*O
.LI
\*LDSX_NORMAL_CLASS\*O
.LI
\*LDSX_PRIV_CLASS\*O
.LI
\*LDSX_RESIDENT_CLASS\*O
.LI
\*LDSX_USEDSA\*O
.LI
\*LDSX_DUA_CACHE\*O
.LE
.P
\*LDSX_DUAFIRST\*O determines where a query operation, such as a
search or list, looks first for an entry.  The default value is
\*LOM_FALSE\*O, indicating that the DSA is searched first.
If the entry is not found, then the DUA cache is searched.
.P
\*LDSX_DONT_STORE\*O determines if information read from the DSAs by a
query function also needs to be stored in the DUA cache.  If this
OM attribute is set to \*LOM_TRUE\*O, nothing is stored in the cache.  If
this OM attribute is set to \*LOM_FALSE\*O, the information read is stored
in the DUA cache.  The objects returned by \*Lds_list(\|)\*O and 
\*Lds_compare(\|)\*O
are stored in the cache without their associated attribute information.
The objects returned by \*Lds_read(\|)\*O and \*Lds_search(\|)\*O are o
stored in the
cache with all their ``cachable'' attributes; these are all public
attributes that do not exceed 4Kbytes in length.
.P
The three different memory classes that the user can specify for a
cached entry are \*LDSX_NORMAL_CLASS\*O, \*LDSX_PRIV_CLASS\*O,
and \*LDSX_\%RESIDENT_\%CLASS\*O.
.P
\*LDSX_NORMAL_CLASS\*O assigns the entry to the class of normal
objects.  If the number of entries in this class exceeds a maximum
value, the entry that is not accessed for the longest period of time
is removed from the DUA cache.
.P 
\*LDSX_PRIV_CLASS\*O assigns the entry to the class of privileged
objects.  Entries can be removed from the class in the same way as
normal objects.  However, by setting this area of memory aside to be used
sparingly, the user can protect entries from deletion.
.P
\*LDSX_RESIDENT_CLASS\*O assigns the entry to the class of resident
objects.  An entry in this class is never removed automatically.  It
must be explicitly removed by using an XDS \*Lds_remove_entry(\|)\*O function
applied directly to the cache; that is, \*LDSX_DUA_CACHE\*O and
\*LDSX_USEDSA\*O are set to \*LOM_TRUE\*O and \*LOM_FALSE\*O,
respectively.
.P
Tables 4-7 through 4-9 show the possible conditions that result 
when \*LDSX_DUA_CACHE\*O and \*LDSX_USEDSA\*O are set to \*LOM_TRUE\*O.
.iX "DUA" "cache""
.P
.TB "Cache Attributes: Read Cache First"
.TS 
center,box,tab(#);
lB | cB | cB
lB | c | c.
OM Attribute Type#OM_TRUE#OM_FALSE
=
DSX_DUA_CACHE#X#
DSX_USEDSA#X#
DS_DONT_USE_COPY##X
DSX_DUAFIRST#X#
.TE
.P
In the situation presented in Table 4-7,
the cache is read first, then the other DSAs.
The requested operation is permitted to use copies of entries.
.P
.ne 3i
.TB "Cache Attributes: Read DSA First"
.TS 
center,box,tab(#);
lB | cB | cB
lB | c | c.
OM Attribute Type#OM_TRUE#OM_FALSE
=
DSX_DUA_CACHE#X#
DSX_USEDSA#X#
DS_DONT_USE_COPY##X
DSX_DUAFIRST##X
.TE
.P
In the situation presented in Table 4-8, the DSA is read first, then
the cache.  The requested operation is permitted to use copies of
entries.
.P
.TB "Cache Attributes: Read DSA Only"
.TS 
center,box,tab(#);
lB | cB | cB
lB | c | c.
OM Attribute Type#OM_TRUE#OM_FALSE
=
DSX_DUA_CACHE#X#
DSX_USEDSA#X#
DS_DONT_USE_COPY#X#
DSX_DUAFIRST#N/A#N/A
.TE
.P
In the situation presented in Table 4-9, only the DSA is read.  The
requested operation is not permitted to use copies of entries.
.P
Tables 4-10 through 4-12 show the possible situations when
\*LDSX_DUA_CACHE\*O and \*LDSX_USEDSA\*O are not both set to \*LOM_TRUE\*O.
.P
.TB "Cache Attributes: DSX_USEDSA is OM_FALSE"
.TS 
center,box,tab(#);
lB | cB | cB
lB | c | c.
OM Attribute Type#OM_TRUE#OM_FALSE
=
DSX_DUA_CACHE#X#
DSX_USEDSA##X
DS_DONT_USE_COPY##X
.TE
.P
In the situation presented in Table 4-10, the DUA Cache is used exclusively.
.P
.ne 3i
.TB "Cache Attributes: DSX_DUA_CACHE is OM_FALSE"
.TS 
center,box,tab(#);
lB | cB | cB
lB | c | c.
OM Attribute Type#OM_TRUE#OM_FALSE
=
DSX_DUA_CACHE##X
DSX_USEDSA#X#
.TE
.P
In the situation presented in Table 4-11, the DSA is used exclusively.
.P
.TB "Cache Attributes: Error"
.TS 
center,box,tab(#);
lB | cB | cB
lB | c | c.
OM Attribute Type#OM_TRUE#OM_FALSE
=
DSX_DUA_CACHE##X
DSX_USEDSA##X
.TE
.P
In the situation presented in Table 4-12, neither the DSA nor the DUA cache
is used, and an error is returned.
.H 4 "Accessing the DUA Cache Without a GDS Server Present"
.P
An application program may need to access the local DUA cache without
binding to a GDS server.  This section describes the steps that should
be included in the application program.  Refer to the Chapters 5 and 6
for information on how to use the XDS and XOM API calls
\*Lds_initialize(\|)\*O, \*Lds_version(\|)\*O, \*Lds_bind(\|)\*O,
\*Lds_shutdown(\|)\*O, \*Lom_create(\|)\*O, \*Lom_remove(\|)\*O, how to
do static initialization of public objects, and how to create private
objects.
.P
The steps are as follows:
.AL
.LI
Call \*Lds_initialize(\|)\*O as normal.
.LI
Negotiate the \*LDSX_GDS_PKG\*O by using \*Lds_version(\|)\*O.  This is necessary because a \*LDSX_C_GDS_CONTEXT\*O is required in order to set the DUA cache service controls.
.LI
Supply a \*LDSX_C_GDS_SESSION\*O object to the \*Lds_bind(\|)\*O call, 
which has no \*LDS_DSA_NAME\*O attribute and 
no \*LDS_\%DSA_\%ADDRESS\*O attribute present.
.P
.ne 4
There are two ways of achieving this:
.ML
.LI
Supply a public \*LDSX_C_GDS_SESSION\*O object (static initialization):
.P
.oS
OM_descriptor cache_session[] = {
    OM_OID_DESC(OM_CLASS, DSX_C_GDS_SESSION),
    OM_NULL_DESCRIPTOR
    };
.oE
.P
The other attributes of \*LDSX_\%C_\%GDS_\%SESSION\*O (\*LDS_\%REQUESTOR\*O, 
\*LDSX_\%PASSWORD\*O, \*LDSX_\%DIR_\%ID\*O, \*LDSX_\%AUTH_\%MECHANISM\*O and
\*LDSX_\%AUTH_\%INFO\*O) can be included if required.
.LI
Supply a private \*LDSX_C_GDS_SESSION\*O object (using XOM API function calls):
.ps 10
.vs 12
.oS
om_create(DSX_C_GDS_SESSION, OM_TRUE, workspace, &cache_session);
om_remove(cache_session, DS_DSA_NAME, 0, OM_ALL_VALUES);
om_remove(cache_session, DS_DSA_ADDRESS, 0, OM_ALL_VALUES);
.oE
.ps 12
.vs 14
.P
Note that an uninitialized session object may not be passed to 
\*Lds_bind(\|)\*O.  That means that \*LOM_FALSE\*O  should 
not be used with the previous \*Lom_create(\|)\*O function call.
.LE
.LI
Supply a \*LDSX_C_GDS_CONTEXT\*O object to the XDS calls that access the DUA cache.  The following service controls must be set to ensure that access is restricted to the DUA cache alone: 
.oS
DSX_DUA_CACHE = OM_TRUE
DSX_USEDSA    = OM_FALSE
.oE
.P
(Service controls that access the DSA will result in a 
\*LDS_\%E_\%BAD_\%CONTEXT\*O error.)
.P
There are two ways of achieving this:
.ML
.LI
Supply a public \*LDSX_C_GDS_CONTEXT\*O object (static initialization)
.LI
Supply a private \*LDSX_C_GDS_CONTEXT\*O object (using XOM API function calls)
.LE
.LI
.ne 5
Supply the bound \*LDSX_C_GDS_SESSION\*O object to the \*Lds_unbind(\|)\*O call.
.LI
Call \*Lds_shutdown(\|)\*O as normal.
.LE
.H 3 "GDS Configurations"
.P
A GDS machine can be configured in two ways:
.ML
.LI 
Client Only
.P
A node can contain only the client side of GDS.
This node can access remote DSAs and cache information in the DUA
cache.
.LI 
Client/Server
.P
A machine can be configured with both the GDS client
and server.  This is the typical configuration for a machine acting as
a GDS server.  This configuration can be useful even if a node acts
mainly as a client because the DSA can be used as a larger, more
permanent cache of information contained in remote DSAs.
.LE
.nS note
When a client and server reside on the same machine, access to the
directory is optimized.  Communications between the DUA and the DSA are by
means of interprocess communications (IPC) via shared memory.
.nE
.H 3 "GDS Security"
.P
.iX "GDS" "security"
.iX "GDS" "binding with credentials"
.iX "GDS" "authenticated bind"
A number of authentication mechanisms are supported by GDS. XDS applications
must indicate which method is to be used.  Since authentication takes
place at bind time, it is appropriate to pass the selected authentication
mechanism as an argument to \*Lds_bind(\|)\*O.
.P
A bind operation can be performed by
the application program with or without user credentials.  A bind with
credentials is referred to as an \*Eauthenticated bind\*O and allows
an application program to require a user to specify a distinguished
name password as user credentials.  A bind without user credentials
only permits access to public information in the directory.
.P
A special OM object class, \*LDSX_C_GDS_SESSION\*O, is provided in the
GDS package to accommodate user credentials and authentication mechanisms.
In addition to
the OM attributes inherited from its superclass \*LDS_C_SESSION\*O,
this OM class consists of the following OM attributes:
.ML
.LI
\*LDSX_PASSWORD\*O
.P
This attribute contains the password for the user credentials.
.LI
\*LDSX_DIR_ID\*O
.P
This attribute contains the identifier for distinguishing between several
configurations of the directory service within a GDS installation.  \*LDSX_DIR_ID\*O plays no role in user credentials.
.LI
\*LDSX_AUTH_MECHANISM\*O
.P
If this attribute is present it identifies the selected authentication
mechanism.  If this attribute is absent then a bind without credentials
(that is, anonymous bind) is attempted.
.LI
\*LDSX_AUTH_INFO\*O
.P
This attribute is for future use.
.LE
.P
The GDS package also provides the following special OM
classes to support access rights to specific OM attributes by
directory service users:
.ML
.LI
\*LDSX_C_GDS_ACL\*O
.P
This attribute describes up to five categories of rights for one or
more directory users.
.LI
\*LDSX_C_GDS_ACL_ITEM\*O
.P
This attribute specifies the user, or subtree of users, to whom
an access right applies.
.LE
.P
.ne 15
The five categories of rights correspond to the access rights defined
for the directory service as described in the \*(Ax.
The categories are as follows:
.ML
.LI
Modify Public
.LI
Read Standard
.LI
Modify Standard
.LI
Read Sensitive
.LI
Modify Sensitive
.LE
.P  
Refer to Chapter 6 for more information on binding with credentials
and setting access rights for users.  The sample programs in Chapter 7
provide examples of how security features are used in
application programs.
.H 3 "GDS API Logging"
.P
The GDS API logging facility displays informational and error messages
for XDS functions.  In addition, the input and output arguments to XDS
function calls can  also be displayed.  For each XDS object, its OM
types, syntaxes, and values are displayed recursively.  A number of
different display formats can be selected for the XDS objects.  These
are selected by setting the value of the environment variable
\*LXDS_LOG\*O as shown in Table 4-13.
.P
Logging can be
activated dynamically at runtime by setting the environment variable
\*LXDS_LOG\*O.
.P
.ne 6i
.TB "XDS_LOG Values"
.na
.TS 
center,allbox,tab(#);
lB | cB | cB
lB | lw(2i) | l.
XDS_LOG Value#Result#Example
_
Bit 1 = on#T{
Display arguments, messages, results and errors
T}#N/A
Bit 1 = off#T{
Display messages only (all other bits ignored)
T}#N/A
Bit 2 = on#T{
Display result and error objects as private objects
T}#N/A
Bit 2 = off#T{
Display result and error objects as public objects
T}#N/A
Bit 3 = on#T{
Object identifiers displayed as specified in 4th bit
T}#N/A
Bit 3 = off#T{
Object identifiers displayed as symbolic constants
T}#\*LDS_C_SESSION\*O
Bit 4 = on#T{
Object identifiers displayed as dotted-decimal
T}#\*L2.5.4.35\*O
Bit 4 = off#T{
Object identifiers displayed as hexadecimal bytes
T}#\*L\ex55\ex04\ex23\*O
Bit 5 = on#T{
Syntaxes displayed as integers
T}#\*L127\*O
Bit 5 = off#T{
Syntaxes displayed as symbolic constants
T}#\*LOM_S_OBJECT\*O
Bit 6 = on#T{
Types displayed as integers
T}#\*L715\*O
Bit 6 = off#T{
Types displayed as symbolic constants
T}#\*LDS_AVAS\*O	
.TE
.ad
.P
.ne 4
The bits shown in Table 4-13 can be combined.  For example, the 
following command sequence sets \*LXDS_LOG\*O to \*L5\*O (00101 in binary):
.iS
XDS_LOG=5; export XDS_LOG
.iE
.P
.ne 6
In this example, the logging facility is directed to display 
arguments, messages, results, and errors, to convert results and
errors into public objects (for display purposes only), and to
display object identifiers as hexadecimal bytes; and to display
OM syntaxes and OM types as symbolic constants.
Normally, \*LXDS_LOG\*O 
should be set to 0.  If full tracing is required, then set \*LXDS_LOG\*O
to 1.
.H 4 "Logging Format"
.P
The following general display format is used by the logging facility:
.P
.iS
\*Videntifier-name\*L = { 
  { \*Vtype, \*Vsyntax\*L, \*Vvalue\*L },
  { \*Vtype, \*Vsyntax\*L, \*Vvalue\*L },
  \&.
  \&.
  \&.
}; /* \*Videntifier-name\*L */
.iE
.P
where:
.P
.VL
.LI "\*Vtype\*O"
Is the integer or symbolic constant for the specified type.
.LI "\*Vsyntax\*O"
Is the integer or symbolic constant for the specified syntax.  A \*L+L\*O is 
appended to the syntax label if the \*LOM_\%S_\%LOCAL_\%STRING\*O 
bit is set in the \*LOM_syntax\*O field.
.LI "\*Vvalue\*O"
Is one of the following:
.ML
.LI
An integer (if \*Vsyntax\*O is \*LOM_S_INTEGER\*O or 
\*LOM_\%S_\%ENUMERATION\*O).
.LI
\*LOM_FALSE\*O or \*LOM_TRUE\*O (if \*Vsyntax\*O is 
\*LOM_\%S_\%BOOLEAN\*O).
.LI
Symbolic constant, dotted-decimal notation, or hexadecimal bytes (if \*Vsyntax\*O is \*LOM_\%S_\%OBJECT_\%ID_\%STRING\*O).
.LI
Quoted-string (if \*Vsyntax\*O is any other type of string).
.LI
Another object (if \*Vsyntax\*O is \*LOM_S_OBJECT\*O).
.LE
.LE
.nS note
The terminating NULL descriptor is expected but not displayed.
.nE
.H 4 "Examples"
.P
The following examples show how a selection of XDS objects are
displayed by the logging facility.
.P
The following filter selects entries that do not have the value
\*Lsecret\*O for the \*LDS_A_USER_PASSWORD\*O attribute.  The
\*LDS_FILTER_TYPE\*O has the value \*LDS_NOT\*O.  It contains a single
\*LDS_C_FILTER_ITEM\*O attribute.  \*LDS_C_FILTER_ITEM\*O tests
for equality against the \*LDS_\%A_\%USER_\%PASSWORD\*O attribute.
.ps 11
.vs 13
.oS
my_filter = {
 { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_FILTER },
 { DS_FILTER_ITEMS, OM_S_OBJECT, 
  {
   { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_FILTER_ITEM },
   { DS_FILTER_ITEM_TYPE, OM_S_ENUMERATION, 0 },
   { DS_ATTRIBUTE_TYPE, OM_S_OBJECT_ID_STRING, DS_A_USER_PASSWORD },
   { DS_ATTRIBUTE_VALUES, OM_S_OCTET_STRING, "secret" },
  },
 },
 { DS_FILTER_TYPE, OM_S_ENUMERATION, 3 },
}; /* my_filter */
.oE
.ps 12
.vs 14
.P
.ne 7
The following example shows logging output if the interface logger encounters a NULL pointer.  The NULL pointer is flagged as follows:
.ps 11
.vs 13
.oS
my_session = {
 { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_SESSION },
 { DS_DSA_NAME, OM_S_OBJECT, ---WARNING: NULL pointer encountered--- },
}; /* my_session */
.oE
.ps 12
.vs 14
.P
.ne 6
The following example shows logging output if the interface logger encounters a private object.  The private object is displayed as follows:
.ps 11
.vs 13
.oS
bound_session = {
  { OM_PRIVATE_OBJECT, OM_S_OBJECT_ID_STRING, DS_C_SESSION } ...
}; /* bound_session */
.oE
.ps 12
.vs 14
.P
The following example shows how a 5-part DSA distinguished name is displayed
(\*L/C=de/O=sni/OU=ap/CN=dsa/CN=dsa-m1\*O):
.ps 11
.vs 13
.oS
dsa_name = {
 { DS_DSA_NAME, OM_S_OBJECT, 
  {
   { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_DS_DN },
   { DS_RDNS, OM_S_OBJECT, 
    {
     { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_DS_RDN },
     { DS_AVAS, OM_S_OBJECT, 
      {
       { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_AVA },
       { DS_ATTRIBUTE_TYPE, OM_S_OBJECT_ID_STRING, DS_A_COUNTRY_NAME },
       { DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, "de" },
      },
     },
    },
   },
   { DS_RDNS, OM_S_OBJECT, 
    {
     { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_DS_RDN },
     { DS_AVAS, OM_S_OBJECT, 
      {
       { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_AVA },
       { DS_ATTRIBUTE_TYPE, OM_S_OBJECT_ID_STRING, DS_A_ORG_NAME },
       { DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, "sni" },
      },
     },
    },
   },
   { DS_RDNS, OM_S_OBJECT, 
    {
     { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_DS_RDN },
     { DS_AVAS, OM_S_OBJECT, 
      {
       { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_AVA },
       { DS_ATTRIBUTE_TYPE, OM_S_OBJECT_ID_STRING, DS_A_ORG_UNIT_NAME },
       { DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, "ap" },
      },
     },
    },
   },
.ne 27
   { DS_RDNS, OM_S_OBJECT, 
    {
     { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_DS_RDN },
     { DS_AVAS, OM_S_OBJECT, 
      {
       { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_AVA },
       { DS_ATTRIBUTE_TYPE, OM_S_OBJECT_ID_STRING, DS_A_COMMON_NAME },
       { DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, "dsa" },
      },
     },
    },
   },
   { DS_RDNS, OM_S_OBJECT, 
    {
     { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_DS_RDN },
     { DS_AVAS, OM_S_OBJECT, 
      {
       { OM_CLASS, OM_S_OBJECT_ID_STRING, DS_C_AVA },
       { DS_ATTRIBUTE_TYPE, OM_S_OBJECT_ID_STRING, DS_A_COMMON_NAME },
       { DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, "dsa-m1" },
      },
     },
    },
   },
  },
 },
}; /* dsa_name */
.oE
.ps 12
.vs 14
