...\"
...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\"
...\"
...\" HISTORY
...\" $Log: 5_threads.gpsml,v $
...\" Revision 1.1.6.1  1996/09/03  18:14:35  wardr
...\" 	{enh,R1.2.2}
...\" 	Update for sgml conversion
...\" 	[1996/09/03  18:13:33  wardr]
...\"
...\" Revision 1.1.4.1  1996/03/19  15:22:22  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/19  15:21:34  wardr]
...\" 
...\" Revision 1.1.2.16  1995/06/15  16:29:20  rcb
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/13  19:26:55  rcb]
...\" 
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 
...\" Revision 1.1.2.15  1994/10/18  18:00:15  rnollman
...\" 	dublin editorial comments
...\" 	[1994/10/18  18:00:04  rnollman]
...\" 
...\" Revision 1.1.2.14  1994/10/17  21:29:03  rnollman
...\" 	incorporated editorial comments from Dublin
...\" 	[1994/10/17  21:28:53  rnollman]
...\" 
...\" Revision 1.1.2.13  1994/10/14  15:33:42  rnollman
...\" 	incorporated technical changes from Dublin
...\" 	[1994/10/14  15:33:31  rnollman]
...\" 
...\" Revision 1.1.2.12  1994/10/14  14:32:25  rnollman
...\" 	incorporate technical changes from Dublin
...\" 	[1994/10/14  14:32:12  rnollman]
...\" 
...\" Revision 1.1.2.11  1994/08/05  14:02:03  rnollman
...\" 	completed osf edits
...\" 	[1994/08/05  13:59:18  rnollman]
...\" 
...\" Revision 1.1.2.10  1994/06/13  18:30:06  devobj
...\" 	cr10872 - fix copyright
...\" 	[1994/06/13  18:29:48  devobj]
...\" 
...\" Revision 1.1.2.9  1994/05/14  22:33:05  rnollman
...\" 	last submittal for beta
...\" 	[1994/05/14  22:30:29  rnollman]
...\" 
...\" Revision 1.1.2.8  1994/05/12  15:24:56  rnollman
...\" 	final update for beta
...\" 	[1994/05/12  15:24:26  rnollman]
...\" 
...\" Revision 1.1.2.7  1994/03/14  22:00:35  rom
...\" 	{enh, 10129, R1.1}
...\" 	Fix pathnames of included files for new three-book organization.
...\" 	[1994/03/14  21:20:10  rom]
...\" 
...\" Revision 1.1.2.6  1994/03/14  15:21:42  rnollman
...\" 	no changes - submitting for reorg
...\" 	[1994/03/14  15:21:13  rnollman]
...\" 
...\" Revision 1.1.2.5  1993/11/11  21:26:29  rnollman
...\" 	update SNI copyright
...\" 	[1993/11/11  21:26:14  rnollman]
...\" 
...\" Revision 1.1.2.4  1993/11/05  16:12:10  rnollman
...\" 	fixed a .so command: "/directory" should have been just "directory"
...\" 	[1993/11/05  16:11:32  rnollman]
...\" 
...\" Revision 1.1.2.3  1993/10/27  19:52:58  rnollman
...\" 	fixed Pic pathnames
...\" 	[1993/10/27  19:52:41  rnollman]
...\" 
...\" Revision 1.1.2.2  1993/10/26  14:56:38  wardr
...\" 	Move initial .zA from before to after .H 1.
...\" 	[1993/10/26  14:50:36  wardr]
...\" 
...\" Revision 1.1.2.1  1993/10/25  21:33:04  rnollman
...\" 	create chapter
...\" 	[1993/10/25  21:32:41  rnollman]
...\" 
...\" $EndLog$
...\"
...\"
...\" @OSF_COPYRIGHT@
...\"
...\"
...\" HISTORY
...\" $Log: 5_threads.gpsml,v $
...\" Revision 1.1.6.1  1996/09/03  18:14:35  wardr
...\" 	{enh,R1.2.2}
...\" 	Update for sgml conversion
...\" 	[1996/09/03  18:13:33  wardr]
...\"
...\" Revision 1.1.5.2  1996/09/03  18:13:33  wardr
...\" 	{enh,R1.2.2}
...\" Update for sgml conversion
...\"
...\" Revision 1.1.4.1  1996/03/19  15:22:22  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/19  15:21:34  wardr]
...\"
...\" Revision 1.1.3.2  1996/03/19  15:21:34  wardr
...\" 	{edit R1.2.1}
...\" Release Edits
...\"
...\" Revision 1.1.2.16  1995/06/15  16:29:20  rcb
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/13  19:26:55  rcb]
...\"
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\"
...\" Revision 1.1.3.3  1995/06/13  19:26:55  rcb
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\"
...\" Revision 1.1.2.15  1994/10/18  18:00:15  rnollman
...\" 	dublin editorial comments
...\" 	[1994/10/18  18:00:04  rnollman]
...\"
...\" Revision 1.1.3.2  1994/10/18  18:00:04  rnollman
...\" 	dublin editorial comments
...\"
...\" Revision 1.1.2.14  1994/10/17  21:29:03  rnollman
...\" 	incorporated editorial comments from Dublin
...\" 	[1994/10/17  21:28:53  rnollman]
...\"
...\" Revision 1.1.3.2  1994/10/17  21:28:53  rnollman
...\" 	incorporated editorial comments from Dublin
...\"
...\" Revision 1.1.2.13  1994/10/14  15:33:42  rnollman
...\" 	incorporated technical changes from Dublin
...\" 	[1994/10/14  15:33:31  rnollman]
...\"
...\" Revision 1.1.3.2  1994/10/14  15:33:31  rnollman
...\" 	incorporated technical changes from Dublin
...\"
...\" Revision 1.1.2.12  1994/10/14  14:32:25  rnollman
...\" 	incorporate technical changes from Dublin
...\" 	[1994/10/14  14:32:12  rnollman]
...\"
...\" Revision 1.1.3.2  1994/10/14  14:32:12  rnollman
...\" 	incorporate technical changes from Dublin
...\"
...\" Revision 1.1.2.11  1994/08/05  14:02:03  rnollman
...\" 	completed osf edits
...\" 	[1994/08/05  13:59:18  rnollman]
...\"
...\" Revision 1.1.3.2  1994/08/05  13:59:18  rnollman
...\" 	completed osf edits
...\"
...\" Revision 1.1.2.10  1994/06/13  18:30:06  devobj
...\" 	cr10872 - fix copyright
...\" 	[1994/06/13  18:29:48  devobj]
...\"
...\" Revision 1.1.3.2  1994/06/13  18:29:48  devobj
...\" 	cr10872 - fix copyright
...\"
...\" Revision 1.1.2.9  1994/05/14  22:33:05  rnollman
...\" 	last submittal for beta
...\" 	[1994/05/14  22:30:29  rnollman]
...\"
...\" Revision 1.1.3.2  1994/05/14  22:30:29  rnollman
...\" 	last submittal for beta
...\"
...\" Revision 1.1.2.8  1994/05/12  15:24:56  rnollman
...\" 	final update for beta
...\" 	[1994/05/12  15:24:26  rnollman]
...\"
...\" Revision 1.1.3.2  1994/05/12  15:24:26  rnollman
...\" 	final update for beta
...\"
...\" Revision 1.1.2.7  1994/03/14  22:00:35  rom
...\" 	{enh, 10129, R1.1}
...\" 	Fix pathnames of included files for new three-book organization.
...\" 	[1994/03/14  21:20:10  rom]
...\"
...\" Revision 1.1.3.2  1994/03/14  21:20:10  rom
...\" 	{enh, 10129, R1.1}
...\" Fix pathnames of included files for new three-book organization.
...\"
...\" Revision 1.1.2.6  1994/03/14  15:21:42  rnollman
...\" 	no changes - submitting for reorg
...\" 	[1994/03/14  15:21:13  rnollman]
...\"
...\" Revision 1.1.3.2  1994/03/14  15:21:13  rnollman
...\" 	no changes - submitting for reorg
...\"
...\" Revision 1.1.2.5  1993/11/11  21:26:29  rnollman
...\" 	update SNI copyright
...\" 	[1993/11/11  21:26:14  rnollman]
...\"
...\" Revision 1.1.3.2  1993/11/11  21:26:14  rnollman
...\" 	update SNI copyright
...\"
...\" Revision 1.1.2.4  1993/11/05  16:12:10  rnollman
...\" 	fixed a .so command: "/directory" should have been just "directory"
...\" 	[1993/11/05  16:11:32  rnollman]
...\"
...\" Revision 1.1.3.2  1993/11/05  16:11:32  rnollman
...\" 	fixed a .so command: "/directory" should have been just "directory"
...\"
...\" Revision 1.1.2.3  1993/10/27  19:52:58  rnollman
...\" 	fixed Pic pathnames
...\" 	[1993/10/27  19:52:41  rnollman]
...\"
...\" Revision 1.1.3.2  1993/10/27  19:52:41  rnollman
...\" 	fixed Pic pathnames
...\"
...\" Revision 1.1.2.2  1993/10/26  14:56:38  wardr
...\" 	Move initial .zA from before to after .H 1.
...\" 	[1993/10/26  14:50:36  wardr]
...\"
...\" Revision 1.1.3.2  1993/10/26  14:50:36  wardr
...\" 	Move initial .zA from before to after .H 1.
...\"
...\" Revision 1.1.2.1  1993/10/25  21:33:04  rnollman
...\" 	create chapter
...\" 	[1993/10/25  21:32:41  rnollman]
...\"
...\" Revision 1.1.1.2  1993/10/25  21:32:41  rnollman
...\" 	create chapter
...\"
...\" Revision 1.1.2.3  1993/10/22  19:01:36  rnollman
...\" 	fixed include statements for PIC diagrams
...\" 	[1993/10/22  18:57:56  rnollman]
...\"
...\" 	final changes from Dublin
...\" 	[1993/10/22  18:50:48  rnollman]
...\"
...\" Revision 1.1.2.2  1993/10/22  17:39:49  rnollman
...\" 	incorporated review comments from Dublin
...\" 	[1993/10/22  17:39:25  rnollman]
...\" 
...\" Revision 1.1.2.1  1993/10/15  14:14:30  rnollman
...\" 	new chapter
...\" 	[1993/10/15  14:14:08  rnollman]
...\" 
...\" $EndLog$
...\"
...\" /*****************************************************************
...\" *                                                                *
...\" * COPYRIGHT   (C)  SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1994   *
...\" *                  ALL RIGHTS RESERVED                           *
...\" *                                                                *
...\" *****************************************************************/
.H 1 "Using Threads With The XDS/XOM API"
...\" 
...\" DCE 1.2 WRITERS: The following comment was left over from
...\" DCT's review comments on this guide:
...\" 
...\" Could be beefed up.  I don't think this is as interesting an
...\" example as it could be.  Something talked to CDS + GDS could be more
...\" believably multithreaded, w/mutexes et al.  Having said that, we all
...\" recognize the fact that XDS programming is already hard enough without
...\" this threads stuff ...
...\" 
.P
Some programs work well when they are structured as
multiple flows of control.  Other programs may show better performance
when they are multithreaded allowing the multiple threads to be mapped
to multiple processors when they are available.
.P
GDS application programs can contain multiple threads of control.  For
example, a GDS application can need to query several GDS servers.  This
can be achieved more efficiently by using separate threads
simultaneously to query the different servers.
.P
GDS supports multithreaded applications. Writing multithreaded
applications over GDS imposes new requirements on programmers: they
must manage the threads, synchronize threads' access to global
resources, and make choices about thread scheduling and priorities.
.P
This chapter describes a simple GDS application that uses threads.
(Refer to the \*V*\*L(3thr)\*O reference pages for more information on DCE
threads.)
.P
.ne 5
The XDS/XOM API calls do not change when they are making use of DCE threads in an application program. The service underneath XDS/XOM API is designed to be
both \*Ethread-safe\*O, to allow multiple threads to safely access shared data,
and \*Ecancel-safe\*O, to handle unexpected cancellation of a thread in 
an application program.
.P
Figure 8-1 shows an example of how an application can issue XDS/XOM calls 
from within different threads.
.P
.ne 4.8i
.FG "Issuing XDS/XOM Calls from within Different Threads"
.sp .5
.dI ../directory/xds_gds/Pics/threads2.pic
.sp .5
.P
The order of thread completion is not defined; however, XDS/XOM has an
inherent ordering.  Multithreaded XDS applications must adhere to the
following order of execution:
.AL
.LI 
\*Lds_initialize(\|)\*O
.LI
\*Lds_version(\|)\*O (optional)
.LI
\*Lds_bind(\|)\*O
.LI
Other XDS calls in sequence or parallel from multiple threads
.LI
\*Lds_unbind(\|)\*O
.LI
\*Lds_shutdown(\|)\*O
.LE
.P
.ne 8
Multi-threaded XOM applications must adhere to the
following order of execution:
.AL
.LI 
\*Lds_initialize(\|)\*O
.LI
XOM calls in sequence or parallel from multiple threads
.LI
\*Lds_shutdown(\|)\*O
.LE
.P
The XDS/XOM API will return an appropriate error code if these sequences
are not adhered to.  For example the following errors are returned:
.VL 1.25i
.LI "\*LDS_E_BUSY\*O"
If \*Lds_unbind(\|)\*O is called while there are still outstanding 
operations, or if \*Lds_shutdown(\|)\*O is called before all directory connections have been released by \*Lds_unbind(\|)\*O.
.LI "\*LOM_NO_SUCH_WORKSPACE\*O"
.nL
If any XOM API calls are made before calling \*Lds_initialize(\|)\*O, or
if a call to \*Lds_shutdown(\|)\*O completes while there are outstanding
XOM operations on the same workspace.  In the latter case, these XOM operations will not be performed.
.LE
.H 2 "Overview of Sample Threads Program"
.P
The sample program is called \*Lthradd\*O. The \*Lthradd\*O program is a multithreaded 
XDS application that adds entries to a GDS directory.  Each thread performs 
a \*Lds_add_entry(\|)\*O call.  The information for each entry to be added
is read from an input file.
.P
The \*Lthradd\*O program can also be used to reset the directory to 
its original state.  This is achieved by invoking \*Lthradd\*O with
a \*L-d\*O command-line argument.  In this case, \*Lthradd\*O uses the same 
input file and calls \*Lds_remove_entry(\|)\*O for each entry.
The \*Lds_remove_entry(\|)\*O calls are also done in separate threads.
.P
To keep the program short and clear, it works with a fixed tree for the 
upper nodes (\*L/C=it/O=sni/OU=ap\*O), to which the entries described in the 
input file are added.  This fixed upper tree is added to the directory
by \*Lthradd\*O.  The input file contains the common name, the 
surname, and the phone number of each \*LOrganizational-Person\*O entry to be added.  
.P
.ne 2
For simplicity, only \*Lpthread_join(\|)\*O is used for synchronization 
purposes; mutexes are not used. 
...\" DCE 1.2 WRITERS: DCT comment by above line: "!!"
.P
.ne 6
The \*Lthradd\*O program could be enhanced to satisfy the following scenarios:
.ML
.LI
As a server program for interactive directory actions from different users.
The \*Lthradd\*O program simulates a server program which gets requests from different users to add entries to a directory.  In the case of \*Lthradd\*O, the users' interactive input is simulated through the entries in the input file.  Each line of input represents a different directory entry, and \*Lthradd\*O uses a separate thread for each line.
.LI
Initialization of the directory with data from file.  The \*Lthradd\*O program
could be enhanced to read generic attribute information for a variety of directory object classes from a file, and to add the corresponding entries to the directory.
.LE
.H 3 "User Interface"
.P
The \*Lthradd\*O program is called from the command line as follows:
.iS
thradd\*O [\*L-d\*O] [\*L-f\*O \*Vfile_name\*O]
.iE
where:
.VL 15
.LI \*L-d\*O
Causes the entries in the file and the tree 
\*L/C=it/O=sni/OU=ap\*O are deleted; otherwise, they are added.
.LI  "\*L-f\*O \*Vfile_name\*O"
Specifies the name of the input file.  If no input file
is specified, then a default filename of \*Lthradd.dat\*O is used.
.LE
.H 3 "Input File Format"
.P
The input file can contain any number of lines. Each line represents a
directory entry of an organizational person.  Each line must contain the
following three attributes for each entry:
.iS
\*O<\*Vcommon name\*O>   <\*Vsurname\*O>   <\*Vphone number\*O>
.iE
.P
.ne 4
The attributes must be strings without space characters. Lines containing 
less than three strings are rejected by the program; any input on a line 
after the first three strings is ignored and can be used for comments.  The
attributes are separated by one or more space characters.
.P
The input strings are not verified for their relevant attribute syntax.
A wrong attribute syntax will result in either a \*Lds_add_entry(\|)\*O error
or a \*Lds_remove_entry(\|)\*O error.
.P
The following would be a valid input file for \*Lthradd\*O:
.oS
Anna          Meister        010101
Erwin         Reiter         020202
Gerhard       Schulz         030303
Gottfried     Schmid         040404
Heidrun       Blum           050505
Hermann       Meier          060606
Josefa        Fischer        070707
Jutta         Arndt          080808
Leopold       Huber          090909
Magdalena     Schuster       101010
Margot        Junge          111111
.oE
.H 3 "Program Output"
.P
The \*Lthradd\*O program writes messages to \*Lstdout\*O for every action done by a thread. The order of the output can differ from the order in the input file; it depends on the execution of the different threads.
.P
Errors are reported to \*Lstderr\*O.
.nL
.ne 11
.H 3 "Prerequisites"
.P
The directory must be active before running \*Lthradd\*O.  If running
\*Lthradd\*O in \*Eadding\*O mode then the directory should not contain 
a node \*L/C=it\*O.  The \*Lthradd\*O program should always be invoked twice with the same input file: first without and then with option \*L-d\*O.  This guarantees that the directory is reset to its original state.  The GDS administration
program \*Lgdsditadm\*O can be used to verify the directory contents after 
adding entries.
.H 2 "Description of Sample Program"
.P
The \*Lthradd\*O program has a similar structure to the sample 
XDS programs in the
previous chapter.  Therefore, only a short general outline of the program
is given here.  The thread specifics are described in detail in the next
section.
.P
The static descriptors for the fixed tree (that is, \*L/C=it/O=sni/OU=ap\*O)
are declared in the \*Lthradd.h\*O header file.  Listings of both the
\*Lthradd.c\*O application and the \*Lthradd.h\*O header file are included 
in later sections of this chapter.
.P
The main routine scans the command-line options, initializes the XDS
workspace and, if working in adding mode, binds to the default GDS
server without credentials, adds the fixed tree of upper nodes, and
then unbinds from the directory.
.P
The program then binds to the default GDS server without credentials. 
Each line of the input file is processed in turn by a \*Lwhile\*O loop
(until the end of file is reached).  The \*Lwhile\*O loop contains two \*Lfor\*O
loops.  The first \*Lfor\*O loop creates a separate thread for each
line of the input file, up to a maximum of \*LMAX_THREAD_NO\*O of threads.
.P
The \*Ladd_or_remove(\|)\*O procedure, which adds or removes an entry
to/from the directory, is the starting point of each thread's processing.
.P
The second \*Lfor\*O loop waits for termination of the threads and then
releases the resources used by the threads.
.P
.ne 3
When the entire input file has been processed, \*Lthradd\*O 
closes the connection to the GDS server and, if working 
in \*Eremoving\*O mode, removes the fixed tree of 
upper nodes (that is, \*L/C=it/O=sni/OU=ap\*O).
.P
Finally, the XDS workspace is closed.
.P
Figure 8-2 shows the program flow.
.P
.ne 5i
.FG "Program Flow for the thradd Sample Program"
.sp .5
.dI ../directory/xds_gds/Pics/threads1.pic
.H 2 "Detailed Description of Thread Specifics"
.P
The program consists of the following general steps:
.P
.AL
.LI
Include the header file \*Lpthread.h\*O.
.LI
Define a parameter block structure type for the thread start routine.
.LI
Declare arrays for thread handles and parameter blocks.
.LI
Read the input file line by line.
.LI
Update the parameter block.
.LI
Create the thread.
.LI
Wait for the termination of the thread.
.LI
Release the resources used by the thread.
.LI
Define the thread start routine.
.LI
Declare local variables needed for descriptors for the objects read from the input file.
.LE
.P
The following paragraphs describe the corresponding step numbers from
the program listing in the next section:
.P 
Step 1 includes the header file \*Lpthread.h\*O which is required for thread programming.
.P
Step 2 defines a parameter block structure type for the thread start routine.
A thread start routine must have exactly one parameter.  However,
\*Ladd_or_remove(\|)\*O requires three parameters (session object, 
input line and operating mode).  The structure \*Lpb_add_or_remove\*O 
is defined as the parameter block for these components.  Therefore, the
single parameter block contains the three parameters required by
\*Ladd_or_remove(\|)\*O.
.P
Step 3 declares arrays for thread handles and parameter blocks. The routine which creates the thread (\*Lmain\*O in this case) must maintain the following information for each thread:
.P
.ML
.LI
A thread handle of type \*Lpthread_t\*O to identify the thread for 
join and detach calls.
.LI
A thread specific parameter block that cannot be accessed by any other
thread.  This makes sure that a parameter for one thread is not 
overwritten by another thread.
.LE
.P
Step 4 reads the input file line by line. A thread is created
for each line.  A maximum \*LMAX_THREAD_NO\*O of threads are created
in parallel.  The program then waits for the termination of the created
threads so that it can release the resources used by these threads,
allowing it to create new threads for remaining input lines (if any).
.P
The absolute maximum number of threads working in parallel depends on 
system limits; for \*Lthradd\*O a value of 10 was chosen (see \*Lthradd.h\*O), 
which is well below the maximum on most systems.
.P
Step 5 updates the parameter block. For each thread a different
element of the array of parameter blocks is used.
.P
Step 6 creates the thread. The thread is created by using the function 
\*Lpthread_create(\|)\*O.  The function has the following four parameters:
.ML
.LI
The thread handle (output) is stored in an element of the array of type 
\*Lpthread_t\*O.
.LI
For the thread characteristics, the default \*Lpthread_attr_default\*O is
used.
.LI
The start routine for this thread is \*Ladd_or_remove(\|)\*O.
.LI
The parameter passed to \*Ladd_or_remove(\|)\*O is a pointer to an 
element of the array of parameter blocks.
.LE
.P
Step 7 waits for the termination of the thread.  The
\*Lpthread_join(\|)\*O routine is called with the thread handle as the
input parameter.  The program waits for the termination of the thread.
If the thread has already terminated, then \*Lpthread_join(\|)\*O
returns immediately.  The second parameter of \*Lpthread_\%join(\|)\*O
contains the return value of the start function; here it's a dummy
value because \*Ladd_or_remove(\|)\*O returns a \*Lvoid\*O.
\*Ladd_or_remove(\|)\*O is designed as a \*Lvoid\*O function because
the calling routine does not have to deal with error cases.  The
\*Ladd_or_remove(\|)\*O routine prints status messages itself to show
the processing order of the threads.  Normally a status should be
returned to the application.
.P
Step 8 releases the resources used by the thread. The thread
handle is used as input for the function \*Lpthread_detach(\|)\*O,
which releases the resources (for example, memory) used by the thread.
.P
Step 9 defines the thread start routine. As previously
mentioned, the thread start routine must have exactly one parameter.
In this case, it is a pointer to the parameter block structure defined
in Step 2.
.P
.ne 5
Step 10 declares local variables needed for descriptors for the
objects read from the input file.  These descriptors are variables and
are declared as automatic because of the reentrancy requirement.  In
the previous sample programs, descriptors were generally declared
static.  For this example, this is only possible for the constant
descriptors declared in \*Lthradd.h\*O.
.P
Of course this example shows only a small part of the possibilities of
multithreaded XDS programming.  For example, each thread could make 
its own bind which would be useful if more than one GDS server was involved.
.H 2 "The thradd.c Code"
.P
The following code is a listing of the \*Lthradd.c\*O program:
.nL
.ps 11
.vs 13
.oS
/*
 * The program operates in two modes; it adds or removes entries of
 * object type organizational person to/from a directory.  The 
 * information about the entries is read from a file.
 *
 * The program requires that a tree exists in the directory.
 * Therefore, each time the program runs, the following tree of 3 
 * entries is added to or removed from the directory, according 
 * to the operation mode.
 *
 *              O  C=it
 *              |  (objectClass=Country)
 *              |
 *              O  O=sni
 *              |  (objectClass=Organization)
 *              |
 *              O  OU=ap
 *                 (objectClass=OrganizationalUnit)
 *
 * Information about the organizational persons to be added or 
 * removed is read from the input file.  It may contain any number 
 * of lines, where each line must have the following syntax:
 *
 *     <common name>   <surname>   <phone number>
 *     Each item must be a string without a space.
 *
.ne 5 
 * Lines containing less than 3 strings are rejected by the 
 * program.  The program does not check to see if the strings conform 
 * to the appropiate attribute syntax; that is a wrong attribute 
 * syntax will lead to a ds_add_entry error, or to a 
 * ds_remove_entry error.
 *
 * Usage: thradd [-d] [-f<file_name>]
 *   -d            If the option -d is set, the entries in the 
 *                 file and the tree described above are removed, 
 *                 otherwise they are added.
 *   -f<file_name> The option -f specifies the name of the input 
 *                 file.If left out, the default "thradd.dat" 
 *                 is used.
 */

/* Step 1 */

/*
 * Header file for thread programming:
 */
#include <pthread.h>

#include <stdio.h>
#include <xom.h>
#include <xds.h>
#include <xdsbdcp.h>
#include <xdsgds.h>
#include <xdscds.h>
#include "thradd.h"                  /* static data structures. */

/* Step 2 */

/*
 * typedef for parameter block of function add_or_remove
 * (this is necessary because the start function of a thread 
 * takes only 1 parameter).  The following 3 parameters are
 * passed to add_or_remove:
 *
 *     Input - Session object from the ds_bind call
 *     Input - Buffer with the entry information
 *     Input - "adding" or "removing" mode ?
 */
typedef struct {
    OM_private_object session;  
    char              line[MAX_LINE_LEN+1];
    int               do_remove;
} pb_add_or_remove;

.ne 6
/*
 * static constants:
 * 
 * Default name for input file containing entry information.
 */
static char fn_default[] = "thradd.dat";

/*
 * function declarations:
 */
char *own_fgets(char *s, int n, FILE *f);
void add_or_remove(pb_add_or_remove *pb);

int
main(
    int  argc,
    char *argv[]
)
{
    OM_workspace      workspace;         /* workspace for objects */
    OM_private_object bound_session;     /* Holds the Session     */
                                         /* returned by ds_bind() */
    FILE              *fp;               /* pointer for input file*/
    int               do_remove = FALSE; /* "adding" or "removing"*/
    int               error     = FALSE; /* error in options ?    */
    int               is_eof    = FALSE; /* EOF input file reached*/
    int               thread_count;      /* no. of created threads*/
    char              *file_name;        /* ptr to input file_name*/

.ne 10
/* Step 3 */

    pthread_t         threads[MAX_THREAD_NO];     /* thread table */
    pb_add_or_remove  param_block[MAX_THREAD_NO]; /* 1 param block*/
                                  /* for start routine per thread */
    int               dummy;
    int               c;
    int               i;
    extern char       *optarg;/* external variable used by getopt */
    extern int        optind; /* external variable used by getopt */

    /*
     * scan options -d and -f
     */
    file_name = fn_default;

.ne 15
    while ((c=getopt(argc, argv, "df:")) != EOF)
    {
        switch (c)
        {
        case 'd':
            do_remove = TRUE;
            break;
        case 'f':
            file_name = optarg;
            break;
        default:
            error = TRUE;
            break;
        }
    }

    if (error)
    {
        printf("usage: %s [-d] [-f<file_name>]\en", argv[0]);
        return(FAILURE);
    }

    if (( fp = fopen(file_name, "r")) == (FILE *) NULL)
    {
        printf("fopen() error, file name: %s\en", file_name);
        return(FAILURE);
    }

    /*
     * Initialize a directory workspace for use by XOM.
     */
    if ((workspace = ds_initialize()) == (OM_workspace)0)
        printf("ds_initialize() error\en");

    /*
     * Negotiate the use of the BDCP and GDS packages.
     */
    if (ds_version(features, workspace) != DS_SUCCESS)
        printf("ds_version() error\en");

.ne 6
    /*
     * Add the fixed tree of entries, if in adding mode
     */
    if (!do_remove)
        if (add_entries(workspace))
            printf("add_entries() error\en");

.ne 9
    /*
     * Bind to the default GDS server.
     * The returned session object is stored in the private 
     * object variable bound_session and is used for further 
     * XDS function calls.
     */
    if (ds_bind(DS_DEFAULT_SESSION, workspace, &bound_session) 
        != DS_SUCCESS)
        printf("ds_bind() error\en");

/* Step 4 */

    /*
     * Add or remove entries described in input file.  This is done
     * in parallel, creating up to MAX_THREAD_NO threads at a time.
     */
    while (!is_eof)
    {
        for (thread_count=0; thread_count<MAX_THREAD_NO; 
             thread_count++)
        {

/* Step 5 */

            /*
             * Prepare parameter block:
             */
            is_eof = (own_fgets(param_block[thread_count].line, 
                                MAX_LINE_LEN, fp) == NULL);
            if (is_eof)
                break;

            param_block[thread_count].session   = bound_session;
            param_block[thread_count].do_remove = do_remove;

/* Step 6 */

            /*
             * Create thread with start routine add_or_remove:
             */
            if (pthread_create(&threads[thread_count],
                               pthread_attr_default,
                (pthread_startroutine_t) add_or_remove,
                (pthread_addr_t) &param_block[thread_count])
                != SUCCESS)
                printf("pthread_create() error\en");
        } /* end for */

.ne 6
        /*
         * Wait for termination of the created threads and release 
         * resources:
         */
        for (i=0; i<thread_count; i++)
        {

/* Step 7 */

            /*
             * Wait for termination of thread
             * (If thread has terminated already, the function 
             * returns immediately):
             */
             if (pthread_join(threads[i], (pthread_addr_t) &dummy) 
                 != SUCCESS)
                printf("pthread_join() error\en");

/* Step 8 */

            /*
             * Release resources used by the thread:
             */
             if (pthread_detach(&threads[i]) != SUCCESS)
                printf("pthread_detach() error\en");
        } /* end for */
    } /* end while */

    /*
     * Close the connection to the GDS server.
     */
    if (ds_unbind(bound_session) != DS_SUCCESS)
        printf("ds_unbind() error\en");

    if (om_delete(bound_session) != OM_SUCCESS)
        printf("om_delete() error\en");

    /*
     * Remove the tree from the directory, if removing mode
     */
    if (do_remove)
        if (remove_entries(workspace))
            printf("remove_entries() error\en");

.ne 5
    /*
     * Close the directory workspace.
     */
    if (ds_shutdown(workspace) != DS_SUCCESS)
        printf("ds_shutdown() error\en");

    fclose(fp);
    return(SUCCESS);
} /* end main() */

/* Step 9 */

/*
 * Handle (add or remove) a directory entry
 */
void
add_or_remove( 
    pb_add_or_remove    *pb   /* parameter information    */
)
{

    /*
     * further local variables:
     */
    char               common_name[MAX_AT_LEN+1];
    char               phone_num[MAX_AT_LEN+1]; 
    char               surname[MAX_AT_LEN+1];  
    OM_sint            invoke_id;             

/* Step 10 */

    /*
     * local variables for descriptors for objects read from file
     */
    OM_descriptor    ava_genop[] = {
        OM_OID_DESC(OM_CLASS, DS_C_AVA),
        OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COMMON_NAME),
        OM_NULL_DESCRIPTOR,   /* place holder */
        OM_NULL_DESCRIPTOR
    };
    
    OM_descriptor    rdn_genop[] = {
        OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
        OM_NULL_DESCRIPTOR,   /* place holder */
        OM_NULL_DESCRIPTOR
    };
    
    OM_descriptor dn_genop[] = {
        OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
        {DS_RDNS,OM_S_OBJECT,{0,rdn_it}},
        {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
        {DS_RDNS,OM_S_OBJECT,{0,rdn_ap}},
        OM_NULL_DESCRIPTOR,   /* place holder */
        OM_NULL_DESCRIPTOR
    };
    
    OM_descriptor    att_phone_num[] = {
        OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
        OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_PHONE_NBR),
        OM_NULL_DESCRIPTOR,           /* place holder */
        OM_NULL_DESCRIPTOR
    };
     
    OM_descriptor    att_surname[] = {
        OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
        OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_SURNAME),
        OM_NULL_DESCRIPTOR,           /* place holder */
        OM_NULL_DESCRIPTOR
    };
     
    OM_descriptor    alist_OP[] = {
        OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
        {DS_ATTRIBUTES, OM_S_OBJECT, {0, obj_class_OP} },
        OM_NULL_DESCRIPTOR,   /* place holder */
        OM_NULL_DESCRIPTOR,   /* place holder */
        OM_NULL_DESCRIPTOR
    };
    
    
    rdn_genop[1].type = DS_AVAS;
    rdn_genop[1].syntax = OM_S_OBJECT;
    rdn_genop[1].value.object.padding = 0;
    rdn_genop[1].value.object.object = ava_genop;

    dn_genop[4].type = DS_RDNS;
    dn_genop[4].syntax = OM_S_OBJECT;
    dn_genop[4].value.object.padding = 0;
    dn_genop[4].value.object.object = rdn_genop;

    alist_OP[2].type = DS_ATTRIBUTES;
    alist_OP[2].syntax = OM_S_OBJECT;
    alist_OP[2].value.object.padding = 0;
    alist_OP[2].value.object.object = att_surname;

.ne 4
    alist_OP[3].type = DS_ATTRIBUTES;
    alist_OP[3].syntax = OM_S_OBJECT;
    alist_OP[3].value.object.padding = 0;
    alist_OP[3].value.object.object = att_phone_num;

    if (sscanf(pb->line, "%s %s %s", common_name, 
               surname, phone_num) != 3)
    {
        printf("invalid input line: >%s<\en", pb->line);
        return;
    }
    /*
     * Fill descriptor for common name 
     */
    ava_genop[2].type = DS_ATTRIBUTE_VALUES;
    ava_genop[2].syntax = OM_S_PRINTABLE_STRING;
    ava_genop[2].value.string.length = 
                       (OM_string_length)strlen(common_name);
    ava_genop[2].value.string.elements = common_name;

    if (!pb->do_remove)     /* add */
    {
        /*
         * Fill descriptors for surname and phone number
         */
        att_surname[2].type = DS_ATTRIBUTE_VALUES;
        att_surname[2].syntax = OM_S_TELETEX_STRING;
        att_surname[2].value.string.length = 
                       (OM_string_length)strlen(surname);
        att_surname[2].value.string.elements = surname;

        att_phone_num[2].type = DS_ATTRIBUTE_VALUES;
        att_phone_num[2].syntax = OM_S_PRINTABLE_STRING;
        att_phone_num[2].value.string.length = 
                         (OM_string_length)strlen(phone_num);
        att_phone_num[2].value.string.elements = phone_num;

.ne 12
        /*
         * add entry
         */
        if (ds_add_entry(pb->session, DS_DEFAULT_CONTEXT, dn_genop, 
                         alist_OP, &invoke_id) != DS_SUCCESS)
            printf("ds_add_entry() error: %s %s %s\en",
                                  common_name, surname, phone_num);
        else
            printf("entry added: %s %s %s\en", 
                                  common_name, surname, phone_num);
    }
    else      /* remove */
    {
        /*
         * remove entry
         */
        if (ds_remove_entry(pb->session, DS_DEFAULT_CONTEXT, 
                            dn_genop, &invoke_id) != DS_SUCCESS)
            printf("ds_remove_entry() error: %s\en", common_name);
        else
            printf("entry removed: %s\en", common_name);
    } /* end if */
} /* end add_or_remove() */

/*
 * Add the tree of entries described above.
 */
int
add_entries(
    OM_workspace workspace    /* In--XDS workspace    */
)
{
    OM_private_object bound_session;  /* Holds Session object  */
                                      /* returned by ds_bind() */
    OM_sint           invoke_id;
    int               error = FALSE;


    /* Bind (without credentials) to the default GDS server */

    if (ds_bind(DS_DEFAULT_SESSION, workspace, &bound_session) 
        != DS_SUCCESS)
        error = TRUE;

.ne 9
    /* Add entries to the GDS server */

    if (ds_add_entry(bound_session, DS_DEFAULT_CONTEXT, dn_it, 
                     alist_C, &invoke_id) != DS_SUCCESS)
        error = TRUE;

    if (ds_add_entry(bound_session, DS_DEFAULT_CONTEXT, dn_sni, 
                     alist_O, &invoke_id) != DS_SUCCESS)
        error = TRUE;

    if (ds_add_entry(bound_session, DS_DEFAULT_CONTEXT, dn_ap, 
                     alist_OU, &invoke_id) != DS_SUCCESS)
        error = TRUE;


    /* Close the connection to the GDS server */

    if (ds_unbind(bound_session) != DS_SUCCESS)
        error = TRUE;

    if (om_delete(bound_session) != OM_SUCCESS)
        error = TRUE;

    return (error);
}

/*
 * Remove the tree of entries described above.
 */
int
remove_entries(
    OM_workspace workspace     /* In--XDS workspace  */
)
{
    OM_private_object bound_session;  /* Holds Session object  */
                                      /* returned by ds_bind() */
    OM_sint           invoke_id;
    int               error = FALSE;

    /* Bind to the default GDS server */

    if (ds_bind(DS_DEFAULT_SESSION, workspace, &bound_session) 
        != DS_SUCCESS)
        error = TRUE;

.ne 9
    /* Remove entries from the GDS server */

    if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, 
                        dn_ap, &invoke_id) != DS_SUCCESS)
        error = TRUE;

    if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, 
                        dn_sni, &invoke_id) != DS_SUCCESS)
        error = TRUE;

    if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT, 
                        dn_it, &invoke_id) != DS_SUCCESS)
        error = TRUE;

    /* Close the connection to the GDS server */

    if (ds_unbind(bound_session) != DS_SUCCESS)
        error = TRUE;

    if (om_delete(bound_session) != OM_SUCCESS)
        error = TRUE;

    return (error);
}
 
/*
 * read one line with fgets and overwrite new line by 
 * a null character
 */

char *
own_fgets(
    char *s,   /* OUT--string read                        */
    int  n,    /* IN---maximum number of chars to be read */
    FILE *f    /* IN---input file                         */
)
{
    char *result;
    int  i = 0;

.ne 9
    result = fgets(s, n, f);
    if (result != NULL)
    {
        i = strlen(s);
        if (s[i-1] == '\en')
            s[i-1] = '\e0';
    }
    return (result);
}
.oE
.ps 12
.vs 14
.H 2 "The thradd.h Header File"
The following code is a listing of the \*Lthradd.h\*O header file:
.P
.nL
.ps 11
.vs 13
.oS
#ifndef THRADD_H
#define THRADD_H

#ifndef TRUE
#define TRUE	(1)
#endif

#ifndef FALSE
#define FALSE	(0)
#endif

#define SUCCESS 0
#define FAILURE 1
#define MAX_LINE_LEN  100 /* max length of line in input file */
#define MAX_AT_LEN    100 /* max length of an attribute value */
#define MAX_THREAD_NO  10 /* max number of threads created    */


/* The application must export the object 
   identifiers it requires.      
*/

OM_EXPORT (DS_C_AVA)
OM_EXPORT (DS_C_DS_RDN)
OM_EXPORT (DS_C_DS_DN)
OM_EXPORT (DS_C_ATTRIBUTE)
OM_EXPORT (DS_C_ATTRIBUTE_LIST)

.ne 7
OM_EXPORT (DS_A_COUNTRY_NAME)
OM_EXPORT (DS_A_ORG_NAME)
OM_EXPORT (DS_A_ORG_UNIT_NAME)
OM_EXPORT (DS_A_COMMON_NAME)
OM_EXPORT (DS_A_OBJECT_CLASS)
OM_EXPORT (DS_A_PHONE_NBR)
OM_EXPORT (DS_A_SURNAME)

OM_EXPORT (DS_O_TOP)
OM_EXPORT (DS_O_COUNTRY)
OM_EXPORT (DS_O_ORG)
OM_EXPORT (DS_O_ORG_UNIT)
OM_EXPORT (DS_O_PERSON)
OM_EXPORT (DS_O_ORG_PERSON)


/* Build descriptor lists for the following   */
/* distinguished names:                       */
/*     root                                   */
/*     /C=it                                  */
/*     /C=it/O=sni                            */
/*     /C=it/O=sni/OU=ap                      */

static OM_descriptor    ava_it[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COUNTRY_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("it")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_sni[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("sni")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_ap[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_UNIT_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("ap")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_it[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_it}},
    OM_NULL_DESCRIPTOR
};
.ne 5
static OM_descriptor    rdn_sni[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_sni}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_ap[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_ap}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_root[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_it[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_it}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_sni[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_it}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_ap[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_it}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ap}},
    OM_NULL_DESCRIPTOR
};


/* Build up an array of object identifiers for the  */
/* attributes to be added to the directory.         */

static OM_descriptor    obj_class_C[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_TOP),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_COUNTRY),
    OM_NULL_DESCRIPTOR
};
.ne 7
static OM_descriptor    obj_class_O[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_TOP),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_ORG),
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    obj_class_OU[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_TOP),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_ORG_UNIT),
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    obj_class_OP[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_TOP),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_PERSON),
    OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_ORG_PERSON),
    OM_NULL_DESCRIPTOR
};

static OM_descriptor    alist_C[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, obj_class_C} },
    OM_NULL_DESCRIPTOR
};
 
static OM_descriptor    alist_O[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, obj_class_O} },
    OM_NULL_DESCRIPTOR
};

static OM_descriptor    alist_OU[] = {
    OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
    {DS_ATTRIBUTES, OM_S_OBJECT, {0, obj_class_OU} },
    OM_NULL_DESCRIPTOR
};
 
.ne 10
/* Build up an array of object identifiers for the   */
/* optional packages to be negotiated.               */

static DS_feature features[] = {
    { OM_STRING(OMP_O_DS_BASIC_DIR_CONTENTS_PKG), OM_TRUE },
    { OM_STRING(OMP_O_DSX_GDS_PKG), OM_TRUE },
    { 0 }
};

#endif  /* THRADD_H */
.oE
.ps 12
.vs 14
