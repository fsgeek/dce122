...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
...\" src directory for the full copyright text.
...\" 
...\" HISTORY
...\" $Log: 2_xom_concepts.gpsml,v $
...\" Revision 1.1.12.1  1996/09/03  18:14:17  wardr
...\" 	{enh,R1.2.2}
...\" 	Update for sgml conversion
...\" 	[1996/09/03  18:13:22  wardr]
...\"
...\" Revision 1.1.10.1  1996/03/19  15:22:12  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/19  15:21:27  wardr]
...\" 
...\" Revision 1.1.8.15  1995/06/15  16:28:39  rcb
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/13  19:26:25  rcb]
...\" 
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/07  16:08:07  rcb]
...\" 
...\" Revision 1.1.8.14  1994/11/03  23:33:18  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:38:43  neilson]
...\" 
...\" 	Substituted macros for book names in cross refs.
...\" 
...\" Revision 1.1.8.13  1994/10/20  17:43:32  rnollman
...\" 	fixed formatting error
...\" 	[1994/10/20  17:43:20  rnollman]
...\" 
...\" Revision 1.1.8.12  1994/10/17  20:46:47  rnollman
...\" 	incorporated editorial comments from Dublin
...\" 	[1994/10/17  20:46:33  rnollman]
...\" 
...\" Revision 1.1.8.11  1994/08/05  14:00:47  rnollman
...\" 	completed osf edits
...\" 	[1994/08/05  13:57:18  rnollman]
...\" 
...\" Revision 1.1.8.10  1994/05/18  20:13:32  weir
...\" 	Test
...\" 	[1994/05/18  20:13:08  weir]
...\" 
...\" Revision 1.1.8.9  1994/05/18  18:57:56  rnollman
...\" 	fixed index page range entry problem
...\" 	[1994/05/18  18:57:20  rnollman]
...\" 
...\" Revision 1.1.8.8  1994/05/17  20:29:30  hal
...\" 	No changes
...\" 	[1994/05/17  20:28:53  hal]
...\" 
...\" Revision 1.1.8.7  1994/05/14  22:31:53  rnollman
...\" 	last submission for beta
...\" 	[1994/05/14  22:28:12  rnollman]
...\" 
...\" Revision 1.1.8.6  1994/05/12  15:14:26  rnollman
...\" 	final update for beta
...\" 	[1994/05/12  15:13:59  rnollman]
...\" 
...\" Revision 1.1.8.5  1994/03/14  22:00:26  rom
...\" 	{enh, 10129, R1.1}
...\" 	Fix pathnames of included files for new three-book organization.
...\" 	[1994/03/14  21:20:00  rom]
...\" 
...\" Revision 1.1.8.4  1994/03/14  15:17:03  rnollman
...\" 	no changes - submitting for update of references for reorg of book
...\" 	[1994/03/14  15:16:35  rnollman]
...\" 
...\" Revision 1.1.8.3  1993/11/11  21:11:56  rnollman
...\" 	updated SNI copyright
...\" 	[1993/11/11  21:11:26  rnollman]
...\" 
...\" Revision 1.1.8.2  1993/10/27  19:48:55  rnollman
...\" 	fixed pic pathnames
...\" 	[1993/10/27  19:48:37  rnollman]
...\" 
...\" Revision 1.1.8.1  1993/10/27  18:40:53  rnollman
...\" 	replaced old version with new version from Dublin
...\" 	[1993/10/27  18:40:23  rnollman]
...\" 
...\" Revision 1.1.6.5  1993/01/28  18:41:07  cjd
...\" 	Embedded copyright notice
...\" 	[1993/01/28  18:00:37  cjd]
...\" 
...\" Revision 1.1.6.4  1993/01/08  12:28:11  marrek
...\" 	No changes from SSE Dublin.
...\" 	[1993/01/08  12:26:52  marrek]
...\" 
...\" Revision 1.1.6.3  1992/12/21  16:14:51  rnollman
...\" 	no work done
...\" 	[1992/12/21  16:14:08  rnollman]
...\" 
...\" Revision 1.1.6.2  1992/11/20  16:22:47  weir
...\" 	Moved into 1.0.2doc tree
...\" 	[1992/11/20  16:17:59  weir]
...\" 
...\" Revision 1.1.4.10  1992/11/11  23:46:32  buckler
...\" 	Corrected index entries
...\" 	[1992/11/11  22:49:54  buckler]
...\" 
...\" Revision 1.1.4.9  1992/11/06  18:21:53  lmk
...\" 	Prentice-Hall index edit only
...\" 	[1992/11/06  18:20:17  lmk]
...\" 
...\" Revision 1.1.4.8  1992/11/06  16:09:19  lmk
...\" 	Prentice-Hall index edits only
...\" 	[1992/11/06  16:04:38  lmk]
...\" 
...\" Revision 1.1.4.7  1992/10/29  17:11:02  lmk
...\" 	Prentice-Hall index entries only
...\" 	[1992/10/29  16:57:58  lmk]
...\" 
...\" Revision 1.1.4.6  1992/10/28  22:04:44  lmk
...\" 	Prentice-Hall index edits only
...\" 	[1992/10/28  22:02:23  lmk]
...\" 
...\" Revision 1.1.4.5  1992/10/27  21:12:15  lmk
...\" 	Prentice Hall edits only
...\" 	[1992/10/27  21:10:10  lmk]
...\" 
...\" Revision 1.1.4.4  1992/10/21  20:10:00  steiner
...\" 	Third P-H edit pass, mostly formatting code and tables to fit
...\" 	publish look.
...\" 	[1992/10/21  20:09:21  steiner]
...\" 
...\" Revision 1.1.4.3  1992/10/15  15:11:27  steiner
...\" 	Second P-H edit pass.
...\" 	[1992/10/15  15:10:22  steiner]
...\" 
...\" Revision 1.1.4.2  1992/09/16  15:33:10  steiner
...\" 	First P-H editing pass - edits from Eddie Doyle.
...\" 	[1992/09/16  15:31:18  steiner]
...\" 
...\" Revision 1.1.2.38  1992/07/21  13:42:55  rnollman
...\" 	corrected typos from Brian Keane's list
...\" 	[1992/07/21  13:32:50  rnollman]
...\" 
...\" 	rev comments
...\" 	[1992/07/09  15:22:45  rnollman]
...\" 
...\" Revision 1.1.2.37  1992/07/17  19:05:09  weir
...\" 	Fixed various typos, etc.
...\" 	[1992/07/17  18:57:17  weir]
...\" 
...\" Revision 1.1.2.36  1992/06/30  19:31:29  rnollman
...\" 	added index entries
...\" 	[1992/06/30  19:30:43  rnollman]
...\" 
...\" Revision 1.1.2.35  1992/06/30  18:23:42  rnollman
...\" 	updated index
...\" 	[1992/06/30  18:22:56  rnollman]
...\" 
...\" Revision 1.1.2.34  1992/06/22  20:23:51  rnollman
...\" 	rev comments
...\" 	[1992/06/22  20:22:50  rnollman]
...\" 
...\" Revision 1.1.2.33  1992/06/17  15:54:08  rnollman
...\" 	rev comments
...\" 	[1992/06/17  15:53:17  rnollman]
...\" 
...\" Revision 1.1.2.32  1992/06/17  15:41:55  rnollman
...\" 	rev comments
...\" 	[1992/06/17  15:41:03  rnollman]
...\" 
...\" Revision 1.1.2.31  1992/06/17  15:26:42  rnollman
...\" 	rev comments
...\" 	[1992/06/17  15:25:36  rnollman]
...\" 
...\" Revision 1.1.2.30  1992/06/17  15:07:50  rnollman
...\" 	rev comments
...\" 	[1992/06/17  15:06:39  rnollman]
...\" 
...\" Revision 1.1.2.29  1992/06/17  14:47:19  rnollman
...\" 	rev comments
...\" 	[1992/06/17  14:46:08  rnollman]
...\" 
...\" 	rev comments
...\" 	[1992/06/17  14:43:59  rnollman]
...\" 
...\" Revision 1.1.2.28  1992/06/17  14:09:25  rnollman
...\" 	rev comments
...\" 	[1992/06/17  14:08:35  rnollman]
...\" 
...\" 	rev comments
...\" 	[1992/06/17  13:07:46  rnollman]
...\" 
...\" Revision 1.1.2.27  1992/06/17  12:12:58  rnollman
...\" 	rev comments
...\" 	[1992/06/17  12:12:19  rnollman]
...\" 
...\" Revision 1.1.2.26  1992/06/16  19:54:08  rnollman
...\" 	inc comments
...\" 	[1992/06/16  19:53:17  rnollman]
...\" 
...\" Revision 1.1.2.25  1992/06/16  15:33:07  rnollman
...\" 	rev comments
...\" 	[1992/06/16  15:32:13  rnollman]
...\" 
...\" Revision 1.1.2.24  1992/06/12  20:09:51  rnollman
...\" 	rev comments
...\" 	[1992/06/12  20:08:52  rnollman]
...\" 
...\" Revision 1.1.2.23  1992/06/12  18:44:37  rnollman
...\" 	rev comments
...\" 	[1992/06/12  18:43:52  rnollman]
...\" 
...\" Revision 1.1.2.22  1992/06/12  17:12:19  rnollman
...\" 	rev comments
...\" 	[1992/06/12  17:11:30  rnollman]
...\" 
...\" Revision 1.1.2.21  1992/06/12  16:28:06  rnollman
...\" 	rev comments
...\" 	[1992/06/12  16:27:05  rnollman]
...\" 
...\" Revision 1.1.2.20  1992/06/12  15:22:24  rnollman
...\" 	inc comments
...\" 	[1992/06/12  15:21:09  rnollman]
...\" 
...\" Revision 1.1.2.19  1992/06/09  19:38:19  rnollman
...\" 	rev comments
...\" 	[1992/06/09  19:37:33  rnollman]
...\" 
...\" Revision 1.1.2.18  1992/06/08  18:23:08  rnollman
...\" 	rev comments
...\" 	[1992/06/08  18:22:19  rnollman]
...\" 
...\" Revision 1.1.2.17  1992/06/08  18:17:58  rnollman
...\" 	inc comments
...\" 	[1992/06/08  18:17:13  rnollman]
...\" 
...\" Revision 1.1.2.16  1992/06/06  20:11:25  rnollman
...\" 	review comments
...\" 	[1992/06/06  20:10:52  rnollman]
...\" 
...\" Revision 1.1.2.15  1992/06/06  15:45:23  rnollman
...\" 	rev comments
...\" 	[1992/06/06  15:44:47  rnollman]
...\" 
...\" Revision 1.1.2.14  1992/06/06  15:22:22  rnollman
...\" 	rev comments.
...\" 	[1992/06/06  15:21:47  rnollman]
...\" 
...\" Revision 1.1.2.13  1992/06/06  14:11:03  rnollman
...\" 	rev comments
...\" 	[1992/06/06  14:10:23  rnollman]
...\" 
...\" Revision 1.1.2.12  1992/06/06  12:16:10  rnollman
...\" 	incorporate review comments.
...\" 	[1992/06/06  12:15:27  rnollman]
...\" 
...\" Revision 1.1.2.11  1992/06/05  22:32:41  rnollman
...\" 	inc rev comments.
...\" 	[1992/06/05  22:31:55  rnollman]
...\" 
...\" 	inc review comments.
...\" 	[1992/06/05  16:00:04  rnollman]
...\" 
...\" Revision 1.1.2.10  1992/06/05  13:06:43  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  13:06:04  rnollman]
...\" 
...\" Revision 1.1.2.9  1992/06/05  11:15:49  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  11:15:06  rnollman]
...\" 
...\" Revision 1.1.2.8  1992/06/05  10:09:07  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  10:08:26  rnollman]
...\" 
...\" Revision 1.1.2.7  1992/06/04  21:58:14  rnollman
...\" 	inc review comments.
...\" 	[1992/06/04  21:57:07  rnollman]
...\" 
...\" Revision 1.1.2.6  1992/06/04  13:02:10  rnollman
...\" 	incorporate review comments.
...\" 	[1992/06/04  13:01:27  rnollman]
...\" 
...\" 	incorp comments.
...\" 	[1992/06/04  01:09:27  rnollman]
...\" 
...\" Revision 1.1.2.5  1992/05/13  14:53:11  rnollman
...\" 	updated object identifier constant names with changes to standards
...\" 	[1992/05/13  14:52:07  rnollman]
...\" 
...\" 	_xom_concepts.gpsml Revision 1.1.2.4  1992/05/10  20:48:56  weir
...\" 	New version.
...\" 	[1992/05/10  20:48:34  weir]
...\" 
...\" Revision 1.1.2.3  1992/05/08  21:20:49  weir
...\" 	Added body of file!
...\" 	[1992/05/08  21:20:22  weir]
...\" 
...\" Revision 1.1.2.2  1992/05/08  21:15:55  weir
...\" 	Initial check-in.
...\" 	[1992/05/08  21:15:27  weir]
...\" 
...\" $EndLog$
...\" /******************************************************************
...\" *                                                                *
...\" * COPYRIGHT   (C)  SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1994   *
...\" *                  ALL RIGHTS RESERVED                           *
...\" *                                                                *
...\" *****************************************************************/
.H 1 "XOM Programming"
.P
.iX "-[" "XOM"
XOM API defines a general-purpose interface for use in conjunction
with other application-specific APIs for OSI services, such
as XDS API to directory services or X.400 Application API to
electronic mail service.  It presents the application programmer with
a uniform information architecture based on the concept of groups,
classes, and similar information objects.  
.P
This chapter describes some of the basic concepts required to
understand and use the XOM API effectively.
.P
The following names refer to the complete XDS example programs, which 
can be found in Chapter 7:
.ML
.LI
\*Lacl.c\*O  (\*Lacl.h\*O)
.LI
\*Lexample.c\*O  (\*Lexample.h\*O)
.LI
\*Lteldir.c\*O
.LE
.P
For multithreaded XDS/XOM applications, please refer to Chapter 8.
For use of the XDS/XOM convenience functions please refer to Chapter 9.
.H 2 "OM Objects"
.P
.iX "OM" "objects"
.iX "-: OM" "object" "management"
The purpose of XOM API is to provide an interface to manage complex
information objects.  These information objects belong to classes and
have attributes associated with them.  There are two distinct kinds of
classes and attributes that are used throughout the directory service 
documentation: \*Edirectory\*O classes and attributes
and \*EOM\*O classes and attributes.
.P
The directory classes and attributes defined for XDS API correspond to
entries that make up the objects in the directory.  These classes and
attributes are defined in the X.500 directory standard and by
additional GDS extensions created for DCE.  Other APIs, such as the X.400
API, which is the application interface for the industry
standard X.400 electronic mail service, define their own set of
objects in terms of classes and attributes.  OM classes and OM attributes
are used to model the objects in the directory.  
.P
.iX "workspace"
.iX "XOM" "API" "workspace"
XOM API provides a common information architecture so that the
information objects defined for any API that conforms to this
architectural model can be shared.  Different application service
interfaces can communicate by using this common way of defining objects
by means of workspaces.  A workspace is simply a common work area
where objects defined by a service can be accessed and manipulated.
In turn, XOM API provides a set of standard functions that perform
common operations on these objects in a workspace.  Two different APIs can
share information by copying data from one workspace to another. 
.H 3 "OM Object Attributes"
.P
.iX "attribute" "type" "OM"
.iX "OM" "attribute types"
OM objects are composed of OM attributes.  OM objects may contain zero or more
OM attributes.  Every OM attribute has zero or more values.
An attribute comprises an integer that indicates the attribute's value.
Each value is accompanied by an integer that indicates that value's syntax.
.P
.iX "OM" "attribute types"
An OM attribute type is a category into which all the values of an
OM attribute are placed on the basis of its purpose.  Some OM attributes may
either have zero, one, or multiple values.  The OM attribute type is
used as the name of the OM attribute.  
.P
.iX "OM" "syntax"
A syntax is a category into which a value is placed on the basis of
its form.  \*LOM_S_PRINTABLE_STRING\*O is an example of a syntax.
.P
.iX "object" "value"
An OM attribute value is an information item that can be viewed as a
characteristic or property of the OM object of which it is a part.
.P
OM attribute types and syntaxes have integer values and symbolic
equivalents assigned to them for ease of use by naming authorities
in the various API specifications.  The integers that are assigned to
the OM attribute type and syntax are fixed, but the attribute values may
change.  These OM attribute types and syntaxes are defined in the DCE
implementation of XDS and XOM APIs in header files that are
included with the software along with additional OM attributes specific
to the GDS implementation.
.P
.iX "object" "example of internal structure"
Figure 5-1 shows the internal structure of an OM object.
.P
.ne 5i
.FG "The Internal Structure of an OM Object"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.objattributes.pic
.P
.ne 7
For example, the tables in Figure 5-2 show the OM attributes, syntax, and
values for the OM class \*LDS_C_ENTRY_INFO_SELECTION\*O, and how the
integer values are mapped to corresponding names in the \*Lxom.h\*O and
\*Lxds.h\*O header files.  The chapters in Part 4 of this guide
contain tables for every OM class supported by the directory service.  
Refer to Chapter 11 for a complete description of 
\*LDS_C_ENTRY_INFO_SELECTION\*O and the accompanying table.
.P
\*LDS_C_ENTRY_INFO_SELECTION\*O is a subclass of \*LOM_C_OBJECT\*O.  This
information is supplied in the description of this OM class in Chapter 19.
As such, \*LDS_C_ENTRY_INFO_SELECTION\*O inherits the OM attributes
of \*LOM_C_OBJECT\*O.  The only OM attribute of \*LOM_C_OBJECT\*O 
is \*LOM_CLASS\*O.  \*LOM_CLASS\*O identifies the object's OM class, 
which in this case is \*LDS_C_ENTRY_INFO_SELECTION\*O. 
\*LDS_C_ENTRY_INFO_SELECTION\*O identifies information to be 
extracted from a directory entry and has the following OM attributes, 
in addition to those inherited from \*LOM_C_OBJECT\*O:
.ML
.LI
\*LDS_ALL_ATTRIBUTES\*O
.LI
\*LDS_ATTRIBUTES_SELECTED\*O
.LI
\*LDS_INFO_TYPE\*O
.LE
.P
As part of an XDS function call, \*LDS_ALL_ATTRIBUTES\*O specifies
to the directory service whether all the attributes of a directory entry are
relevant to the application program.  It can take the values
\*LOM_TRUE\*O or \*LOM_FALSE\*O.  These values are defined to be of
syntax \*LOM_S_BOOLEAN\*O.  The value \*LOM_TRUE\*O
indicates that information is requested on all attributes in the
directory entry.  The value \*LOM_FALSE\*O indicates that information is
only requested on those attributes that are listed in the OM attribute
\*LDS_ATTRIBUTES_SELECTED\*O.
.P
\*LDS_ATTRIBUTES_SELECTED\*O lists the types of attributes in the
entry from which information is to be extracted.  The syntax of the
value is specified as \*LOM_S_OBJECT_IDENTIFIER_STRING\*O.
.P
\*LOM_S_OBJECT_IDENTIFIER_STRING\*O contains an octet string of
integers that are BER encoded object identifiers of the types of
OM attributes in the OM attribute list.
The value of \*LDS_\%ATTRIBUTES_\%SELECTED\*O is
significant only if the value of \*LDS_\%ALL_\%ATTRIBUTES\*O
is \*LOM_FALSE\*O, as described previously.
.P
.ne 8
\*LDS_INFO_TYPE\*O identifies what information is to be extracted from
each OM attribute identified.  The syntax of the value is specified as
\*OEnum(\*LDS_Information_Type\*O).  \*LDS_INFO_TYPE\*O is an
enumerated type that has two possible values: \*LDS_TYPES_ONLY\*O and
\*LDS_\%TYPES_\%AND_\%VALUES\*O.  \*LDS_TYPES_ONLY\*O indicates that only
the attribute types in the entry are returned by the directory
service operation.  \*LDS_TYPES_AND_VALUES\*O indicates that both the
types and the values of the attributes in the directory
entry are returned.
.P
A typical directory service operation, such as a read operation
(\*Lds_read(\|)\*O), requires the \*Ventry_information_selection\*O
parameter to specify to the directory service the information to be
extracted from the directory entry.  This
\*Ventry_information_selection\*O parameter is built by the
application program as a public object (Section 5.1.4 describes
how to create a public object), and is included as a parameter to the
\*Lds_read(\|)\*O function call, as shown in the following code fragment from
\*Lexample.c\*O:
.oS
/*
 * Public Object ("Descriptor List") for
 * Entry-Information-Selection
 * parameter to ds_read().
 */
 OM_descriptor selection[] = {
 OM_OID_DESC(OM_CLASS,DS_C_ENTRY_INFO_SELECTION),
 { DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, { OM_FALSE, NULL } },
 OM_OID_DESC(DS_ATTRIBUTES_SELECTED, DS_A_PHONE_NBR),
 { DS_INFO_TYPE,OM_S_ENUMERATION,
 { DS_TYPES_AND_VALUES,NULL } },
 OM_NULL_DESCRIPTOR
 };

 CHECK_DS_CALL(ds_read(session, DS_DEFAULT_CONTEXT,
                   name, selection, &result, &invoke_id));
.oE
.P
.ne 6i
.iX "OM" "classes" "mapping class definition"
.FG "Mapping the Class Definition of DS_C_ENTRY_INFO_SELECTION"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.attrtables.pic
.H 3 "Object Identifiers"
.P
.iX "OM" "classes" "object identifier"
.iX "object" "identifier" "OM class"
.iX "OM" "attribute types"
OM classes are uniquely identifiable by means of ASN.1 object
identifiers.  OM classes have mandatory and optional OM attributes.
Each OM attribute has a type, value, and syntax.  OM objects are
instances of OM classes that are uniquely identifiable by means of
ASN.1 object identifiers.  The syntax of values defined for these OM
object classes and OM attributes are representations at a higher level
of abstraction so that implementors can provide the necessary
high-level language binding for their own implementations of the
various application interfaces, such as XDS API.
.P
The DCE implementation uses C language to define the internal
representation of OM classes and OM attributes.  These
definitions are supplied in the header files that are included as part
of the XDS and XOM API.
.P
OM classes are defined as symbolic constants that correspond to ASN.1
object identifiers.  An ASN.1 object identifier is a sequence of
integers that uniquely identifies a specific class.  OM attribute type
and syntax are defined as integer constants.  These standardized
definitions provide application programs with a uniform and stable
naming environment in which to perform directory operations.
Registration authorities are responsible for allocating the unique
object identifiers.
.P
The following code fragment from the \*Lxdsbdcp.h\*O (the basic directory
contents package) header file contains the symbolic constant
\*LOMP_O_DS_A_COUNTRY_NAME\*O:
.ps 11
.vs 13
.oS
#ifndef dsP_attributeType /* joint-iso-ccitt(2) ds(5) attributeType(4)*/
#define dsP_attributeType(X) ("\ex55\ex04" #X)
#endif

#define OMP_O_DS_A_COUNTRY_NAME              dsp_attributeType(\\x06)
.oE
.ps 12
.vs 14
.P
It resolves to \*L2.5.4.6\*O, which is the object identifier value for
the \*LCountry-Name\*O attribute type as defined in the directory standard.  The symbolic constant for the directory object class \*LCountry\*O resolves to
\*L2.5.6.2\*O, the corresponding object identifier in the directory
standard.  OM classes are defined in the header files in the same
manner.
.H 3 "C Naming Conventions"
.P
.iX "C" "naming conventions"
In the DCE implementation of XDS and XOM APIs, all object identifiers
start with the letters \*Lds\*O, \*LDS\*O, \*LMH\*O, or \*LOMP\*O.  Note
that the interface reserves \*Vall\*O identifiers starting with the
letters \*LdsP\*O and \*LomP\*O for internal use by implementations of the
interface.  It also reserves all identifiers starting with the letters
\*LdsX\*O, \*LDSX\*O, \*LomX\*O, and \*LOMX\*O for vendor-specific
extensions of the interface.  Applications programmers should not use
any identifier starting with these letters.
.P
The C identifiers for interface elements are formed by using 
the following conventions:
.P
.ML
.LI 
XDS API function names are specified entirely in lowercase letters
and are prefixed
by \*Lds_\*O (for example, \*Lds_read(\|)\*O).
.LI 
XOM API function names are specified entirely in lowercase
letters and are prefixed
by \*Lom_\*O (for example, \*Lom_get(\|)\*O).
.LI
C function parameters are derived from the parameter and result names
and are specified entirely in lowercase letters.  In addition, the names of
results have \*L_return\*O added as a suffix (for example,
\*Loperation_status_return\*O).
.LI
OM class names are specified entirely in uppercase letters and are prefixed
by \*LDS_C_\*O and \*LMH_C_\*O (for example, \*LDS_C_AVA\*O).
.LI
OM attribute names are specified entirely in uppercase letters, and are
prefixed by \*LDS_\*O and \*LMH_\*O (for example, \*LDS_RDNS\*O).
.LI
OM syntax names are specified entirely in uppercase letters and are prefixed
by \*LOM_S_\*O (for example, \*LOM_S_PRINTABLE_STRING\*O).
.LI
Directory class names are specified entirely in uppercase letters and
are prefixed by \*LDS_O\*O (for example, \*LDS_O_ORG_PERSON\*O).
.LI 
Directory attribute names are specified entirely in uppercase letters and
are prefixed by \*LDS_A\*O (for example, \*LDS_A_COUNTRY_NAME\*O).
.LI
Errors are treated as a special case.  Constants that are the possible values
of the OM attribute \*LDS_PROBLEM\*O of a subclass of the OM class
\*LDS_C_ERROR\*O are specified entirely in uppercase letters and are prefixed
by \*LDS_E_\*O (for example, \*LDS_E_BAD_CLASS\*O).
.LI
.ne 5
The constants in the Value Length and Value Number columns
of the OM class definition tables are also assigned identifiers.  Where the
upper limit in one of these columns is \*Enot\*O 1, it is given a
name that consists of the OM attribute name, prefixed by \*LDS_VL_\*O for
value length, or \*LDS_VN_\*O for value number.
.LI
The sequence of octets for each object identifier is also assigned an
identifier for internal use by certain OM macros.  These identifiers
are all uppercase letters and are prefixed by \*LOMP_O_\*O. 
.LE
.P
Tables 5-1 and 5-2 summarize the XDS and XOM naming conventions.
.P
.ne 3.5i
.TB "C Naming Conventions for XDS"
.TS
center,box,tab(@);
lB | lB
l | lB.
Item@Prefix
=
Reserved for implementors@dsP
Reserved for interface extensions@dsX
Reserved for interface extensions@DSX
XDS functions@ds_
Error problem values@DS_E_
OM class names@DS_C_, MH_C_
OM attribute names@DS_, MH_
OM value length limits@DS_VL_
OM value number limits@DS_VN_
Other constants@DS_, MH_
Attribute type@DS_A_
Object class@DS_O_
.TE
.P
.ne 3.5i
.TB "C Naming Conventions for XOM"
.TS
center,box,tab (#);
lB | lB 
l | l.
Element Type#Prefix
=
Data type#\*LOM_\*O
Data value#\*LOM_\*O
Data value (class)#\*LOM_C_\*O
Data value (syntax)#\*LOM_S_\*O
Data value component (structure member)#None
Function#\*Lom_\*O
Function parameter#None
Function result#None
Macro#\*LOM_\*O
Reserved for use by implementors#\*LOMP\*O
Reserved for use by implementors#\*LomP\*O
Reserved for proprietary extension#\*LomX\*O
Reserved for proprietary extension#\*LOMX\*O
.TE
.H 3 "Public Objects"
.P
.iX "public object"
.iX "object" "public"
The ultimate aim of an application program is access to the directory
to perform some operation on the contents of the directory.  A user
may request the telephone number or electronic mail address of a fellow
employee.  In order to access this information, the application
performs a read operation on the directory so that information is
extracted about a target object in the directory and manipulated
locally within the application.
.P
XDS functions that perform directory operations, such as
\*Lds_read(\|)\*O, require \*Epublic\*O and \*Eprivate\*O objects as input
parameters.  Typically, a public object is generated by an application
program and contains the information required to access a target
directory object.  This information includes the AVAs and RDNs that
make up a distinguished name of an entry in the directory.  However,
an application program may also generate a private object.
Private objects are
described in Section 5.1.5.
.P
.ne 4
A public object is created by using OM classes and OM attributes.  These OM
classes and OM attributes model the target object entry in the directory
and provide other information required by the directory service to access
the directory.  
.H 4 "Descriptor Lists"
.P
.iX "descriptor list"
A public object is represented by a sequence of \*LOM_descriptor\*O
data structures that is built by the application program.  A
descriptor contains the type, syntax, and value for an OM attribute in
a public object.
.P
The data structure \*LOM_descriptor\*O is defined in the \*Lxom.h\*O header
file as follows:
.oS
typedef struct OM_descriptor_struct {
        OM_type                 type;
        OM_syntax               syntax;
        union OM_value_union    value;
}OM_descriptor;
.oE
.P
Figure 5-3 shows the representation of a public object in a
descriptor list.  The first descriptor in the list indicates the object's
OM class; the last descriptor is a NULL descriptor that signals the end
of the list of OM attributes.  In between the first and the last
descriptor are the descriptors for the OM attributes of the object.
.iX "descriptor list" "representation of public object"
.iX "object" "representation of public object"
.iX "public object" "representation by using descriptor list"
.P
For example, the following represents the public object \*Lcountry\*O in
\*Lexample.c\*O:
.oS
static OM_descriptor        country[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COUNTRY_NAME),
 { DS_ATTRIBUTE_VALUES,OM_S_PRINTABLE_STRING,OM_STRING("US") },
 OM_NULL_DESCRIPTOR
 };
.oE
.P
.ne 4i
.FG "A Representation of a Public Object By Using a Descriptor List"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.descriptorlist.pic
.sp 
.P
The descriptor list is an array of data type \*LOM_descriptor\*O that
defines the OM class, OM attribute types, syntax, and values that make up a
public object.
.P
The first descriptor gives the OM class of the object.  The OM class of
the object is defined by the OM attribute type, \*LOM_CLASS\*O.  The
\*LOM_\%OID_\%DESC\*O macro initializes the syntax and value of an object
identifier, in this case to OM class \*LDS_C_AVA\*O, with the syntax of
\*LOM_\%S_\%OBJECT_\%IDENTIFIER_\%STRING\*O.  
\*LOM_\%S_\%OBJECT_\%IDENTIFIER_\%STRING\*O is an OM syntax type that is
assigned by definition in the macro to any OM attribute type and value
parameters input to it.
.P
The second descriptor defines the first OM attribute type,
\*LDS_ATTRIBUTE_TYPE\*O, which has as its value \*LDS_\%A_\%COUNTRY_\%NAME\*O
and syntax \*LOM_\%S_\%OBJECT_\%IDENTIFIER_\%STRING\*O.
.P
.ne 9
The third descriptor specifies the AVA of an object entry in the
directory.  The \*LOM_OID_DESC\*O macro is not used here because
\*LOM_OID_DESC\*O is only used to initialize values having
\*LOM_\%S_\%OBJECT_\%IDENTIFIER_\%STRING\*O syntax.  The OM attribute type is
\*LDS_ATTRIBUTE_VALUES\*O, the syntax is \*LOM_\%S_\%PRINTABLE_\%STRING\*O,
and the value is \*LUS\*O.  The \*LOM_STRING\*O macro creates a data value
for a string data type (data type \*LOM_string\*O), in this case
\*LOM_\%S_\%PRINTABLE_\%STRING\*O.  A string is specified in terms of its
length or whether or not it terminates with a NULL.  (The
\*LOM_STRING\*O macro is described in Section 5.8.2.4.)
.P
The last descriptor is a NULL descriptor that marks the end of the
public object definition.  It is defined in the \*Lxom.h\*O header file as
follows:
.oS
#define OM_NULL_DESCRIPTOR     
  { OM_NO_MORE_TYPES, OM_S_NO_MORE_SYNTAXES,
  { { 0, OM_ELEMENTS_UNSPECIFIED } } }
.oE
.P
\*LOM_NULL_DESCRIPTOR\*O is OM attribute type 
\*LOM_\%NO_\%MORE_\%TYPES\*O, syntax
\*LOM_\%S_\%NO_\%MORE_\%SYNTAXES\*O, and value 
\*LOM_\%ELEMENTS_\%UNSPECIFIED\*O.
.P
Figure 5-4 shows the composition of a descriptor list representing a public
object.
.P
.ne 4.5i
.FG "A Descriptor List for the Public Object: country"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.diromobject.pic
.H 4 "Building the Distinguished Name as a Public Object"
.P
.iX "directory" "building a distinguished name"
.iX "distinguished name" "as a public object"
.iX "distinguished name"
Recall that RDNs are built from AVAs, and a distinguished name is built
from a series of RDNs.  In a typical application program, several AVAs
are defined in descriptor lists as public objects.  These public
objects are incorporated into descriptor lists that represent
corresponding RDNs.  Finally, the RDNs are incorporated into one
descriptor list that represents the distinguished name of an object in
the directory, as shown in Figure 5-5.  This descriptor list is included
as one of the input parameters to a directory service function.
.P
.ne 4i
.FG "The Distinguished Name of ``Peter Piper'' in the DIT"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.sampletree.pic
.sp .5
.P
The following code fragment from \*Lexample.c\*O shows how a
distinguished name is built as a public object.  The public object is
the \*Vname\*O parameter for a subsequent read operation call to the
directory.  The representation of a distinguished name in the DIT is
shown in Figure 5-5.
.P
The first section of code defines the four AVAs.  These AVAs make the
assertion to the directory service that the attribute values in the
distinguished name of \*LPeter Piper\*O are valid and can therefore be
read from the directory.  The country name is \*LUS\*O, the organization
name is \*LAcme Pepper Co\*O,
the organizational unit name is \*LResearch\*O, and the
common name is \*LPeter Piper\*O.
.nL
.ps 11
.vs 13
.oS
.ne 30
/*
 * Public Object ("Descriptor List") for Name parameter to
 * ds_read().
 * Build the Distinguished-Name of Peter Piper 
 */

static OM_descriptor        country[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COUNTRY_NAME),
 { DS_ATTRIBUTE_VALUES,OM_S_PRINTABLE_STRING,OM_STRING("US") },
 OM_NULL_DESCRIPTOR
 };
static OM_descriptor        organization[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_NAME),
 { DS_ATTRIBUTE_VALUES,OM_S_TELETEX_STRING, 
	OM_STRING("Acme Pepper Co") },
 OM_NULL_DESCRIPTOR
 };
static OM_descriptor        organizational_unit[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_UNIT_NAME),
 { DS_ATTRIBUTE_VALUES,OM_S_TELETEX_STRING, OM_STRING("Research") },
 OM_NULL_DESCRIPTOR
 };
static OM_descriptor        common_name[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COMMON_NAME),
 { DS_ATTRIBUTE_VALUES,OM_S_TELETEX_STRING, OM_STRING("Peter Piper") },
 OM_NULL_DESCRIPTOR
 };
.oE
.ps 12
.vs 14
.P
The next section of code is nested one level above the previously
defined AVAs.  Each RDN has a descriptor with OM attribute type
\*LDS_AVAS\*O (indicating that it is OM attribute type \*LAVA\*O), a syntax of
\*LOM_S_OBJECT\*O, and a value of the name of the descriptor array
defined in the previous section of code for an AVA.
The \*Lrdn1\*O descriptor contains the
descriptor list for the AVA country, the \*Lrdn2\*O descriptor
contains the descriptor
list for the AVA organization, and so on.
.P
\*LOM_S_OBJECT\*O is a syntax that indicates that its value is a
subobject.  For example, the value for \*LDS_AVAS\*O is the previously
defined object \*Lcountry\*O.  In this manner, a hierarchy of linked
objects and subobjects can be constructed.
.oS
.ne 20
static OM_descriptor        rdn1[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 { DS_AVAS, OM_S_OBJECT, { 0, country } },
 OM_NULL_DESCRIPTOR
 };
static OM_descriptor        rdn2[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 { DS_AVAS, OM_S_OBJECT, { 0, organization } },
 OM_NULL_DESCRIPTOR
 };
static OM_descriptor        rdn3[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 { DS_AVAS, OM_S_OBJECT, { 0, organizational_unit } },
 OM_NULL_DESCRIPTOR
  };
static OM_descriptor        rdn4[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
 { DS_AVAS, OM_S_OBJECT, { 0, common_name } },
 OM_NULL_DESCRIPTOR
 };
.oE
.P
The next section of code contains the RDNs that make up the
distinguished name, which is stored in the array of
descriptors called \*Vname\*O.  It is made up of the OM class
\*LDS_C_DS_DN\*O (representing a distinguished name) and four RDNs of
OM attribute type \*LDS_RDNS\*O and syntax \*LOM_S_OBJECT\*O.
.oS
OM_descriptor       name[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_DN),
 { DS_RDNS, OM_S_OBJECT, { 0, rdn1 } },
 { DS_RDNS, OM_S_OBJECT, { 0, rdn2 } },
 { DS_RDNS, OM_S_OBJECT, { 0, rdn3 } },
 { DS_RDNS, OM_S_OBJECT, { 0, rdn4 } },
 OM_NULL_DESCRIPTOR
 };
.oE
In summary, the distinguished name for \*LPeter Piper\*O
is stored in the array of
descriptors called \*Vname\*O, which is composed
of three nested levels of arrays of descriptors (see Figure 5-6).
The definitions for
the AVAs are at the innermost level, the definitions for RDNs are at the
next level up, and the distinguished name is at the top level.
.P
.ne 5i
.FG "Building a Distinguished Name"
.dI ../directory/xds_gds/Pics/fig03.sybpublicobj.pic
.sp .5
.P
Figure 5-7 shows a more general view of the structure distinguished name.
.P
.ne 3.1i
.FG "A Simplified View of the Structure of a Distinguished Name"
.dI ../directory/xds_gds/Pics/fig02.structdistname.pic
.sp .5
.P
The \*Lname\*O descriptor defines a public object that is provided as
the \*Vname\*O parameter required by the XDS API read function call,
\*Lds_read(\|)\*O, as follows (XDS API function calls are described in
detail in Chapter 6):
.oS
CHECK_DS_CALL(ds_read(session, DS_DEFAULT_CONTEXT,
                   name, selection, &result, &invoke_id));
.oE
.P
The result of the \*Lds_read(\|)\*O function call is in a private
implementation-specific format; it is stored in a workspace and
pointed to by \*Lresult\*O.  The application program must use XOM function
calls (described in Section 5.7) to interpret the data and
extract the information.  This extraction process involves uncovering
the nested data structures in a series of XOM function calls.
.H 4 "Client-Generated and Service-Generated Public Objects" 
.P
.iX "public object" "client-generated"
.iX "public object" "service-generated"
There are two types of public objects: service-generated objects and
client-generated objects.
The distinguished name object described in the previous section
is a client-generated
public object because an application program (the client) created the
data structure.  As the creator of the public object, it is the
responsibility of the application program to manage the memory
resources allocated for it.
.P
Service-generated public objects are created by the XOM service.
Service-generated public objects may be generated as a result of an
XOM request.  An XOM API function, such as \*Lom_get(\|)\*O, converts a
private object into a service-generated public object.  This is
necessary because XDS may return a pointer to data in private format
that can only be interpreted by XOM functions such as \*Lom_get(\|)\*O.
.P
For example, Figure 5-8 shows how the read request described in the
previous example returns a pointer to an encoded data structure
stored in \*Lresult\*O.  This encoded data structure, referred to as a
\*Eprivate object\*O (described in the next section) is one of the
input parameters to \*Lom_get(\|)\*O.  The \*Lom_get(\|)\*O function
provides a pointer
to a public object (in this case, \*Lentry\*O) as an output parameter.
The public object is a data structure that has been interpreted by
\*Lom_get(\|)\*O and is accessible by the application program (the
client).  The information requested by the application in the read
request is contained in the output parameter \*Lentry\*O.
.P
.ne 5.75i
.FG "Client-Generated and Service-Generated Objects"
.dI ../directory/xds_gds/Pics/fig02.pubprivobj.pic
.P
The application program is responsible for managing the storage
(memory) for the service-generated public object.  This is an
important point because it requires that the application issue a
series of \*Lom_delete(\|)\*O calls to delete the service-generated public
object from memory.  Because the data structures involved with
directory service requests can be very large (often involving large
subtrees of the DIT), it is imperative that the application programmer
build into any application program the efficient management of memory
resources.
.P
.ne 15
The following code fragment from \*Lexample.h\*O demonstrates how
storage for public and private objects is released by using a series of
\*Lom_delete(\|)\*O function calls after they are no longer needed by the
application program.  The data (a list of phone numbers associated
with the name \*LPeter Piper\*O required by the application program) has
already been extracted by using a series of \*Lom_get(\|)\*O function calls,
as follows:
.oS
/*  We can now safely release all the private objects
 *  and the public objects we no longer need
 */
CHECK_OM_CALL(om_delete(session));
CHECK_OM_CALL(om_delete(result));
CHECK_OM_CALL(om_delete(entry));
CHECK_OM_CALL(om_delete(attributes));
CHECK_DS_CALL(ds_shutdown(workspace));
.oE
.H 3 "Private Objects"
.P
.iX "private object"
Private objects are created dynamically by the service interface.
In Figure 5-8, the \*Lds_read(\|)\*O function returns a pointer to the
data structure
\*Lresult\*O in the workspace.  This service-generated data structure
is a private object in a private implementation-specific format, which
requires a call to \*Lom_get(\|)\*O to interpret the data.  A private object is
one of the required input parameters to XOM API functions (such as
\*Lom_get(\|)\*O), as shown in Figure 5-8.  Private objects are always
service generated.  
.P
Table 5-3 compares private and public objects.
.iX "public object" "comparison with private objects"
.P
.ne 6i
.TB "Comparison of Private and Public Objects"
.na
.TS 
tab(@),center,box;
lB | lB
l | l.
Private@Public
=
T{
Representation is implementation specific
T}@T{
Representation is defined in the API specification
T}
_
T{
Not directly accessible by the client
T}@T{
Directly accessible by the client
T}
_
T{
Manipulated by the client by using OM functions
T}@T{
Manipulated by the client by using programming constructs
T}
_
T{
Created in storage provided by the service
T}@T{
Is a service-generated object if created
by the service

Is a client-generated object if 
created by the client in storage provided by the client
T}
_
T{
Cannot be modified by the client directly, except through the service
interface
T}@T{
If a client-generated object, can be modified directly by the client

If a service-generated object, cannot be modified directly by the
client, except through the service interface
T}
_
T{
Storage is allocated and released by the service
T}@T{
If a service-generated object,
storage is allocated and released by the service

If a client-generated object, storage is allocated and released by the
client
T}
.TE
.ad
.P
Private objects can also be used as input to XOM and XDS API functions
to improve program efficiency.  For example, the output of a
\*Lds_search(\|)\*O request can be used as input to a \*Lds_read(\|)\*O.  The
search request returns the name of each entry in the search.  If the
application program requires the address and telephone number of each
name, a \*Lds_read(\|)\*O operation can be performed on each name as a private
object.
.H 3 "Object Classes"
.P
.iX "OM" "classes"
.iX "class" "OM object"
.iX "XOM" "API" "OM class"
Objects are categorized into OM classes based on their purpose and
internal structure.  An object is an instance of its OM class.  An OM class
is characterized by OM attribute types that may appear in its instances.
An OM class is uniquely identified by an ASN.1 object identifier.  
.P
Later in this section, it will be shown how OM classes are organized
into groups of OM classes, called \*Vpackages\*O, that support some aspect of
the directory service.
.H 4 "OM Class Hierarchy and Inheritance Properties"
.P
.iX "object" "class hierarchy"
.iX "object" "OM class inheritance"
.iX "class" "OM inheritance"
.iX "class" "OM hierarchy"
.iX "OM" "classes" "inheritance"
.iX "OM" "classes" "hierarchy"
.iX "XOM" "API" "OM class inheritance"
.iX "XOM" "API" "OM class hierarchy"
OM classes are related to each other in a tree hierarchy whose root is a
special OM class called \*LOM_C_OBJECT\*O.  Each of the other OM classes is
the immediate subclass of precisely one other OM class.  This tree
structure is known as the \*EOM class hierarchy\*O.  It is important because
of the property of inheritance.  The OM class hierarchy is defined by
the XDS/XOM standards.  DCE implements this hierarchy for GDS and adds its own
set of OM classes defined in the GDS package.
.P
The OM attribute types that may exist in an instance of an OM class but not
in an instance of the OM class above it in the tree hierarchy, are said to be
\*Especific\*O to that OM class.
OM Attributes that may appear in an object are
those specific to its OM class as well as those inherited from OM classes
above it in the tree.  OM classes above an instance of an OM class in the
tree are \*Esuperclasses\*O of that OM class.
OM classes below an instance of an
OM class are \*Esubclasses\*O of that OM class.  
.P
For example, as shown in Figure 5-9, \*LDS_C_ENTRY_INFO_SELECTION\*O
inherits its OM attributes from its superclass \*LOM_C_OBJECT\*O.  The
OM attributes \*LDS_ALL_ATTRIBUTES\*O, \*LDS_ATTRIBUTES_SELECTED\*O, and
\*LDS_INFO_TYPE\*O are attributes specific to the OM class
\*LDS_C_ENTRY_INFO_SELECTION\*O.  
The \*LDS_\%C_\%ENTRY_\%INFO_\%SELECTION\*O class has no subclasses.
.P
.ne 2.5i
.FG "The OM Class DS_C_ENTRY_INFO_SELECTION"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.relatomclasses.pic
.sp .5
.P
Another important point about OM class inheritance is that an instance of
an OM class is also considered to be an instance of each of its
superclasses and may appear wherever the interface requires an
instance of any of those superclasses.  
For example, \*LDS_C_DS_DN\*O is a subclass of \*LDS_C_NAME\*O.  Everywhere
in an application program where \*LDS_C_NAME\*O is expected at the interface
(as a parameter to \*Lds_read(\|)\*O, for example), it is permitted to supply
\*LDS_C_DS_DN\*O.
.H 4 "Abstract and Concrete Classes"
.P
.iX "class" "abstract OM"
.iX "class" "concrete OM"
.iX "abstract OM class"
.iX "concrete OM class"
.iX "OM" "classes" "abstract"
.iX "OM" "classes" "concrete"
OM classes are defined as being either \*Eabstract\*O or \*Econcrete\*O.
An abstract OM class is an OM class in which instances are not permitted.  An
abstract OM class may be defined so that subclasses can share a common
set of OM attributes between them.
.P
In contrast to abstract OM classes, instances of OM concrete classes are
permitted.  However, the definition of each OM concrete class may include
the restriction that a client not be allowed to create instances of
that OM class.  For example, consider two alternative means 
of defining the OM classes used in XDS:
\*LDS_C_LIST_INFO\*O and \*LDS_C_READ_RESULT\*O.
\*LDS_C_LIST_INFO\*O and \*LDS_C_READ_RESULT\*O are subclasses of the
abstract OM class \*LDS_C_COMMON_RESULT\*O.
.P
.ne 5
Figure 5-10 shows the relationship of \*LDS_C_LIST_INFO\*O and
\*LDS_\%C_\%READ_\%RESULTS\*O when the abstract
OM class \*LDS_\%C_\%COMMON_\%RESULT\*O is defined and when it is not defined.
It demonstrates that the presence of an abstract OM class enables the
programmer to develop applications that process information more
efficiently.
.iX "abstract OM class"
.iX "concrete OM class"
.P
.ne 7.5i
.FG "Comparison of Two Classes With/Without an Abstract OM Class"
.dI ../directory/xds_gds/Pics/fig02.abstractclasses.pic
.P
The following list contains the hierarchy of concrete and abstract OM
classes in the directory service package.  Abstract OM classes are
shown in italics.
The indentation shows the class hierarchy; for example, the abstract
class
\*VOM_C_OBJECT\*O
is a superclass of the abstract class
\*VDS_C_COMMON_RESULTS\*O, which in turn is a superclass of the concrete
class \*LDS_C_COMPARE_RESULT\*O.
.P
\*VOM_C_OBJECT\*O
.ML 
.LI 
\*LDS_C_ACCESS_POINT\*O
.LI 
\*VDS_C_ADDRESS\*O
.ML
.LI 
\*LDS_C_PRESENTATION_ADDRESS\*O
.LE
.LI 
\*LDS_C_ATTRIBUTE\*O
.ML
.LI 
\*LDS_C_AVA\*O
.LI 
\*LDS_C_ENTRY_MOD\*O
.LI 
\*LDS_C_FILTER_ITEM\*O
.LE
.LI
\*LDS_C_ATTRIBUTE_ERROR\*O
.LI 
\*LDS_C_ATTRIBUTE_LIST\*O
.ML
.LI 
\*LDS_C_ENTRY_INFO\*O
.LE
.LI 
\*VDS_C_COMMON_RESULTS\*O
.ML
.LI 
\*LDS_C_COMPARE_RESULT\*O
.LI 
\*LDS_C_LIST_INFO\*O
.LI 
\*LDS_C_READ_RESULT\*O
.LI 
\*LDS_C_SEARCH_INFO\*O
.LE
.LI 
\*LDS_C_CONTEXT\*O
.LI 
\*LDS_C_CONTINUATION_REF\*O
.ML
.LI
\*LDS_C_REFERRAL\*O
.LE
.LI 
\*LDS_C_ENTRY_INFO_SELECTION\*O
.LI 
\*LDS_C_ENTRY_MOD_LIST\*O
.LI 
.ne 7
\*VDS_C_ERROR\*O
.ML
.LI
\*LDS_C_ABANDON_FAILED\*O
.LI
\*LDS_C_ATTRIBUTE_PROBLEM\*O
.LI
\*LDS_C_COMMUNICATIONS_ERROR\*O
.LI
\*LDS_C_LIBRARY_ERROR\*O
.LI
\*LDS_C_NAME_ERROR\*O
.LI
\*LDS_C_SECURITY_ERROR\*O
.LI
\*LDS_C_SERVICE_ERROR\*O
.LI
\*LDS_C_SYSTEM_ERROR\*O
.LI
\*LDS_C_UPDATE_ERROR\*O
.LE
.LI 
\*LDS_C_EXT\*O
.LI 
\*LDS_C_FILTER\*O
.LI 
\*LDS_C_LIST_INFO_ITEM\*O
.LI 
\*LDS_C_LIST_RESULT\*O
.LI 
\*VDS_C_NAME\*O
.ML
.LI 
\*LDS_C_DS_DN\*O
.LE
.LI 
\*LDS_C_OPERATION_PROGRESS\*O
.LI 
\*LDS_C_PARTIAL_OUTCOME_QUAL\*O
.LI 
\*VDS_C_RELATIVE_NAME\*O
.ML
.LI 
\*LDS_C_DS_RDN\*O
.LE
.LI 
\*LDS_C_SEARCH_RESULT\*O
.LI 
\*LDS_C_SESSION\*O
.LE 
.P
.iX "OM" "classes" "defining"
In summary, an OM class is defined with the following elements:
.ML
.LI
OM class name (indicated by an object identifier)
.LI
Identity of its immediate superclass
.LI
Definitions of the OM attribute types specific to the OM class
.LI
.ne 3
Indication whether the OM class is abstract or concrete
.LI
Constraints on the OM attributes
.LE
.P
A complete description of OM classes, OM attributes, syntaxes, and values that
are defined for XDS and XOM APIs are described in Part 4.
Tables and textual descriptions, such as the one shown in Figure 5-11
for the concrete OM class \*LDS_C_ATTRIBUTE\*O, are provided for each
OM class.
.P
.ne 6.5i
.FG "Complete Description of Concrete OM Class DS_C_ATTRIBUTE"
.dI ../directory/xds_gds/Pics/fig02.wholeomclass.pic
.sp .5
.P
.ne 5
.iX "OM" "classes" "OM attribute"
.iX "OM" "classes" "value syntax"
.iX "OM" "classes" "value length"
.iX "OM" "classes" "value number"
.iX "OM" "classes" "initial value"
The table shown in Figure 5-11
provides information under the following headings: 
.ML 
.LI
OM Attribute
.P
This is the name of each of the OM attributes. 
.LI 
Value Syntax
.P
This provides the syntaxes
of each of the OM attribute's values. 
.LI 
Value Length
.P
This describes any constraints
on the number of bits, octets, or characters in each value that is a
string. 
.LI 
Value Number
.P
This describes any constraints on the number of values.
.LI
Value Initially
.P
This is any value with which the OM attribute can be initialized.
.LE
.P
An OM class can be constrained to contain only one member of a set of
OM attributes.  In turn, OM attributes can be restricted to having no more
than a fixed number of values, either 0 (zero) or 1 as an optional
value, or exactly one mandatory value.
.P
An OM attribute's value may be also constrained to a single syntax.  That
syntax can be further restricted to a subset of defined values.  
.P
An object passed as a parameter to an XOM and XDS function call needs to
meet a minimum set of conditions, as follows:
.ML
.LI
The type of each OM attribute must be
specific to the object's OM class or one of
its superclasses.
.LI
The number of values of each OM attribute must be
within OM class limits.
.LI
The syntax of each value must be among those the OM class permits.
.LI
The number of bits, octets, or characters in each string value must
be within OM class limits.
.LE
.H 2 "Packages"
.P
.iX "package"
.iX "package" "directory service"
.iX "package" "GDS"
.iX "package" "MHS directory user"
.iX "strong authentication package"
.iX "package" "strong authentication"
A \*Epackage\*O is a collection of OM classes that are grouped together,
usually by function.  The packages themselves are
features that are negotiated with the directory service
by using the XDS function \*Lds_version(\|)\*O.  Consider what
OM classes will be required for your application programs and determine
the packages that contain these OM classes.  
.P
A package is uniquely identified by an ASN.1 object identifier.  DCE XDS
API supports the following five packages,
of which one is mandatory and four are optional:
.ML
.LI
The directory service package  (mandatory)
.LI
The basic directory contents package (optional)
.LI
The strong authentication package (optional)
.LI
The GDS package (optional)
.LI
The message handling system (MHS) directory user package (optional)
.LE
.H 3 "The Directory Service Package"
.P
The directory service package is the default package and as such does
not require negotiation.  The optional packages have
to be negotiated with the directory service by using the \*Lds_version(\|)\*O
function.
.P
The object identifiers for specific packages are defined in header
files that are part of the XDS API and XOM API.  An
object identifier consists of a string of integers.  The header files
include \*L#define\*O preprocessor statements that assign names to
these constants in order to make them more readable.  These assignments
alleviate the application programmer from the burden of maintaining
these strings of integers.
For example, the object identifiers for the directory service package
are defined in \*Lxds.h\*O.
The \*Lxds.h\*O header file
contains OM class and OM attribute names, OM object constants,
and defines prototypes
for XDS API functions, as shown in the following
code fragment from \*Lxds.h\*O:
.oS
.ne 6
/* DS package object identifier */
/* {iso(1) identifier-organization(3) icd-ecma(12)
 *  member-company(2)
 *  dec(1011) xopen(28) dsp(0) } */

#define OMP_O_DS_SERVICE_PKG   "\\x2B\\x0C\\x02\\x87\\xlC\\x00"
.oE 
.P
.iX "package" "ds_version"
.iX "package" "negotiating features"
A \*Lds_version(\|)\*O function call must be included within an
application program to negotiate the optional features (packages) with
the directory service.  The first step is to build an array of object
identifiers for the optional packages to be negotiated (the basic
directory contents package and the GDS package), as shown in the
following code fragment from the \*Lacl.h\*O header file:
.oS
DS_feature features[] = {
 { OM_STRING(OMP_O_DS_BASIC_DIR_CONTENTS_PKG), OM_TRUE },
 { OM_STRING(OMP_O_DSX_GDS_PKG), OM_TRUE },
 { 0 }
};
.oE
.P
The \*LOM_STRING\*O macro is provided for creating a data value of data type
\*LOM_string\*O for octet strings and characters.  XOM API macros are
described in Section 5.8.2.
.P
The array of object identifiers is stored in \*Lfeatures\*O, and
passed as an input parameter to \*Lds_version(\|)\*O, as shown in the
following code fragment from \*Lacl.c\*O:
.oS
/* Negotiate the use of the BDC and GDS packages. */

if (ds_version(features) != DS_SUCCESS)
   printf("ds_version() error\en");
.oE
.nL
.ne 15
.H 3 "The Basic Directory Contents Package"
.P
.iX "package" "basic directory contents"
The basic directory contents package contains the object identifier
definition of directory classes and attribute types as defined by the
X.500 standard.  These definitions allow the creation of and
maintenance of directory entries for a number of common objects so
that the representation of all such objects is the same throughout the
directory.  Also included are the definitions of the OM classes and OM
attributes required to support the directory attribute types.
Chapter 12 describes the basic directory contents package in detail.
.P
The object identifier associated with the basic directory contents
package is shown in the following code fragment from the
\*Lxdsbdcp.h\*O header file: 
.nL
.ps 11
.vs 13
.oS
/* BDC package object identifier */
/* { iso(1) identifier-organization(3) icd-ecma(12)
 *   member-company (2)
 *   dec(1011) xopen(28) bdcp(1) } */

#define OMP_DS_BASIC_DIR_CONTENTS_PKG "\ex2B\ex0C\ex02\ex87\ex73\ex1C\ex01"
.oE
.ps 12
.vs 14
.H 3 "The Strong Authentication Package"
.P
.iX "package" "strong authentication"
.iX "strong authentication package"
The strong authentication package contains the object identifier
definition of directory classes and attribute types as defined by the
X.500 standard for security purposes.  
Also included are the definitions of the OM classes and OM
attributes required to support these security attribute types.
Chapter 13 describes the strong authentication package in detail.
.P
The object identifier associated with the strong authentication package 
is shown in the following code fragment from the
\*Lxdsap.h\*O header file: 
.nL
.ps 11
.vs 13
.oS
/* SA package object identifier */
/* { iso(1) identifier-organization(3) icd-ecma(12)
 *   member-company (2)
 *   dec(1011) xopen(28) sap(2) } */

#define OMP_DS_STRONG_AUTHENT_PKG "\ex2B\ex0C\ex02\ex87\ex73\ex1C\ex02"
.oE
.ps 12
.vs 14
.H 3 "The GDS Package"
.P
.iX "package" "GDS extension"
.iX "GDS" "extension package"
The GDS package contains the
definition of a DCE extension to the XDS API.  It contains the
definitions of OM classes, OM attributes, and syntaxes to support extended
functionality specific to DCE.
Chapter 15 describes the GDS package in detail.
.P
The following code fragment from the \*Lxdsgds.h\*O header file shows
the object identifier for the GDS package:
.nL
.ps 11
.vs 13
.oS
/* GDS package object identifier */
/* { iso(1) identifier-organization(3) icd-ecma(12) member-company (2) 
/*    siemens-units(1107) sni(1) directory(3) xds-api(100) gdsp(1) } */

#define OMP_O_DSX_GDS_PKG   "\ex2B\ex0C\ex02\ex88\ex53\ex01\ex03\ex64\ex01"
.oE
.ps 12
.vs 14
.H 3 "The MHS Directory User Package"
.P
.iX "package" "MHS directory user"
.iX "MHS" "directory user package"
The MHS directory user package
contains definitions to support the use
of the directory in accordance with the standard X.400 (1988) User Agents
and Message Transfer Agents (MTAs) for name resolution, distribution
list expansion, and capability assessment.  The definitions are based on
the attribute types and syntaxes specified in X.402, Annex A.
The definitions of the OM classes and OM
attributes required to support these MHS attribute types are also included
with this package.  Chapter 14 describes the MHS directory 
user package in detail.
.P
The object identifier associated with the MHS directory user
package is shown in the following code fragment from the
\*Lxdsmdup.h\*O header file: 
.nL
.ps 11
.vs 13
.oS
/* MDU package object identifier */
/* { iso(1) identifier-organization(3) icd-ecma(12)
 *   member-company (2)
 *   dec(1011) xopen(28) mdup(3) } */

#define OMP_DS_MHS_DIR_USER_PKG "\ex2B\ex0C\ex02\ex87\ex73\ex1C\ex03"
.oE
.ps 12
.vs 14
.P
.ne 4
Part 4 of this guide describes in detail the attributes and data types 
that make up the OM and directory classes defined in the XDS API packages.
Chapter 7 examines in detail how these packages are used in developing the
sample application programs.
.H 3 "Package Closure"
.P
.iX "package" "closure"
.iX "closure" "package"
An OM class can be defined to have an attribute whose OM class is defined in
some other package.  This avoids duplication of OM classes.  This gives
rise to the concept of a package closure.  A package closure is the
set of all OM classes that need to be supported so that all possible
instances of all OM classes can be defined in the package.
.H 2 "Workspaces"
.P
.iX "workspace"
Two application-specific APIs or two different implementations of the
same service require work areas, called \*Vworkspaces\*O, to maintain
private and public (service-generated) objects.  The workspace is
required because two implementations of the same service (or different
services) can represent private objects differently.  Each one has its
own workspace.  Using the functions provided by XOM API, such as
\*Lom_get(\|)\*O and \*Lom_copy(\|)\*O, objects can be copied and moved from
one workspace to another.
.P
Recall that private objects are returned by a service to a workspace
in private implementation-specific format.
Using the OM function calls
described in Section 5.7, the data can be extracted from the
private object for further program processing.
.P
Before a request to the directory can be made by an application
program, a workspace must be created by using the appropriate XDS function.
An application creates a workspace by performing
the XDS API call \*Lds_initialize(\|)\*O.  Once the workspace is
obtained, subsequent XDS API calls, such as \*Lds_read(\|)\*O, return a
pointer to a private object in the workspace.  When program processing
is completed, the workspace is destroyed by using the \*Lds_shutdown(\|)\*O
XDS API function.  Implicit in \*Lds_shutdown(\|)\*O is a call to the
XOM API function \*Lom_delete(\|)\*O to delete each private object the
workspace contains.
.P
The programs in Chapter 7 demonstrate how
to initialize and shut down a workspace.
The XDS functions \*Lds_initialize(\|)\*O
and \*Lds_shutdown(\|)\*O are described in detail in Chapter 6.
.P
The closures of one or more packages are associated with a workspace.
A package can be associated with any number of workspaces.  An
application program must obtain a workspace that supports an OM class
before it is able to create any instances of that OM class.
For example, some of these operations in an application may require
involvement with GDS security, ACLs, or the DUA cache.  Therefore,
in addition to the basic packages provided by the directory service
APIs, the workspace would have to support the GDS
package.  The following code fragment demonstrates how an application
initializes a workspace and negotiates the packages to be associated
with that workspace:
.oS
/* Build up an array of object identifiers for the optional */
/* packages to be negotiated.                               */

DS_feature features[] = {
 { OM_STRING(OMP_O_DS_BASIC_DIR_CONTENTS_PKG), OM_TRUE },
 { OM_STRING(OMP_O_DSX_GDS_PKG), OM_TRUE },
 { 0 }
};

CHECK_DS_CALL((OM_object) !(workspace = ds_initialize()));

CHECK_DS_CALL(ds_version(bdcp_package, workspace));
.oE
.H 2 "Storage Management"
.P
.iX "storage management"
An object occupies storage.  The storage occupied by a public object
is allocated by the client, and is, therefore, directly accessible by
the client and can be released by the client.  The storage occupied by
a private object is not accessible by the client and must be managed
indirectly by using XOM function calls.  
.P
.ne 7
Objects are accessed by an application program via object handles.
Object handles are used as input parameters to interface functions by
the client and returned as output parameters by the service.  The
object handle for a public object is simply a pointer to the data
structure (an array of descriptors) containing the object OM attributes.
The object handle for a private object is a pointer to a data structure
that is in private implementation-specific format and therefore
inaccessible directly by client.
.P
The client creates a client-generated public object by using normal
programming language constructs; for example, static initialization.
The client is responsible for managing any storage involved.  The
service creates service-generated public objects and allocates the
necessary storage.  As previously mentioned, the client must destroy
service-generated public objects and release the storage by applying
the XOM function \*Lom_delete(\|)\*O to it, as shown in the following code
fragment:
.oS
/*  We can now safely release all the private objects
 *  and the public objects we no longer need
 */
CHECK_OM_CALL(om_delete(session));
CHECK_OM_CALL(om_delete(result));
CHECK_OM_CALL(om_delete(entry));
CHECK_OM_CALL(om_delete(attributes));
CHECK_DS_CALL(ds_shutdown(workspace));
.oE
.P
The service also creates private objects for which it allocates
storage that must be managed by the application.
.P
One of the input parameters to the \*Lds_read(\|)\*O function call is
\*Vname\*O.
The \*Vname\*O parameter
is a public object created by the application from a series of
nested data structures (RDNs and AVAs) to represent the distinguished
name containing \*LPeter Piper\*O.
When the application no longer needs the public
object, it issues the XDS function call \*Lds_shutdown(\|)\*O to release
the memory resources associated with the public object.
The \*Lds_read(\|)\*O call
returns the pointer to a private object, \*Lresult\*O, deposited in
the workspace by the service.
.P
.ne 11
The program goes on to use the XOM function \*Lom_get(\|)\*O with the input
parameter \*Vresult\*O as a pointer to extract attribute values from the
returned private object.
The \*Lom_get(\|)\*O call returns the pointer \*Ventry\*O as a
service-generated public object to the program so that the attribute
values specified in the call can be accessed by it.
Once the value is extracted, the application can continue processing; 
for example, printing a message to a user with some extracted 
value like a phone number or postal address.  The service-generated 
public object becomes the responsibility of the application program.  
The program goes on to release the resources allocated by the service 
by issuing a series of calls to \*Lom_delete(\|)\*O,
as shown in the following code fragment from \*Lexample.h\*O:
.oS
/*
 * extract the telephone number(s) of "name" from the result
 *
 * There are 4 stages:
 * (1) get the Entry-Information from the Read-Result.
 * (2) get the Attributes from the Entry-Information.
 * (3) get the list of phone numbers.
 * (4) scan the list and print each number.
 */

CHECK_OM_CALL(   om_get(result,
             OM_EXCLUDE_ALL_BUT_THESE_TYPES
           + OM_EXCLUDE_SUBOBJECTS,
             entry_list, OM_FALSE, 0, 0, &entry,
             &total_num));

CHECK_OM_CALL(   om_get(entry->value.object.object,
             OM_EXCLUDE_ALL_BUT_THESE_TYPES
           + OM_EXCLUDE_SUBOBJECTS,
             attributes_list, OM_FALSE, 0, 0, &attributes,
             &total_num));

CHECK_OM_CALL(   om_get(attributes->value.object.object,
             OM_EXCLUDE_ALL_BUT_THESE_TYPES
           + OM_EXCLUDE_SUBOBJECTS,
             telephone_list, OM_FALSE, 0, 0, &telephones,
             &total_num));

.ne 7
/*  We can now safely release all the private objects
 *  and the public objects we no longer need
 */
CHECK_OM_CALL(om_delete(session));
CHECK_OM_CALL(om_delete(result));
CHECK_OM_CALL(om_delete(entry));
CHECK_OM_CALL(om_delete(attributes));
.oE
.P
If the client possesses a valid handle (or pointer) for an object, it
has access to a private object.  If the client does not possess an
object handle or the handle is not a valid one, a private object is
inaccessible to the client and an error is returned to the calling
function.  In the preceding code fragment, the handles for the
objects stored in \*Ventry\*O, \*Vattributes\*O, and \*Vtelephones\*O
are the pointers
\*V&entry\*O, \*V&attributes\*O, and \*V&telephones\*O, respectively.
.H 2 "OM Syntaxes for Attribute Values"
.P
.iX "attribute" "value"
.iX "attribute" "OM syntax"
.iX "attribute" "syntax template"
.iX "syntax" "template"
An OM attribute is made up of an integer uniquely defined within a
package that indicates the OM attribute's type, an integer giving that
value's syntax, and an information item called a \*Vvalue\*O.  The
syntaxes defined by the XOM API standard are closely aligned with
ASN.1 types and type constructors.
.P
Some syntaxes are described in the standard in terms of syntax
templates.  
.P
A syntax template defines a group of related syntaxes.  The syntax templates
that are defined are as follows:
.ML
.LI 
Enum(\*L*\*O)
.LI 
Object(\*L*\*O)
.LI
String(\*L*\*O)
.LE
.nL
.ne 15
.H 3 "Enumerated Types"
.P
.iX "enumerated type"
.iX "attribute" "OM syntax" "enumerated type"
An OM attribute with syntax template Enum(\*L*\*O) is an enumerated type
(\*LOM_S_ENUMERATION\*O) and has a set of values associated with that
OM attribute.  For example, one of the OM attributes of the OM class
\*LDS_C_ENTRY_INFO_SELECTION\*O is \*LDS_INFO_TYPE\*O.
\*LDS_\%INFO_\%TYPE\*O is listed in the OM attribute table for
\*LDS_\%C_\%ENTRY_\%INFO_\%SELECTION\*O in Chapter 11
as having a value syntax of
\*OEnum(\*LDS_Information_Type\*O), as shown in Table 5-4.
\*LDS_\%INFO_\%TYPE\*O takes one of the following values:
.ML
.LI
\*LDS_TYPES_ONLY\*O
.LI
\*LDS_TYPES_AND_VALUES\*O
.LE
.P
.ne 3.0i
.TB "Description of an OM Attribute By Using Syntax Enum(*)"
.ps 11
.vs 13
.TS
tab(@),center,box;
cB s s s s
lB | lB | lB | lB | lB
lB | lB | lB | lB | lB
lB | lB | c | c | cB.
OM Attributes of a DS_C_ENTRY_INFO_SELECTION
_
@@Value@Value@Value
OM Attribute@Value Syntax@Length@Number@Initially
_
DS_ALL_@OM_S_BOOLEAN@\*(EM@1@OM_TRUE
ATTRIBUTES@
_
DS_ATTRIBUTES_@\*OString\*L(OM_S_@\*(EM@0 or more@\*O\*(EM\*L
SELECTED@OBJECT_
@IDENTIFIER_
@STRING)
_
DS_INFO_TYPE@\*OEnum(\*LDS_@\*(EM@1@DS_TYPES_
@Information_Type)@@@AND VALUES
.TE
.ps 12
.vs 14
.P
The C language representation of the syntax of the OM attribute type
\*LDS_INFO_TYPE\*O is \*LOM_S_ENUMERATION\*O as defined in the
\*Lxom.h\*O header file.  The value of the OM attribute is either
\*LDS_TYPES_ONLY\*O or \*LDS_TYPES_AND_VALUES\*O, as shown in the
following code fragment from \*Lexample.h\*O:
.oS
.ne 13
/*
 * Public Object ("Descriptor List") for
 * Entry-Information-Selection
 * parameter to ds_read().
 */
 OM_descriptor selection[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ENTRY_INFO_SELECTION),
 { DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, { OM_FALSE, NULL } },
 OM_OID_DESC(DS_ATTRIBUTES_SELECTED, DS_A_PHONE_NBR),
 { DS_INFO_TYPE,OM_S_ENUMERATION,
 { DS_TYPES_AND_VALUES,NULL } },
 OM_NULL_DESCRIPTOR
 };
.oE
.H 3 "Object Types"
.P
.iX "object" "type"
.iX "attribute" "OM syntax" "object type"
An OM attribute with syntax template \*OObject(\*L*\*O)\*O has
\*LOM_S_OBJECT\*O as syntax and a subobject as a value.  For example,
one of the OM attributes of the OM class \*LDS_C_DS_DN\*O is
\*LDS_RDNS\*O.  \*LDS_RDNS\*O is listed in the OM attribute table for
\*LDS_C_DS_DN\*O as having a value syntax of \*OObject(\*LDS_C_DS_RDN\*O),
as shown in Table 5-5.
.P
.ne 1.25i
.TB "Description of an OM Attribute By Using Syntax Object(*)"
.ps 11
.vs 13
.TS
tab(@),center,box;
cB s s s s
lB | lB | lB | lB | lB
lB | lB | lB | lB | lB
lB | lB | c | l | c.
OM Attributes of a DS_C_DS_DN
_
@@Value@Value@Value
OM Attribute@Value Syntax@Length@Number@Initially
_
DS_RDNS@\*OObject(\*LDS_C_DS_RDN)@\*(EM@0 or more@\*(EM
.TE
.ps 12
.vs 14
.P
.ne 12
The C language representation of the syntax of the OM attribute
type \*LDS_RDNS\*O is \*LOM_S_OBJECT\*O, as shown in following
code fragment from \*Lexample.h\*O:
.oS
OM_descriptor       name[] = {
 OM_OID_DESC(OM_CLASS, DS_C_DS_DN),
 { DS_RDNS, OM_S_OBJECT, { 0, rdn1 } },
 { DS_RDNS, OM_S_OBJECT, { 0, rdn2 } },
 { DS_RDNS, OM_S_OBJECT, { 0, rdn3 } },
 { DS_RDNS, OM_S_OBJECT, { 0, rdn4 } },
 OM_NULL_DESCRIPTOR
 };
.oE
.H 3 "Strings"
.P
.iX "string" "type"
.iX "attribute" "OM syntax" "string type"
An OM attribute with syntax template String(\*L*\*O) specifies the string
syntax of its value.  A string is categorized as either a \*Ebit
string\*O, an \*Eoctet string\*O, or a \*Echaracter string\*O.  The
bits of a bit string, the octets of an octet string, or the octets
of a character string constitute
the \*Eelements\*O of the string.  (Refer to Chapter 17
for a list of the syntaxes that form the string group.)
.P
The value length of a string is the number of elements in the
string.  Any constraints on the value length of a string are specified
in the appropriate OM class definitions.
.P
The elements of the string are numbered.  The position of the first
element is 0 (zero).  The positions of successive elements are successive
positive integers.
.P
For example, one of the attributes of the OM class
\*LDS_\%C_\%ENTRY_\%INFO_\%SELECTION\*O is
\*LDS_\%ATTRIBUTES_\%SELECTED\*O.  \*LDS_\%ATTRIBUTES_\%SELECTED\*O is listed
in the OM attribute table for \*LDS_\%C_\%ENTRY_\%INFO_\%SELECTION\*O as
having a value syntax of String(\*LOM_\%S_\%OBJECT_\%IDENTIFIER_\%STRING\*O),
as shown in Table 5-4.
.H 3 "Other Syntaxes"
.P
The other syntaxes are defined as follows:
.ML
.LI
\*LOM_S_BOOLEAN\*O
.P
A value of this syntax is a Boolean; that is, the value can be
\*LOM_TRUE\*O or \*LOM_FALSE\*O.
.LI
\*LOM_S_INTEGER\*O
.P
A value of this syntax is a positive or negative integer.
.LI
\*LOM_S_NULL\*O
.P
The one value of this syntax is a valueless placeholder.
.LE
.H 2 "Service Interface Data Types"
.P
.iX "service" "interface data types"
The local variables within an application program that contain the
parameters and results of XDS and XOM API function calls are declared
by using a standard set of data types.  These data types are defined by
\*Ltypedef\*O statements in the \*Lxom.h\*O header files.
Some of the more commonly
used data types are described in the following subsections.
A complete description of service interface data types is provided 
in Chapter 18 and in the \*(Dr.
.H 3 "The OM_descriptor Data Type"
.P
.iX "descriptor list" "OM_descriptor data structure"
The \*LOM_descriptor\*O data type is used to describe an OM attribute
type and value.  A data value of this type is a descriptor, which
embodies an OM attribute value.  An array of descriptors can represent
all the values of an object.  
.P
.ne 9
\*LOM_descriptor\*O is defined in the
\*Lxom.h\*O header file as follows:
.oS
.ne 7
/* Descriptor */

typedef struct OM_descriptor_struct {
        OM_type                 type;
        OM_syntax               syntax;
        union OM_value_union    value;
} OM_descriptor;
.oE
.P
\*LOM_descriptor\*O is made up of a series of nested data structures,
as shown in Figure 5-12.
.P
.ne 6i
.FG "Data Type OM_descriptor_struct"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.omdescrstruct.pic
.sp .5
.P
.ne 10
Figure 5-12 shows that \*Ltype\*O and \*Lsyntax\*O are integer
constants for an OM attribute type and syntax, as shown in the following
code fragment from \*Lexample.c\*O:
.nL
.ps 11
.vs 13
.oS
static OM_descriptor        country[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COUNTRY_NAME),
 { DS_ATTRIBUTE_VALUES,OM_S_PRINTABLE_STRING,OM_STRING("US") },
 OM_NULL_DESCRIPTOR
 };
.oE
.ps 12
.vs 14
.P
The code fragment initializes four descriptors, as shown in Figure 5-13.
The type and syntax evaluate to integers for all four descriptors. 
.iX "descriptor list" "initializing"
.iX "XOM" "API" "initializing descriptors"
.P
.ne 3.5i
.FG "Initializing Descriptors"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.typevaluedescr.pic
.sp .5
.P
The \*Lvalue\*O component is a little more complex.  Figure 5-12 shows
that \*Lvalue\*O is a union of \*LOM_value_union\*O.
\*LOM_value_union\*O has five members: \*Lstring\*O, \*Lboolean\*O,
\*Lenumeration\*O, \*Linteger\*O, and \*Lobject\*O.
The members \*Lboolean\*O,
\*Lenumeration\*O, and \*Linteger\*O have integer values.
The \*Lstring\*O member contains a string of type \*LOM_string\*O, which is
a structure composed of a length and a pointer to a string of characters.
The \*Lobject\*O member is a structure of type \*LOM_padded_object\*O that
points to another object nested below it.  Many OM attributes have other
objects as values.  These subobjects, in turn, may have other
subobjects and so on.
.P
.ne 7
For example, as shown in Figure 5-14, the OM class
\*LDS_C_READ_RESULT\*O has one OM attribute: \*LDS_ENTRY\*O.  The syntax of
\*LDS_ENTRY\*O is \*LOM_S_OBJECT\*O with a value of
\*LDS_C_ENTRY_INFO\*O, indicating that it points to the subobject
\*LDS_C_ENTRY_INFO\*O.  \*LDS_C_ENTRY_INFO\*O has the OM attribute
\*LDS_OBJECT_NAME\*O with the syntax \*LOM_S_OBJECT\*O, indicating that
it points to the subobject \*LDS_C_NAME\*O.
.iX "object" "subordinate"
.P
.FG "An Object and a Subordinate Object"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.objectomdescrtype.pic
.H 3 "Data Types for XDS API Function Calls"
.P
The following code fragment from \*Lexample.h\*O shows how the data types
are used to declare the variables that contain the output parameters from
the XDS API function calls.
.ps 11
.vs 13
.oS
int main(void)
{
  DS_status         error;      /* return value from DS functions   */
  OM_return_code    return_code;/* return value from OM functions   */
  OM_workspace      workspace;  /* workspace for objects            */
  OM_private_object session;    /* session for directory operations */
  OM_private_object result;     /* result of read operation         */
  OM_sint           invoke_id;  /* Invoke-ID of the read operation  */
.oE
.ps 12
.vs 14
.P
The code fragment shows the following:
.ML
.LI
The \*Lds_initialize(\|)\*O call returns
a variable of type \*LOM_workspace\*O that contains a handle or pointer to
a workspace.
.LI
.ne 4
The \*Lds_bind(\|)\*O call returns a pointer to a variable of type
\*LOM_private_object\*O.  The private object
contains the session information required
by all subsequent XDS API calls, except \*Lds_shutdown(\|)\*O.
.LI
.ne 2
The \*Lds_read(\|)\*O call returns a pointer to the result of a directory 
read request in a variable of type \*LOM_private_object\*O.
.LI
The error handing macros \*LCHECK_DS_CALL\*O and \*LCHECK_\%OM_\%CALL\*O,
defined in the \*Lexample.h\*O header file, use the data types
\*LDS_status\*O and \*LOM_return_code\*O, respectively, as return
values from XDS and XOM API function calls.
.LE
.H 3 "Data Types for XOM API Calls"
.P
The following code fragment from \*Lexample.h\*O shows how the data types
are used to declare the variables that contain the input and output parameters for the XOM API function calls.
.ps 11
.vs 13
.oS
/*
 * variables to extract the telephone number(s)
 */
 OM_type            entry_list[]      = { DS_ENTRY, 0 };
 OM_type            attributes_list[] = { DS_ATTRIBUTES, 0 };
 OM_type            telephone_list[]  = { DS_ATTRIBUTE_VALUES, 0 };
 OM_public_object   entry;
 OM_public_object   attributes;
 OM_public_object   telephones;
 OM_descriptor     *telephone;  /* current phone number  */
 OM_value_position  total_num;  /* number of Attribute Descriptors */
.oE
.ps 12
.vs 14
.P
The code fragment shows the following:
.ML
.LI
The series of \*Lom_get(\|)\*O calls requires a list of OM attribute types
that identifies the types of OM attributes to be included in the
operation.  The variables \*Lentry_list\*O, \*Lattribute_list\*O, and
\*Ltelephone_list\*O are declared as type \*LOM_type\*O.
.LI
.ne 3
The series of \*Lom_get(\|)\*O calls return pointers to variables of
type \*LOM_public_object\*O.  The \*Lom_get(\|)\*O call
generates public objects that are
accessible to the application program.
.LI
Where the variable \*Ltotal_num\*O is type \*LOM_value_position\*O and is
used to hold the number of OM descriptors returned by \*Lom_get(\|)\*O.
.LE
.P
Chapter 17 contains detailed descriptions
of all the data types defined by XOM API.
.H 2 "OM Function Calls"
.P
XOM API supports general-purpose OM functions defined by the X/Open
standards body that allow an application program to manipulate objects
in a workspace.  
Section 5.7.1 lists the OM function calls and gives a brief description
of each.
Section 5.7.2 illustrates the use of OM function calls, by using the
\*Lom_get(\|)\*O call as an example.
.H 3 "Summary of OM Function Calls"
.P
The following list of XOM API function calls contains a brief description
of each function.  Refer to the appropriate reference page in the \*(Dr
for a detailed description of the input and output parameters, return
codes, and usage of each function.
.iX "XOM" "API" "OM functions"
.ML
.LI
\*Lom_copy(\|)\*O
.P
Creates an independent copy of an existing private object and all of
its subobjects in a specified workspace.
.LI
\*Lom_copy_value(\|)\*O
.P
Replaces an existing OM attribute value or inserts a new value into a
target private object with a copy of an existing OM attribute value found
in a source private object.
.LI
\*Lom_create(\|)\*O
.P
Creates a private object that is an instance of the specified OM class.
.LI
\*Lom_delete(\|)\*O
.P
Deletes a private or service-generated public object.
.LI
\*Lom_get(\|)\*O
.P
Creates a new public object that is an exact, but independent,
copy of an existing private object; certain exclusions and/or syntax
conversion may be requested for the copy.
.LI
\*Lom_instance(\|)\*O 
.P
Tests to determine if an object is an instance of a
specified OM class (includes the case when the object is a subclass of
that OM class).
.LI
\*Lom_put(\|)\*O
.P
Places or replaces copies of the attribute values of the source
private or public object into the target private object.
.LI
\*Lom_read(\|)\*O
.P
Reads a segment of a string attribute from a private object.
.LI
\*Lom_remove(\|)\*O
.P
Removes and discards values of an attribute of a private object.
.LI
\*Lom_write(\|)\*O
.P
Writes a segment of a string attribute to a private object.
.LI
\*Lom_encode(\|)\*O
.P
Not supported by DCE XOM API.
.LI
\*Lom_decode(\|)\*O
.P
Not supported by DCE XOM API.
.LE
.H 3 "Using the OM Function Calls"
.P
Most application programs require the use of a series of \*Lom_get(\|)\*O
function calls to create service-generated public objects from which
the program can extract requested information.  For this reason, this
section uses the operation of \*Lom_get(\|)\*O as an example
to describe how
XOM API functions operate in general.
.P
.ne 4
The following code fragment from \*Lexample.h\*O shows how a series of
\*Lom_get(\|)\*O function calls extract a list of telephone numbers
from a workspace.  The \*Lds_read(\|)\*O function call
deposits the private object stored in
\*Lresult\*O
in the workspace and provides access to it by the pointer \*L&result\*O.
.oS
/*
 * extract the telephone number(s) of "name" from the result
 *
 * There are 4 stages:
 * (1) get the Entry-Information from the Read-Result.
 * (2) get the Attributes from the Entry-Information.
 * (3) get the list of phone numbers.
 * (4) scan the list and print each number.
 */

CHECK_OM_CALL(   om_get(result,
             OM_EXCLUDE_ALL_BUT_THESE_TYPES
           + OM_EXCLUDE_SUBOBJECTS,
             entry_list, OM_FALSE, 0, 0, &entry,
             &total_num));

CHECK_OM_CALL(   om_get(entry->value.object.object,
             OM_EXCLUDE_ALL_BUT_THESE_TYPES
           + OM_EXCLUDE_SUBOBJECTS,
             attributes_list, OM_FALSE, 0, 0, &attributes,
             &total_num));

CHECK_OM_CALL(   om_get(attributes->value.object.object,
             OM_EXCLUDE_ALL_BUT_THESE_TYPES
           + OM_EXCLUDE_SUBOBJECTS,
             telephone_list, OM_FALSE, 0, 0, &telephones,
             &total_num));

/*  We can now safely release all the private objects
 *  and the public objects we no longer need
 */
CHECK_OM_CALL(om_delete(session));
CHECK_OM_CALL(om_delete(result));
CHECK_OM_CALL(om_delete(entry));
CHECK_OM_CALL(om_delete(attributes));
CHECK_DS_CALL(ds_shutdown(workspace));

.ne 11
for (telephone = telephones;
     telephone->type != DS_ATTRIBUTE_VALUES;
     telephone++)
    {
 if (telephone->type   != DS_ATTRIBUTE_VALUES
||  (telephone->syntax & OM_S_SYNTAX) !=
     OM_S_PRINTABLE_STRING)
      {
(void) fprintf(stderr, "malformed telephone number\en");
        exit(EXIT_FAILURE);
      }

(void) printf("Telephone number: %s\en",
        telephone->value.string.elements);
      }

CHECK_OM_CALL(om_delete(telephones));
.oE
.P
The \*Lom_get(\|)\*O call
makes a copy of all or a selected set of parts of a private
object.  The copy is a service-generated public object that is accessible
to the application program.  The application program extracts the list of
telephone numbers from this copy.
.H 4 "Required Input Parameters"
.P
The \*Lom_get(\|)\*O function requires the following input parameters:
.ML
.LI
A private object
.LI
A set of exclusions
.LI
A set of OM attributes to be included in the copy
.LI
A flag to indicate whether local string processing is required
.LI
The position of the first value to be copied (the base value)
.LI
The position within each OM attribute that is
one beyond the last attribute to
be included in the copy (indicating the scope of the copy)
.LE
.P
.ne 5
The \*Lom_get(\|)\*O call returns the following output parameters:  
.ML
.LI
The public object that is a copy of the private object
.LI
The number of OM attribute descriptors returned in the public object
.LE
.P
In the code fragment from \*Lexample.h\*O, the private object
\*Lresult\*O is input to \*Lom_get(\|)\*O.
.P
The next parameter, the \*Vexclusions\*O parameter, reduces the copy to a
prescribed portion of the original.  The exclusions apply to the
OM attributes of the object, but not to those of subobjects.  The
possibilities for determining the combinations of types, values,
subobjects, and descriptors to be excluded depend on the creativity of
the programmer.  For a detailed description of all the exclusion
possibilities, refer to the \*(Dr.  The values chosen for 
the \*Lom_get(\|)\*O calls in \*Lexample.h\*O are simplified for 
clarity.  These exclusion values are as follows:
.ML
.LI
\*LOM_EXCLUDE_ALL_BUT_THESE_TYPES\*O
.LI
\*LOM_EXCLUDE_SUBOBJECTS\*O
.LE
.P
Each value indicates an exclusion, as defined by \*Lom_get(\|)\*O, and is
chosen from the set of exclusions; alternatively, the single value
\*LOM_NO_EXCLUSIONS\*O may be chosen, which selects the entire object.
Each value, except \*LOM_NO_EXCLUSIONS\*O, is represented by a
distinct bit, the presence of the value being represented as 1, and
its absence as 0 (zero).  Multiple exclusions are requested by adding or
ORing the values that indicate the individual exclusions.
.P
\*LOM_EXCLUDE_ALL_THESE_TYPES\*O indicates that the OM attributes
included are only the ones defined in the list of included types
supplied in the next parameter, \*Ventry_list\*O.
\*LOM_EXCLUDE_SUBOBJECTS\*O indicates that for each value whose syntax
is \*LOM_S_OBJECT\*O, a descriptor containing an object handle for the
original private subobject is returned, rather than a public copy of it.
This
handle makes that subobject accessible for use in subsequent function
calls.  This exclusion provides a means to examine an object one
level at a time.  The object the handle points to is
used in the next \*Lom_get(\|)\*O call to get the next level.
.P
.ne 7
The \*Ventry_list\*O parameter
is declared in \*Lexample.h\*O as data type \*LOM_type\*O
and initialized as a two-cell array with values \*LDS_ENTRY\*O and a
NULL terminator.  \*LDS_ENTRY\*O specifies the single OM attribute
type included for that \*Lom_get(\|)\*O call.  This call only limits
processing to the one directory entry; only one entry was defined
previously in the program, the distinguished name of \*LPeter Piper\*O.
The 0 (zero) marks the end of the OM attribute list.
.P
The next parameter, \*LOM_FALSE\*O, indicates that mapping to a local
string format is not required.
The next two
parameters set the initial and limiting value to 0 (zero),
meaning that no
specific values are to be excluded.
.P
The final two parameters are output parameters: \*Ventry\*O, a pointer
to a service-generated public object deposited by \*Lom_get(\|)\*O in the
workspace, and \*Vtotal_num\*O, an integer.  Both \*Ventry\*O and
\*Vtotal_num\*O are available for examination by the application
program.
.H 4 "Extracting the Data from the Read Result"
.P
The \*Ventry\*O parameter
contains the result of processing by \*Lom_get(\|)\*O of the
\*Lread\*O parameter generated by the \*Lds_read(\|)\*O operation.
A successful
call to \*Lds_read(\|)\*O returns an instance of OM class
\*LDS_C_READ_RESULT\*O in the private object \*Vresult\*O.
\*LDS_C_READ_RESULT\*O contains the information extracted from the
directory entry of the target object.  Figure 5-15 shows the relationship
of some of the superclasses, subclasses, and the OM attribute of
\*LDS_C_READ_RESULT\*O.  Consider Figure 5-15 as a partial map of the
contents of \*Lresult\*O.
.P
.ne 3.1i
.FG "The Read Result"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.readresult.pic
.sp .5
.P
The \*Lom_get(\|)\*O function call
creates a public object to make the information contained
in \*Lresult\*O available to the application program.
The \*Ventry\*O parameter is
defined as data type \*LOM_public_object\*O.  As such, it is composed
of several nested layers of subobjects that contain entry information,
OM attributes, and OM attribute values, as shown in Figure 5-16.
The series of
\*Lom_get(\|)\*O calls removes these layers of objects to extract a
list of telephone numbers.
.P
Figure 5-16 also shows that the process of exposing the subobjects
continues while the syntax of the subobjects is \*LOM_S_OBJECT\*O.
In effect, \*Lexample.h\*O is reversing the process of building up a
series of public objects as input to \*Lds_read(\|)\*O; namely,
the distinguished
name of \*LPeter Piper\*O and the descriptor list for
\*Ventry_information_selection\*O.  
.P
.ne 4.4i
.FG "Extracting Information Using om_get(\|)"
.sp .5
.dI ../directory/xds_gds/Pics/fig02.omgetresolved.pic
.sp .5
.P
The following code fragment from
\*Lexample.c\*O shows how the syntax of the variable \*Ltelephones\*O
is tested for valid syntax; in this case, \*LOM_S_PRINTABLE_STRING\*O:
.oS
for (telephone = telephones;
     telephone->type != DS_ATTRIBUTE_VALUES;
     telephone++)
    {
 if (telephone->type != DS_ATTRIBUTE_VALUES ||
     (telephone->syntax & OM_S_SYNTAX) !=
     OM_S_PRINTABLE_STRING)
      {
(void) fprintf(stderr, "malformed telephone number\en");
        exit(EXIT_FAILURE);
      }
(void) printf("Telephone number: %s\en",
        telephone->value.string.elements);
      }
.oE
.P
.ne 6
The preceding example determines whether
\*Ltelephones\*O is in a format that can be used by the
application program as string data that can be printed out, and that
the syntax is correct for a list of telephone numbers.  Note that the
program uses the constant \*LOM_S_SYNTAX\*O to mask off the top 6 bits.
These bits are special bits that are used by XOM API.  (Refer to
Chapter 18 for more information on these special bits.)
.H 4 "Return Codes"
.P
XOM API function calls return a value of type \*LOM_return_code\*O,
which indicates whether the function succeeded.  If the function is
successful, the value of \*LOM_return_code\*O is set to \*LOM_SUCCESS\*O.
If the function fails, it returns one of the values listed in Chapter
18.  The constants for \*LOM_return_code\*O are defined in the
\*Lxom.h\*O header file.
.H 2 "XOM API Header Files"
.P
.iX "XOM" "header files"
.iX "header files" "XOM API"
.iX "\*Lxom.h\*O header file"
The XOM API includes the header file \*Lxom.h\*O.
This header file is composed of declarations defining the C
workspace interface.
It supplies type definitions, symbolic constant definitions, and macro
definitions.
.H 3 "XOM Type Definitions and Symbolic Constant Definitions"
.P
The \*Lxom.h\*O header file includes \*Ltypedef\*O statements
that define the data types of all OM objects used in
the interface.  It also provides
definitions of symbolic constants used by the interface.
.P
Refer to the \*Lxom.h(4xom)\*O reference page for more information.
.H 3 "XOM API Macros"
.P
.iX "XOM" "macros"
XOM API provides several macros that are useful in defining
public objects in your application programs.   These macros are defined
in the \*Lxom.h\*O header file.
.ML
.LI
\*LOM_IMPORT\*O
.P
Makes object identifier symbolic constants available within a C source module.
.LI
\*LOM_EXPORT\*O
.P
Allocates memory and initializes object identifier symbolic constants
within a C source module.
.LI
\*LOM_OID_DESC\*O
.P
Initializes the type, syntax, and value of an OM attribute
that holds an object identifier.
.LI
\*LOM_NULL_DESCRIPTOR\*O
.P
Marks the end of a client-generated public object.
.LI
\*LOMP_LENGTH\*O
.P
Calculates the length of an object identifier.
.LI
\*LOM_STRING\*O
.P
Creates a data value of a string data type.
.LE
.H 4 "The \*LOM_EXPORT\*O and \*LOM_IMPORT\*O Macros"
.P
Most application programs find it convenient to export all the names
they use from the same C source module.  \*LOM_EXPORT\*O allocates
memory for the constants that represent an object OM class or an object
identifier, as shown in the following code fragment from 
\*Lexample.c\*O:
.oS
.ne 11
/*  Define necessary Object Identifier constants
 */
OM_EXPORT(DS_A_COMMON_NAME)
OM_EXPORT(DS_A_COUNTRY_NAME)
OM_EXPORT(DS_A_ORG_NAME)
OM_EXPORT(DS_A_ORG_UNIT_NAME)
OM_EXPORT(DS_A_PHONE_NBR)
OM_EXPORT(DS_C_AVA)
OM_EXPORT(DS_C_DS_DN)
OM_EXPORT(DS_C_DS_RDN)
OM_EXPORT(DS_C_ENTRY_INFO_SELECTION)
.oE
.P
In this code fragment, object identifier constants that represent
OM classes defined in the \*Lxds.h\*O and \*Lxdsbdcp.h\*O header
files are exported to the main program module.  The object identifier
constants are defined in \*Lxds.h\*O with the \*LOMP_O\*O prefix
followed by the variable name for the object identifier.  The constant
itself provides the hexadecimal value of the object identifier string.
.P
The \*LOM_EXPORT\*O macro takes the OM class name as input and creates
two new data structures: a character string and a structure of type
\*LOM_string\*O.  The structure of type \*LOM_string\*O contains a length and a
pointer to a string that may be used later in an application program by the
\*LOM_OID_DESC\*O macro to initialize the value of an object
identifier.
.P
\*LOM_IMPORT\*O marks the identifiers as external for the compiler.
It is used if \*LOM_EXPORT\*O is called in a different file from where
its values are referenced.  \*LOM_IMPORT\*O is not used in
\*Lexample.c\*O because \*LOM_EXPORT\*O is called in the file where
the object identifiers are referenced.
.H 4 "The \*LOM_OID_DESC\*O and \*LOMP_LENGTH\*O Macros"
.P
The \*LOM_OID_DESC\*O macro initializes the type, syntax, and value of
an OM attribute that holds an object identifier; in other words,
it initializes \*LOM_descriptor\*O.  It takes as input an OM attribute
type and the name of an object identifier.  The object identifier
should have already been exported to the program module, as shown in
the previous section.
.P
.ne 6
The output of the macro is an \*LOM_descriptor\*O composed of a type, syntax,
and value.  The type is the name of the OM class.
The syntax is \*LOM_S_OBJECT_IDENTIFIER\*O.  The value is
a two-member structure with the length of the object identifier and a
pointer to the actual object identifier string.  It is defined as a pointer
to \*Lvoid\*O so that it can be used as a generic pointer; it can point to
any data type.
.P
\*LOM_OID_DESC\*O calls \*LOMP_LENGTH\*O to calculate the length
of the object identifier string.
.P
The following code fragment from \*Lxom.h\*O shows the \*LOM_OID_DESC\*O
and \*LOMP_LENGTH\*O macros:
.oS
/* Private macro to calculate length
 * of an object identifier
 */
#define OMP_LENGTH(oid_string) (sizeof(OMP_O_##oid_string)-1)

/* Macro to initialize the syntax and value
 * of an object identifier
 */
#define OM_OID_DESC(type, oid_name)
        { (type), OM_S_OBJECT_IDENTIFIER_STRING,
         { OMP_LENGTH(oid_name) , OMP_D_##oid_name } }
.oE
.H 4 "The \*LOM_NULL_DESCRIPTOR\*O Macro"
.P
The \*LOM_NULL_DESCRIPTOR\*O macro marks the end of a client-generated
public object by setting the type, syntax, and value to
\*LOM_NO_MORE_TYPES\*O, \*LOM_S_NO_MORE_SYNTAXES\*O, and a value of
zero length and a NULL string, respectively.
.H 4 "The \*LOM_STRING\*O Macro"
.P
The \*LOM_STRING\*O macro creates a string data value.  Data strings
are of type \*LOM_string\*O, as shown from this code fragment from the
\*Lxom.h\*O header file:
.oS
.ne 9
/* String */

typedef struct {
        OM_string_length     length;
        void                 *elements;
} OM_string;

#define OM_STRING(string)       \e
         { (OM_string_length)(sizeof(string)-1), string }
.oE
.P
A string is specified in terms of its length or whether or not it
terminates with a NULL.  \*LOM_string_length\*O is the number of
octets by which the string is represented, or it is the
\*LOM_LENGTH_UNSPECIFIED\*O value if the string terminates with a
NULL.
.P
The bits of a bit string are represented as a sequence of octets.  The
first octet stores the number of unused bits in the last octet.  The
bits in the bit string, beginning with the first bit and proceeding to
the trailing bit, are placed in bits 7 to 0 of the second octet.
These are followed by bits 7 to 0 of the third octet, then by bits 7
to 0 of each octet in turn, followed by as many bits as are required
of the final octet commencing with bit 7.
.iX "-]" "XOM"
