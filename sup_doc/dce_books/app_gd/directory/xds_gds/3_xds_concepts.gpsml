...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
...\" src directory for the full copyright text.
...\" 
...\" HISTORY
...\" $Log: 3_xds_concepts.gpsml,v $
...\" Revision 1.1.13.1  1996/09/03  18:14:23  wardr
...\" 	{enh,R1.2.2}
...\" 	Update for sgml conversion
...\" 	[1996/09/03  18:13:26  wardr]
...\"
...\" Revision 1.1.11.1  1996/03/19  15:22:17  wardr
...\" 	{edit R1.2.1}
...\" 	Release Edits
...\" 	[1996/03/19  15:21:31  wardr]
...\" 
...\" Revision 1.1.9.15  1995/06/15  16:28:52  rcb
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/13  19:26:36  rcb]
...\" 
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/08  12:15:11  rcb]
...\" 
...\" Revision 1.1.9.14  1994/11/03  23:33:32  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:38:46  neilson]
...\" 
...\" 	Substituted macros for book names in cross refs.
...\" 
...\" Revision 1.1.9.13  1994/10/20  17:12:26  rnollman
...\" 	final checkin to be safe
...\" 	[1994/10/20  17:12:11  rnollman]
...\" 
...\" Revision 1.1.9.12  1994/10/19  15:54:49  rnollman
...\" 	fixed format problems
...\" 	[1994/10/19  15:54:36  rnollman]
...\" 
...\" Revision 1.1.9.11  1994/10/18  18:01:06  rnollman
...\" 	dublin edits
...\" 	[1994/10/18  18:00:51  rnollman]
...\" 
...\" Revision 1.1.9.10  1994/10/17  21:37:45  rnollman
...\" 	incorporated editorial changes from Dublin
...\" 	[1994/10/17  21:37:32  rnollman]
...\" 
...\" Revision 1.1.9.9  1994/10/14  14:27:17  rnollman
...\" 	incorporated technical changes from Dublin
...\" 	[1994/10/14  14:26:59  rnollman]
...\" 
...\" Revision 1.1.9.8  1994/08/05  14:01:14  rnollman
...\" 	completed osf edits
...\" 	[1994/08/05  13:57:59  rnollman]
...\" 
...\" Revision 1.1.9.7  1994/05/14  22:32:18  rnollman
...\" 	last submission for beta
...\" 	[1994/05/14  22:28:57  rnollman]
...\" 
...\" Revision 1.1.9.6  1994/05/12  15:17:59  rnollman
...\" 	final update for beta
...\" 	[1994/05/12  15:17:28  rnollman]
...\" 
...\" Revision 1.1.9.5  1994/03/14  22:00:29  rom
...\" 	{enh, 10129, R1.1}
...\" 	Fix pathnames of included files for new three-book organization.
...\" 	[1994/03/14  21:20:04  rom]
...\" 
...\" Revision 1.1.9.4  1994/03/14  15:18:39  rnollman
...\" 	no changes - submitting for reorg of book
...\" 	[1994/03/14  15:18:15  rnollman]
...\" 
...\" Revision 1.1.9.3  1993/11/11  21:15:46  rnollman
...\" 	updated SNI copyright
...\" 	[1993/11/11  21:15:29  rnollman]
...\" 
...\" Revision 1.1.9.2  1993/10/27  19:50:41  rnollman
...\" 	fixed Pic pathnames
...\" 	[1993/10/27  19:50:23  rnollman]
...\" 
...\" Revision 1.1.9.1  1993/10/27  18:43:23  rnollman
...\" 	replacing old version with new version from Dublin
...\" 	[1993/10/27  18:43:06  rnollman]
...\" 
...\" Revision 1.1.6.6  1993/01/28  18:41:19  cjd
...\" 	Embedded copyright notice
...\" 	[1993/01/28  18:00:48  cjd]
...\" 
...\" Revision 1.1.6.5  1993/01/18  19:09:28  steiner
...\" 	Fixed error introduced by changing GDS to GDSP (changed it back).
...\" 	[1993/01/18  19:08:30  steiner]
...\" 
...\" Revision 1.1.6.4  1993/01/08  12:31:38  marrek
...\" 	No changes from SSE Dublin.
...\" 	[1993/01/08  12:30:21  marrek]
...\" 
...\" Revision 1.1.6.3  1992/12/21  16:10:45  rnollman
...\" 	added new section on Advanced Administration Functions
...\" 	[1992/12/21  16:10:04  rnollman]
...\" 
...\" Revision 1.1.6.2  1992/11/20  16:23:02  weir
...\" 	Moved into 1.0.2doc tree
...\" 	[1992/11/20  16:18:12  weir]
...\" 
...\" Revision 1.1.4.8  1992/11/11  23:46:51  buckler
...\" 	Corrected index entries
...\" 	[1992/11/11  22:50:15  buckler]
...\" 
...\" Revision 1.1.4.7  1992/11/06  16:11:40  lmk
...\" 	Prentice-Hall index edits only
...\" 	[1992/11/06  16:04:54  lmk]
...\" 
...\" Revision 1.1.4.6  1992/10/29  17:11:17  lmk
...\" 	Prentice-Hall index entries only
...\" 	[1992/10/29  16:58:13  lmk]
...\" 
...\" Revision 1.1.4.5  1992/10/29  15:55:28  lmk
...\" 	Prentice-Hall index entries only
...\" 	[1992/10/29  15:54:16  lmk]
...\" 
...\" Revision 1.1.4.4  1992/10/27  21:12:26  lmk
...\" 	Prentice Hall edits only
...\" 	[1992/10/27  21:10:24  lmk]
...\" 
...\" Revision 1.1.4.3  1992/10/15  19:17:29  steiner
...\" 	Second P-H edit.
...\" 	[1992/10/15  19:16:54  steiner]
...\" 
...\" Revision 1.1.4.2  1992/09/21  18:56:48  steiner
...\" 	First edit pass for P-H (edits from Eddie).
...\" 	[1992/09/21  18:43:15  steiner]
...\" 
...\" Revision 1.1.2.33  1992/07/21  14:08:35  rnollman
...\" 	make corrections requested by Brian Keane
...\" 	[1992/07/21  14:00:18  rnollman]
...\" 
...\" 	rev comments
...\" 	[1992/07/09  15:23:28  rnollman]
...\" 
...\" Revision 1.1.2.32  1992/07/17  19:05:48  weir
...\" 	Fixed various typos, etc.
...\" 	[1992/07/17  18:59:01  weir]
...\" 
...\" Revision 1.1.2.31  1992/07/10  17:29:28  weir
...\" 	Fixed two index entries.
...\" 	[1992/07/10  17:28:58  weir]
...\" 
...\" Revision 1.1.2.30  1992/06/30  19:48:24  rnollman
...\" 	added new index entries
...\" 	[1992/06/30  19:47:40  rnollman]
...\" 
...\" Revision 1.1.2.29  1992/06/30  19:16:47  rnollman
...\" 	new index entries
...\" 	[1992/06/30  19:16:05  rnollman]
...\" 
...\" Revision 1.1.2.28  1992/06/30  18:51:10  rnollman
...\" 	add some index entries
...\" 	[1992/06/30  18:50:28  rnollman]
...\" 
...\" Revision 1.1.2.27  1992/06/22  20:38:34  rnollman
...\" 	rev comments
...\" 	[1992/06/22  20:37:26  rnollman]
...\" 
...\" Revision 1.1.2.26  1992/06/17  12:20:03  rnollman
...\" 	rev comments
...\" 	[1992/06/17  12:19:27  rnollman]
...\" 
...\" Revision 1.1.2.25  1992/06/17  00:14:40  rnollman
...\" 	rev comments
...\" 	[1992/06/17  00:14:03  rnollman]
...\" 
...\" Revision 1.1.2.24  1992/06/15  13:37:52  rnollman
...\" 	rev comments
...\" 	[1992/06/15  13:37:03  rnollman]
...\" 
...\" Revision 1.1.2.23  1992/06/12  19:59:07  rnollman
...\" 	review comments
...\" 	[1992/06/12  19:58:08  rnollman]
...\" 
...\" Revision 1.1.2.22  1992/06/12  19:08:47  rnollman
...\" 	*** empty log message ***
...\" 
...\" Revision 1.1.2.21  1992/06/12  17:55:01  rnollman
...\" 	rev comments
...\" 	[1992/06/12  17:54:08  rnollman]
...\" 
...\" Revision 1.1.2.20  1992/06/12  15:43:13  rnollman
...\" 	rev comments.
...\" 	[1992/06/12  15:42:02  rnollman]
...\" 
...\" Revision 1.1.2.19  1992/06/11  19:01:45  rnollman
...\" 	rev comments
...\" 	[1992/06/11  19:00:47  rnollman]
...\" 
...\" Revision 1.1.2.18  1992/06/10  20:39:21  rnollman
...\" 	rev comments
...\" 	[1992/06/10  20:38:37  rnollman]
...\" 
...\" Revision 1.1.2.17  1992/06/08  18:27:00  rnollman
...\" 	inc comments
...\" 	[1992/06/08  18:26:12  rnollman]
...\" 
...\" Revision 1.1.2.16  1992/06/08  13:15:02  rnollman
...\" 	inc rev comments
...\" 	[1992/06/08  13:12:56  rnollman]
...\" 
...\" Revision 1.1.2.15  1992/06/08  12:48:26  rnollman
...\" 	rev comments.
...\" 	[1992/06/08  12:47:41  rnollman]
...\" 
...\" Revision 1.1.2.14  1992/06/07  19:16:04  rnollman
...\" 	rev comments
...\" 	[1992/06/07  19:15:28  rnollman]
...\" 
...\" Revision 1.1.2.13  1992/06/07  17:39:15  rnollman
...\" 	inc comments
...\" 	[1992/06/07  17:38:44  rnollman]
...\" 
...\" Revision 1.1.2.12  1992/06/07  16:12:02  rnollman
...\" 	rev comments
...\" 	[1992/06/07  16:11:31  rnollman]
...\" 
...\" Revision 1.1.2.11  1992/06/07  12:41:22  rnollman
...\" 	review comments
...\" 	[1992/06/07  12:40:52  rnollman]
...\" 
...\" Revision 1.1.2.10  1992/06/06  20:07:54  rnollman
...\" 	rev comments.
...\" 	[1992/06/06  20:07:23  rnollman]
...\" 
...\" Revision 1.1.2.9  1992/06/05  21:54:18  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  21:53:22  rnollman]
...\" 
...\" Revision 1.1.2.8  1992/06/05  20:53:32  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  20:52:34  rnollman]
...\" 
...\" Revision 1.1.2.7  1992/06/05  20:17:52  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  20:16:29  rnollman]
...\" 
...\" Revision 1.1.2.6  1992/06/05  19:19:18  rnollman
...\" 	inc review comments.
...\" 	[1992/06/05  19:18:33  rnollman]
...\" 
...\" Revision 1.1.2.5  1992/06/05  00:32:34  rnollman
...\" 	inc review comments
...\" 	[1992/06/05  00:31:54  rnollman]
...\" 
...\" Revision 1.1.2.4  1992/05/13  15:10:05  rnollman
...\" 	updated object identifier constants to match standards
...\" 	[1992/05/13  15:08:53  rnollman]
...\" 
...\" Revision 1.1.2.3  1992/05/10  20:50:07  weir
...\" 	New version.
...\" 	[1992/05/10  20:49:43  weir]
...\" 
...\" Revision 1.1.2.2  1992/05/08  21:25:56  weir
...\" 	Initial check-
...\" 	[1992/05/08  21:24:08  weir]
...\" 
...\" $EndLog$
...\" 
...\" /*****************************************************************
...\" *                                                                *
...\" * COPYRIGHT   (C)  SIEMENS NIXDORF INFORMATIONSSYSTEME AG 1994   *
...\" *                  ALL RIGHTS RESERVED                           *
...\" *                                                                *
...\" *****************************************************************/
.H 1 "XDS Programming"
.P
.iX "-[" "XDS"
.iX "XDS" "API"
The XDS API defines an application programming interface to directory
services in the X/Open Common Applications Environment as defined in
the X/Open Portability Guide.  This interface is based on the 1988
CCITT X.500 Series of Recommendations and the ISO 9594 Standard.  This
joint standard is referred to from this point on simply as X.500.
.P
This chapter describes the purpose and function of XDS API functions
in a general way.  Refer to the reference pages in the
\*(Dr for complete and detailed information on specific function calls.
.P
The sections that follow describe the following types of XDS functions:
.iX "XDS" "interface management functions"
.iX "directory" "service functions"
.iX "directory" "connection management functions"
.iX "XDS" "API" "XDS interface management functions"
.ML
.LI
XDS interface management functions
.P
These functions interact with the XDS interface
.LI
Directory connection management functions
.P
These functions initiate, manage, and terminate
connections with the directory
.LI
Directory operation functions
.P
These functions perform operations on a directory  
.LE
.nS note
The DCE XDS API does not support asynchronous operations from within the
same thread.  If an application requires asynchronous XDS operations,
then it should use multiple threads to achieve this functionality.  Please
refer to Chapter 8 for information on using the XDS/XOM API in a
multithreaded application.
.P
The \*Lds_abandon(\|)\*O function is not supported in this release. 
A \*Lds_abandon(\|)\*O call returns a \*LDS_C_ABANDON_FAILED\*O 
(\*LDS_E_TOO_LATE\*O) error.  Refer to Chapter 10 for information on
abandoning directory operations.
.nE
.P
The following names refer to the complete XDS example programs, 
which can be found in Chapter 7:
.ML
.LI
\*Lacl.c\*O  (\*Lacl.h\*O)
.LI
\*Lexample.c\*O  (\*Lexample.h\*O)
.LI
\*Lteldir.c\*O
.LE
.H 2 "XDS Interface Management Functions"
.P
.iX "XDS" "management functions"
.iX "XDS" "API" "XDS interface management functions"
XDS API defines a set of functions that only interact with the XDS
interface and have no counterpart in the directory standard definition:
.ML
.LI
\*Lds_initialize(\|)\*O
.LI
\*Lds_version(\|)\*O
.LI
\*Lds_shutdown(\|)\*O
.LE
.P
These interface functions perform operations that involve the
initialization, management, and termination of sessions with the
XDS interface service.
.H 3 "The ds_initialize(\|) Function Call"
.P
Every application program must first call \*Lds_initialize(\|)\*O to establish 
a workspace where objects returned by the directory service are 
deposited.  The \*Lds_initialize(\|)\*O function
must be called before any other 
directory interface functions are called. 
.P
The \*Lds_initialize(\|)\*O call
returns a handle (or pointer) to a workspace.  The
application program performs operations on OM objects in this
workspace.  OM objects created in this workspace can be used as input
parameters to the other directory interface functions.  In addition,
objects returned by the directory service are deposited in the
workspace.
.P
Within the following code fragment from \*Lexample.c\*O, a workspace is
initialized. (The declaration of the variable \*Vworkspace\*O and the
call to \*Lds_initialize(\|)\*O are found in different sections of the
program.)
.ps 11
.vs 13
.oS
int main(void)
{
  DS_status         error;      /* return value from DS functions   */
  OM_return_code    return_code;/* return value from OM functions   */
  OM_workspace      workspace;  /* workspace for objects            */
  OM_private_object session;    /* session for directory operations */
  OM_private_object result;     /* result of read operation         */
  OM_sint           invoke_id;  /* Invoke-ID of the read operation  */
  OM_value_position total_num;  /* Number of Attribute Descriptors  */

/*
 * Perform the Directory operations:
 * (1) Initialize the directory service and get an OM workspace.
 * (2) bind a default directory session.
 * (3) read the telephone number of "name".
 * (4) terminate the directory session.
 */

  CHECK_DS_CALL((OM_object)  !(workspace=ds_initialize()));
.oE
.ps 12
.vs 14
.P
.ne 7
\*LOM_workspace\*O is a type definition
in the \*Lxom.h\*O header file defined
as a pointer to \*Lvoid\*O.  A void pointer is a generic pointer that may
point to any data type.  The variable \*Vworkspace\*O is declared as
data type \*LOM_workspace\*O.  The return value is assigned to the
variable \*Vworkspace\*O and the \*LCHECK_DS_CALL\*O macro determines
if the call is successful.  \*LCHECK_DS_CALL\*O is an error handling
macro that is defined in \*Lexample.h\*O.
.P
The \*Lds_initialize(\|)\*O call
returns a handle to a workspace in which OM
objects can be created and manipulated.  Only objects created in this
workspace can be used as parameters to other directory interface
functions.
The \*Lds_initialize(\|)\*O call returns NULL if it fails.
.H 3 "The ds_version(\|) Function Call"
.P
The \*Lds_version(\|)\*O call
negotiates features of the directory interface.  These
features are collected into packages that define the scope of the
service.  Packages define such things as object identifiers for
directory and OM classes and OM attributes, enumerated types, structures,
and OM object constants.
.P
XDS API defines the following packages in separate header files as
part of the XDS API software product:
.iX "XDS" "API" "MHS directory user package"
.iX "package" "directory service"
.iX "package" "basic directory contents"
.iX "package" "GDS"
.iX "package" "MHS directory user"
.ML
.LI
Directory service package
.P
The directory service package contains the OM classes and OM attributes
used to interact with the directory service.  This package is
contained in the \*Lxds.h\*O header file.
.LI
Basic directory contents package
.P
The basic directory contents package
contains OM classes and OM attributes
that represent values of selected attributes and selected objects
defined in the X.500 standard.  This package is contained in the
\*Lxdsbdcp.h\*O header file.
.LI
Strong authentication package
.P
The strong authentication package contains OM classes and OM attributes
that represent values of security attributes and objects defined in the
X.500 standard.  This package is contained in the \*Lxdssap.h\*O header file.
.LI
.ne 4
GDS package
.P
The GDS package
contains the OM classes and OM attributes that
are required for GDS.
This package is contained in the \*Lxdsgds.h\*O header file.
.LI
MHS directory user package
.P
The MHS (message handling system) directory user
package contains the OM classes and OM attributes
that are required for electronic mail support.
This package is contained in the
\*Lxdsmdup.h\*O header file.
.LE
.P
The application program, which is the client, uses \*Lds_version(\|)\*O to
negotiate the scope of the services the directory service
will provide to the
client.  A \*Lds_version(\|)\*O function call includes a list of features
(or packages) that the client wants to include as part of the
interface.  The features are object identifiers that represent
packages supported by the DCE XDS API.  The service returns a list of
Boolean values to indicate whether or not
the package was successfully negotiated.
.P
These features are assigned to the workspace that an application
program initialized (as described in Section 6.1.1).  In
addition, an application program must include the header files for the
appropriate packages as part of the source code.
.P
It is not necessary to negotiate the directory service package.  It it
a mandatory requirement for XDS API, and as such it is included by default.
The other packages listed previously
are optional and require negotiation by using
\*Lds_version(\|)\*O.
.P
The following code fragment from \*Lacl.h\*O shows how an application
builds up an array of object identifiers for the optional packages to be
negotiated: the basic directory contents package and the
GDS package.
.P
.oS
static DS_feature features[] = {
    { OM_STRING(OMP_O_DS_BASIC_DIR_CONTENTS_PKG), OM_TRUE },
    { OM_STRING(OMP_O_DSX_GDS_PKG), OM_TRUE },
    {0}
};
.oE
.P
The \*LOM_STRING\*O
macro is provided for creating a data value of data type
\*LOM_string\*O for octets strings and characters.  The array of object
identifiers is stored in \*Vfeatures\*O, the input parameter to
\*Lds_version(\|)\*O, as shown in the following code fragment from
\*Lacl.c\*O:
.oS
.ne 4
/* Negotiate the use of the BDCP and GDS packages.    */

if (ds_version(features,workspace) != DS_SUCCESS)
    printf("ds_version() error\en");
.oE
.H 3 "The ds_shutdown(\|) Function Call"
.P
The \*Lds_shutdown(\|)\*O call deletes the workspace established by
\*Lds_initialize(\|)\*O and enables the directory service to release
resources.  No other directory functions that
reference that workspace may be called after this function.
.P
The following code fragment from \*Lacl.c\*O demonstrates how the
application closes the directory workspace by performing a
\*Lds_shutdown(\|)\*O call.
.P
.oS
/* Close the directory workspace.                     */

if (ds_shutdown (workspace) != DS_SUCCESS)
   printf ("ds_shutdown() error \en");
.oE
.H 2 "Directory Connection Management Functions"
.P
.iX "directory" "connection management functions"
.iX "XDS" "API" "directory connection management functions"
The following subsections
describe the XDS functions that initiate, manage, and
terminate connections with the directory service.
.H 3 "A Directory Session"
.P
.iX "session" "directory"
.iX "directory" "session"
A directory session identifies the DSA to which
a directory operation is sent.  It also defines the characteristics of
a session, such as the distinguished name of the requestor.
.P
.ne 5
.iX "session" "directory"
An application program can request a session with specific OM attributes
tailored for the program's requirements.  The application passes an
instance of OM class \*LDC_C_SESSION\*O with the
appropriate OM attributes, or it uses the
default parameters by passing the constant \*LDS_DEFAULT_SESSION\*O as a
parameter to the \*Lds_bind(\|)\*O function call.
.H 3 "The ds_bind(\|) Function Call"
.P
The \*Lds_bind(\|)\*O call establishes a session with the directory.
The \*Lds_bind(\|)\*O call
corresponds to the \*LDirectoryBind\*O function in the Abstract Service
defined in the X.500 standard.
.P
When a \*Lds_bind(\|)\*O call
completes successfully, the directory returns a pointer to an OM
private object of OM class \*LDC_C_SESSION\*O.  This parameter is then passed
as the first parameter to most interface function calls until a
\*Lds_unbind(\|)\*O is called to terminate the directory session.  
.P
.iX "session" "multiple concurrent"
XDS API supports multiple concurrent sessions so that an application can interact with the directory service by using several identities, and
interact directly and concurrently with different parts of the
directory service.
.P
The following code fragment from \*Lexample.c\*O shows how an application
binds to the GDS server (without credentials) by using the default session:
.nL
.ps 11
.oS
CHECK_DS_CALL(ds_bind(DS_DEFAULT_SESSION, workspace, &session));
.oE
.ps 12
.P
If a user wants to do an authenticated bind and/or
wants to specify the directory identifier, an instance of OM class
\*LDSX_C_GDS_SESSION\*O from the GDS package is required.
\*LDSX_C_GDS_SESSION\*O identifies a particular link from an application
to a DSA.  Since \*LDSX_\%C_\%GDS_\%SESSION\*O is a subclass of the standard
OM class for a session, \*LDS_\%C_\%SESSION\*O, it may be passed as a
parameter
to an XDS API function, such as \*Lds_bind(\|)\*O, wherever a standard session
is expected.
.P
.iX "authenticated bind"
.iX "bind" "authenticated"
The following code fragment from \*Lacl.c\*O shows how an application
performs an authenticated bind to the GDS:
.nL
.ps 11
.vs 13
.oS
.ne 28
/*
 * Create a default session object.
 */
if ((rc = om_create(DSX_C_GDS_SESSION,OM_TRUE,workspace,&session))
        != OM_SUCCESS)
    printf("om_create() error %d\en", rc);


/*
 * Alter the default session object to include the following
 * credentials:
 *  requestor:  /C=de/O=sni/OU=ap/CN=norbert
 *  password:   "secret"
 *  authentication mechanism: simple
 */
if ((rc = om_put(session, OM_REPLACE_ALL, credentials, 0 ,0, 0))
        != OM_SUCCESS)
    printf("om_put() error %d\en", rc);


/*
 * Bind with credentials to the default GDS server.
 * The returned session object is stored in the private object
 * variable bound_session and is used for all further XDS
 * function calls.
 */
if (ds_bind(session, workspace, &bound_session) != DS_SUCCESS)
    printf("ds_bind() error\en");
.oE
.ps 12
.vs 14
.P
.iX "bind" "credentials"
.iX "XDS" "API" "bind credentials"
The program creates a default session object by using the XOM API function
\*Lom_create(\|)\*O and alters the default session object by using
\*Lom_put(\|)\*O.
The bind credentials are initialized in the following code fragment from
the \*Lexample.h\*O header file included in the main program module:
.oS
.ne 10
/* The following descriptor list specifies
 * the bind credentials
 */

static OM_descriptor credentials[] = {
 {DS_REQUESTOR, OM_S_OBJECT, {0, dn_norbert} },
 {DSX_PASSWORD, OM_S_OCTET_STRING, OM_STRING("secret")},
 {DSX_AUTH_MECHANISM, OM_S_ENUMERATION, {DSX_SIMPLE,0}},
 OM_NULL_DESCRIPTOR
};
.oE
.P
.ne 4
The \*Vcredentials\*O parameter is provided as an input parameter to the
\*Lom_put(\|)\*O function call to modify the existing session object in
the directory service.  A private object is returned to the workspace by
\*Lom_put(\|)\*O that is used for all subsequent directory calls.
.H 3 "The ds_unbind(\|) Function Call"
.P
The \*Lds_unbind(\|)\*O call
terminates a directory session and makes the \*Vsession\*O
parameter unavailable for use with other interface functions.
However, the unbound session can be modified by OM functions and used
again as a parameter to \*Lds_bind(\|)\*O.  When the \*Vsession\*O parameter is no
longer needed, it should be deleted by using OM functions such as
\*Lom_delete(\|)\*O.
.P
The following code fragment from \*Lexample.c\*O shows how the application
closes the connection to the GDS server by using \*Lds_unbind(\|)\*O:
.P
.oS
/* Close the connection to the GDS server.  */

if (ds_unbind(bound_session) != DS_SUCCESS)
    printf("ds_unbind() error\en");
.oE
.P
The \*Lds_unbind(\|)\*O call
corresponds to the \*LDirectoryUnbind\*O function in the
Abstract Service defined in the X.500 standard.
.H 3 "Automatic Connection Management"
.P
.iX "automatic connection management"
.iX "directory" "automatic connection management"
The XDS implementation does not support automatic connection
management.  A DSA connection is established when \*Lds_bind(\|)\*O is
called and released when \*Lds_unbind(\|)\*O is called.
.H 2 "XDS Interface Class Definitions"
.P
.iX "XDS" "interface class definitions" 
.iX "XDS" "definitions" 
The XDS interface class definitions are described in detail in Chapter 11.
The OM attribute types,
syntax, and values and inheritance properties are described for each OM class.  
.P
A good way to begin to understand how the OM class hierarchy is structured and
the relationship between OM classes and OM attributes to the service provided by
the directory service package is to look up one of the OM classes listed
in Chapter 11.
.H 3 "Example: The DS_C_FILTER Class"
.P
For example, \*LDS_C_FILTER\*O inherits the OM attributes from its superclass
\*LOM_C_OBJECT\*O, as do all OM classes.  \*LOM_C_OBJECT\*O,
as defined in Chapter 19,
has one OM attribute, \*LOM_CLASS\*O, which has the value of an
object identifier string that identifies the numeric representation of
the object's OM class.  \*LDS_C_FILTER\*O, on the other hand, has several
OM attributes.
.P
The purpose of \*LDS_C_FILTER\*O is to select or reject an object on the
basis of information in its directory entry.  It has the following
OM attributes:
.ML
.LI
\*LDS_FILTER_ITEMS\*O
.LI
\*LDS_FILTERS\*O
.LI
\*LDS_FILTER_TYPE\*O
.LE
.P 
.ne 9
Two of these OM attributes, \*LDS_FILTER_ITEMS\*O and \*LDS_FILTERS\*O,
have values that are OM object classes themselves.
The value of the
OM attribute \*LDS_FILTER_ITEMS\*O is \*LDS_C_FILTER_ITEM\*O, which is
an OM class.
\*LDS_C_FILTER_ITEM\*O is a component of a filter and defines the
nature of the filter.
The value of the OM attribute \*LDS_FILTERS\*O is
\*LDS_C_FILTER\*O, an OM class.
Thus, \*LDS_FILTERS\*O defines a collection of filters.  The
OM attribute \*LDS_FILTER_TYPE\*O has a value that is an enumerated type,
which takes one of the values \*LDS_AND\*O, \*LDS_OR\*O, or
\*LDS_NOT\*O.
.P
Refer to Figure 6-3 for a description of the relationship of \*LDS_C_FILTER\*O to its superclass \*LOM_C_OBJECT\*O and its attributes.
.H 3 "The DS_C_CONTEXT Parameter"
.iX "context"
.iX "directory" "context"
The OM class \*LDS_C_CONTEXT\*O is the second parameter to every directory
service request.  \*LDS_C_CONTEXT\*O defines the characteristics of the
directory service interaction that are specific to a particular directory
service
operation.  These characteristics are divided into three categories of
OM attributes: common parameters, service controls, and local controls.
.P
.iX "context" "common parameters"
Common parameters affect the processing of each directory service operation.
.P
.iX "context" "service controls" 
Service controls indicate how the directory service should handle
requests.  Included in this category are decisions about whether
or not chaining is permitted, the priority of requests, the scope of
referral (to DSAs within a country or within a DMD), and the maximum number of objects about which a function should return information.
.P
.iX "context" "local controls" 
Local controls include asynchronous support and automatic continuation;
XDS does not currently support asynchronous operations from within the
same thread.  Applications requiring asynchronous use of the XDS/XOM API
should use threads as defined in Chapter 8.
.H 2 "Directory Class Definitions"
.P
.iX "directory" "class definitions"
The X.500 standards define a number of attribute types and classes.
These definitions allow the creation and maintenance of directory
entries for a number of common objects so that the representation of
all such objects is the same throughout the directory.  The basic
directory contents package contains OM classes and OM attributes that
model the X.500 attribute types and classes.
.P
The X.500 object classes and attributes are defined in the following documents
published by CCITT.  These are the objects and the associated
attributes that will be the targets of directory service operations in your
application programs:
.iX "directory" "selected attribute types"
.iX "directory" "selected object classes"
.iX "object" "selected attribute types"
.iX "object" "selected classes"
.ML
.LI
\*EThe Directory: Selected Attributes Types (Recommendation X.520)\*O
.LI
\*EThe Directory: Selected Object Classes (Recommendation X.521)\*O
.LE
.P
Table 6-1 describes the OM classes, OM attributes, and their object
identifiers that model the X.500 objects and attributes.
(See Chapter 12 for more tables with the same type of information.)
.P
.TB "Representation of Values for Selected Attribute Types"
.ps 11
.vs 13
.TS 
center,box,tab(#);
lB | lB | lB | lB | lB
lB | lB | lB | lB | lB
l1B | l1 | c1 | c1 | c1.
##Value#Multi-#Matching
Attribute Type#OM Value Syntax#Length#valued#Rules
_
DS_A_ALIASED_#Object\*L(DS_C_NAME)\*O#\*(EM#no#E
OBJECT_NAME
_
DS_A_BUSINESS_#String\*L(OM_S_\*O
CATEGORY#\*LTELETEX_STRING)\*O#1-128#yes#E, S
_
DS_A_COMMON_NAME#String\*L(OM_S_\*O
#\*LTELETEX_STRING)\*O#1-64#yes#E, S
_
DS_A_COUNTRY_NAME#String\*L(OM_S_\*O
#\*LPRINTABLE_STRING)\*O\s-2\u1\d\s+2#2#no#E
_
DS_A_DESCRIPTION#String\*L(OM_S_\*O
#\*LTELETEX_STRING)\*O#1-1024#yes#E, S
.TE
.ps 12
.vs 14
.VL .2i
.LI "\s-11\d\s+1"
As permitted by ISO 3166.
.LE
.sp .5
.P
.ne 3
.iX "directory" "service package"
The tables in Chapter 12
contain similar categories of information as do similar tables for the
attributes defined in the directory service package.  These information
categories include the following:
.iX "OM" "value syntax"
.iX "attribute" "OM syntax" "value"
.iX "attribute" "value length"
.iX "attribute" "multi-valued"
.iX "attribute" "matching rules"
.ML
.LI
OM Value Syntax
.LI
Value Length
.LI
Multivalued
.LI
Matching Rules
.LE
.P
The OM Value Syntax column describes the structure of the values of an OM
attribute.  The Value Length column gives the range of lengths
permitted for the
string types.  The Multivalued column indicates whether
the attribute can have multiple values.
.P
The CCITT standards define matching rules that are used for
determining whether two
values are equal, for ordering two values, or for identifying one value as 
a substring of another in directory service operations. 
These are indicated in the Matching Rules column.
.P
The GDS administrator maintains the directory service and determines the
structure of the DIT as defined by the GDS schema.  The GDS standard
(or default) schema is based on the recommendations in the CCITT
documents mentioned previously.
.P
Recall that the structure rule table (SRT) of the GDS schema defines
the structure of the DIT, the object class table (OCT) defines class
inheritance properties, and the attribute table (AT) defines the
mandatory and optional attributes for each class.  You will find it
useful to familiarize yourself with the existing schema when
developing an application program that will access the directory.
This is because the public objects that your programs will create
(by using OM classes and OM attributes) are modeled after objects and
attributes in the directory.
.H 2 "The GDS Package" 
.P
.iX "GDS" "package"
.iX "XDS" "API" "GDS package"
.iX "package" "GDS"
The GDS software provides functional extensions to the standard in the
following areas:
.ML
.LI
Authentication
.LI
Access Control
.LI
DUA Cache
.LE
.H 3 "Authentication"
.iX "authentication"
.iX "directory" "authentication"
An instance of OM class \*LDSX_C_GDS_SESSION\*O identifies a
particular link from an application program to a DSA.  This
additional OM class is necessary if the user either wants to specify use of an
authentication mechanism (for example, a password), or wants to specify a
directory identifier.
.H 3 "Access Control" 
.iX "access control"
.iX "directory" "access control"
In addition to authentication (for example, by means of name and
password), access protection is required for each object at the
attribute level.  A telephone number, for example, is an attribute
that in general everybody is allowed to read.  However, an attribute
value such as a userpassword normally has restricted access.  In
addition, even for attributes that everyone is allowed to read, it may
only be acceptable for a small number of people to have authorization
to change the values.
.P
Because there can be a multitude of different attributes in the DIT, it is
too expensive to define a protection mechanism for each individual
attribute type.  The directory attribute \*LDSX_A_ACL\*O is present for
each entry in the DIT.  Its syntax is Object(\*LDSX_C_GDS_ACL\*O),
referencing the GDS class \*LDSX_C_GDS_ACL\*O.  These OM classes
and attributes have been added to the directory service to specify the
category of access to the individual attributes that are granted to
users.  There are three categories of access: public, standard, and
sensitive.
.P
\*LDSX_C_GDS_ACL\*O has five OM attributes that define the read and modify
access rights for each of these categories (read access is granted to
all users; modify access implicitly grants read access):
.P
.ML
.LI
\*LDSX_MODIFY_PUBLIC\*O
.P
Specifies the user, or group of users, that can modify attributes
classified as public attributes
.LI
\*LDSX_READ_STANDARD\*O
.P
Specifies the user, or group of users, that can read attributes
classified as standard attributes
.LI
.ne 4
\*LDSX_MODIFY_STANDARD\*O
.P
Specifies the user, or group of users, that can modify attributes
classified as standard attributes
.LI
\*LDSX_READ_SENSITIVE\*O
.P
Specifies the user, or group of users, that can read attributes
classified as sensitive attributes
.LI
\*LDSX_MODIFY_SENSITIVE\*O
.P
Specifies the user, or group of users, that can modify attributes
classified as sensitive attributes
.LE
.P
The ACL of the default schema has no access rights when GDS is configured.
Every user, including the anonymous user, has read and modify access to
all attributes in the schema.
.P
A master entry can be created only by the user who has write access to the
naming attribute of the parent node.
Thus, the user can create all attributes
of the entry.
Using the ACL class, the user can establish which objects can be
accessed.  If the user does not enter an ACL attribute when creating an
entry, GDS automatically uses the ACL attribute of the parent node
for the new entry.
.P
A master entry can only be deleted by users who have write access to the
naming attribute of the entry to be deleted.
.P
A shadow entry created by means of shadow handling 
(refer to the \*(Ax) has the same ACL attribute
as the corresponding master entry.  
This entry can therefore only be modified and
deleted by the user who can also modify and delete the master entry.  
.nL
.ne 12
.H 3 "DUA Cache"
.P
.iX "DUA" "cache"
To further optimize access times, frequently requested information is
automatically loaded to a section of memory in the client computer,
the DUA cache, and can be overwritten again if it is not used within a
certain interval of time.  The cache may be periodically updated.  The
GDS administration program specifies the period.  It can also specify that certain data
is never written to the cache, or that certain data that is
transferred must under no circumstances be deleted, unless it is deleted
by the user.  Because the DUA cache is not subject to any access control, GDS
ensures that only the information that everybody is allowed to read is
stored.
.P
.iX "GDS" "extension package"
The GDS package includes the OM class \*LDSX_C_GDS_CONTEXT\*O to
support additional service controls for caching.  \*LDSX_C_GDS_CONTEXT\*O is
a subclass of \*LDS_C_CONTEXT\*O.  As such, it inherits all the standard
X.500 attributes associated with \*LDS_C_CONTEXT\*O, in addition to its own
OM attributes related to caching.  Refer to Chapter 4
for more information on how to manage the DUA cache by using XDS.
.H 3 "Advanced Administration Operations"
.P
GDS makes use of three operational attributes:
.ML
.LI
\*LDSX_A_MASTER_KNOWLEDGE\*O
.P
Contains the distinguished name of the DSA that holds the master copy of a specific entry
.LI
\*LDSX_A_ACL\*O 
.P
Used for GDS access control
.LI
\*LDS_A_USER_PASSWORD\*O attribute of a \*LDS_O_DSA\*O object class 
.P
Used by the GDS shadowing mechanism.
.LE
.P
.ne 7
The \*LDSX_A_MASTER_KNOWLEDGE\*O and \*LDSX_A_ACL\*O attributes are
present in every GDS entry.  When an application requests all
attributes, it may prevent any of these three attributes from being
returned by setting the \*LDSX_PREFER_ADM_FUNCS\*O service control (OM
class \*LDSX_\%C_\%GDS_\%CONTEXT\*O) to \*LOM_FALSE\*O.  Certain GDS
applications, such as GDS administration, may need these
attributes.  They can achieve this by setting this service control to
\*LOM_TRUE\*O.
.H 2 "Directory Operation Functions"
.P
.iX "directory" "operation functions"
.iX "Abstract Service Definition"
The X.500 standard defines the operations provided by the directory in a
document called the \*EAbstract Service Definition\*O.  DCE implements this
standard with XDS API functions calls.  The XDS API functions allow an
application program to interact with the directory service.  The standard
divides these interactions into three general categories: read,
search, and modify. 
.P
The XDS API functions correspond to the Abstract Service functions defined
in the X.500 standard, as shown in Table 6-2.
.P
.ne 2.2i
.TB "Mapping of XDS API Functions to the Abstract Services"
.TS 
center,box,tab(#);
lB | lB
lB | lB.
XDS Function Call#Abstract Service Equivalent
=
ds_read(\|)#Read
ds_compare(\|)#Compare
ds_list(\|)#List
ds_search(\|)#Search
ds_add_entry(\|)#AddEntry
ds_remove_entry(\|)#RemoveEntry
ds_modify_entry(\|)#ModifyEntry
ds_modify_rdn(\|)\#ModifyRDN
.TE
.H 2 "Directory Read Operations" 
.P
.iX "directory" "read operations"
.iX "XDS" "directory read operations"
Read functions retrieve information from specific named entries in the
directory where names are mapped to attributes.  This is analogous to
looking up some information about a name in the ``White Pages'' phone
directory.
.P
XDS API implements the following read functions:
.ML
.LI
\*Lds_read(\|)\*O
.P
The requestor supplies a distinguished name and one or more attribute types.
The value(s) of requested attributes or just the attribute type(s) is
returned by the DSA.
.LI
\*Lds_compare(\|)\*O
.P
The requestor gives a distinguished name and an Attribute Value
Assertion (AVA).  If the AVA is TRUE for the named entry, a value of
TRUE is returned by the DSA.
.LE
.P
For example, a typical read operation could request the telephone
number of a particular employee.  A read request would submit the
distinguished name of the employee with an indication to return its
telephone number: \*L/C=us/O=sni/OU=sales/CN=John Smith\*O.
.H 3 "Reading an Entry from the Directory"
.P
.iX "directory" "reading an entry"
.iX "object" "entries"
The following sections describe a typical read operation by using the
\*Lds_read(\|)\*O function call.  They include a description of tasks
directly related to the read operation.  They do not include
service-related tasks such as initializing the interface, allocating an
OM workspace, and binding to the directory.  These tasks are described
in Section 6.1.
The following sections also do not describe the process of
extracting information from the workspace by using XOM functions.
Refer to Chapter 5
for a description of how to use XOM functions to access
the workspace.
.P
.ne 8
A typical read operation involves the following steps:
.AL
.LI
Define the necessary object identifier constants for the OM classes and 
OM attributes that will define public objects for input to
\*Lds_read(\|)\*O, by using the \*LOM_EXPORT\*O macro.
.LI
Declare the variables that will contain the output from the XDS 
functions to be used in the application.
.LI
Build public objects (descriptor lists) for the \*Vname\*O parameter to
\*Lds_read(\|)\*O.
.LI
Create a descriptor list for the \*Vselection\*O parameter
to \*Lds_read(\|)\*O that selects the type and scope of information in your
request.
.LI
Perform the read operation.
.LE
.P
These steps are demonstrated in the following code fragments from
\*Lexample.c\*O (refer to Chapter 7 for a complete
program listing).  The program reads the telephone numbers of a given
target entry.
.H 3 "Step 1: Export Object Identifiers for Required Directory Classes and Attributes"
.P
.iX "XOM" "API" "macros"
Most application programs find it convenient to export all the names
they use from the same C source module.  In the following code
fragment from \*Lexample.c\*O, the \*LOM_EXPORT\*O macro allocates
memory for the constants that represent the OM object classes and
directory attributes required for the read operation:
.P
.oS
/*  Define necessary Object Identifier constants
 */
OM_EXPORT(DS_A_COMMON_NAME)
OM_EXPORT(DS_A_COUNTRY_NAME)
OM_EXPORT(DS_A_ORG_NAME)
OM_EXPORT(DS_A_ORG_UNIT_NAME)
OM_EXPORT(DS_A_PHONE_NBR)
OM_EXPORT(DS_C_AVA)
OM_EXPORT(DS_C_DS_DN)
OM_EXPORT(DS_C_DS_RDN)
OM_EXPORT(DS_C_ENTRY_INFO_SELECTION)
.oE
.P
.ne 4
The \*LOM_EXPORT\*O macro performs the following steps:
.AL
.LI
It defines a character array called \*LOMP_D_\*O concatenated with the
\*Vclass_name\*O input parameter.
.LI
It initializes this array to the value of a character string called
\*LOMP_O_\*O concatenated with the \*Vclass_name\*O input parameter.
This value has already been defined in a header file.
.LI
It defines an \*LOM_string\*O data structure as the \*Vclass_name\*O
input parameter.
.LI
It initializes the \*LOM_string\*O data structure's first component to
the length of the array initialized in Step 2 and initializes the
second component to a pointer to the value of the array initialized
in Step 2.
.LE
.H 3 "Step 2: Declare Local Variables"
.P
The local variables \*Vsession\*O, \*Vresult\*O, and \*Vinvoke_id\*O are
defined in the following code fragment from \*Lexample.c\*O:
.nL
.ps 11
.vs 13
.oS
int main(void)
{
  DS_status         error;      /* return value from DS functions  */
  OM_return_code    return_code;/* return value from OM functions  */
  OM_workspace      workspace;  /* workspace for objects           */
  OM_private_object session;    /* session for directory operations*/
  OM_private_object result;     /* result of read operation        */
  OM_sint           invoke_id;  /* Invoke-ID of the read operation */
  OM_value_position total_num;  /* Number of Attribute Descriptors */
.oE
.ps 12
.vs 14
.P
These data types are defined in a \*Ltypedef\*O statement in the \*Lxom.h\*O
header file.  The \*Vsession\*O and \*Vresult\*O variables
are defined as data type
\*LOM_private_object\*O because they are returned by \*Lds_bind(\|)\*O and
\*Lds_read(\|)\*O, respectively, to the workspace as private objects.
Since asynchronous operations (within the same thread)
are not supported, the \*Vinvoke_id\*O
functionality is redundant.  The \*Vinvoke_id\*O parameter must be
supplied to the XDS functions as described in the \*(Dr,
but its return value should be ignored.
.P
.ne 6
Values in \*Verror\*O and \*Vreturn_code\*O are returned by XOM and XDS
functions to indicate whether a call was successful.  The \*Vworkspace\*O variable
is defined as \*LOM_workspace\*O and is used when establishing an OM
workspace.  The \*Vtotal_num\*O variable is defined as
\*LOM_value_position\*O to
indicate the number of attribute descriptors returned in the public
object by \*Lom_get(\|)\*O, based on the inclusion and exclusion parameters
specified.
.H 3 "Step 3: Build Public Objects"
.P
.iX "public object" "creating"
A \*Lds_read(\|)\*O function call can take a public object as an input
parameter.  A public object is generated by an application program
and contains the information required to access a target directory
object.  This information includes the AVAs and RDNs that make up a
distinguished name of an entry in the directory.
.P
A public object is created by using OM classes and OM attributes.  These OM
classes and OM attributes model the target object entry in the directory
and provide other information required by the directory service to access
the directory.  In this case, the target object entry in the directory
is the entry for \*LPeter Piper\*O.
.P
Chapter 5 describes how
to create the required public objects for the \*Lds_read(\|)\*O function
call by using macros and data structures defined in the XDS and XOM API
header files.
.P
The purpose of building the public objects for AVAs and RDNs is to
provide the public objects that represent a distinguished
name.  The distinguished name public object is stored in the array of
descriptors called \*Vname\*O and provided as an input parameter to
the \*Lds_read(\|)\*O function call.
.H 3 "Step 4: Create an Entry-Information-Selection Parameter"
.P
The distinguished name for \*LPeter Piper\*O is an entry in the directory that
the application is designed to access.  The \*Vselection\*O parameter
of the \*Lds_read(\|)\*O function call
tailors its results to obtain just part
of the required entry.  Information on all attributes, no attributes,
or a specific group of attributes can be chosen.  Attribute types are
always returned, but the attribute values need not be.
.P
The value of the parameter is a public object (descriptor list) that is an
instance of OM class \*LDS_C_ENTRY_INFO_SELECTION\*O, as shown in the
following code fragment from \*Lexample.c\*O:
.P
.oS
/*
 * Public Object ("Descriptor List") for
 * Entry-Information-Selection
 * parameter to ds_read().
 */
 OM_descriptor selection[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ENTRY_INFO_SELECTION),
 { DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, { OM_FALSE, NULL } },
 OM_OID_DESC(DS_ATTRIBUTES_SELECTED, DS_A_PHONE_NBR),
 { DS_INFO_TYPE,OM_S_ENUMERATION,
 { DS_TYPES_AND_VALUES,NULL } },
 OM_NULL_DESCRIPTOR
 };
.oE
.P
\*LDS_C_ENTRY_INFO_SELECTION\*O is a subclass of
\*LOM_C_OBJECT\*O. (This information is supplied in the description of
this class in Chapter 11.)
As such,
\*LDS_C_ENTRY_INFO_SELECTION\*O inherits the OM attributes of
\*LOM_C_OBJECT\*O.  The only OM attribute of \*LOM_C_OBJECT\*O is
\*LOM_CLASS\*O.  \*LOM_CLASS\*O identifies an object's class, which in
this case is \*LDS_C_ENTRY_INFO_SELECTION\*O.
\*LDS_\%C_\%ENTRY_\%INFO_\%SELECTION\*O identifies information to be
extracted from a directory entry and has the following OM attributes:
.ML
.LI
\*LOM_C_CLASS\*O (inherited from \*LOM_C_OBJECT\*O)
.LI
\*LDS_ALL_ATTRIBUTES\*O
.LI
\*LDS_ATTRIBUTES_SELECTED\*O
.LI
\*LDS_INFO_TYPE\*O
.LE
.P
As part of a \*Lds_read(\|)\*O or \*Lds_search(\|)\*O function call,
\*LDS_\%ALL_\%ATTRIBUTES\*O specifies to the directory service which
attributes of a directory entry are relevant to the application
program.  It can take the values \*LOM_\%TRUE\*O or \*LOM_FALSE\*O.
These values are defined to be of syntax \*LOM_S_BOOLEAN\*O.  The
value \*LOM_TRUE\*O indicates that information is requested on all
attributes in the directory entry.  The value \*LOM_\%FALSE\*O, used in
the preceding sample code fragment, indicates that information is only
requested on those attributes that are listed in the OM attribute
\*LDS_\%ATTRIBUTES_\%SELECTED\*O.
.P
\*LDS_ATTRIBUTES_SELECTED\*O lists the types of attributes in the
entry from which information is to be extracted.  The syntax of the
value is specified as \*LOM_S_OBJECT_IDENTIFIER_STRING\*O.
.P
\*LOM_S_OBJECT_IDENTIFIER_STRING\*O contains an octet string of
BER-encoded integers, which are decimal representations of object
identifiers of the types of attributes in the attribute list.  In the
preceding code fragment, the string value is the attribute name
\*LDS_A_PHONE_NBR\*O because the purpose of the read call is to
read a list of telephone numbers from the directory.
.P
\*LDS_INFO_TYPE\*O identifies what information is to be
extracted from each attribute identified.  The syntax of the value is
specified as \*OEnum(\*LDS_Information_Type\*O).  \*LDS_INFO_TYPE\*O is an
enumerated type that has two possible values: \*LDS_TYPES_ONLY\*O and
\*LDS_TYPES_AND_VALUES\*O.  \*LDS_TYPES_ONLY\*O indicates that only
the attribute types of the selected attributes in the entry are
returned by the directory service operation.
\*LDS_TYPES_AND_VALUES\*O indicates that both the attribute types and
the attribute values of the selected attributes in the entry are
returned.  The code fragment from \*Lexample.c\*O shown previously defines
the value of \*LDS_INFO_TYPE\*O as \*LDS_\%TYPES_\%AND_\%VALUES\*O
because the program wants to get the actual telephone numbers.
.nL
.ne 30
.H 3 "Step 5: Perform the Read Operation"
.P
.iX "XDS" "API" "performing a read operation"
The following code fragment from \*Lexample.c\*O shows the
\*Lds_read(\|)\*O function call and the XDS calls that precede it:
.P
.oS
/*
 * Perform the Directory operations:
 * (1) Initialize the directory service
 *     and get an OM workspace.
 * (2) bind a default directory session.
 * (3) read the telephone number of "name".
 * (4) terminate the directory session.
 */

CHECK_DS_CALL((OM_object) !(workspace = ds_initialize()));

CHECK_DS_CALL(ds_version(bdcp_package, workspace));

CHECK_DS_CALL(ds_bind(DS_DEFAULT_SESSION, workspace,
                &session));

CHECK_DS_CALL(ds_read (session, DS_DEFAULT_CONTEXT,
                   name, selection, &result, &invoke_id));
.oE
.P
\*LCHECK_DS_CALL\*O is an error-checking macro defined in the
\*Lexample.h\*O header file that is included by \*Lexample.c\*O.  The
\*Lds_read(\|)\*O call returns a return code of type \*LDS_status\*O to
indicate whether or not the read operation completed successfully.
If the call
was successful, \*Lds_read(\|)\*O returns the value \*LDS_SUCCESS\*O.  If
the call fails, it returns an error code.
(Refer to Chapter 11 for a comprehensive list of error codes.)
\*LCHECK_DS_CALL\*O interprets this return value and returns
successfully to the program or branches to an error-handling routine.
.P
.ne 6
The \*Vsession\*O input parameter is a private object generated by
\*Lds_bind(\|)\*O prior to the \*Lds_read(\|)\*O call, as shown in the
preceding code fragment.  \*LDS_\%DEFAULT_\%CONTEXT\*O describes the
characteristics of a directory service interaction.  Most XDS API function
calls require these two input parameters because they define the
operating parameters of a session with a GDS server.
(Sessions are described in Section 6.2.1; contexts are described in 
Section 6.3.2.)
.P
.ne 4
The result of a directory service request is returned in a private object (in
this case, \*Vresult\*O) that is appropriate to the type of operation.
The result of the operation is returned in a single OM object.  The
components of the result are represented by OM attributes in the
operations result object:
.ML
.LI
\*LDS_C_COMPARE_RESULT\*O
.P
Returned by \*Lds_compare(\|)\*O
.LI
\*LDS_C_LIST_RESULT\*O
.P
Returned by \*Lds_list(\|)\*O
.LI
\*LDS_C_READ_RESULT\*O
.P
Returned by \*Lds_read(\|)\*O
.LI
\*LDS_C_SEARCH_RESULT\*O
.P
Returned by \*Lds_search(\|)\*O
.LE
.P
The OM class returned by \*Lds_read(\|)\*O is \*LDS_C_READ_RESULT\*O.
The OM class returned by the 
\*Lds_compare(\|)\*O call is \*LDS_C_COMPARE_RESULT\*O, and so on.
(Refer to the reference pages in the
\*(Dr for a description of the OM classes
associated with a particular function call; refer to Chapter 11 
for full descriptions of the OM attributes, syntaxes, and
values associated with these OM classes.)
.P
The superclasses, subclasses, and OM attributes for
\*LDS_\%C_\%READ_\%RESULT\*O are shown in Figure 6-1.
.iX "read result"
.P
.ne 5i
.FG "Output from ds_read(\|): DS_C_READ_RESULT"
.sp .5
.dI ../directory/xds_gds/Pics/fig03.read.pic
.sp .5
.P
The \*Vresult\*O value is returned to the workspace in private
implementation-specific format.  As such, it cannot be read directly
by an application program, but it requires a series of \*Lom_get(\|)\*O
function calls to extract the requested information from it.  The
following code fragment from \*Lexample.c\*O shows how a series of
\*Lom_get(\|)\*O calls extracts the list of telephone numbers associated
with the distinguished name for \*LPeter Piper\*O.
Chapter 5 describes this extraction process in detail.
.oS
.ne 27
/*
 * extract the telephone number(s) of "name" from the result
 *
 * There are 4 stages:
 * (1) get the Entry-Information from the Read-Result.
 * (2) get the Attributes from the Entry-Information.
 * (3) get the list of phone numbers.
 * (4) scan the list and print each number.
 */

CHECK_OM_CALL(   om_get(\|)(result,
             OM_EXCLUDE_ALL_BUT_THESE_TYPES
           + OM_EXCLUDE_SUBOBJECTS,
             entry_list, OM_FALSE, 0, 0, &entry,
             &total_num));

CHECK_OM_CALL(   om_get(\|)(entry->value.object.object,
             OM_EXCLUDE_ALL_BUT_THESE_TYPES
           + OM_EXCLUDE_SUBOBJECTS,
             attributes_list, OM_FALSE, 0, 0, &attributes,
             &total_num));

CHECK_OM_CALL(   om_get(\|)(attributes->value.object.object,
             OM_EXCLUDE_ALL_BUT_THESE_TYPES
           + OM_EXCLUDE_SUBOBJECTS,
             telephone_list, OM_FALSE, 0, 0, &telephones,
             &total_num));
.oE
.H 2 "Directory Search Operations"
.P
.iX "directory" "search operations"
Search functions can be used to browse through the Directory
Information Tree (DIT).  For example, a search request could supply the
distinguished name of an entry and request a list of the distinguished
names of the children of that entry.
.P
.ne 6
XDS API implements the following search operations:
.ML
.LI
\*Lds_list(\|)\*O
.P
The requestor supplies a distinguished name.  The
directory service returns a list of the immediate subordinates of the named
entry.  
.LI
.iX "filter"
.iX "-]" "XDS"
.iX "directory" "search criteria"
.iX "directory" "filter"
\*Lds_search(\|)\*O
.P
The requestor supplies a search criterion known
as a \*Efilter\*O.  The user names a subtree of the DIT, specifies some
target attribute types, and formulates an expression by combining a
number of attributes by using logical AND, OR, or NOT operators.
The directory service returns information from all of the entries within the
specified portion of the DIT that matches the filter.  Section 6.8.6
includes a description of how filters are used in \*Lacl.c\*O.
.LE
.H 3 "Searching the Directory"
.P
.iX "directory" "search operation"
This section describes a typical search operation by using the \*Lds_search(\|)\*O
function call.   It only includes the tasks directly related to the search
operation and does not include tasks related to the XDS interface or other
directory operations.
.P
A typical search operation involves the following steps:
.AL
.LI
Define the necessary object identifier constants for the OM classes and 
OM attributes that will define public objects for input to
\*Lds_search(\|)\*O by using
the \*LOM_EXPORT\*O macro.
.LI
Declare the variables that will contain the output from the XDS 
functions that will be used in the application.
.LI
Build public objects (descriptor lists) for the \*Vname\*O parameter to 
\*Lds_search(\|)\*O.
.LI
Specify the portion of the DIT to be searched.
.LI
Create a descriptor list for the \*Vfilter\*O parameter to
\*Lds_search(\|)\*O 
that designates which entries are to be eliminated from the search.
.LI
.ne 4
Create a descriptor list for the \*Vselection\*O parameter
to \*Lds_search(\|)\*O that selects the type and scope of information in your
request.
.LI
Perform the search operation.
.LE
.P
These steps are demonstrated in the following code fragments from
\*Lacl.h\*O.  The program includes a search operation.  In order to
perform the operation, the program assumes the directory contains the
subtree shown in Figure 6-2.
.P
.ne 6.5i
.FG "Subtree for the acl.h Sample Program"
.sp .5
.dI ../directory/xds_gds/Pics/fig04.entries.pic
.H 3 "Step 1: Export Object Identifiers"
.P
.iX "XOM" "API" "macros"
Most application programs find it convenient to export all the names
they use from the same C source module.  In the following \*Lacl.c\*O 
fragment, the \*LOM_EXPORT\*O macro allocates memory for
the constants that represent the object OM classes and OM attributes required
for the search operation:
.oS
/* The application must export the object identifiers it  */
/* requires.                                              */

OM_EXPORT (DS_C_AVA)
OM_EXPORT (DS_C_DS_RDN)
OM_EXPORT (DS_C_DS_DN)
OM_EXPORT (DS_C_ENTRY_INFO_SELECTION)
OM_EXPORT (DS_C_ATTRIBUTE)
OM_EXPORT (DS_C_ATTRIBUTE_LIST)
OM_EXPORT (DS_C_FILTER)
OM_EXPORT (DS_C_FILTER_ITEM)
OM_EXPORT (DSX_C_GDS_SESSION)
OM_EXPORT (DSX_C_GDS_CONTEXT)
OM_EXPORT (DSX_C_GDS_ACL)
OM_EXPORT (DSX_C_GDS_ACL_ITEM)

OM_EXPORT (DS_A_COUNTRY_NAME)
OM_EXPORT (DS_A_ORG_NAME)
OM_EXPORT (DS_A_ORG_UNIT_NAME)
OM_EXPORT (DS_A_COMMON_NAME)
OM_EXPORT (DS_A_LOCALITY_NAME)
OM_EXPORT (DS_A_OBJECT_CLASS)
OM_EXPORT (DS_A_USER_PASSWORD)
OM_EXPORT (DS_A_PHONE_NBR)
OM_EXPORT (DS_A_SURNAME)
OM_EXPORT (DS_A_ACL)
OM_EXPORT (DS_TYPELESS_RDN)

OM_EXPORT (DS_O_TOP)
OM_EXPORT (DS_O_COUNTRY)
OM_EXPORT (DS_O_ORG)
OM_EXPORT (DS_O_ORG_UNIT)
OM_EXPORT (DS_O_PERSON)
OM_EXPORT (DS_O_ORG__PERSON)
.oE
.P
.ne 4
The \*LOM_EXPORT\*O macro takes the OM class name as input and creates
two new data structures: a character string and structure of type
\*LOM_string\*O.  The structure of type \*LOM_string\*O contains a
length and a pointer that are used in Step 3 to initialize the value
of the object identifier.
.H 3 "Step 2: Declare Local Variables"
.P
The local variables are defined in the following code fragment from
\*Lacl.c\*O:
.nL
.ps 11
.vs 13
.oS
OM_workspace       workspace;     /* workspace for objects           */
OM_private_object  session;       /* Session object.                 */
OM_private_object  bound_session; /* Holds the Session object which  */
                                  /* is returned by ds_bind()        */
OM_public_object   context;       /* Context object.                 */
OM_private_object  result;        /* Holds the search result object. */
OM_sint            invoke_id;     /* Integer for the invoke id       */
                                  /* returned by ds_search().        */
                                  /* (this parameter must be present */
                                  /* even though it is ignored).     */
OM_type            sinfo_list[] = { DS_SEARCH_INFO, 0 };
OM_type            entry_list[] = { DS_ENTRIES, 0 };
                                  /* Lists of types to be extracted  */
OM_public_object   sinfo;         /* Search-Info object from result. */
OM_public_object   entry;         /* Entry object from search info.  */
OM_value_position  total_num;     /* Number of descriptors returned. */
OM_return_code     rc;            /* XOM function return code.       */
register int       i;
char               user_name[MAX_DN_LEN];
                                  /* Holds requestor's name.         */
char               entry_string[MAX_DN_LEN + 7] = "[?r??] ";
                                  /* Holds entry details.            */
.oE
.ps 12
.vs 14
.P
.ne 5
These data types are defined in a \*Ltypedef\*O statement in the \*Lxom.h\*O
header file.  Since asynchronous operations (within the same thread)
are not supported, the
\*Vinvoke_id\*O functionality is redundant.  The \*Vinvoke_id\*O
parameter must be supplied to the XDS functions as described in the
\*(Dr, but its return value should be ignored.
.H 3 "Step 3: Build Public Objects for the name Parameter to ds_search(\|)"
.P
.iX "public object" "building for \*Lds_search(\|)\*O"
The public objects required by the search operation are defined in the
\*Lacl.h\*O header file.  The \*Vname\*O input parameter in the
\*Lds_search(\|)\*O function call in \*Lacl.c\*O is the representation of
the distinguished name for the root of the DIT.  The following code
fragment from \*Lacl.c\*O shows how the descriptor list for the
distinguished name is initialized:
.oS
static OM_descriptor dn_root[] = {
 OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
 OM_NULL_DESCRIPTOR
};
.oE
.H 3 "Step 4: Specify the Portion of the DIT To Be Searched"
.P
.iX "directory" "search"
The \*Lds_search(\|)\*O call requires the \*Vsubset\*O input parameter.
The \*Vsubset\*O parameter
specifies the portion of the DIT to be searched.  It takes the value of
one of the following symbolic constants, which are
defined in the \*Lxds.h\*O header
file:
.ML
.LI
\*LDS_BASE_OBJECT\*O, meaning to
search just the given object entry
.LI
\*LDS_ONE_LEVEL\*O, meaning to
search just the immediate subordinates of the given object
entry
.LI
\*LDS_WHOLE_SUBTREE\*O,
meaning to search the given object and all its subordinates
.LE
.P
The \*Vsubset\*O parameter in \*Lacl.c\*O takes the value
\*LDS_WHOLE_SUBTREE\*O.
.H 3 "Step 5: Create a Filter"
.P
.iX "filter"
The \*Vfilter\*O input parameter is used to eliminate entries from the
search that are not wanted.  Information is only returned on entries
that satisfy the filter.
.P 
\*LDS_C_FILTER\*O inherits the attributes from its superclass
\*LOM_\%C_\%OBJECT\*O, as do all OM classes.  \*LOM_C_OBJECT\*O (as defined
in Chapter 11) has one OM attribute, \*LOM_CLASS\*O, which has the
value of an object identifier string that identifies the numeric
representation of the object's OM class.  \*LDS_C_FILTER\*O, on the other
hand, has several OM attributes.
.P
The purpose of the \*LDS_C_FILTER\*O is to select or reject an object
on the basis of information in its directory entry.  It has the
following OM attributes:
.ML
.LI
\*LDS_FILTER_ITEMS\*O
.LI
\*LDS_FILTERS\*O
.LI
\*LDS_FILTER_TYPE\*O
.LE
.P 
Two of these OM attributes, \*LDS_FILTER_ITEMS\*O and \*LDS_FILTERS\*O,
have values that are OM object classes themselves.  The OM attribute
\*LDS_FILTER_ITEMS\*O has the value OM class \*LDS_C_FILTER_ITEM\*O.
\*LDS_C_FILTER_ITEM\*O is a component of a filter and defines the
nature of the filter.  The OM attribute \*LDS_FILTERS\*O has the value of
OM class \*LDS_C_FILTER\*O and thus defines a collection of filters.
The OM attribute \*LDS_FILTER_TYPE\*O has a value that is an enumerated
type, which takes one of the values \*LDS_AND\*O, \*LDS_OR\*O, or
\*LDS_NOT\*O.
.P
Figure 6-3 shows the relationship of \*LDS_C_FILTER\*O to its superclass
\*LOM_C_OBJECT\*O, and its attibutes.
.P
.ne 4.5i
.FG "OM Class DS_C_FILTER"
.sp .5
.dI ../directory/xds_gds/Pics/fig03.ds_filter.pic
.sp
.P
The \*LDS_NO_FILTER\*O constant can be used as the value of this
parameter if all entries are searched and no entries are eliminated.
This corresponds to a filter with a \*LDS_FILTER_TYPE\*O value of
\*LDS_AND\*O, and no values of the \*LDS_FILTERS\*O or
\*LDS_FILTER_ITEMS\*O OM attributes.
.P
The following code fragment from \*Lacl.c\*O shows the descriptor list
for a filter:
.oS
.ne 17
/* The following descriptor list specifies a filter */
/* for search :                                     */
/*     (Present: objectClass)                       */

static OM_descriptor filter_item[] = {
 OM_OID_DESC(OM_CLASS, DS_C_FILTER_ITEM),
 {DS_FILTER_ITEM_TYPE, OM_S_ENUMERATION, {DS_PRESENT, 0} },
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
 OM_NULL_DESCRIPTOR
};

static OM_descriptor filter[] = {
 OM_OID_DESC(OM_CLASS, DS_C_FILTER),
 {DS_FILTER_ITEMS, OM_S_OBJECT, {0, filter_item} },
 {DS_FILTER_TYPE, OM_S_ENUMERATION, {DS_AND, 0} },
 OM_NULL_DESCRIPTOR
};
.oE
.H 3 "Step 6: Create an Entry-Information-Selection Parameter"
.P
The \*Lds_search(\|)\*O call requires a \*Vselection\*O input
parameter to specify
what information from the entry is requested.  The \*Vselection\*O
parameter of the \*Lds_search(\|)\*O call in \*Lacl.h\*O requests
information on all attributes, as shown in the following code fragment:
.P
.oS
static OM_descriptor selection_acl[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ENTRY_INFO_SELECTION),
 {DS_ALL_ATTRIBUTES, OM_S_BOOLEAN, OM_FALSE},
 OM_OID_DESC(DS_ATTRIBUTES_SELECTED, DSX_A_ACL),
 {DS_INFO_TYPE, OM_S_ENUMERATION, DS_TYPES_AND_VALUES},
 OM_NULL_DESCRIPTOR
};
.oE
.P
As shown in the code fragment, \*LDS_ALL_ATTRIBUTES\*O has a
syntax of \*LOM_S_BOOLEAN\*O that is set to \*LOM_FALSE\*O, indicating
that only the requested attributes of the entry are to be returned.
The ACL attribute's types and values are selected.  \*LDS_INFO_TYPE\*O
has a value of \*LDS_TYPES_AND_VALUES\*O, indicating that both the
attribute types and the attribute values in the entry are returned.
.H 3 "Step 7: Perform the Search Operation"
.P
The following code fragment from \*Lacl.c\*O shows the \*Lds_search(\|)\*O
function call:
.nL
.ps 11
.vs 13
.oS
/* Search the whole subtree below root.                          
 * The filter selects entries with an object-class attribute.    
 * The selection extracts the ACL attribute from each
 * selected entry.
 * The results are returned in the private object "result".     
 *
 * NOTE: Since every entry contains an object-class attribute the
 *       filter performs no function other than to demonstrate how
 *       filters may be used.
 *
 */
if(ds_search(bound_session, context, dn_root, DS_WHOLE_SUBTREE,
  filter, OM_FALSE, selection_acl, &result, &invoke_id) != DS_SUCCESS)
	printf("ds_search() error\en");
.oE
.ps 12
.vs 14
.P
The \*Lds_search(\|)\*O call returns the value \*LDS_SUCCESS\*O if the call
successfully completes.  Otherwise, it returns an error code.  (Refer to
Chapter 11 for a comprehensive list of error codes.)
.P
The result of the search operation is returned to the workspace in a
private object \*Lresult\*O.  This result is returned as a single OM
object.  The components of the result are represented by OM attributes
in the operation's \*Lresult\*O object.
.P
The OM class returned by \*Lds_search(\|)\*O is \*LDS_C_SEARCH_RESULT\*O.
The superclasses, subclasses, and attributes for
\*LDS_C_SEARCH_RESULT\*O are shown in Figure 6-4.
.P
.ne 6i
.FG "OM Class DS_C_SEARCH_RESULT"
.sp .5
.dI ../directory/xds_gds/Pics/fig03.search.pic
.sp .5
.P
.ne 4
The \*Lresult\*O object
is returned to the workspace in a private implementation-specific
format.  As such, it cannot be read directly by an application program, but
requires a series of \*Lom_get(\|)\*O function calls to extract the requested
information.
.H 2 "Directory Modify Operations"
.P
.iX "directory" "modify operations"
Modify functions alter information in the directory.  For example, if
an employee of an organizational unit transfers to a new
organizational unit, a typical modify request would modify the \*LOU\*O
name attribute in the person's directory entry to reflect the change.
.P
XDS API implements the following modify functions:
.ML
.LI
\*Lds_modify_entry(\|)\*O
.P
The requestor gives a distinguished name and
a list of modifications to the named entry.  The directory service
carries out
the specified changes if the user requesting the change has
proper access rights.
.LI
\*Lds_add_entry(\|)\*O
.P
The requestor gives a distinguished name and
values for a new entry.  The entry is added as a leaf node in the DIT
if the user requesting the change has proper access rights.
.LI
\*Lds_remove_entry(\|)\*O
.P
The requestor gives a distinguished name.
The entry with that name is removed if the user requesting the
change has proper access rights.
.LI
\*Lds_modify_rdn(\|)\*O
.P
The requestor gives a distinguished name and a
new RDN for the entry.  The directory
changes the entry's RDN if the user requesting the change has
proper access rights.
.LE
.P
Note that \*Lds_add_entry(\|)\*O, \*Lds_remove_entry(\|)\*O, and
\*Lds_modify_rdn(\|)\*O only apply to leaf entries.  They are not
intended to provide a general facility for building and manipulating
the DIT.
.nL
.ne 12
.H 3 "Modifying Directory Entries"
.P
.iX "directory" "modifying entries"
.iX "directory"
.iX "XDS" "API" "modifying entries"
This section describes a modification and subsequent listing of the DIT
by using the
\*Lds_add_entry(\|)\*O, \*Lds_list(\|)\*O, and \*Lds_remove_entry(\|)\*O
function calls.  It includes a description of tasks directly related
to these operations and does not include service-related tasks.  It
does not include a \*Lds_modify_entry(\|)\*O function call.  The modify
operation is used in the context of the X.500 \*EAbstract Service
Definition\*O.
.P
A typical operation to add, remove, or list an entry involves
following the same basic steps that were defined previously for the
read and search operations:
.AL
.LI
Define the necessary object identifier constants for the OM classes and 
OM attributes that will define public objects for input to the function
calls by using the \*LOM_EXPORT\*O macro.
.LI
Declare the variables that will contain the output from the XDS 
functions you will use in your application.
.LI
Build public objects (descriptor lists) for the \*Vname\*O
parameters to the function calls.
.LI
Create descriptor lists for the attributes to be added, removed, or listed.
.LI
Perform the operations.
.LE
.P
These steps are demonstrated in the following code fragments.  The
program adds two entries to the directory, then a list operation is
performed on their superior entry, and finally the two entries are removed
from the directory.  The directory tree shown in Figure 6-5 is used
in the program.
.P
.ne 2i
.FG "A Sample Directory Tree"
.sp .5
.dI ../directory/xds_gds/Pics/fig03.cdstree.pic
.nL
.ne 10
.H 3 "Step 1: Export Object Identifiers for Required Directory Classes and Attributes"
.P
In the following code fragment, the \*LOM_EXPORT\*O macro allocates
memory for the constants that represent the object classes and
attributes required for the add, list, and remove operations:
.P
.oS
/* The application has to export the object identifiers   */
/* it requires.     */

OM_EXPORT (DS_C_AVA)
OM_EXPORT (DS_C_DS_RDN)
OM_EXPORT (DS_C_DS_DN)
OM_EXPORT (DS_C_ENTRY_INFO_SELECTION)
OM_EXPORT (DS_C_ATTRIBUTE)
OM_EXPORT (DS_C_ATTRIBUTE_LIST)

OM_EXPORT (DS_A_COUNTRY_NAME)
OM_EXPORT (DS_A_ORG_NAME)
OM_EXPORT (DS_A_ORG_UNIT_NAME)
OM_EXPORT (DS_A_COMMON_NAME)
OM_EXPORT (DS_A_OBJECT_CLASS)
OM_EXPORT (DS_A_PHONE_NBR)
OM_EXPORT (DS_A_USER_PASSWORD)
OM_EXPORT (DS_A_SURNAME)

OM_EXPORT (DS_O_TOP)
OM_EXPORT (DS_O_PERSON)
OM_EXPORT (DS_O_ORG_PERSON)
.oE
.H 3 "Step 2: Declare Local Variables"
.P
The local variables \*Vbound_session\*O, \*Vresult\*O, and
\*Vinvoke_id\*O are defined in the following sample code fragment:
.nL
.ps 11
.vs 13
.oS
.ne 10
OM_private_object bound_session; /* Holds the Session object  */
                                 /* which is returned by      */
                                 /* ds_bind().                */
OM_private_object result;        /* Holds the list result     */
                                 /* object.                   */
OM_sint           invoke_id;     /* Integer for the invoke id */
                                 /* returned by ds_search().  */
                                 /* This parameter must be    */
                                 /* present even though it is */
                                 /* ignored.                  */
.oE
.ps 12
.vs 14
.P
These data types are defined in \*Ltypedef\*O statements in the \*Lxom.h\*O
header file.  The \*Vbound_session\*O and \*Vresult\*O variables
are defined as data
type \*LOM_private_object\*O because they are returned by
\*Lds_bind(\|)\*O and \*Lds_list(\|)\*O operations to the
workspace as private objects.  Since asynchronous operations (within the
same thread) are not
supported, the \*Vinvoke_id\*O parameter functionality is redundant.
The \*Vinvoke_id\*O parameter must be supplied to the XDS functions as
described in the \*(Dr, but its return value should be ignored.
.H 3 "Step 3: Build Public Objects"
.P
The public objects required by the \*Lds_add_entry(\|)\*O, \*Lds_list(\|)\*O,
and \*Lds_remove_entry(\|)\*O operations are defined in the following code
fragment:
.nL
.ps 11
.vs 13
.oS
/* Build up descriptor lists for the following distinguished names: */
/*     C=ie/O=sni                                                   */
/*     C=ie/O=sni/OU=ap/CN=brendan                                  */
/*     C=ie/O=sni/OU=ap/CN=sinead                                   */

static OM_descriptor    ava_ie[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COUNTRY_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING, OM_STRING("ie")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_sni[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("sni")},
    OM_NULL_DESCRIPTOR
};
.ne 6
static OM_descriptor    ava_ap[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_ORG_UNIT_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("ap")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_brendan[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COMMON_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("brendan")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    ava_sinead[] = {
    OM_OID_DESC(OM_CLASS, DS_C_AVA),
    OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_COMMON_NAME),
    {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, OM_STRING("sinead")},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_ie[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_ie}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_sni[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_sni}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_ap[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_ap}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_brendan[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_brendan}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor    rdn_sinead[] = {
    OM_OID_DESC(OM_CLASS, DS_C_DS_RDN),
    {DS_AVAS, OM_S_OBJECT, {0, ava_sinead}},
    OM_NULL_DESCRIPTOR
};
.ne 7
static OM_descriptor dn_ap[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ie}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ap}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_brendan[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ie}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ap}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_brendan}},
    OM_NULL_DESCRIPTOR
};
static OM_descriptor dn_sinead[] = {
    OM_OID_DESC(OM_CLASS,DS_C_DS_DN),
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ie}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sni}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_ap}},
    {DS_RDNS,OM_S_OBJECT,{0,rdn_sinead}},
    OM_NULL_DESCRIPTOR
};
.oE
.ps 12
.vs 14
.H 3 "Step 4: Create Descriptor Lists for Attributes"
.P
The following code fragments show how the attribute lists are created
for the attributes to be added to the directory.
.P
First, initialize the public object \*Lobject_class\*O to contain the
representation of the classes in the DIT that are common to both \*LOrganizational-Person\*O entries, \*LTop\*O, \*LPerson\*O, and \*LOrganizational-Person\*O:
.oS
.ne 11
/* Build up an array of object identifiers for the     */
/* attributes to be added to the directory.            */

static OM_descriptor    object_class[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_OBJECT_CLASS),
 OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_TOP),
 OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_PERSON),
 OM_OID_DESC(DS_ATTRIBUTE_VALUES, DS_O_ORG_PERSON),
 OM_NULL_DESCRIPTOR
};
.oE
.P
Next, initialize the public objects that represent the attributes to be
added: \*Lsurname\*O and \*Ltelephone\*O for the distinguished name of
Brendan, and \*Lsurname2\*O and \*Lpassword\*O for the distinguished name
of Sinead:
.P
.oS
static OM_descriptor    telephone[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_PHONE_NBR),
 {DS_ATTRIBUTE_VALUES, OM_S_PRINTABLE_STRING,
 OM_STRING("+49 89 636 0")},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    surname[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_SURNAME),
 {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING, 
	OM_STRING("Moloney")},
 OM_NULL_DESCRIPTOR
};

static OM_descriptor    surname2[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_SURNAME),
 {DS_ATTRIBUTE_VALUES, OM_S_TELETEX_STRING,
 OM_STRING("Murphy")},
 OM_NULL_DESCRIPTOR
};

.ne 6
static OM_descriptor    password[] = {
 OM_OID_DESC(OM_CLASS, DS_C_AVA),
 OM_OID_DESC(DS_ATTRIBUTE_TYPE, DS_A_USER_PASSWORD),
 {DS_ATTRIBUTE_VALUES, OM_S_OCTET_STRING, 
	OM_STRING("secret")},
 OM_NULL_DESCRIPTOR
};
.oE
.P
Finally, initialize the public objects that represent the list of
attributes to be added to the directory: \*Vattr_list1\*O for the
distinguished name Brendan, and \*Vattr_list2\*O for the
distinguished name Sinead:
.P  
.oS
static OM_descriptor    attr_list1[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
 {DS_ATTRIBUTES, OM_S_OBJECT, {0, object_class} },
 {DS_ATTRIBUTES, OM_S_OBJECT, {0, surname} },
 {DS_ATTRIBUTES, OM_S_OBJECT, {0, telephone} },
 OM_NULL_DESCRIPTOR
};
 
static OM_descriptor    attr_list2[] = {
 OM_OID_DESC(OM_CLASS, DS_C_ATTRIBUTE_LIST),
 {DS_ATTRIBUTES, OM_S_OBJECT, {0, object_class} },
 {DS_ATTRIBUTES, OM_S_OBJECT, {0, surname2} },
 {DS_ATTRIBUTES, OM_S_OBJECT, {0, password} },
 OM_NULL_DESCRIPTOR
};
.oE
.P
The \*Vattr_list1\*O variable contains the public objects \*Lsurname\*O and
\*Ltelephone\*O, the C representations of the attributes of the
distinguished name \*L/C=ie/O=sni/OU=ap/CN=Brendan\*O that are added to
the directory.  The \*Vattr_list2\*O variable contains the public objects
first \*Lsurname2\*O and \*Lpassword\*O, which are the C representations of the
attributes of the distinguished name \*L/C=ie/O=sni/OU=ap/CN=Sinead\*O.
.nL
.ne 12
.H 3 "Step 5: Perform the Operations"
.P
The following code fragments show the \*Lds_add_entry(\|)\*O,
\*Lds_list(\|)\*O, and the \*Lds_remove_entry(\|)\*O calls.
.P
First, the two \*Lds_add_entry(\|)\*O function calls add the attribute
lists contained in \*Vattr_list1\*O and \*Vattr_list2\*O to the
distinguished names represented by \*Ldn_brendan\*O and \*Ldn_sinead\*O,
respectively:
.oS
/* Add two entries to the GDS server.                */

if (ds_add_entry(bound_session, DS_DEFAULT_CONTEXT,
   dn_brendan, attr_list1,
   &invoke_id) != DS_SUCCESS)
   printf("ds_add_entry() error\en");

if (ds_add_entry(bound_session, DS_DEFAULT_CONTEXT,
   dn_sinead, attr_list2,
   &invoke_id) != DS_SUCCESS)
   printf("ds_add_entry() error\en");
.oE
.P
Next, list all the subordinates of the object referenced by the
distinguished name \*L/C=ie/O=sni/OU=ap\*O:
.P
.oS
if (ds_list(bound_session, DS_DEFAULT_CONTEXT, dn_ap,
   &result, &invoke_id)
   != DS_SUCCESS)
   printf("ds_list() error\en");
.oE
.P
The \*Lds_list(\|)\*O call
returns the result in the private object \*Lresult\*O to
the workspace.  The components of \*Lresult\*O are represented by OM
attributes in the OM class \*LDS_C_LIST_RESULT\*O (as shown in Figure
6-6) and can only be read by a series of \*Lom_get(\|)\*O calls.
.P
.ne 7i
.FG "OM Class DS_C_LIST_RESULT"
.sp .5
.dI ../directory/xds_gds/Pics/fig03.list.pic
.sp
.P
.ne 11
Finally, remove the two entries from the directory:
.P
.oS
if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT,
    dn_brendan, &invoke_id)
    != DS_SUCCESS)
    printf("ds_remove_entry() error\en");

if (ds_remove_entry(bound_session, DS_DEFAULT_CONTEXT,
    dn_sinead, &invoke_id)
    != DS_SUCCESS)
    printf("ds_remove_entry() error\en");
.oE
.H 2 "Return Codes"
.P
XDS API function calls return a value of type \*LDS_status\*O, the
exception being \*Lds_initialize(\|)\*O which returns a value of type
\*LOM_workspace\*O.  If the function is successful, then \*LDS_status\*O 
returns with a value of \*LDS_SUCCESS\*O.  If the function does not 
complete successfully, then \*LDS_status\*O takes either the error
constant \*LDS_NO_WORKSPACE\*O or one of the private error objects described
in Chapter 11.
