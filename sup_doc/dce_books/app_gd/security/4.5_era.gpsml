...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" 
...\" HISTORY
...\" $Log: 4.5_era.gpsml,v $
...\" Revision 1.1.6.1  1996/08/16  17:18:58  sherman
...\" 	{edt, R1.2.2}
...\" 	Fixed typo
...\" 	[1996/08/16  17:18:31  sherman]
...\"
...\" Revision 1.1.4.1  1996/03/27  14:03:56  wardr
...\" 	{edit R1.2.1}
...\" 	More Release Edits
...\" 	[1996/03/27  14:03:28  wardr]
...\" 
...\" Revision 1.1.2.16  1995/06/07  14:46:54  rcb
...\" 	edited 1.1 version, PRENTICE HALL reformat
...\" 	[1995/06/07  14:46:06  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/05/11  15:00:25  rcb]
...\" 
...\" 	incorporated 1.1 edits
...\" 	[1995/05/10  17:01:47  rcb]
...\" 
...\" Revision 1.1.2.15  1994/11/03  23:35:19  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:39:10  neilson]
...\" 
...\" 	Substituted macros for book names in cross refs.
...\" 
...\" Revision 1.1.2.14  1994/10/21  15:43:49  jshirley
...\" 	Figures don't print in double-side mode.
...\" 	OK in single-side mode so did not try to fix.
...\" 	[1994/10/21  15:43:04  jshirley]
...\" 
...\" Revision 1.1.2.13  1994/10/19  20:10:40  jshirley
...\" 	Removed \*L - \*O pair from inside a heading.
...\" 	[1994/10/19  20:10:23  jshirley]
...\" 
...\" Revision 1.1.2.12  1994/10/14  19:35:45  millette
...\" 	(enh, 10056, R1.1)
...\" 	.pI fixes
...\" 	[1994/10/14  19:34:01  millette]
...\" 
...\" 	(enh, 10056, R1.1)
...\" 	HP review edits
...\" 	[1994/10/14  18:50:59  millette]
...\" 
...\" Revision 1.1.2.10  1994/08/26  16:53:34  millette
...\" 	(enh,11628,R1.1)
...\" 	Add info on DCE attr interface
...\" 	(enh, 10056, R1.1)
...\" 	Added section on macros to use with calls
...\" 	[1994/08/26  16:52:44  millette]
...\" 
...\" Revision 1.1.2.9  1994/06/13  18:20:40  devobj
...\" 	cr10872- fix copyright
...\" 	[1994/06/13  18:18:19  devobj]
...\" 
...\" Revision 1.1.2.8  1994/05/17  18:21:32  millette
...\" 	(enh, 10056, R1.1)
...\" 	head numbering fix
...\" 	[1994/05/17  18:20:58  millette]
...\" 
...\" Revision 1.1.2.7  1994/05/17  17:30:13  jshirley
...\" 	SGML conversion edits.
...\" 	[1994/05/17  17:29:58  jshirley]
...\" 
...\" Revision 1.1.2.6  1994/05/13  15:14:20  millette
...\" 	(enh, 10056, R1.1)
...\" 	index fix
...\" 	[1994/05/13  15:13:50  millette]
...\" 
...\" Revision 1.1.2.5  1994/05/11  15:58:21  millette
...\" 	(enh, 10056, R1.1)
...\" 	Code changes to confidential bytes encoding type
...\" 	[1994/05/11  15:57:22  millette]
...\" 
...\" Revision 1.1.2.4  1994/04/04  16:33:28  millette
...\" 	(enh, 10056, R1.1)
...\" 	Fixed PS embeds
...\" 	[1994/04/04  16:33:04  millette]
...\" 
...\" Revision 1.1.2.3  1994/03/15  19:54:49  millette
...\" 	(enh, 10056, R1.1)
...\" 	HP internal review changes.
...\" 	[1994/03/15  19:54:21  millette]
...\" 
...\" Revision 1.1.2.2  1994/03/14  22:00:54  rom
...\" 	{enh, 10129, R1.1}
...\" 	Fix pathnames of included files for new three-book organization.
...\" 	[1994/03/14  21:20:31  rom]
...\" 
...\" Revision 1.1.2.1  1994/03/11  22:13:07  millette
...\" 	(enh, 10056, R1.1)
...\" 	Created for new ERA chapter.
...\" 	[1994/03/11  22:12:32  millette]
...\" 
...\" $EndLog$
.H 1 "The Extended Attribute API"
.P
.iX "API" "extended attribute"
.iX "extended attribute" "API"
This chapter describes the extended attribute APIs.  There are two extended
attribute APIs: the extended registry attribute (ERA) interface to 
create attributes in the registry database and the DCE attribute interface 
to create attributes in a database of your choice.
.P
The ERA interface (consisting of \*Lsec_attr_\*V*\*L(\|)\*O calls) 
provides facilities for extending 
the registry database by
creating, maintaining, and viewing attribute types and instances, 
and providing information to and receiving it from outside attribute servers 
known as \*Eattribute triggers\*O.  It is the preferred API for security 
schema and attribute manipulations. 
Application servers that manage legacy security attributes or 
provide third-party processing of attributes stored in the registry 
database can export and implement the \*Lsec_attr(\|)\*O interface.  
Trigger servers are accessed through the \*Lsec_attr_trig(\|)\*O 
interface by the security client agent during certain \*Lsec_rgy_attr_\*V*\*L(\|)\*O 
calls.  The ERA interface uses the same binding mechanism as the registry API, 
described in Chapter 28.
.P
The DCE attribute interface (consisting of \*Ldce_attr_sch_\*V*\*L(\|)\*O calls) is provided for 
schema and attribute manipulation of data repositories other than the registry.  
Although similar to the ERA interface, the functionality of the DCE 
attribute interface is limited to creating schema entries (attribute types).  
The interface does not provide calls to create and manipulate attribute instances or to 
access trigger servers.
.P
The chapter first describes the ERA interface and 
then the DCE attribute interface.  Finally is describes macros and 
utilities provided for developers who use either attribute API.
.H 2 "The ERA API"
.iX "Schema"
.iX "attribute" "schema" "defined"
.iX "registry" "extending"
.P
The registry is a repository for principal, group, organization, and
account data.  It stores the network privilege attributes used
by DCE and account data used by local operating systems.  This local 
account data, however, is appropriate only for UNIX operating systems.  
The ERA facility provides a mechanism for extending 
the registry schema to include data (attributes) required by or useful to 
operating systems other than UNIX operating systems.
.P
The ERA API provides the ability to define attribute types and 
to attach attribute instances to registry objects.  
registry objects are nodes in the registry database, to which 
access is controlled by an ACL manager type.  The registry objects are
.ML
.LI
\*Lprincipal\*O
.LI
\*Lgroup\*O
.LI 
\*Lorganization\*O
.LI
\*Lpolicy\*O
.LI
\*Ldirectory\*O
.LI
\*Lreplist\*O
.LI
\*Lattr_schema\*O
.LE
.P
All registry objects and their accompanying ACL manager type are 
described in the \*(Ac.  
.P
The ERA API also provides a trigger interface that application servers 
use to integrate their attribute services with ERA services.
.H 3 "Attribute Schema"
The schema extensions are implemented in a single attribute schema that 
is essentially a 
catalog of schema entries, each of which defines the format and 
function of an attribute type.  The schema can be dynamically updated to 
create, modify, or delete schema entries.
.P
The attribute schema is identified by 
the name \*Lxattrschema\*O under the security junction point 
(usually \*L/.:/sec\*O) in the CDS namespace.  Access to the attribute 
schema (hereinafter called simply \*Eschema\*O) is controlled by an  
ACL on the schema object. 
.iX "\*Lxattrschema object\*O"
.iX "attribute" "type" "access control"
The schema is propagated from the master security
server to replicas, like other registry data.  Since the attribute schema 
is local to a cell, it defines the types that can be used within the cell, but 
not outside the cell (unless the type is also defined in another cell).
.H 3 "Attribute Types and Instances"
.P
Each attribute type definition in the schema consists of attribute type identifiers 
(UUID and name) and semantics that control the instances of attributes of this type.
In this manual, \*Eschema entry\*O refers to the registry entry that defines 
an attribute type. 
.P 
An attribute instance is an attribute that is attached to an 
object and has a value (as opposed to 
an attribute type, which has no values but simply defines the semantics 
to which attribute instances of that attribute type must 
adhere).  Attribute instances contain the UUID of their attribute type.
.iX "Schema"
.iX "attribute" "instance"  "defined"
.iX "attribute" "type"  "defined"
.H 3 "Attribute Type Components"
.P
The \*Lsec_attr_schema_entry_t\*O data type defines an attribute type.  
This data type contains attribute type identifiers and 
characteristics.  
.P 
The identifiers of attribute types are a name and a UUID.  
Generally, the name is used for interactive access and the UUID 
for programmatic access. 
.P
Attribute type characteristics describe the format and function 
of the attribute type and thus control the format and function of 
instances of that type.  
These characteristics, all specified in the 
\*Lsec_attr_schema_entry_t\*O data type, 
are described in the following sections.
.H 4 "Attribute Encoding"
.P
Attribute encoding defines the legal encoding for 
instances of the attribute type.  
The encoding controls the format of the 
attribute instance values, such as whether the attribute value is 
an integer, string, a UUID, or a vector of UUIDs that define an 
attribute set. 
.P
Attribute encodings are specified in 
the \*Lsec_attr_encoding_t\*O data type (fully described in the \*(Dr). 
.P
The possible encodings for attribute types are
.ML
.LI
\*Lany\*O
.P
The attribute instance value can be of any legal encoding type. 
.LI
\*Lvoid\*O
.P
The attribute instance has no value. 
It is simply a marker that is either present or absent.
.LI
\*Lprintstring\*O
.P
The attribute value is a printable IDL character 
string from the DCE Portable Character Set (PCS).
...\" DCE 1.2 WRITER: above sentence correct?
.LI
\*Lprintstring_array\*O
.P
The attribute value is an array of print strings.
.LI
\*Linteger\*O
.P
The attribute value is a signed 32-bit integer.
.LI
\*Lbytes\*O
.P
The attribute value is a string of bytes. 
The byte string is assumed to be a 
pickle or is otherwise a self-describing type.
.LI
\*Lconfidential_bytes\*O
.P
The attribute value is a string of encrypted 
bytes.  This encrypted data can be passed over the network and is available to user-developed 
applications.
.LI
\*Li18n_data\*O
.P
An internationalized string of bytes with a tag identifying 
the OSF registered codeset used to encode the data.
.LI
\*Luuid\*O
.P
A DCE UUID.
.LI
\*Lattr_set\*O
.P
The value is an attribute set, 
a vector of attribute type UUIDs 
used to associate multiple related attribute instances (members of the set).  
The vector contains the UUIDs of each member of the set.   
Attribute sets provide a flexible way to 
group related attributes on an object for 
easier search and retrieval. 
.P
The attribute type UUIDs referenced in an attribute 
set instance must correspond 
to existing attribute schema entries.  Although the members specified in a 
set are generally expected to be attached to the object to which the set 
instance is attached, no checking is done to confirm that they are.
Thus, it is possible to create an attribute set instance 
on an object before creating member attribute instances on that object.  
A query on such an attribute set returns all instances of member 
attributes that exist on 
the object along with a warning that some attribute types were missing.
.P
Note that attribute sets cannot be nested; a member UUID of an attribute 
set cannot itself identify an attribute set. 
.P
A query on an attribute set expands to a query per the set's members. In other words, 
an attribute lookup operation on an attribute 
set returns all attribute instances that are members of the set, not the 
set instance itself.  (Certain operations, such as
\*Lsec_rgy_attr_set_lookup_by_id(\|)\*O and 
\*Lsec_rgy_attr_lookup_by_name(\|)\*O, can retrieve attribute set instances.)
.P
Updates to an attribute set (\*Lsec_rgy_attr_update(\|)\*O) 
do not expand the update to its members but 
apply only to the attribute set.  Since the value carried by 
a set instance is a vector containing the UUIDs of the member 
attribute types, an update makes changes only to the 
set's members, not the values carried by those member attributes.   
Deletions of attribute sets delete only the set instance, not the member 
instances.
.P
Since the attributes that are set members exist independently of the attribute 
set, they can be manipulated directly like any other attribute.
.LI
\*Lbinding\*O
.P
The attribute value is a \*Lsec_attr_binding_info_t\*O type containing 
authentication, authorization, and binding information suitable for 
communicating with a DCE server.
.LE
.H 4 "ACL Manager Set"
.P
An attribute type's ACL manager set specifies the 
ACL manager type or types (by UUID) that 
control access to the object types to which attribute instances of this type can 
be attached.  
Attribute instances 
can be attached only to objects protected by the ACL manager types in the schema 
entry.  For example, suppose an ACL manager set for 
an attribute type named \*LMVSname\*O lists only the ACL manager type for principals.  
Then, instances 
of the attribute type named \*LMVSname\*O can be attached only to 
principals and not any other registry 
objects.  
.iX "attribute" "instance" "access control"
.P
Access to an attribute instance is controlled by the ACL on the 
object to which the attribute instance is attached and access control 
is implemented by the 
object's ACL manager type.  
For example, access to an attribute named \*LMVSname\*O on the principal 
object named \*Ldelores\*O is controlled by the ACL on 
the \*Ldelores\*O object. 
.P
Do not confuse access to an attribute type definition (a schema entry) with 
access to an attribute instance.  As described previously, access 
to a schema entry is 
controlled by the ACL on the \*Lxattrschema\*O object.  Access to 
an attribute instance is controlled by the ACL on the object to which the 
attribute instance is attached.
.P
In addition to the ACL manager types, the ACL manager set 
defines the permission bits needed
to query, update, test, and delete instances 
of the attribute type.  These bits are used by the object's ACL manager 
to determine rights to the object's attributes.
.P
The ACL manager types and permissions 
defined for the attribute type apply to all instances of the attribute type. 
.P  
Note that the ACL manager facility supports additional generic 
attribute type permissions (\*LO\*O through \*LZ\*O inclusive).  
Administrators can assign these permissions to attribute types 
of their choice.  
All uses of these additional permission bits are controlled by the cell's 
administrator.  See the \*(Ac for more information. 
.H 4 "Attribute Flags"
.P
The attribute type flags set in a schema entry are described in the following 
paragraphs.
.H 5 "The Unique Flag"
.P
The unique flag specifies whether or not 
the value of each instance of an attribute type must be 
unique within the cell.  For example, assume that an instance of attribute 
type A is attached to 25 principals in the cell.  If the unique flag is set on, 
the value of the A attribute for each of those 25 principals must be 
different.  If it is set off, the all 25 principals can share the same value 
for attribute A. 
.H 5 "The Multivalued Flag"
.P
The multivalued flag specifies whether or not instances of the 
attribute can be multivalued.  If an attribute is multivalued, multiple 
instances of the same attribute type can be attached to a single registry 
object.  For example, if the multivalued flag is set on, a single principal 
can have multiple instances of attribute type A.  If the flag is set off, a single 
principal can have only one instance of attribute type A.
.P
All instances' multivalued attributes share the UUID  
(the UUID of their attribute type), but the values carried by the 
instances differ.  Generally, to access all instances of a multivalued 
attribute, you supply the attribute UUID.  To access a specific instance 
of a multivalued attribute, you supply the UUID and the value carried 
by that instance. 
.H 5 "The Reserved Flag"
.P
The reserved flag indicates whether or not the 
attribute type can be deleted from the schema.  
Note that, when an attribute type is deleted, all instances of the 
attribute type are deleted.  If the reserved flag is set on, the 
entry cannot be deleted.    
If the reserved flag is set off, authorized principals can 
delete the schema entry.
.H 5 "The Apply-Defaults Flag"
.P
The apply-defaults flag indicates 
whether or not default attributes 
should be returned when objects are queried by 
a client with the \*Lsec_\%rgy_\%attr_\%get_\%effective(\|)\*O call. 
If the apply-defaults flag is set on, defaults are 
applied.  If it is set off, defaults are not supplied. 
.P
Defaults are determined in the 
following manner:
.AL
.LI
If the requested attribute exists on the principal, that 
attribute is returned.  If it does not, the search continues.  
.LI
The next step in the search depends on the type of object:
.P
For principals with accounts:
.AL
.LI
The organization named in the principal's 
account is examined to 
see if an attribute of the requested type exists.  If it does, it 
is returned and the search ends.  If it does not, the search continues 
to the \*Lpolicy\*O object as described in Step 2b.
.LI
The registry \*Lpolicy\*O object is examined to 
see if an attribute of the requested type exits.  
If it does, it is returned.  If it does not, a message indicating that 
no attribute of the type exists for the object is returned.
.LE
.P
For principals without accounts, for groups, and for organizations: 
.P
The registry \*Lpolicy\*O object is examined to 
see if an attribute of the requested type exits.  
If it does, it is returned.  If it does not, a message indicating that 
no attribute of the type exists for the object is returned.
.LE
.H 4 "The Intercell Action Field"
.P
The intercell action field of the schema entry specifies the action that should be taken 
by the privilege server when reading attributes from a foreign cell.   This 
field can contain one of three values:
.ML
.LI
\*Lsec_attr_intercell_act_accept\*O
.P
To accept the foreign attribute instance
.LI
\*Lsec_attr_intercell_act_reject\*O
.P
To reject the foreign attribute instance
.LI
\*Lsec_attr_intercell_act_evaluate\*O
.P
To call a remote trigger 
server to determine how the attribute instance should be handled
.LE
.P
When the privilege server generates a PTGT for a foreign principal, it 
retrieves the list of attributes from the foreign principal's EPAC.
.P 
These attributes instances may be 
attached to the \*Lprincipal\*O object itself or attached to the group or 
\*Lorganization\*O object associated with the \*Lprincipal\*O object.
.P
The privilege server then checks the local attribute schema for 
attribute types with UUIDs that match the UUIDs of the 
the attribute instances from the foreign cell that are contained in the 
EPAC.  At this point, the privilege server 
takes one of the following two actions:
.AL
.LI
If the privilege server cannot find a matching attribute type in the 
local attribute schema, it checks the \*Lunknown_intercell_action\*O 
attribute on the \*Lpolicy\*O object.  If the \*Lunknown_intercell_action\*O 
attribute is set to
.ML
.LI 
\*Lsec_attr_intercell_act_accept\*O, the foreign 
attribute instance is retained and included in the EPAC generated 
for the object by the privilege server.
.LI
\*Lsec_attr_intercell_act_reject\*O, the 
foreign attribute is discarded.
.LE
.P
.nS note 
The \*Lunknown_intercell_action\*O attribute must be created 
by the system administrator and attached to the \*Lpolicy\*O object.  The 
attribute type, which takes the same values as the 
intercell_action field, 
has the following characteristics:
.na
.sp .5
Name:\ \ \*Lunknown_intercell_action\*O
.sp .5
Attribute\ UUID:
.nL
\*L171e0ef2c-d12e-11cc-bb7b-080009353559\*O
.sp .5
Encoding:\ \ \*Lsec_attr_encoding_integer\*O
.sp .5
ACL manager set:\ \ \*Lpolicy_acl_mgr\*O
.sp .5
Unique:\ \ false
.sp .5
Multivalued:\ \ false
.sp .5
Reserved:\ \ true
.sp .5
Comment\ text:\ \ Flag indicating whether to accept or reject foreign 
attributes for which no schema entry exists 
.ad
.nE
.P
.LI
If the privilege server finds a matching attribute type in the 
local attribute schema, it retrieves the attribute.  The action it 
now takes depends on  
the setting of the attribute type's intercell action field 
and unique flag as follows:
.ML
.LI
If the intercell action field is set to \*Lsec_attr_intercell_act_accept\*O and
.ML
.LI
The
unique flag is not set on, the privilege server includes the foreign attribute 
instance in the principal's EPAC.
.LI
The
unique flag is set on, the privilege server includes the foreign attribute 
instance in the principal's EPAC only if 
the attribute instance value is unique among all instances of the attribute 
type within the local cell.
.LE
.nS note
If the unique attribute type flag is set on and a query trigger exists for a 
given attribute type, the intercell action field cannot be set to 
\*Lsec_\%attr_\%intercell_\%act_\%accept\*O because, in this case, only the 
query trigger server can reasonably perform a uniqueness check.
.nE
.LI
If the intercell action field is set to \*Lsec_attr_intercell_act_reject\*O, 
the privilege server unconditionally discards the foreign attribute instance.
.LI
If the intercell action field is set to 
\*Lsec_\%attr_\%intercell_\%act_\%evaluate\*O,
the privilege server makes a remote \*Lsec_\%attr_\%trig_\%intercell_\%avail(\|)\*O 
call to an attribute trigger by
using the binding information in the local attribute type schema entry.  
The remote attribute trigger decides whether to retain, discard, or map 
the attribute instance to another value(s). 
The privilege server includes the values returned by the 
attribute trigger in the \*Lsec_attr_trig_query(\|)\*O call output array 
in the principal's EPAC.
.LE
.LE
.H 4 "Attribute Scope"
.P
The scope field controls the objects to which the attribute can be 
be attached.  If scope is defined, the attribute can be attached only to 
objects defined by the scope.  For example, if the scope for a given attribute 
type is defined as the directory name \*L/principal/krbgt\*O, instances of that 
attribute type can be attached only to objects in the \*L/principal/krbgt\*O 
directory (a directory that by convention contains only cell principals).  
If the scope is narrowed by fully specifying an object in the 
\*L/principal/krbgt\*O directory (for example, 
\*L/principal/krbgt/dresden.com\*O) then the attribute can be 
attached only to the \*Ldresden.com\*O principal.
.H 4 "Trigger Type Flag"
.P
The schema entry trigger type flag specifies whether the trigger 
server associated with the attribute type is invoked for update or query operations. 
See Section 29.4 for more information 
on attribute triggers. 
.H 4 "Trigger Binding"
.P
The schema entry trigger binding field contains a binding handle to a 
remote trigger that will perform processing for the attribute instances.
See Section 29.4 for more information 
on attribute triggers. 
.H 2 "Calls to Manipulate Schema Entries"
.P
This section first introduces the \*Lsec_attr_schema_entry_t\*O data type 
used by the calls that create and update schema entries that define 
attribute types.  It 
then describes the calls that create, modify, delete, and read schema entries.
.H 3 "The sec_attr_schema_entry_t Data Type"
.P
The \*Lsec_attr_schema_entry_t\*O data type is used in 
the calls that create and update 
schema entries.  The data type consists of 
four values and six other data types.  
The values used by the \*Lsec_attr_schema_entry_t\*O are 
the attribute type name, UUID, scope, and a text field for comments.  
.P
The data types used by the \*Lsec_attr_schema_entry_t\*O are
.ML
.LI
\*Lsec_attr_sch_entry_flags_t\*O
.P
Specifies the unique, multivalued, reserved, and apply defaults attribute flags.
.LI
\*Lsec_attr_acl_mgr_info_set_t\*O
.P
Specifies the attribute type's 
ACL manager(s).  This data type defines the attribute type ACL manager 
set.  This data type contains an array of pointers of 
type \*Lsec_attr_mgr_info_p_t\*O, which reference 
\*Lsec_\%attr_\%acl_\%mgr_\%info_\%t\*O data types.  There is one 
\*Lsec_\%attr_\%acl_\%mgr_\%info_\%t\*O data type for each 
ACL manager associated with the attribute type.  
Each \*Lsec_attr_acl_mgr_info_t\*O defines the
ACL manager UUID and the permission bits.
.LI
\*Lsec_attr_encoding_t\*O
.P
Specifies the schema entry encoding.
.LI
\*Lsec_attr_trig_type_t\*O
.P
Specifies the type of attribute trigger associated with the 
attribute type (if an attribute trigger is to be associated with the attribute 
type).  See Section 29.4 for more information on attribute triggers.
.LI
\*Lsec_attr_intercell_action_t\*O
.P
Specifies the action to be taken 
attribute instances of this type that come from a foreign cell.
.LI
\*Lsec_attr_bind_info_t\*O
.P
Specifies binding information for the trigger 
server associated with the attribute type (if an attribute trigger is associated 
with the attribute type). 
.P
The \*Lsec_attr_bind_info_t\*O data type uses two other data types:  
\*Lsec_\%attr_\%bind_\%auth_\%info_\%t\*O and \*Lsec_\%attr_\%binding_\%t\*O.   
The \*Lsec_\%attr_\%bind_\%info_\%t\*O structure for trigger binding 
is described fully in Section 29.4.
.LE
.P
Figure 29-1 illustrates the structure of 
a \*Lsec_attr_schema_entry_t\*O data type.
.P
.FG "The sec_attr_schema_entry_t Data Type" 
.pI ../security/figures/4.5_era_10.ps 5.2i 4.3i
...\" .pI security/figures/4.5_era_10.ps 0 0 1
.H 3 "Creating and Managing Schema Entries"
.P
This section describes the calls to create, modify, and delete the 
schema entries that define attribute types. 
.H 4 "The \*Lsec_rgy_attr_sch_create_entry(\|)\*O Call"
.P
The \*Lsec_rgy_attr_sch_create_entry(\|)\*O call creates a schema entry 
that defines an attribute type in the attribute schema.
.P
This call uses the \*Lsec_attr_schema_entry_t\*O data type 
that completely defines the schema entry, including the following:
.ML
.LI
The attribute type name (generally used for interactive access) and UUID 
(generally used for programmatic access).  Note that attribute instances share 
the name and UUID of their attribute type.
.LI
The attribute's encoding (described in Section 29.1.3).  The encoding is 
specified as an enumerator of type \*Lsec_attr_encoding_t\*O.  For some  
kinds of encodings, additional data types are used to further specify the 
encoding information.  These additional data types, the kinds of encodings 
that require them, and the purpose of the data types are listed in 
Table 29-1.
.LE
.P
.TB "Encodings and Required Data Types"
.ps 10
.vs 12
.na
.TS
center,box,tab(@);
lB | lB | lB
lB | lB | lB
l | l | l.
@Required@Purpose of
Encoding@Data Type@Data Type
=
\*Lsec_attr_enc_bytes\*O@\*Lsec_attr_enc_bytes_t\*O@T{
Defines the length of attribute values
T}
_
\*Lsec_attr_enc_confidential_bytes\*O@\*Lsec_attr_enc_bytes_t\*O@T{
Defines the length of attribute values
T}
_
\*Lsec_attr_enc_i18n_data\*O@\*Lsec_attr_i18n_data_t\*O@T{
Defines the i18n codeset
T}
_
\*Lsec_attr_enc_attr_set\*O@\*Lsec_attr_enc_attr_set_t\*O@T{
Defines the total number of members in the attribute set and 
the UUID of each member
T}
_
\*Lsec_attr_enc_printstring\*O@\*Lsec_attr_enc_printstring_t\*O@T{
Defines a single print string
T}
_
\*Lsec_attr_enc_printstring_array\*O@\*Lsec_attr_enc_str_array_t\*O@T{
Defines an array of print strings
T}
.TE
.ad
.ps 12
.vs 14
.H 4 "The \*Lsec_rgy_attr_sch_update_entry(\|)\*O Call"
.P
The \*Lsec_rgy_attr_sch_update_entry(\|)\*O call updates a schema entry that defines 
an attribute type.
.P
The schema entry components that can be modified are controlled by the 
ERA API and the \*Vmodify_parts\*O parameter of 
the \*Lsec_\%rgy_\%attr_\%sch_\%update_\%entry(\|)\*O call.
.P
To ensure that registry and access control data 
remains consistent, the ERA API 
allows only the following schema entry components to 
be modified:
.ML
.LI
Attribute name
.LI
Reserved flag 
.LI
Apply defaults flag
.LI
Intercell action flag
.LI
Trigger binding
.LI
Comment
.LE
.P
Note that ACL managers can be added to a schema entry's ACL manager 
set, but they cannot be modified or deleted.
.P
To modify any other schema entry fields implies a drastic change to the 
attribute type.  If this change must be made, the schema entry 
must be deleted 
(which deletes all attribute instances of that type) 
and then recreated. 
.P
The \*Vmodify_parts\*O parameter of the \*Lsec_rgy_attr_sch_update_entry(\|)\*O call can 
also be used to prohibit modification of additional schema entry fields.  This parameter, which 
is actually a \*Lsec_attr_schema_entry_parts_t\*O data type, lists the fields that 
can be modified by the call.  Only those fields listed in 
\*Lsec_attr_schema_entry_parts_t\*O can be modified.
.P
The new values used to update the attribute type 
are supplied in a \*Lsec_attr_schema_entry_t\*O data type.
.H 4 "The \*Lsec_rgy_attr_sch_delete_entry(\|)\*O Call"
.P
The \*Lsec_rgy_attr_sch_delete_entry(\|)\*O call deletes 
attributes types from the attribute schema.  
The attribute type to be deleted is specified by UUID.  
When an attribute type is deleted, 
all instances of that attribute type are invalidated.
.H 3 "Reading Schema Entries"
.P
This section describes the calls that read schema entries and the cursor used by 
the \*Lsec_rgy_attr_sch_scan(\|)\*O call.
.H 4 "Using \*Lsec_attr_cursor_t\*O with \*Lsec_rgy_attr_sch_scan(\|)\*O"
.P
The \*Lsec_rgy_attr_sch_scan(\|)\*O call, which reads a specified number of 
attribute type entries from the attribute schema, uses a cursor of type 
\*Lsec_attr_cursor_t\*O.  
This cursor must be allocated before it can be used as input to 
the \*Lsec_rgy_attr_sch_scan(\|)\*O call.  In addition, it can also 
be initialized to the first attribute type entry in the schema, although this 
is not required.  After use, the resources allocated to the \*Lsec_attr_cursor_t\*O 
must be released.
.P
The following calls allocate, initialize, and release a \*Lsec_attr_cursor_t\*O for 
use with the \*Lsec_rgy_attr_sch_scan(\|)\*O call:
.ML
.LI
\*Lsec_rgy_attr_sch_cursor_init(\|)\*O
.P   
The \*Lsec_rgy_attr_sch_cursor_init(\|)\*O call allocates resources to the cursor and 
initializes the cursor to the first attribute type entry in the attribute schema.  
This call also supplies 
the total number of entries in the attribute schema as part of its output.  
The cursor 
allocation is a local operation.  The cursor initialization is a remote operation 
and makes a remote call to the registry.
.LI
.ne 10
\*Lsec_rgy_attr_sch_cursor_alloc(\|)\*O
.P
The \*Lsec_rgy_attr_sch_cursor_alloc(\|)\*O call allocates 
resources to the cursor but does not initialize the cursor.  
However, since the \*Lsec_rgy_attr_sch_scan(\|)\*O call will initialize the 
cursor if it is passed in uninitialized, you may prefer this call to 
limit the number of remote calls performed by an application.  
Be aware that the \*Lsec_\%rgy_\%attr_\%sch_\%cursor_\%init(\|)\*O call 
provides the total 
number of entries in the named schema, a piece of information not 
provided by the \*Lsec_\%rgy_\%attr_\%sch_\%cursor_\%alloc(\|)\*O call.
.LI
\*Lsec_rgy_attr_sch_cursor_release(\|)\*O 
.P
The \*Lsec_rgy_attr_sch_cursor_release(\|)\*O call releases all resources 
allocated to a \*Lsec_attr_cursor_t\*O cursor used with the 
\*Lsec_\%rgy_\%attr_\%sch_\%scan(\|)\*O call.
.LI
\*Lsec_rgy_attr_sch_cursor_reset(\|)\*O 
.P
The \*Lsec_rgy_attr_sch_cursor_reset(\|)\*O call initializes a  
\*Lsec_\%attr_\%cursor_\%t\*O cursor used with the 
\*Lsec_rgy_attr_sch_scan(\|)\*O call.  The reset cursor can then 
be used without releasing and reallocating.
.LE
.H 4 "The \*Lsec_rgy_attr_sch_scan(\|)\*O Call"
.P
The \*Lsec_rgy_attr_sch_scan(\|)\*O call reads a specified number of schema 
entries from the attribute schema.  
.P
The number of entries to read is specified as an unsigned 32-bit integer. 
The read begins at the entry at which the \*Lsec_attr_cursor_t\*O 
cursor is positioned and continues through the number of entries specified.  
The cursor must be allocated but can be initialized or uninitialized since 
\*Lsec_\%rgy_\%attr_\%sch_\%scan(\|)\*O initializes any uninitialized 
cursor it receives as input.  
.P
The call output includes an array of \*Lsec_attr_schema_entry_t\*O values 
and a 
32-bit integer that specifies the number of schema entries returned.    
.P
To read through all entries in a schema, continue making 
\*Lsec_\%rgy_\%attr_\%sch_\%scan(\|)\*O calls, 
until the \*Lno_\%more_\%entries\*O message is received.  
When all calls are complete, 
release the resources allocated to the 
\*Lsec_\%attr_\%cursor_\%t\*O cursor by using the 
\*Lsec_\%rgy_\%attr_\%sch_\%cursor_\%release(\|)\*O call.
.H 4 "The \*Lsec_rgy_attr_sch_lookup_by_id(\|)\*O and \*Lsec_rgy_attr_sch_lookup_by_name(\|)\*O Calls"
.P
The \*Lsec_rgy_attr_sch_lookup_by_id(\|)\*O call reads the attribute 
schema entry identified by UUID.  The output of the call is a 
\*Lsec_\%attr_\%schema_\%entry_\%t\*O type that contains the specified attribute 
type's name, UUID, and characteristics.  Generally, this call is used for 
programmatic access.  
.P
For interactive access, use the \*Lsec_rgy_attr_sch_lookup_by_name(\|)\*O call. 
This call returns the same information as the 
\*Lsec_\%rgy_\%attr_\%sch_\%lookup_\%by_\%id(\|)\*O 
call but specifies the schema entry to read by name instead of by UUID.
.H 3 "Reading the ACL Manager Types"
.P
Two calls retrieve the ACL manager types that 
protect objects dominated by a named schema:
.ML
.LI 
\*Lsec_rgy_attr_sch_get_acl_mgrs(\|)\*O
.P
Retrieves the UUIDs of the ACL manager types protecting all 
objects in a named schema.
.LI
\*Lsec_rgy_attr_sch_aclmgr_strings(\|)\*O
.P
Retrieves printable strings for each ACL manager type protecting objects 
in a named schema.  The strings contain the ACL manager type's name, associated 
help information, and supported permission bits.
.LE
.H 2 "Calls to Manipulate Attribute Instances"
.P
This section introduces the \*Lsec_attr_schema_t\*O data type 
used by the calls that create and update attribute instances and
then describes the calls that create, modify, delete, 
and read attribute instances.  
For all calls, the object whose 
attributes should be accessed is identified by name and 
by the domain in which the object exists.  
(The domain parameter is ignored 
for the \*LPolicy\*O and the \*LReplist\*O objects.)   
Registry domains are described in Chapter 28.
.H 3 "The sec_attr_t Data Type"
.P
The \*Lsec_attr_t\*O data type is used in the calls that create and update 
attribute instances.  The data type consists of a value of type \*Luuid_t\*O 
that identifies the attribute to be accessed by UUID and data type of 
\*Lsec_attr_value_t\*O.  The \*Lsec_attr_value_t\*O data type 
is a tagged union of the actual value 
assigned (or to be assigned to the attribute instance) and a data type of 
\*Lsec_attr_encoding_t\*O that specifies the encoding tags that define the 
attribute type characteristics.  
Figure 29-2 illustrates the structure of 
a \*Lsec_attr_t\*O data type.
.P
.FG "The sec_attr_t Data Type" 
.pI ../security/figures/4.5_era_20.ps 0 0 1
...\" .pI security/figures/4.5_era_20.ps 0 0 1
.H 3 "Creating and Managing Attribute Instances"
.P
This section describes the calls to create, modify, and delete the 
attribute instances. 
.H 4 "The \*Lsec_rgy_attr_update(\|)\*O Call"
.P
The \*Lsec_rgy_attr_update(\|)\*O call creates new attribute 
instances and updates existing attribute instances attached to an
object specified by name and registry domain.  
The instances to be created or updated are 
passed as an array of \*Lsec_attr_t\*O data types.
.P
Because the new values are passed in as an array, if the update of any 
attribute instance in the array fails, all fail.  However, to help pinpoint the 
cause of the failure, the call identifies the first attribute whose update failed 
in a failure index by array element number. 
.P
For existing attribute instances attached to the object, the values 
passed in the array overwrite the existing values.  In other 
words, if the UUID passed in the input array matches 
the UUID of an existing instance, the values passed in overwrite 
the existing values.  
.P
If the attribute instance does not exist, it is created.  
In other 
words, if the UUID passed in in the array does not match 
any other attribute type UUID attached to the object, a new 
attribute instance is created. 
.P
For multivalued attributes, 
because every instance of the multivalued attribute is identified by the same 
UUID, every instance is overwritten with the supplied 
value.  For example, suppose object \*Ldelores\*O 
has three attributes of the multivalued type \*Lsecurity_role\*O.  
If you pass in 
one value for \*Lsecurity_role\*O, the values of all 
three are changed to the one you enter.  
.P
To change only one of the \*Lsecurity_role\*O values, you must supply the values 
that should be unchanged as well as the new value.  For example, 
suppose object \*Ldelores\*O 
has three \*Lsecurity_role\*O attributes with values of \*Llevel1\*O, 
\*Llevel2\*O, and \*Llevel3\*O.  
To change \*Llevel1\*O to \*Llevel1O.\*5 and retain \*Llevel2\*O 
and \*Llevel3\*O, the input array must contain 
\*llevel1.5\*O, \*Llevel2\*O, and \*Llevel3\*O.
.P
To create instances of multivalued attributes, 
you must create individual \*Lsec_attr_t\*O 
data types to define each multivalued attribute 
instance and then pass all of them in the 
\*Lsec_rgy_attr_update(\|)\*O input array.
.P
If an input attribute is associated with an update attribute trigger, 
the attribute trigger is invoked (by the \*Lsec_attr_trig_update(\|)\*O call),
and the values in the \*Lsec_rgy_attr_update(\|)\*O input 
array are used as input to the update attribute trigger.
The output values from the update attribute trigger are stored 
in the registry database and returned in the \*Lsec_\%rgy_\%attr_\%update(\|)\*O 
output array.
.H 4 "The \*Lsec_rgy_attr_test_and_update(\|)\*O Call"
.P
The \*Lsec_rgy_attr_test_and_update(\|)\*O call, like the \*Lsec_rgy_attr_update(\|)\*O 
call,  creates new attribute instances and updates 
existing attribute instances attached to an
object specified by name and registry domain.   
However, it performs the update only 
if a set of specified attribute instances match the attribute instances that 
already exist for the object.  This call is useful to ensure that updates 
are made only if certain conditions exist.
.P
The attribute instances to be matched are passed in an input array of \*Lsec_attr_t\*O 
values.  Other than this conditional test, this call functions exactly the same as 
the \*Lsec_rgy_attr_update(\|)\*O call.
.H 4 "The \*Lsec_rgy_attr_delete(\|)\*O Call"
.P
The \*Lsec_rgy_attr_delete(\|)\*O call deletes the specified attribute instances 
from an object identified by name and registry domain.  The attribute instances to 
be deleted are passed in  as an array of values of \*Lsec_attr_t\*O.  
.P
To delete attribute instances that are not multivalued and to 
delete all instances of a multivalued attribute, an attribute UUID 
is all that is required.  For these attribute instances, supply the attribute 
UUID in the input array and 
set the attribute encoding (in \*Lsec_attr_encoding_t\*O)  
to \*Lsec_\%attr_\%enc_\%void\*O.     
.P
To delete a specific instance of a multivalued attribute, you 
must supply the UUID and value that uniquely identify the multivalued 
attribute instance in the input array.
.P
Note that, if the deletion of any 
attribute instance in the array fails, all fail.  However, to help pinpoint the 
cause of the failure, the call identifies the first attribute whose deletion failed 
in a failure index by array element number. 
.H 3 "Reading Attribute Instances"
.P
This section describes the calls that read attribute instances, 
and it describes the cursor used by the  
\*Lsec_rgy_attr_lookup_by_id(\|)\*O call.
.H 4 "Using \*Lsec_rgy_attr_cursor_t\*O with \*Lsec_rgy_attr_lookup_by_id(\|)\*O"
.P
The \*Lsec_rgy_attr_lookup_by_id(\|)\*O call, which reads attributes for 
a specified object, uses a cursor of type 
\*Lsec_attr_cursor_t\*O.  
This cursor must be allocated before it can be used as input to 
the \*Lsec_\%rgy_\%attr_\%lookup_\%by_\%id(\|)\*O call.  
In addition, it can also be 
initialized to the first attribute in the specified object's list 
of attributes, although this 
is not required.  After use, the resources allocated to the \*Lsec_attr_cursor_t\*O 
must be released.
.P
The following calls allocate, initialize, and release a \*Lsec_attr_cursor_t\*O for 
use with the \*Lsec_rgy_attr_lookup_by_id(\|)\*O call:
.ML
.LI
\*Lsec_rgy_attr_cursor_init(\|)\*O
.P   
The \*Lsec_rgy_attr_sch_cursor_init(\|)\*O call allocates resources to and 
initializes the cursor to the first attribute in the specified object's list of 
attributes.   
This call also supplies 
the total number of attributes attached to the object as part of its output.  
The cursor 
allocation is a local operation.  The cursor initialization is a remote operation 
and makes a remote call to the registry.
.LI
\*Lsec_rgy_attr_cursor_alloc(\|)\*O
.P
The \*Lsec_rgy_attr_cursor_alloc(\|)\*O call allocates resources to 
the cursor but does not initialize the cursor.  However, 
since the \*Lsec_rgy_attr_lookup_by_id(\|)\*O call will initialize the 
cursor if it is passed in uninitialized, you may prefer this call to 
limit the number of remote calls performed by the application.  
Be aware that the \*Lsec_rgy_attr_cursor_init(\|)\*O call provides the total 
number of attributes attached to the specified object, a piece of information not 
provided by this call.
.LI
.ne 5
\*Lsec_rgy_attr_cursor_release(\|)\*O 
.P
The \*Lsec_rgy_attr_cursor_release(\|)\*O call releases all resources 
allocated to a \*Lsec_attr_cursor_t\*O cursor used with the 
\*Lsec_\%rgy_\%attr_\%lookup_\%by_\%id(\|)\*O call. 
.LI
\*Lsec_rgy_attr_cursor_reset(\|)\*O 
.P
The \*Lsec_rgy_attr_cursor_reset(\|)\*O call reinitializes a  
\*Lsec_attr_cursor_t\*O cursor used with the 
\*Lsec_rgy_attr_lookup_by_id(\|)\*O call.  The reset cursor can then be used without releasing and reallocating.
.LE
.H 4 "The \*Lsec_rgy_attr_lookup_by_id(\|)\*O Call"
.P
The \*Lsec_rgy_attr_lookup_by_id(\|)\*O call reads attributes specified by UUID for 
an object specified by name and domain.  Specifically the call returns
the following:
.ML
.LI
An array of \*Lsec_attr_t\*O values.
.LI
A count of the total number of attribute instances returned.
.LI
A count of the total number of attribute instances 
that could not be returned because of size constraints of 
the \*Lsec_attr_t\*O array.  (Note that the call allows the size of the 
array to be specified.)
.LE
.P
For multivalued attributes, the call returns 
a \*Lsec_attr_t\*O for each value as an individual attribute instance.  
For attribute sets, the call returns a \*Lsec_attr_t\*O  for each member 
of the set, but not the set instance.  This routine is useful for programmatic access.
.P
If the attribute instance to be read is not 
associated with a query trigger or no additional information is
required by the query trigger, an attribute UUID is all that is required.  
For these attribute instances, supply the attribute 
UUID in the input array and 
set the attribute encoding (in \*Lsec_attr_encoding_t\*O)  
to \*Lsec_attr_enc_void\*O.   
.P
If the attribute instance to be read is associated with a 
query attribute trigger that 
requires additional information before it can process the query request, 
use a \*Lsec_attr_value_t\*O to supply the requested information  
by doing the following:
.ML
.LI
.ne 4
Set the \*Lsec_attr_encoding_t\*O to an encoding type that is 
compatible with the information required by the query attribute trigger.  
.LI
Set the \*Lsec_attr_value_t\*O to hold the 
required information.
.LE
.P
You can define the number of elements in the input array of \*Lsec_attr_t\*O values (in 
the \*Vnum_attr_keys\*O parameter).  If you define the number of elements as 
0 (zero), the call returns all of the object's 
attribute instances that the caller 
is authorized to see.  You should be aware, however, that if you 
define the number of elements as zero and the attribute is associated with 
a query attribute trigger, you will be unable to pass any information to the 
query attribute trigger. 
.H 4 "The \*Lsec_rgy_attr_set_lookup_by_id(\|)\*O Call"
.P
The \*Lsec_rgy_attr_set_lookup_by_id(\|)\*O call reads attribute sets specified by 
set instance UUID for 
an object specified by name and domain.  Specifically the call returns
the following:
.ML
.LI
A \*Lsec_attr_t\*O for each attribute instance in the 
attribute set.  
.LI
A count of the total number of attribute set instances returned.
.LI
A count of the total number that could not be returned because of size constraints of 
the \*Lsec_attr_t\*O array.  (Note that the call allows the size and length of the 
array to be specified.)
.LE
.P
.nS note
Since attribute triggers cannot be associated with an attribute set instance, 
this call 
provides no way to supply input data to a query attribute trigger.  
.nE
.H 4 "The \*Lsec_rgy_attr_lookup_by_name(\|)\*O Call"
.P
The \*Lsec_rgy_attr_lookup_by_name\*O(\|) call reads a single attribute 
instance specified by name 
for an object specified by name and domain.  The call returns a 
\*Lsec_attr_t\*O  for the specified attribute instance.
.P
.ne 3
For multivalued attributes, 
the call returns the first instance of the 
multivalued attribute. (To retrieve every instance of a multivalued attribute, 
use the \*Lsec_rgy_attr_lookup_by_id(\|)\*O call.)
.P
.ne 3
For attribute sets, the call returns the attribute set 
instance, not the member instances.  
To retrieve all members of the set, use the 
\*Lsec_\%rgy_\%attr_\%lookup_\%by_\%id(\|)\*O call.
.P
.nS note
This call provides no way to supply input data to a query attribute trigger.  
If the attribute to be read is 
associated with a query trigger that requires input data, 
use the \*Lsec_\%rgy_\%attr_\%lookup_\%by_\%id(\|)\*O call.  
.nE
...\" .cS
...\" ******NOT AVAILABLE FOR BETA************************
...\" .H 3 "Searching for Attribute Instances"
...\" .P
...\" This section describes calls that search for objects that possess 
...\" specified attribute instances.
...\" .H 4 "Using sec_attr_srch_cursor_t with sec_rgy_attr_srch Calls"
...\" .P
...\" The \*Lsec_rgy_attr_srch_names(\|)(\.)\*O  and \*Lsec_rgy_attr_srch_names_attrs(\|)\*O calls 
...\" use a cursor of type \*Lsec_attr_srch_cursor_t\*O initialized to a list of objects that 
...\" meet a specified criteria.    
...\" This cursor must be initialized before it can be used as input to 
...\" the calls.  After use, the resources allocated to the \*Lsec_attr_srch_cursor_t\*O 
...\" must be released.  The following calls allocate, initialize, and release a 
...\" \*Lsec_attr_srch_cursor_t\*O.
...\" .ML
...\" .LI
...\" \*Lsec_rgy_attr_srch_cursor_init(\|)\*O
...\" .P
...\" The \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call allocates resources to a 
...\" \*Lsec_attr_srch_cursor_t\*O and initializes the cursor to a search set 
...\" of objects that possess specified attribute types or instances.  
...\" The attribute types and attribute instance values searched for are 
...\" identified in an array of 
...\" \*Lsec_attr_t\*O values.   
...\" .P
...\" .P
...\" To find all attributes of a specified type, an attribute UUID is all 
...\" that is required.  For these attributes, supply the UUID of the 
...\" desired attribute type in the input array and set 
...\" attribute encoding (in \*Lsec_attr_encoding_t\*O) to 
...\" \*Lsec_attr_enc_void\*O.
...\" .P 
...\" To find a specific attribute instance, supply that attribute instance's
...\" UUID and value in the \*Lsec_attr_t\*O.  This method is 
...\" useful for finding a single instance of a multivalued attribute.
...\" .P
...\" If you specify an attribute set in the input array, 
...\" only the set instance is found, not the members of the set.  
...\" .P
...\" Query triggers are not supported during evaluation 
...\" of the input \*O array.  
...\" Although an attribute type associated with a query trigger 
...\" can be used in the array, 
...\" if the attribute type also carries a value, a match 
...\" will not be found.  The match will fail because the query 
...\" trigger is not executed; therefore, a value will not 
...\" be retrieved for comparison against the search value.
...\" .P
...\" You can define the number of elements in the input array (in 
...\" the \*Vnum_search_attrs\*O parameter).  If you define the number as 
...\" zero, the search set 
...\" is a list of all attributes in the named domain that 
...\" are managed by the server to which the call is bound.  
...\" The cursor is positioned at the beginning of the 
...\" list.
...\" .LI
...\" \*Lsec_rgy_attr_srch_cursor_release(\|)\*O
...\" .P
...\" The \*Lsec_rgy_attr_srch_cursor_release(\|)\*O call releases all resources 
...\" allocated to a \*Lsec_rgy_attr_srch_cursor\*O cursor.
...\" .LE
...\" .H 4 "sec_rgy_attr_srch_names(\|)"
...\" .P
...\" The \*Lsec_rgy_attr_srch_names(\|)\*O call returns the names of the objects that possess the 
...\" attributes selected in the search set selected by the 
...\" \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call.  Specifically this call returns:
...\" .ML
...\" .LI
...\" An array of names (\*Lsec_rgy_name_t\*O) of the objects that possess the attributes 
...\" specified as input to the \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call.
...\" .LI
...\" A count of the total object names returned.
...\" .LI
...\" An array of values that specify the total number of attributes attached to each object 
...\" whose name is returned in the names array.
...\" .LE
...\" .P
...\" The position of the element in the array of names and the number of 
...\" attributes array connects the object name to the object's total number of attributes.  
...\" As illustrated in the Figure titled "Array Correspondence", the 
...\" object named in position 1 of the array of names has the total number of 
...\" attributes listed in position 1 total number of attributes array. 
...\" .P
...\" .nP
...\" ...\" .ne 2.5
...\" .FG "Array Correspondence"
...\" .pI ../security/figures/4.5_era_30.ps 0 0 1
...\" ...\" .pI security/figures/4.5_era_30.ps 0 0 1
...\" .P
...\" Before this call is executed, must execute the \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call 
...\" to select the search set, initialize a \*Lsec_rgy_attr_srch_cursor_t\*O cursor to the 
...\" beginning of the search set, and allocate resources to the cursor.  
...\" After a \*Lsec_rgy_attr_srch_names(\|)\*O call is 
...\" executed, you must execute a \*Lsec_rgy_attr_srch_cursor_release(\|)\*O call to release 
...\" resources allocated to the cursor.
...\" .H 4 "sec_rgy_attr_srch_names_attrs(\|)"
...\" .P
...\" The \*Lsec_rgy_attr_srch_names_attrs(\|)\*O call returns:
...\" .ML
...\" .LI
...\" The names of the objects that possess the 
...\" attributes in the search set selected by the 
...\" \*Lsec_rgy_attr_srch_cursor_init(\|)\*O call. 
...\" .LI
...\" For those objects, the attributes specified in an array of attribute UUIDs 
...\" supplied as a parameter to this call.
...\" .LE
...\" .P
...\" Except for the fact that you can return attributes in addition to  
...\" object names, the call is similar to the \*Lsec_rgy_attr_srch_names_attrs(\|)\*O call.  
...\" Like the \*Lsec_rgy_attr_srch_names(\|)\*O call, this call returns an 
...\" array of object names (\*Lsec_rgy_name_t\*O), a count of the total object names returned, and 
...\" array of values that specify the total number of attributes attached to each object 
...\" whose name is returned in the names array.  In addition, this call returns the 
...\" following information that is not returned by the \*Lsec_rgy_attr_srch_names(\|)\*O call:
...\" .ML
...\" .LI
...\" A array of specified attribute UUIDs and values (\*Lsec_attr_t\*O).
...\" .LI
...\" A count of the total number of attributes that are attached to the 
...\" object.
...\" .LI
...\" A count of the total number of attributes returned.
...\" .LE
...\" .P
...\" The attributes to be returned are specified in an array type \*Luuid_t\*O values.  
...\" ******NOT AVAILABLE FOR 1.1************************
...\" .cE
.H 2 "The Attribute Trigger Facility"
.P
Some attribute types require the support of an outside server either 
to verify input attribute values or to supply output attribute values 
when those values are stored in an external database. 
Such a server could, for example, 
connect a legacy registry system to the DCE registry.  
The attribute trigger facility provides for automatic calls  
to outside DCE servers, known as \*Eattribute triggers\*O.
.P
Trigger servers, which are written by application developers, 
export the \*Lsec_attr_trig\*O interface.  They 
are invoked automatically when an attribute that has been associated with an 
attribute trigger (during schema entry creation) is queried or updated.  
The attribute trigger facility consists of three components:
.ML
.LI
The attribute schema trigger fields (\*Ltrig_types\*O and 
\*Ltrig_binding\*O) that associate an 
attribute trigger and its binding information with an attribute type.  These 
fields are part of the standard creation of a schema entry that 
defines an attribute type.  See Section 29.1.1.
.LI
The \*Lsec_attr_trig\*O APIs 
that define the query and update trigger operations.  
The APIs are provided in the \*Lsec_attr_trig_\*V*\*L(\|)\*O calls.
.LI
The user-written attribute trigger servers are independent from DCE servers.  
The trigger servers implement the trigger operations for the attribute types 
that require attribute trigger 
processing.  These servers are not provided as part of DCE, 
but must be written by application developers.
.LE  
.H 3 "Defining an Attribute Trigger/Attribute Association"
.P
When an attribute is created with the \*Lsec_rgy_attr_update(\|)\*O call,
you define the association between the attribute type and an attribute trigger 
by specifying the following:
.ML
.LI
Trigger Type
.P
Defines the trigger as a query server (invoked for 
query operations) or an update server (invoked for updates operations).  
The trigger type is defined in a \*Lsec_attr_trig_type_t\*O data type, 
which is used by a \*Lsec_attr_schema_entry_t\*O data type.
.LI
Trigger Binding
.P
Defines the server binding handle for the attribute trigger.  
The details of the trigger binding are defined in a number of data types, 
which are also used by the \*Lsec_attr_schema_entry_t\*O data type.  Trigger 
binding is described in detail in Section 29.1.3.7.
.LE
.P
Only if both of pieces of information are provided will the association between the 
attribute type and the attribute trigger be created.  You can 
associate an attribute trigger to any attribute type of any encoding except for 
attribute sets.
.H 4 "Query Triggers"
.P
When you execute a call that 
accesses an attribute associated 
with a query trigger, the client-side 
attribute lookup code performs the following 
tasks:
.ML
.LI
Binds to the attribute trigger (using a binding from the attribute type's schema entry)
.LI
Makes the remote \*Lsec_attr_trig_query(\|)\*O call to the attribute trigger server, 
passing in the attribute keys and 
optional information provided by the caller
.LI
If the \*Lsec_attr_trig_query(\|)\*O call is successful, returns the output attribute(s) 
to the caller
.LE
.P
.ne 5
If you execute a \*Lsec_rgy_attr(\|)\*O update call with an attribute type 
that is associated with a query trigger, not an update trigger, 
the input attribute values are ignored and a ``stub'' attribute instance 
is created on the 
named object simply to mark the existence of this attribute on the object.  
Modifications 
to the real attribute value must occur at the attribute trigger.
.H 4 "Update Triggers"
.P
When you execute a call that 
accesses an attribute associated 
with an update trigger, the client-side attribute update code 
performs the following tasks:
.ML
.LI
Binds to the attribute trigger (using a binding from the attribute type's schema entry)
.LI
Makes the remote \*Lsec_attr_trig_update(\|)\*O call to the attribute trigger server, 
passing in the 
attributes provided by the 
caller 
.LI
If the \*Lsec_attr_trig_update(\|)\*O call is successful, stores the output attribute(s) 
in the registry database and returns the output attribute(s) to the caller
.LE
.H 3 "Trigger Binding"
.P
Two data types are used to defined an attribute trigger.  The 
\*Lsec_attr_trig_type_t\*O type
defines the type of attribute trigger.  The \*Lsec_attr_bind_info_t\*O 
data type, illustrated in Figure 29-3 and described 
in this section, specifies the attribute trigger's binding.
.P
.ne 4.5i
.FG "The sec_attr_bind_info_t Data Type"  
.pI ../security/figures/4.5_era_40.ps 4i 5.1i
...\" .pI security/figures/4.5_era_40.ps 0 0 1
.sp .5
.P  
The \*Lsec_attr_bind_info_t\*O data type uses two data types:  
\*Lsec_attr_binding_t\*O, 
which defines the information used to generate binding handle 
and \*Lsec_attr_bind_auth_info_t\*O, which defines the 
binding authentication and 
authorization information.
.H 4 "The \*Lsec_attr_binding_t\*O Data Type"
.P
To describe the binding handle, the \*Lsec_attr_binding_t\*O type uses a 
\*Lsec_attr_bind_type_t\*O data type that specifies the format to the 
data used to generate the binding handle and a tagged union that 
contains the binding handle.  The binding handle can 
be generated from any of the following:
.ML
.ne 9
.LI
\*LA server directory entry name\*O (used 
with \*Lrpc_\%ns_\%binding_\%import_\%\*V*\*L(\|)\*O calls)
.P
If the binding information is a server name, 
call \*Lrpc_\%ns_\%binding_\%import_\%begin(\|)\*O 
to establish a context for importing RPC 
binding handles from the name service database.  
For the \*Lrpc_\%ns_\%binding_\%import_\%begin(\|)\*O call, 
specify the CDS server directory entry name, an entry name syntax value of  
\*Lrpc_c_ns_syntax_dce\*O, and \*Lsec_attr_trig\*O as the interface handle 
of the interface to import. 
.LI
\*LA string binding\*O (used with \*Lrpc_binding_from_string_binding(\|)\*O calls)
.P
If the binding information is a string binding, call 
\*Lrpc_\%binding_\%from_\%string_\%binding(\|)\*O to 
generate an RPC binding handle.
.P
.LI
\*LAn RPC protocol tower set\*O (used with \*Lrpc_tower_to_binding(\|)\*O calls)
.P
If the binding information is a protocol tower, two additional data types are used to pass in an 
unallocated array of towers, which the server must then allocate.  These 
data types are \*Lsec_attr_twr_ref_t\*O to point to the tower and 
\*Lsec_attr_twr_set_t\*O to define the array of towers.  
.P
Architectural components of DCE can take advantage 
of the internal \*Lrpc_tower_to_binding\*O 
operation in \*Lrpcpvt.idl\*O to generate a binding handle from the 
canonical representation of 
a protocol tower.
.LE
.P
Although the server directory entry name, with the actual server 
address stored in CDS, is the recommended 
way to specify an 
attribute trigger binding handle, prototype applications may want to specify a 
string binding or protocol tower for convenience.  
.H 4 "The \*Lsec_attr_bind_auth_info_t\*O Data Type"
.P
To describe whether or not RPC calls to the server will be authenticated and,
for authenticated calls, to provide authentication and 
authorization information,  
the \*Lsec_attr_bind_auth_info_t\*O type uses the 
\*Lsec_\%attr_\%bind_\%auth_\%info_\%type_\%t\*O data type, 
and a tagged union.  The 
\*Lsec_\%attr_\%bind_\%auth_\%info_\%type_\%t\*O type defines whether or not the call is 
authenticated.  The tagged union contains the authentication and authorization 
parameters.    
.P
.ne 3
Once a binding handle is obtained, 
call \*Lrpc_binding_set_auth_info(\|)\*O and supply it with the 
binding handle and authorization and authentication 
information.
.H 3 "Access Control on Attributes with Triggers"
.P
When a query or update call accesses an attribute associated with an
attribute trigger, the call checks the ACL of the 
object with which the attribute is associated to see if the 
client has the permissions required for the operation.  
If access is granted, the operation returns a
binding handle authenticated with the client's login context.  
This handle is then used to 
perform the the \*Lsec_attr_trig_query\*O 
or \*Lsec_attr_trig_update\*O operation.   
.P
Access to information maintained by an attribute trigger is controlled entirely by that 
attribute trigger.  The attribute trigger can choose to implement any authorization mechanism, 
including none.   For example, the attribute trigger can
obtain the client's identity from the RPC runtime to  
perform name-based authentication and perform ACL 
checks (or any other type of access control mechanism), 
and it can query the registry 
attribute schema for the attribute type's 
permission set  to use for an ACL check. 
Access control
on attribute information stored outside of the registry database 
is left to the application designer.
.H 2 "Calls that Access Attribute Triggers"
.P
This section describes the calls that send information to 
and receive it from attribute triggers.
.H 3 "Using sec_attr_trig_cursor_t with sec_attr_trig_query(\|)"
.P
The \*Lsec_attr_trig_query(\|)\*O call, which reads attributes associated with 
a query attribute trigger, uses a cursor of type 
\*Lsec_attr_trig_cursor_t\*O.  
This cursor must be allocated and initialized before it can be used as input to 
the \*Lsec_attr_trig_query(\|)\*O call.  
After use, the resources allocated to \*Lsec_attr_trig_cursor_t\*O 
must be released.
.P
The following calls allocate, initialize, and 
release a \*Lsec_\%attr_\%trig_\%cursor_\%t\*O type for 
use with the \*Lsec_attr_trig_query(\|)\*O call:
.ML
.LI
\*Lsec_attr_trig_cursor_init(\|)\*O
.P   
The \*Lsec_attr_trig_cursor_init(\|)\*O 
call allocates resources to the cursor and 
initializes the cursor to the first attribute in the list of attributes 
for the object whose binding handle is specified.  
This call makes a remote call.
.P
.LI
\*Lsec_attr_trig_cursor_release(\|)\*O 
.P
The \*Lsec_rgy_attr_cursor_release(\|)\*O call releases 
all resources 
allocated to a \*Lsec_attr_trig_cursor_t\*O type
by \*Lsec_attr_trig_cursor_init(\|)\*O. 
.LE
.H 3 "The sec_rgy_attr_trig_query(\|) and sec_rgy_attr_trig_update(\|) Calls"
.P
The \*Lsec_attr_trig_query(\|)\*O call 
reads instances of attributes coded with a trigger type of query for a specified object.  
It passes an array of \*Lsec_attr_t\*O values to a  
query attribute trigger and receives the output parameters 
back from the server.  
The \*Lsec_attr_trig_update(\|)\*O routine 
passes attributes coded with a trigger type of update 
to an update attribute trigger for evaluation 
before the updates are made to the registry. 
.P
Both calls are called automatically by 
the DCE attribute lookup or update code for all schema entries that 
specify a trigger.  
Although you should not call these
calls directly, if you are implementing a trigger 
server, it will receive input from these calls and the 
attribute trigger's output should be passed back to them.  The data received must be 
in a form accessible to the call and, if it is the result of an update, a 
form that can be stored in the registry database.
.P
The object whose attribute instances are to be read or updated is identified by
.ML
.LI
The name of the cell in which the object exists
.LI
The name of the object or a UUID in string format 
that identifies the object
.LE
.H 3 "The priv_attr_triq_query(\|) Call"
.P
The \*Lpriv_attr_trig_query(\|)\*O call is used by the privilege service to retrieve 
trigger attributes and add them to a 
princpal's EPAC.  The privilege service executes this call when it 
receives a request to add a principal and its extended attribute instances to an EPAC and the 
attributes are associated with a trigger server.  
The call passes an array of
\*Lsec_attr_t\*O values to the   
attribute trigger and receives the attribute values back from the trigger server 
in another array of \*Lsec_attr_t\*O values.  
If the principal is being added to a delegation chain, the call also passes the 
UUIDs of all of the current members of the delegation chain to the trigger server.  
The trigger server can then evaluate all identities to determine access rights to the 
requested attributes.
.P
Like the \L*sec_rgy_attr_trig_query(\|)\*O and 
\*Lsec_rgy_attr_trig_update(\|)\*O calls, you will not call \*Lpriv_attr_trig_query(\|)\*O 
directly.  However, if you are implementing a trigger 
server, it will receive input from these call and the 
attribute trigger's output should be passed back to the call.  The data received must be 
in a form accessible to the call.
.H 2 "The DCE Attribute API"
.P
The DCE attribute calls are not described in detail.  This is 
because, with the exception of the calls that bind to a selected 
database (\*Ldce_\%attr_\%sch_\%bind(\|)(\*)\*O and 
\*Ldce_attr_sch_bind_free(\|)\*O), 
the \*Ldce_\%sec_\%attr_\*V*\*L(\|)\*O calls 
are the same as the \*Lsec_rgy_attr_sch_\*V*\*L(\|)\*O 
calls.  Refer to Section 29.1 for information on 
using each call.  Note also that the DCE attribute calls are suffixed with 
\*L3dce\*O, not \*L3sec\*O (for example, \*Ldce_\%attr_\%sch_\%bind.3dce\*O).
.P
The DCE attribute API consists of the following calls:
.ML
.LI
\*Ldce_attr_sch_bind(\|)\*O
.P
Returns an opaque handle of 
type \*Ldce_attr_sch_handle_t\*O to a 
schema object specified by name and sets authentication and 
authorization parameters for the handle.  This is the call used 
to bind to the schema of your choice.
.LI 
\*Ldce_attr_sch_bind_free(\|)\*O
.P
Releases an opaque handle of 
type \*Ldce_attr_sch_handle_t\*O.
.LI
\*Ldce_attr_sch_create_entry(\|)\*O
.P
Creates a schema entry in a schema 
bound to with \*Ldce_attr_sch_bind\*O.  This call is based on 
\*Lsec_rgy_attr_sch_create_entry(\|)\*O and is used in the same way. 
.LI
\*Ldce_attr_sch_update_entry(\|)\*O
.P
Updates a schema entry in a schema bound to with \*Ldce_attr_sch_bind(\|)\*O.  
This call is based on 
\*Lsec_\%rgy_\%attr_\%sch_\%update_\%entry(\|)\*O and is used in the same way. 
.LI
\*Ldce_attr_sch_delete_entry(\|)\*O
.P
Deletes a schema entry in a schema bound to with \*Ldce_attr_sch_bind(\|)\*O.  
This call is based on 
\*Lsec_rgy_attr_sch_delete_entry(\|)\*O and is used in the same way. 
.LI 
\*Ldce_attr_sch_scan(\|)\*O
.P
Reads a specified number of schema entries.  This call is based on 
\*Lsec_rgy_attr_sch_scan(\|)\*O and is used in the same way. 
.LI
\*Ldce_attr_sch_cursor_init(\|)\*O
.P
Allocates resources 
to and initializes a cursor used with \*Ldce_attr_sch_scan(\|)\*O. 
The \*Ldce_attr_sch_cursor_init(\|)\*O routine makes a
remote call that also returns the current number of 
schema entries in the schema.
The \*Ldce_attr_sch_cursor_init(\|)\*O call is based on 
\*Lsec_rgy_attr_sch_cursor_init(\|)\*O and is used in the same way. 
.LI
.ne 6
\*Ldce_attr_sch_cursor_alloc(\|)\*O
.P
Allocates resources to a cursor 
used with \*Ldce_attr_sch_scan(\|)\*O.  The \*Ldce_attr_sch_cursor_alloc(\|)\*O 
routine is a local operation.
The \*Ldce_attr_sch_cursor_alloc(\|)\*O 
call is based on 
\*Lsec_\%rgy_\%attr_\%sch_\%cursor_\%alloc(\|)\*O and is used in the same way. 
.LI
\*Ldce_attr_sch_cursor_release(\|)\*O
.P
Releases states associated with a 
cursor created by \*Ldce_attr_sch_cursor_alloc(\|)\*O or 
\*Ldce_attr_sch_cursor_init(\|)\*O.
The \*Ldce_attr_sch_cursor_release(\|)\*O call is based on 
\*Lsec_\%rgy_\%attr_\%sch_\%cursor_\%release(\|)\*O and is used in the same way. 
.LI 
\*Ldce_attr_sch_cursor_reset(\|)\*O
.P
Reinitializes a cursor used with 
\*Ldce_attr_sch_scan(\|)\*O.  The reset cursor can then be reused without 
releasing and reallocating.
This call is based on the 
\*Lsec_rgy_attr_sch_cursor_reset(\|)\*O and is used in the same way. 
.LI 
\*Ldce_attr_sch_lookup_by_id(\|)\*O
.P
Reads a schema entry identified by UUID.  This call is based on 
\*Lsec_rgy_attr_lookup_by_id(\|)\*O and is used in the same way. 
.LI
\*Ldce_attr_sch_lookup_by_name(\|)\*O
.P
Reads a schema entry identified by name.  
This call is based on 
\*Lsec_rgy_attr_sch_lookup_by_name(\|)\*O and is used in the same way. 
.LI
\*Ldce_attr_sch_get_acl_mgrs(\|)\*O
.P
Retrieves the UUIDs of ACL manager types 
protecting objects dominated by a named schema.  This call is based on 
\*Lsec_rgy_attr_sch_get_acl_mgrs(\|)\*O and is used in the same way.  
.LI
\*Ldce_attr_sch_aclmgr_strings(\|)\*O
.P
Retrieves the print strings containing information about ACL manager types 
protecting objects dominated by a named schema.  The print 
strings contain the manager's 
name, help information, and supported permission bits.  This call is based 
on \*Lsec_\%rgy_\%attr_\%sch_\%aclmgr_\%strings(\|)\*O and is used in the same way.  
.LE
.H 2 "Macros to Aid Extended Attribute Programming"
.P
The extended attribute APIs includes macros to help programmers using the 
extended 
attribute interfaces.  The 
macros perform a variety of function including
.P
.ML
.LI
Accessing fields in data structures
.LI
Calculating the size of data structures
.LI
Performing semantic and flag checks 
.LI
Setting flags
.LE
.P
The macros are in \*Ldce/rpcbase.h\*O, which is derived 
from \*Ldce/rpcbase.idl\*O.
.P
The following subsections list the definitions of each macro.
.H 3 "Macros to Access Binding Fields"
.P
In the following macro definitions, which are used by a 
\*Lsec_attr_schema_entry_t\*O and its equivalent \*Ldce_attr_sch\*O 
data type, B is a pointer to \*Lsec_attr_bind_info_t\*O.
.nL
.ps 10
.vs 12
.oS
.ne 50
#define SA_BND_AUTH_INFO(B)		(B)->auth_info
#define SA_BND_AUTH_INFO_TYPE(B)	(SA_BND_AUTH_INFO(B)).info_type

#define SA_BND_AUTH_SVR_PNAME_P(B) \\
 
	(SA_BND_AUTH_DCE_INFO(B)).svr_princ_name

#define SA_BND_AUTH_PROT_LEVEL(B) \\
 
        (SA_BND_AUTH_DCE_INFO(B)).protect_level

#define SA_BND_AUTH_AUTHN_SVC(B) \\
 
        	(SA_BND_AUTH_DCE_INFO(B)).authn_svc

#define SA_BND_AUTH_AUTHZ_SVC(B) \\
 
	(SA_BND_AUTH_DCE_INFO(B)).authz_svc

#define SA_BND_NUM(B)			(B)->num_bindings
#define SA_BND_ARRAY(B,I)		(B)->bindings[I]
#define SA_BND_TYPE(B,I)		(SA_BND_ARRAY(B,I)).bind_type

#define SA_BND_STRING_P(B,I) \\
 
	(SA_BND_ARRAY(B,I)).tagged_union.string_binding

#define SA_BND_SVRNAME_P(B,I) \\
 
	(SA_BND_ARRAY(B,I)).tagged_union.svrname

#define SA_BND_SVRNAME_SYNTAX(B,I) \\
 
	(SA_BND_SVRNAME_P(B,I))->name_syntax

#define SA_BND_SVRNAME_NAME_P(B,I) \\
 
	(SA_BND_SVRNAME_P(B,I))->name

#define SA_BND_TWRSET_P(B,I) \\
 
	(SA_BND_ARRAY(B,I)).tagged_union.twr_set

#define SA_BND_TWRSET_COUNT(B,I)	(SA_BND_TWRSET_P(B,I))->count
#define SA_BND_TWR_P(B,I,J)		(SA_BND_TWRSET_P(B,I))->towers[J]
#define SA_BND_TWR_LEN(B,I,J)		(SA_BND_TWR_P(B,I,J))->tower_length

#define SA_BND_TWR_OCTETS(B,I,J) \\
 
	(SA_BND_TWR_P(B,I,J))->tower_octet_string\*O
.oE
.P
.ps 12
.vs 14
.H 3 "Macros to Access Schema Entry Fields
.P
In the following macro definitions, 
S is a pointer to \*Lsec_attr_schema_entry_t\*O 
(and its equivalent \*Ldce_attr_sch\*O data type) and 
I and J are nonnegative integers for array element selection.
.nL
.ps 10
.vs 12
.oS
#define SA_ACL_MGR_SET_P(S)		(S)->acl_mgr_set
#define SA_ACL_MGR_NUM(S)		(SA_ACL_MGR_SET_P(S))->num_acl_mgrs
#define SA_ACL_MGR_INFO_P(S,I)		(SA_ACL_MGR_SET_P(S))->mgr_info[I]
#define SA_ACL_MGR_TYPE(S,I)		(SA_ACL_MGR_INFO_P(S,I))->acl_mgr_type
#define SA_ACL_MGR_PERMS_QUERY(S,I)	(SA_ACL_MGR_INFO_P(S,I))->query_permset
#define SA_ACL_MGR_PERMS_UPDATE(S,I)	(SA_ACL_MGR_INFO_P(S,I))->update_permset
#define SA_ACL_MGR_PERMS_TEST(S,I)	(SA_ACL_MGR_INFO_P(S,I))->test_permset
#define SA_ACL_MGR_PERMS_DELETE(S,I)	(SA_ACL_MGR_INFO_P(S,I))->delete_permset
#define SA_TRG_BND_INFO_P(S)		(S)->trig_binding

#define SA_TRG_BND_AUTH_INFO(S) \\
 
	(SA_BND_AUTH_INFO(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_INFO_TYPE(S) \\
 
	(SA_BND_AUTH_INFO_TYPE(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_DCE_INFO(S) \\
 
	(SA_BND_AUTH_DCE_INFO(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_SVR_PNAME_P(S) \\
 
	(SA_BND_AUTH_SVR_PNAME_P(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_PROT_LEVEL(S) \\
 
	(SA_BND_AUTH_PROT_LEVEL(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_AUTHN_SVC(S) \\
 
	(SA_BND_AUTH_AUTHN_SVC(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_AUTHZ_SVC(S) \\
 
	(SA_BND_AUTH_AUTHZ_SVC(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_NUM(S) \\
 
	(SA_BND_NUM(SA_TRG_BND_INFO_P(S)))

.ne 3
#define SA_TRG_BND_ARRAY(S,I) \\
 
	(SA_BND_ARRAY((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_TYPE(S,I) \\
 
	(SA_BND_TYPE((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_STRING_P(S,I) \\
 
	(SA_BND_STRING_P((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_SVRNAME_P(S,I) \\
 
	(SA_BND_SVRNAME_P((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_SVRNAME_SYNTAX(S,I) \\
 
        (SA_BND_SVRNAME_SYNTAX((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_SVRNAME_NAME_P(S,I) \\
 
        (SA_BND_SVRNAME_NAME_P((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_TWRSET_P(S,I) \\
 
	(SA_BND_TWRSET_P((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_TWRSET_COUNT(S,I) \\
 
	(SA_BND_TWRSET_COUNT((SA_TRG_BND_INFO_P(S)),I))

#define SA_TRG_BND_TWR_P(S,I,J) \\
 
	(SA_BND_TWR_P((SA_TRG_BND_INFO_P(S)),I,J))

#define SA_TRG_BND_TWR_LEN(S,I,J) \\
 
	(SA_BND_TWR_LEN((SA_TRG_BND_INFO_P(S)),I,J))

#define SA_TRG_BND_TWR_OCTETS(S,I,J) \\
 
	(SA_BND_TWR_OCTETS((SA_TRG_BND_INFO_P(S)),I,J))
.oE
.P
.ps 12
.vs 14
.H 3 "Macros to Access Attribute Instance Fields"
.P
In the following macro descriptions, 
S is a pointer to \*Lsec_attr_t\*O, and 
I and J are nonnegative integers for array element selection.
.nL
.ps 10
.vs 12
.oS
#define SA_ATTR_ID(S)			(S)->attr_id
#define SA_ATTR_VALUE(S)		(S)->attr_value
#define SA_ATTR_ENCODING(S)		(SA_ATTR_VALUE(S)).attr_encoding

#define SA_ATTR_INTEGER(S) \\
 
	(SA_ATTR_VALUE(S)).tagged_union.signed_int

#define SA_ATTR_PRINTSTRING_P(S) \\

	(SA_ATTR_VALUE(S)).tagged_union.printstring
 

#define SA_ATTR_STR_ARRAY_P(S) \\
 
	(SA_ATTR_VALUE(S)).tagged_union.string_array

#define SA_ATTR_STR_ARRAY_NUM(S)	(SA_ATTR_STR_ARRAY_P(S))->num_strings
#define SA_ATTR_STR_ARRAY_ELT_P(S,I)	(SA_ATTR_STR_ARRAY_P(S))->strings[I]

#define SA_ATTR_BYTES_P(S) \\
 
	(SA_ATTR_VALUE(S)).tagged_union.bytes

#define SA_ATTR_BYTES_LEN(S)		(SA_ATTR_BYTES_P(S))->length
#define SA_ATTR_BYTES_DATA(S,I)		(SA_ATTR_BYTES_P(S))->data[I]

#define SA_ATTR_IDATA_P(S) \\
 
	(SA_ATTR_VALUE(S)).tagged_union.idata

#define SA_ATTR_IDATA_CODESET(S)	(SA_ATTR_IDATA_P(S))->codeset
#define SA_ATTR_IDATA_LEN(S)		(SA_ATTR_IDATA_P(S))->length
#define SA_ATTR_IDATA_DATA(S,I)		(SA_ATTR_IDATA_P(S))->data[I]

#define SA_ATTR_UUID(S) \\
 
	(SA_ATTR_VALUE(S)).tagged_union.uuid

#define SA_ATTR_SET_P(S) \\
 
	(SA_ATTR_VALUE(S)).tagged_union.attr_set

.ne 3
#define SA_ATTR_SET_NUM(S)		(SA_ATTR_SET_P(S))->num_members
#define SA_ATTR_SET_MEMBERS(S,I)	(SA_ATTR_SET_P(S))->members[I]

#define SA_ATTR_BND_INFO_P(S) \\
 
	(SA_ATTR_VALUE(S)).tagged_union.binding

#define SA_ATTR_BND_AUTH_INFO(S) \\
 
	(SA_BND_AUTH_INFO(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_INFO_TYPE(S) \\
 
	(SA_BND_AUTH_INFO_TYPE(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_DCE_INFO(S) \\
 
	(SA_BND_AUTH_DCE_INFO(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_SVR_PNAME_P(S) \\

	(SA_BND_AUTH_SVR_PNAME_P(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_PROT_LEVEL(S) \\
 
	(SA_BND_AUTH_PROT_LEVEL(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_AUTHN_SVC(S) \\
 
	(SA_BND_AUTH_AUTHN_SVC(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_AUTHZ_SVC(S) \\
 
	(SA_BND_AUTH_AUTHZ_SVC(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_NUM(S) \\
 
	(SA_BND_NUM(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_ARRAY(S,I) \\
 
	(SA_BND_ARRAY((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_TYPE(S,I) \\
 
	(SA_BND_TYPE((SA_ATTR_BND_INFO_P(S)),I))

.ne 3
#define SA_ATTR_BND_STRING_P(S,I) \\
 
	(SA_BND_STRING_P((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_SVRNAME_P(S,I) \\
 
	(SA_BND_SVRNAME_P((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_SVRNAME_SYNTAX(S,I) \\
 
        (SA_BND_SVRNAME_SYNTAX((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_SVRNAME_NAME_P(S,I) \\
 
        (SA_BND_SVRNAME_NAME_P((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_TWRSET_P(S,I) \\
 
	(SA_BND_TWRSET_P((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_TWRSET_COUNT(S,I) \\
 
	(SA_BND_TWRSET_COUNT((SA_ATTR_BND_INFO_P(S)),I))

#define SA_ATTR_BND_TWR_P(S,I,J) \\
 
	(SA_BND_TWR_P((SA_ATTR_BND_INFO_P(S)),I,J))

#define SA_ATTR_BND_TWR_LEN(S,I,J) \\
 
	(SA_BND_TWR_LEN((SA_ATTR_BND_INFO_P(S)),I,J))

#define SA_ATTR_BND_TWR_OCTETS(S,I,J) \\
 
	(SA_BND_TWR_OCTETS((SA_ATTR_BND_INFO_P(S)),I,J))
.oE
.P
.ps 12
.vs 14
.H 3 "Binding Data Structure Size Calculation Macros"
.P
The following macros are supplied to calculate the size 
of data types that hold binding information.  The macros 
work with the ERA API data types 
and their equivalent \*Ldce_attr_sch\*O 
data types.
.nL
.ps 10
.vs 12
.oS
/*
 * SA_BND_INFO_SIZE(N) - calculate the size required
 * for a sec_attr_bind_info_t with N bindings.
 */
#define SA_BND_INFO_SIZE(N) ( sizeof(sec_attr_bind_info_t) + \\
 
        (((N) - 1) * sizeof(sec_attr_binding_t)) )

.ne 7
/*
 * SA_TWR_SET_SIZE(N) - calculate the size required
 * for a sec_attr_twr_set_t with N towers.
 */
#define SA_TWR_SET_SIZE(N) ( sizeof(sec_attr_twr_set_t) + \\
 
        (((N) - 1) * sizeof(sec_attr_twr_ref_t)) )

/*
 * SA_TWR_SIZE(N) - calculate the size required
 * for a twr_t with a tower_octet_string of length N.
 */
#define SA_TWR_SIZE(N) ( sizeof(twr_t) + (N) - 1 )
.oE
.P
.ps 12
.vs 14
.H 3 "Schema Entry Data Structure Size Calculation Macros"
.P
The following macro is supplied to calculate the size 
of a \*Lsec_attr_alc_mgr_info_set_t\*O data type.
.nL
.ps 10
.vs 12
.oS
/*
 * SA_ACL_MGR_SET_SIZE(N) - calculate the size required
 * for a sec_attr_acl_mgr_info_set_t with N acl_mgrs.
 */
#define SA_ACL_MGR_SET_SIZE(N) ( sizeof(sec_attr_acl_mgr_info_set_t) + \\
 
        (((N) - 1) * sizeof(sec_attr_acl_mgr_info_p_t)) )
.oE
.P
.ps 12
.vs 14
.H 3 "Attribute Instance Data Structure Size Calculation Macros"
.P
The following macros are supplied to calculate the size 
of data types that hold attribute information.
.nL
.ps 10
.vs 12
.oS
/*
 * SA_ATTR_STR_ARRAY_SIZE(N) - calculate the size required
 * for a sec_attr_enc_str_array_t with N sec_attr_enc_printstring_p_t-s.
 */
#define SA_ATTR_STR_ARRAY_SIZE(N) ( sizeof(sec_attr_enc_str_array_t) + \\
 
        (((N) - 1) * sizeof(sec_attr_enc_printstring_p_t)) )

.ne 5
/*
 * SA_ATTR_BYTES_SIZE(N) - calculate the size required
 * for a sec_attr_enc_bytes_t with byte string length of N.
 */
#define SA_ATTR_BYTES_SIZE(N) ( sizeof(sec_attr_enc_bytes_t) + (N) - 1 )

/*
 * SA_ATTR_IDATA_SIZE(N) - calculate the size required
 * for a sec_attr_i18n_data_t with byte string length of N.
 */
#define SA_ATTR_IDATA_SIZE(N) ( sizeof(sec_attr_i18n_data_t) + (N) - 1 )

/*
 * SA_ATTR_SET_SIZE(N) - calculate the size required
 * for a sec_attr_enc_attr_set_t with N members (uuids).
 */
#define SA_ATTR_SET_SIZE(N) ( sizeof(sec_attr_enc_attr_set_t) + \\
 
        (((N) - 1) * sizeof(uuid_t)) )
.oE
.P
.ps 12
.vs 14
.H 3 "Binding Semantic Check Macros"
.P
The following macros are supplied to check the semantics of 
entries in the binding fields.  The macros 
work with the ERA API data types 
and their equivalent \*Ldce_attr_sch\*O 
data types.
.nL
.ps 10
.vs 12
.oS
/*
 * SA_BND_AUTH_INFO_TYPE_VALID(B) - evaluates to TRUE (1)
 * if the binding auth_info type is valid; FALSE (0) otherwise.
 * B is a pointer to a sec_attr_bind_info_t.
 */
#define SA_BND_AUTH_INFO_TYPE_VALID(B)	( \\
 
    (SA_BND_AUTH_INFO_TYPE(B)) == sec_attr_bind_auth_none	|| \\
 
    (SA_BND_AUTH_INFO_TYPE(B)) == sec_attr_bind_auth_dce ? true : false )

/*
 * SA_BND_AUTH_PROT_LEV_VALID(B) - evaluates to TRUE (1)
 * if the binding auth_info protect_level is valid; FALSE (0) otherwise.
 * B is a pointer to a sec_attr_bind_info_t.
 */
#define SA_BND_AUTH_PROT_LEV_VALID(B)	( \\
 
.ne 6
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_default		|| \\
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_none		|| \\
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_connect		|| \\
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_call		|| \\
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_pkt		|| \\
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_pkt_integ	|| \\
 
    (SA_BND_AUTH_PROT_LEVEL(B)) == rpc_c_protect_level_pkt_privacy ? \\
 
    true : false )

/*
 * SA_BND_AUTH_AUTHN_SVC_VALID(B) - evaluates to TRUE (1)
 * if the binding auth_info authentication service is valid; 
 * FALSE (0) otherwise.
 * B is a pointer to a sec_attr_bind_info_t.
 */
#define SA_BND_AUTH_AUTHN_SVC_VALID(B)	( \\
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_none		|| \\
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_dce_secret	|| \\
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_dce_public	|| \\
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_dce_dummy		|| \\
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_dssa_public	|| \\
 
    (SA_BND_AUTH_AUTHN_SVC(B)) == rpc_c_authn_default ? \\
    true : false )

/*
 * SA_BND_AUTH_AUTHZ_SVC_VALID(B) - evaluates to TRUE (1)
 * if the binding auth_info authorization service is valid; 
 * FALSE (0) otherwise.
 * B is a pointer to a sec_attr_bind_info_t.
 */
#define SA_BND_AUTH_AUTHZ_SVC_VALID(B)	( \\
 
.ne 8
    (SA_BND_AUTH_AUTHZ_SVC(B)) == rpc_c_authz_none	|| \\
 
    (SA_BND_AUTH_AUTHZ_SVC(B)) == rpc_c_authz_name	|| \\
 
    (SA_BND_AUTH_AUTHZ_SVC(B)) == rpc_c_authz_dce ? \\
 
    true : false )
.oE
.P
.ps 12
.vs 14
.H 3 "Schema Entry Semantic Check Macros"
.P
The following macros are supplied to check the semantics of 
schema entry fields.  In the macros, S is a pointer to 
\*Lsec_attr_schema_entry_t\*O and its equivalent \*Ldce_attr_sch\*O 
data type.
.nL
.ps 10
.vs 12
.oS
#define SA_TRG_BND_AUTH_INFO_TYPE_VALID(S) \\
 
	(SA_BND_AUTH_INFO_TYPE_VALID(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_PROT_LEV_VALID(S) \\
 
	(SA_BND_AUTH_PROT_LEV_VALID(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_AUTHN_SVC_VALID(S) \\
 
	(SA_BND_AUTH_AUTHN_SVC_VALID(SA_TRG_BND_INFO_P(S)))

#define SA_TRG_BND_AUTH_AUTHZ_SVC_VALID(S) \\
 
	(SA_BND_AUTH_AUTHZ_SVC_VALID(SA_TRG_BND_INFO_P(S))
.oE
.P
.ps 12
.vs 14
.H 3 "Attribute Instance Semantic Check Macros"
.P
The following macros are supplied to check the semantics of 
entries in the attribute instance fields.  In the following macros, 
S is a pointer to \*Lsec_attr_t\*O.  F is a 
\*Lsec_attr_trigs_types_flags_t\*O. 
.nL
.ps 10
.vs 12
.oS
.ne 35
#define SA_ATTR_BND_AUTH_INFO_TYPE_VALID(S) \\
 
	(SA_BND_AUTH_INFO_TYPE_VALID(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_PROT_LEV_VALID(S) \\
 
	(SA_BND_AUTH_PROT_LEV_VALID(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_AUTHN_SVC_VALID(S) \\
 
	(SA_BND_AUTH_AUTHN_SVC_VALID(SA_ATTR_BND_INFO_P(S)))

#define SA_ATTR_BND_AUTH_AUTHZ_SVC_VALID(S) \\
 
	(SA_BND_AUTH_AUTHZ_SVC_VALID(SA_ATTR_BND_INFO_P(S))

#define SA_SCH_FLAG_IS_SET(S,F) \\
 
	(((S)->schema_entry_flags & (F)) == (F))

#define SA_SCH_FLAG_IS_SET_UNIQUE(S) \\
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_sch_entry_unique))

#define SA_SCH_FLAG_IS_SET_MULTI_INST(S) \\
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_sch_entry_multi_inst))

#define SA_SCH_FLAG_IS_SET_RESERVED(S) \\
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_sch_entry_reserved))

#define SA_SCH_FLAG_IS_SET_USE_DEFAULTS(S) \\
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_sch_entry_use_defaults))
.oE
.P
.ps 12
.vs 14
.H 3 "Schema Entry Flag Set and Unset Macros"
.P
The following macros set and unset flag(s) in 
the schema entry \*Lschema_entry_flags\*O field.    
In the following macros, S is a pointer to \*Lsec_attr_schema_entry_t\*O.  
.nL
.ps 10
.vs 12
.oS
.ne 41
/*
 * Macros to set the flags. 
 */
#define SA_SCH_FLAG_SET(S, FLAG) ((S)->schema_entry_flags |= (FLAG))

#define SA_SCH_FLAG_SET_UNIQUE(S) \\
 
        (SA_SCH_FLAG_SET((S),sec_attr_sch_entry_unique))

#define SA_SCH_FLAG_SET_MULTI_INST(S) \\
 
        (SA_SCH_FLAG_SET((S),sec_attr_sch_entry_multi_inst))

#define SA_SCH_FLAG_SET_RESERVED(S) \\
 
        (SA_SCH_FLAG_SET((S),sec_attr_sch_entry_reserved))

#define SA_SCH_FLAG_SET_USE_DEFAULTS(S) \\
 
        (SA_SCH_FLAG_SET((S),sec_attr_sch_entry_use_defaults))

/*
 * Macros to unset the flags. 
 */
#define SA_SCH_FLAG_UNSET(S, FLAG) ((S)->schema_entry_flags &= ~(FLAG))

#define SA_SCH_FLAG_UNSET_UNIQUE(S) \\
 
        (SA_SCH_FLAG_UNSET((S),sec_attr_sch_entry_unique))

#define SA_SCH_FLAG_UNSET_MULTI_INST(S) \\
 
        (SA_SCH_FLAG_UNSET((S),sec_attr_sch_entry_multi_inst))

#define SA_SCH_FLAG_UNSET_RESERVED(S) \\
 
        (SA_SCH_FLAG_UNSET((S),sec_attr_sch_entry_reserved))

#define SA_SCH_FLAG_UNSET_USE_DEFAULTS(S) \\
 
        (SA_SCH_FLAG_UNSET((S),sec_attr_sch_entry_use_defaults))
.oE
.P
.ps 12
.vs 14
.H 3 "Schema Trigger Entry Flag Check Macros"
.P
The following macros evaluate to TRUE if the requested flag(s) is 
set in the schema entry \*Ltrig_types\*O field.    
In the following macros, S is a pointer to \*Lsec_attr_schema_entry_t\*O and 
F is a \*Lsec_attr_trigs_types_flags_t\*O type.  
.nL
.ps 10
.vs 12
.oS
.ne 15
#define SA_SCH_TRIG_FLAG_IS_SET(S,F) \\

	(((S)->trig_types & (F)) == (F))

#define SA_SCH_TRIG_FLAG_IS_NONE(S) \\
 
	(SA_SCH_TRIG_FLAG_IS_SET((S),sec_attr_trig_type_none))

#define SA_SCH_TRIG_FLAG_IS_QUERY(S) \\
 
	(SA_SCH_TRIG_FLAG_IS_SET((S),sec_attr_trig_type_query))

#define SA_SCH_TRIG_FLAG_IS_UPDATE(S) \\
 
	(SA_SCH_FLAG_IS_SET((S),sec_attr_trig_type_update))
.oE
.nL
.ps 12
.vs 14
.H 2 "Utilities to Use with Extended Attribute Calls"
.P
The extended attribute APIs includes utilities to help programmers using 
the extended attribute interfaces.  These utilities are
.ML
.LI
\*Lsec_attr_util_alloc_copy\*O\(emCopies data from one \*Lsec_attr_t\*O 
data type to another.
.LI
\*Lsec_attr_util_free\*O\(emFrees memory allocated to \*Lsec_attr_t\*O 
by the \*Lsec_attr_util_alloc_copy(\|)\*O function.
.LI
\*Lsec_attr_util_inst_free_ptrs\*O\(emFrees nonnull pointers in a 
\*Lsec_attr_t\*L type.
.LI
\*Lsec_attr_util_inst_free\*O\(emFrees nonnull pointers in a 
\*Lsec_attr_t\*O type and the pointer to the \*Lsec_attr_t\*O 
itself.
.LI
\*Lsec_attr_util_sch_ent_free_ptrs\*O\(emFrees nonnull pointers in a 
\*Lsec_\%attr_\%schema_\%entry_\%t\*L type.
.LI
.ne 4
\*Lsec_\%attr_\%util_\%sch_\%ent_\%free\*O\(emFrees nonnull pointers in a 
\*Lsec_\%attr_\%schema_\%entry_\%t\*O type and the 
pointer to the \*Lsec_\%attr_\%schema_\%entry_\%t\*O 
itself.  The utility also works with the equivalent \*Ldce_attr_sch\*O 
data type.
.LE
