...\"
...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
...\" src directory for the full copyright text.
...\"
...\"
...\"
...\" HISTORY
...\" $Log: 2_authn.gpsml,v $
...\" Revision 1.1.10.6  1996/11/26  21:45:06  wardr
...\" 	{enh,CR13609,R1.2.2}
...\" 	Final edits to PKSS material
...\" 	[1996/11/26  21:44:26  wardr]
...\"
...\" Revision 1.1.10.5  1996/10/22  14:47:53  sherman
...\" 	{edits,R1.2.2}
...\" 	OSF edits
...\" 	[1996/10/22  14:47:06  sherman]
...\" 
...\" Revision 1.1.10.4  1996/10/07  15:49:16  wardr
...\" 	{enh,CR13609,R1.2.2}
...\" 	Add PKSS info to public key protocol
...\" 	[1996/10/07  15:48:57  wardr]
...\" 
...\" Revision 1.1.10.3  1996/10/04  15:58:07  sherman
...\" 	{enh,13609,R1.2.2}
...\" 	Added public key login; altered some headings - readability/consistency
...\" 	[1996/10/04  15:57:36  sherman]
...\" 
...\" Revision 1.1.10.2  1996/08/09  12:16:06  sherman
...\" 	Check in user-to-user OSF edits on dce_books/app_gd/security/2_authn.gpsml
...\" 	[1996/08/09  12:15:26  sherman]
...\" 
...\" Revision 1.1.10.1  1996/07/18  13:05:34  sherman
...\" 	{edt,R1.2.2}
...\" 	OSF edits
...\" 	{enh,13562,R1.2.2}
...\" 	Add user-to-user protocol
...\" 	[1996/07/18  13:04:40  sherman]
...\" 
...\" Revision 1.1.8.1  1996/03/27  13:53:03  wardr
...\" 	{edit R1.2.1}
...\" 	More Release Edits
...\" 	[1996/03/27  13:52:37  wardr]
...\" 
...\" Revision 1.1.6.23  1995/06/07  14:39:21  rcb
...\" 	PRENTICE HALL: finally done including all edits, changes, reformatting, and new figures
...\" 	[1995/06/05  19:43:59  rcb]
...\" 
...\" 	incorporated Walt Tuvell changes; figures not fully corrected yet
...\" 	[1995/05/29  20:06:04  rcb]
...\" 
...\" 	corrected spelling errors
...\" 	[1995/05/10  13:58:20  rcb]
...\" 
...\" 	PRENTICE HALL reformat done; awaiting further 1.1 changes from W. Tuvell
...\" 	[1995/05/08  21:14:58  rcb]
...\" 
...\" 	PRENTICE HALL reformat: first stage done, awaiting possible future changes
...\" 	[1995/05/08  16:19:30  rcb]
...\" 
...\" 	incorporated changes (for accuracy) from Walt Tuvell and 1.1 edits
...\" 	[1995/05/04  18:53:47  rcb]
...\" 
...\" Revision 1.1.6.22  1994/11/03  23:34:58  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:39:06  neilson]
...\" 
...\" 	Substituted macros for book names in cross refs.
...\" 
...\" Revision 1.1.6.21  1994/10/21  15:48:05  jshirley
...\" 	Lots of cross-refs. and figure/space fiddling.
...\" 	[1994/10/21  15:47:48  jshirley]
...\" 
...\" Revision 1.1.6.20  1994/10/13  17:56:30  norb
...\" 	changes for Ext.  Login
...\" 	[1994/10/13  17:55:53  norb]
...\" 
...\" Revision 1.1.6.19  1994/10/12  15:46:04  rjohnson
...\" 	Revised "Walkthrough of DCE Application Authentication Using GSSAPI" section to reflect delegation enhancements.
...\" 	[1994/10/12  15:45:42  rjohnson]
...\" 
...\" Revision 1.1.6.18  1994/10/06  15:11:26  millette
...\" 	(edit,R1.1)
...\" 	Fixed bad .pI
...\" 	[1994/10/06  15:10:56  millette]
...\" 
...\" Revision 1.1.6.17  1994/10/05  20:25:28  millette
...\" 	(enh, 10514 R1.1)
...\" 	Additions for delegation
...\" 	[1994/10/05  20:24:41  millette]
...\" 
...\" Revision 1.1.6.16  1994/10/04  15:36:50  norb
...\" 	edits and additions for preauth
...\" 	[1994/10/04  15:34:51  norb]
...\" 
...\" Revision 1.1.6.15  1994/09/30  15:20:40  norb
...\" 	edits and additions for preauth
...\" 	[1994/09/30  15:13:55  norb]
...\" 
...\" Revision 1.1.6.14  1994/09/07  21:46:02  rjohnson
...\" 	Changes made: None.
...\" 	[1994/09/07  21:45:38  rjohnson]
...\" 
...\" Revision 1.1.6.13  1994/08/29  16:02:28  marty
...\" 	Undefunct this file
...\" 	[1994/08/29  16:02:13  marty]
...\" 
...\" 	<<<no changes>>>
...\" 	[1994/08/26  13:15:12  norb]
...\" 
...\" 	checked out by mistake
...\" 	[1994/08/09  13:12:22  norb]
...\" 
...\" Revision 1.1.6.12  1994/08/26  13:18:15  norb
...\" 	File is defunct
...\" 
...\" Revision 1.1.6.11  1994/05/17  17:08:25  jshirley
...\" 	SGML conversion edits.
...\" 	[1994/05/17  17:08:07  jshirley]
...\" 
...\" Revision 1.1.6.10  1994/05/11  15:07:51  rjohnson
...\" 	Changes made: Updated to include CR#10577.
...\" 	[1994/05/11  15:06:35  rjohnson]
...\" 
...\" Revision 1.1.6.9  1994/05/10  22:22:40  jshirley
...\" 	Fixed  doc build errors.
...\" 	[1994/05/10  22:22:20  jshirley]
...\" 
...\" Revision 1.1.6.8  1994/05/09  10:55:30  rjohnson
...\" 	Changes made: Added GSSAPI enhancements to chapter for release 1.1.
...\" 	File name: app_gd/security/2_authn.gpsml
...\" 	[1994/05/02  02:48:38  rjohnson]
...\" 
...\" Revision 1.1.6.5  93/02/22  21:43:24  buckler
...\" 	Changed .P! to .pI and added Postscript boundary boxes
...\" 	[1993/02/22  21:42:29  buckler]
...\" 
...\" Revision 1.1.6.4  1993/01/28  18:45:51  cjd
...\" 	Embedded copyright notice
...\" 	[1993/01/28  18:06:42  cjd]
...\" 
...\" Revision 1.1.6.3  1992/12/07  21:04:07  millette
...\" 	Bug 5054: changed sec_login_set_identity to sec_login_set_context
...\" 	40.2.1
...\" 	[1992/12/07  19:53:19  millette]
...\" 
...\" Revision 1.1.6.2  1992/11/20  19:58:47  weir
...\" 	Moved into 1.0.2doc tree
...\" 	[1992/11/20  19:50:07  weir]
...\" 
...\" Revision 1.1.4.7  1992/11/11  23:52:22  buckler
...\" 	Corrected index entries
...\" 	[1992/11/11  22:57:46  buckler]
...\" 
...\" Revision 1.1.4.6  1992/11/06  16:30:43  lmk
...\" 	Prentice-Hall index edits only
...\" 	[1992/11/06  16:26:50  lmk]
...\" 
...\" Revision 1.1.4.5  1992/10/10  15:50:12  casey
...\" 	Index changes for PH
...\" 	[1992/10/10  15:36:36  casey]
...\" 
...\" Revision 1.1.4.4  1992/10/09  15:17:36  lmk
...\" 	Prentice-Hall edits only
...\" 	[1992/10/09  15:14:11  lmk]
...\" 
...\" Revision 1.1.4.3  1992/09/30  13:52:52  lmk
...\" 	Prentice-Hall edits
...\" 	[1992/09/30  13:45:57  lmk]
...\" 
...\" Revision 1.1.4.2  1992/09/11  21:02:25  lmk
...\" 	Prentice-Hall edits only
...\" 	[1992/09/11  20:59:16  lmk]
...\" 
...\" Revision 1.1.2.2  1992/05/07  14:47:47  millette
...\" 	Bug 2769: Miscellaneous editoral corrections.  Not marked
...\" 	with change bars.
...\" 	[1992/05/07  14:24:46  millette]
...\" 
...\" Revision 1.1  1992/01/29  16:08:16  damon
...\" 	Initial revision
...\" 
...\" $EndLog$
...\"
...\" (c) Copyright 1991, Open Software Foundation, Inc.  ALL RIGHTS RESERVED
...\" 
...\" DCE 1.2 WRITERS: This chapter represents a new version I perhaps
...\" unwisely accepted from Walt Tuvell.  Apparently the old chapter
...\" was very inaccurate in places, and I'm sure this version is more
...\" accurate.  However it is editorially and stylistically inadequate
...\" in some ways, and beyond that there are deliberately introduced
...\" inconsistencies with the rest of the security chapters and the
...\" App Dev Guide.  I have tried to address these problems in brief fashion
...\" but the chapter should be reviewed carefully, and please view
...\" contents with a grain of salt. -- rcb
...\" 
.H 1 "Authentication"
.P
.iX "-[" "authentication"
.iX "-; protocols" "authentication"
This chapter describes the authentication process of users and applications, 
as well as of principals in other cells.   
.nS note
The authenticated RPC facility may 
also be referred to as the \*Eprotected\*O RPC facility, as it
involves services beyond authentication.
.H 2 "Background Concepts"
.P
The following concepts, as they relate to this chapter, are described within
this section:
.ML
.LI
Principals, which are the subjects of authentication
.LI
The shared-secret authentication protocol, which
is the mechanism by which authentication is effected when applications
specify this protocol via the authenticated RPC facility
.LI
Cells, which are the environment where authentication
takes place
.LI
Protection levels, which are the various degrees to
which transmitted application-level data may be protected
.LI
Data encryption/decryption (cryptographic) algorithms, which are the mechanisms
that the security server and client and server runtimes use to encrypt
and decrypt data exchanged between principals
.LE
.H 3 "Principals"
.iX "principal" "definition of"
.P
For the purposes of this discussion, the term \*Eprincipal\*O
may be precisely defined as an
entity that is capable of believing it can communicate securely
with another entity.  In DCE security, principals are represented
.iX "registry" "database"
as entries in the registry database.  DCE principals include the following:
.ML
.LI
Users, who are also referred to as \*Einteractive principals\*O
.LI
Instances of DCE (system-level) servers
.LI
Instances of application-level servers
.LI
Computers (hosts) in a DCE cell
.LI
.iX "authentication" "surrogates"
.iX "surrogates" "authentication"
Key distribution service (KDS) surrogates (these are used for
cross-cell authentication; see Section 24.3)
.LE
.P
.iX "-: security server" "privilege service"
.iX "Authentication Service"
.iX "ticket-granting service"
.iX "key distribution service"
.iX "registry" "service"
.iX "privilege service"
.iX "-: ticket-granting service" "TGS"
.iX "services" "authentication"
.iX "services" "ticket-granting"
.iX "services" "key distribution"
.iX "services" "registry"
.iX "services" "privilege"
.iX "-: key distribution service" "KDS"
The DCE security server itself comprises three principals that correspond
to the three services that it provides: KDS,
registry service, and privilege service.  The KDS in turn
provides two subservices: the authentication (sub)service and the
ticket-granting (sub)service (TGS).
.nS "note"
As used in the literature, the term \*Eauthentication service\*O is
sometimes ambiguous.  This name may be, in places,
associated with at least three distinct entities: the authentication
(sub)service of the KDS, the KDS itself (comprising its
authentication and ticket-granting subservices), and the entire DCE
Security Service (comprising the KDS, the registry service,
and the privilege service).  
.nE
These three servers (KDS, registry service, and privilege service)
comprise the main part of the DCE \*Enetwork trusted computing base\*O.
The KDS, registry service, and privilege service servers are commonly 
all implemented in a single process called the 
security server or security daemon.
.H 3 "The Shared-Secret Authentication Protocol"
.P
.iX "shared-secret authentication protocol"
.iX "protocols" "shared-secret authentication"
The registry service maintains a database, which 
contains an entry representing every
principal, identifying the principal by its name and a secret key
\*Ebound\*O to it.
It is this binding of the principal identity to a secret key shared with
the registry that is at the root of the DCE shared-secret authentication
protocols, as will be seen in this chapter.
In the case of an interactive principal, the
secret key is derived from the user's
password (at login time).  In order to establish its identity as a principal,
a \*Enoninteractive principal\*O, such as a server or computer, must store
its secret key in a data file or hardware device, or rely on a system
administrator to enter it.  The secret keys of servers are considered to
be stronger than those of users/clients, because they are ``truly
random'' (as opposed to being derived from a password, which greatly
restricts their randomness).
.P
DCE shared-secret authentication implements an extended version
of the Kerberos Version 5 system as its authentication protocol.
Namely, the part of the DCE security server that corresponds to Kerberos
is the KDS.  The other parts 
(registry service and privilege service) do not occur in Kerberos.
The Kerberos system was originally developed at the Massachusetts
Institute of Technology
as part of Project Athena, and provides a trustworthy, shared-secret
authentication system.  The walkthrough of the authentication protocol
in this chapter describes the protocol in general terms.
.nS "note"
The KDS is an exceptional principal in that it does not
share its key with any other principal.  KDS surrogates (see Section 24.3) are
also exceptional in that they are not autonomous participants in authenticated
communications, as other kinds of principals are.
.nE
.P
In the theory of shared-secret authentication 
all principals are initially considered to be
untrusted, except for those in the trusted computing base 
itself (KDS,
registry service, privilege service).  
A security-sensitive application must make use of the trusted
computing base to convince itself of the level of trust it may place in
all other principals.  How that is done is the subject of this chapter.
.H 3 "Cells and Realms"
.iX "cell" "and security"
.iX "-: cell" "realm"
.iX "security" "server" "and cells"
.P
The cell is the basic unit of configuration and administration in
DCE. In terms of security, a cell is the set of principals that share
a secret key with an instance of the registry service. Therefore,
each instance of a security server (together with its replicas) defines
a separate cell.
.P
From the perspective of security only, a cell is sometimes also known as a
\*Erealm\*O or \*Esecurity domain\*O.  (The term
realm is often used in Kerberos documentation, and so may be more familiar
to some readers than is the term \*Ecell\*O.)  A security cell is always
configured to coincide with a corresponding CDS cell, and perhaps
Distributed File System (DFS) cell as well.  DCE documentation always refers
to such a collective configuration of services as a cell.
.H 3 "Protection Levels"
.iX "protection levels"
.iX "levels of protection"
.PP
Protection levels specify how much of the information in network
messages exchanged by principals is encrypted.  As a rule, the higher
the protection level,
the greater the negative impact on performance.  An application can set
a protection level by using either authenticated RPC or GSSAPI.
.H 4 "Authenticated RPC and Protection Levels"
.iX "protection levels" "authenticated RPC"
.iX "levels of protection" "authenticated RPC"
.P
The authenticated RPC facility provides several levels of protection so
that applications can control tradeoffs between security and
performance.  Following is a summary of some of the protection levels
that an application using authenticated RPC may specify:
.ML
.LI
Connect level
.P
Performs authentication only when
a client and server establish a relationship (or connection)
.LI
Call level
.P
Attaches a verifier to each client call and server response
that protects the system-level \*Emetadata\*O of every remote call (but not the
application-level data)
.LI
Packet-integrity level
.P
In addition to protecting metadata, ensures the
integrity of the application-level data (RPC and return parameters)
transferred between two principals, that is, that none of it has been
modified in transit
.LI
Packet-privacy level
.P
In addition to protecting metadata and integrity,
encrypts all application-level data, thus guaranteeing its confidentiality
.LE
.P
Refer to the discussion of authenticated RPC in Chapters 13 and 14
for complete information about protection levels.
.H 4 "GSSAPI and Protection Levels"
.iX "protection levels" "GSSAPI"
.iX "levels of protection" "GSSAPI"
.iX "GSSAPI" "protection levels"
.iX "GSSAPI" "data integrity with"
.iX "per-message security"
.iX "GSSAPI" "per-message security"
.PP
...\" .cS
...\" per-message protection isn't a "level, or quality, or protection". It refers
...\" to how the protection is applied (i.e you take a message and if you want to
...\" protect it, you invoke a per-message service).  The per-message routines
...\" (gss_sign/gss_seal) take an input parameter that specifies a quality of
...\" protection.  Currently, only a single level is supported (apps should specify
...\" 0), but after discussions with the Kerberos people, it looks like I'm going to
...\" have to extend this to two or maybe three levels.  This means that we'll need
...\" to change the man-pages for gss_sign & gss_seal, but it won't be a big change.
...\" We certainly won't need to change anything for the Alpha/OSF DCE 1.2
...\" field-test.
...\" .cE
Unlike authenticated 
RPC, where the client chooses a protection level that is then
applied automatically to all data transferred in either direction,
applications that use GSSAPI must explicitly protect data on a
message-by-message basis.
This allows an application the option of protecting only particularly
sensitive messages, and avoids the overhead of security processing for other
messages.
(That is possible with RPC too, of course, provided that the programmer
is willing to specify security attributes on an RPC call-by-call basis.)
.P
GSSAPI offers two distinct types of protection through the \*Lgss_sign(\|)\*O/
\*Lgss_verify(\|)\*O routines and the \*Lgss_seal(\|)\*O/\*Lgss_unseal(\|)\*O
routines, as follows:
.ML
.LI
The \*Lgss_sign(\|)\*O routine creates a token containing an encrypted
signature to
protect the integrity of the message data.  The token contains only the
signature (not the message data).  The application must send both the
token and the message to which
it applies to the peer application for verification.  The receiving application
calls the \*Lgss_verify(\|)\*O routine to check the signature.
.LI
The \*Lgss_seal( )\*O routine creates a token containing both an
encrypted signature
and the message data, and may optionally encrypt the message data.  Only
the token need
be sent to the peer application, which processes it by using the
\*Lgss_unseal(\|)\*O routine to verify the signature and extract the message
data.
.LE
.P
Three distinct signature algorithms are supported by the per-message
protection routines.  An algorithm may be requested by providing one of
several constants to the \*Lqop_request\*O parameter (\*Lqop\*O stands
for ``quality of protection'') of either the
\*Lgss_sign(\|)\*O or the \*Lgss_seal(\|)\*O routine.  The constants are as
follows:
.VL 2.75i
.LI \*LGSSDCE_C_QOP_DES_MAC\*O
Conventional DES MAC.  Slow but well understood.
...\" DCE 1.2 WRITERS: need definition of DES MAC here?  Or expansion?
.LI \*LGSSDCE_C_QOP_DES_MD5\*O
DES MAC of an MD5 (Message Digest #5) signature.  Faster than DES MAC.
.LI \*LGSSDCE_C_QOP_MD5\*O
MD5 signature.  Fastest supported signature algorithm.  The default.
.LE
.H 3 "Data Encryption Mechanisms"
.iX "encryption mechanisms"
.iX "-: Data Encryption Standard" "DES"
.iX "Data Encryption Standard"
.iX "data" "encryption mechanisms"
.P
Authentication protocols assume the availability of a data encryption
mechanism, parameterized by a so-called \*Ecrypto-variable\*O or \*Ekey\*O.
In fact, it is the knowledge of such a key that is the concrete
manifestation of the abstract notion of authentication.
One mechanism that is frequently used is the Data Encryption
Standard (DES), though the DCE security architecture supports other
cryptographic algorithms.
Your version of DCE security may use DES for data privacy
or for principal authentication and data-integrity checking; or
it may use another encryption mechanism, or no encryption at all.
Consult the documentation supplied by your DCE vendor for specific
information.
.H 2 "A Walkthrough of Shared-Secret Authentication Protocols"
.iX "authentication" " protocols"
.iX "protocols" "authentication"
.P
This section walks you through the following topics:
.ML
.LI
Authentication of the user during login, in Section 24.2.1.
.LI
Authentication of applications, in Section 24.2.2.
.LE
.P
The walkthrough is seen primarily from the user and the associated
application-client side.  The illustrations in this
chapter show only a high-level view (not low-level details) of what
happens when a user logs in and runs an authenticated
application; they are intended only to provide a general understanding
of the protocol.  (See the \*ESecurity Volume\*O of the \*(Dc 
for full details.)
.P
.ne 5
In these figures, fill patterns represent encryption key values
and encrypted data.  The key symbol within a box indicates that
a key is being passed as data.  The key symbol on a line indicates 
that encryption or decryption is taking place, depending
on whether the resulting data is represented as encrypted or not.  
These conventions are shown in Figure 24-1.
.PP
.ne 
.FG "Conventions Used in Authentication Walkthrough Illustrations"
.pI ../security/figures/2_authn_10.ps 2.5i 4.4i
.sp .5
.nS "note"
All computer-to-computer communications initiated by DCE security are
processed through the RPC mechanism, although the
integration of security with client and server RPC runtimes are not
illustrated or explained in any detail here.
.nE
.P
Finally, note that to use shared-secret protocol, you do not need to
understand how it works. It is described here so that application
developers can determine whether it provides sufficient security
for their needs.  The discussion that follows is technical and detailed
and may not be of interest to every reader.
.zA "enh,13609,R1.2.2,Added public key login & fixed headings"
.H 3 "Authenticating a User"
.iX "-: ticket-granting ticket" "TGT"
.iX "authentication" "commands"
.iX "commands" "authentication"
.iX "security" "commands used in authentication"
.iX "ticket-granting ticket"
.P
This section explains how DCE security authenticates a user/client. DCE
authentication basically consists of two successive procedures:
.AL
.ne 5
.LI
Acquisition by the security client of a ticket-granting ticket (TGT) for
the user.
.LI
Acquisition by the security client of a privilege-ticket-granting ticket
(PTGT) for the user.
.LE
.P
These procedures are described in the following two subsections.
.H 4 "How the Client Obtains a TGT for the User"
.iX "-: ticket-granting ticket" "TGT"
.iX "authentication" "commands"
.iX "commands" "authentication"
.iX "security" "commands used in authentication"
.iX "ticket-granting ticket"
.P
This section describes the acquisition, by the security client, of 
the user's TGT.
It is the authentication service of the KDS that issues TGTs.
Acquisition of the user's TGT is
the first of the two parts of DCE user authentication.
The other part is the acquisition of service tickets, which are issued by
the TGS of the KDS.
.P
Authentication protocols used by DCE security clients and servers to 
obtain TGTs for users, which is the first part of the user-authentication 
process, are:
.ML
.LI
The \*Vpublic key\*O protocol, which provides the highest level of security
.LI
The \*Vthird-party\*O protocol, which is less secure than public key protocol
.LI
The \*Vtimestamps\*O protocol, which is less secure than the third-party
protocol
.LI
The DCE Version 1.0 protocol, which is the least secure of the three and is
provided solely to enable DCE Version 1.1 security servers to process requests
from pre-DCE Version 1.1 clients
.LE
.P
The protocol used by the security client when it makes a login request to
the authentication service is determined as follows:
.AL
.LI
Pre-DCE Version 1.1 clients always use the DCE Version 1.0 protocol.
.LI
DCE Version 1.1 clients always use the third-party protocol, unless the 
host machine's
session key, which the client uses to construct the request, is unavailable.
It then uses the timestamps protocol.
.LI
DCE Version 1.2.2 clients always attempt to use the public key authentication
protocol. If a client is unable to use the protocol, the client reverts to
DCE Version 1.1 behavior.
.LE
.P
The protocol used by the authentication service
to respond to the client is determined by the following:
.ML
.LI
The protocol used by the client making the login request
.LI
The value of any \*Vpre_auth_req\*O ERA attached to the requesting principal
.LE
.P
.ne 6
The authentication service always attempts to reply by using the same protocol
used by the client making the request, unless the value of the ERA ``forbids''
it to do so. (See the discussion of DCE Version 1.1 authentication in the 
\*(Ac for more detailed information on how security clients and the 
authentication service determine which protocol to use.)
.P
For a general discussion of the security aspects of these protocols, and
of security administration and security ERAs, see the \*(Ac.
The following  subsections explain how the three protocols operate.
.H 5 "The Public Key Authentication Protocol"
.iX "public key protocol"
.iX "authentication" "public key protocol"
.iX "-: Key Distribution Center" "KDC"
.iX "Key Distribution Center"
.P
Public key authentication protocol works via public and private key-pairs.
A user's identity is proven to the DCE Key Distribution Center (KDC) through
a signature in the user's private authentication key. The KDC verifies the
request through the user's authentication public key, which must be contained
in the DCE registry. If the request is verified, the KDC replies with a TGT that
is first signed by the KDC using its own private authentication key, and then
is encrypted by the KDC using the client's key encipherment public key, which
must be stored in the DCE registry.
Because the KDC does not know the user's private keys, a compromise of the KDC 
cannot reveal the private keys. Therefore, public key
users will not have any identifying information exposed to an intruder. This
method of public and private key pair usage constitutes the public key protocol.
.P
The public key protocol invokes routines
\*Lsec_login_validate_identity()\*O, 
\*Lsec_login_valid_and_cert_ident()\*O, and 
\*Lsec_login_validate_first()\*O as follows: 
.AL
.LI
The user logs in. 
.LI
The client process sends a message to the KDC. The message consists of
a timestamp and nonce signed by the client's private digital signature key. 
An optional certificate of the client can also be sent along. 
.LI
The KDC checks the timestamp and signature of the client's message. If the
information is valid, the KDC sends a reply key to the client. The reply 
consists of a message signed by the KDC's digital signature key and then 
encrypted by the client's key encipherment key. The reply key is for encrypting 
the encrypted portion of the
Kerberos \*LKRB_AS_REP\*O message, which includes the symmetric session key
associated with the TGT. The session key used in association with the TGT
is returned in the standard \*LEncKDCRepPart\*O field of the \*LKRB_AS_REP\*O message.
.P
If the KDC is unable to authenticate 
the user's supplied
public key data, the KDC returns an error indicating why the
authentication failed and whether the user is required to use the public key
authentication protocol. The KDC determines this from the \*Lpre_auth_req\*O ERA
attached to the user principal.
.P
If the public key login attempt fails, the \*Lsec_login\*O code instead falls 
back to the use of existing
password-based authentication unless the KDC error information indicates
that the principal is required to use public key login authentication. 
Preventing fall back is done by giving each principal a
\*Lpre_auth_req\*O ERA value of \*LPADATA_ENC_PUBLIC_KEY\*O.
.P
Authentication information is transmitted as data types:
.ML
.LI
\*LKRB5_PADATA_PUBKEY_REQ\*O
.LI
\*LPADATA_ENC_PUBKEY_REP\*O
.LE
.LI
The client checks the signature on the reply to make sure it is from the KDC.
The sesion key can be decrypted only by the legitimate client that possesses
the private key needed to decrypt. The client then uses the TGT and
associated session key.
.LE
.zZ "enh,13609,R1.2.2,Added public key login & fixed headings"
.zA "enh,13609,R1.2.2,Add PKSS info to public key protocol"
.H 5 "Storage of the Private Key"
...\" xxx
.iX "private key storage server (PKSS)"
Private key information is stored either in a local file or by the DCE
private key storage server (PKSS).  If the principal's
\*LDCEPKPrivateKeyStorage\*O ERA value is not set, the login program
assumes the private key is stored in a local file.  If the principal's
\*LDCEPKPrivateKeyStorage\*O ERA value is set, the login program
obtains the private key from the private key storage mechanism
associated with the UUID contained in the ERA.  The currently
supported storage mechanisms and their associated UUID's are the
following:
.ML
.LI 
Local file \(em The UUID is \*L8687c5b8-b01a-11cf-b137-0800090a5254\*O.
.LI 
Private key storage server (PKSS) \(em The UUID is
\*L72053e72-b01a-11cf-8bf5-0800090a5254\*O.
.LI 
Registry Database \(em The UUID is
\*Ladb48ed4-e94d-11cf-ab4b-08000919ebb5\*O. (This mechanism is
supported for internal security server purposes only.)
.LE
.P
The PKSS stores private keys in records that have the
following information:
.ML
.LI
The user's principal name.
.LI
The user's public key.
.LI
The key version of the user's public key (key v.n).
.LI
The application domain. (Currently, private keys are used only in
the context of a DCE login.)
.LI
Key usage flags. (Currently, private keys are used only for
authentication and for key encipherment.)
.LI
Password hash value 2 (H2) derived from the user's password.
.LI
The user's private key encrypted under the user's password hash value
1 (H1).
.LE
.P
The PKSS cannot directly access the user's private key because it does
not have the user's password H1 value. An ACL protects user
records from unauthorized access, allowing access to only the
\*Lsec_admin\*O principal.
.P
The following two descriptions depict the initial message exchange
between the login client and the PKSS, and the second (final) exchange
in which the PKSS returns the private key to the client.
...\" .H 6 "Client Initiation of Private Key Acquisition from PKSS"
.P
.SP
\*LClient Initiation of Private Key Acquisition from PKSS\*O
.P
The client DCE login program begins the process of key acquisition
from the PKSS. Refer to Figure 24-2 as you read the following steps.
.AL 
.LI
The login client sends a message to the PKSS that consists of the
following components:
.ML
.LI
The user's principal name.
.LI
The application domain.
.LI
Key usage flags. 
.LI
The key version number (key v.n).
.LI
An exponentiated Diffie-Hellman value (S\u\s-2c\s+2\d)
used for establishing a Diffie-Hellman key.
.LI
An algorithm list (alg list), which is a list of secret key encryption
algorithms supported by the client (currently only DES). The client
and the PKSS use this algorithm with the Diffie-Hellman key and the
session key.
.LE
.LI
Upon receipt of this message from the login client, the PKSS generates
a Diffie-Hellman value of its own (S\u\s-2s\s+2\d).  Using this value
along with the client's Diffie-Hellman value, the PKSS computes a
Diffie-Hellman key.
.P
The PKSS determines whether it supports any of the algorithms listed
in the client message. If so, it can communicate securely with the
client and the PKSS selects one of the supported algorithms for use.
(Currently, OSF DCE clients and servers support only DES.)
.LI
The PKSS generates a random session key and a nonce (N\u\s-2s\s+2\d).
The session key will be used to encrypt messages between the client
and server.  The PKSS encrypts the nonce (N\u\s-2s\s+2\d) with the
session key, then encrypts the session key with the user's password
H2 value taken from the user record.
.LI
The PKSS computes a hash on the algorithm list provided by
the client.  It encrypts both the hashed algorithm list and the
encrypted session key (see step 3) under the Diffie-Hellman key
generated in step 2.
.LI
The PKSS composes and sends the client a message consisting of
.ML
.LI
The nonce (N\u\s-2c\s+2\d) encrypted under the random session key. 
.LI
The session key encrypted by the user's password H2 value and
then encrypted under the Diffie-Hellman key.
.LI
The hashed algorithm list further encrypted under the Diffie-Hellman
key.
.LI
The algorithm to be used for the session key. (The algorithm is chosen
from the client's algorithm list.)
.LI
The PKSS-generated Diffie-Hellman value.
.LE
.LI
Upon receipt, the login client extracts the PKSS-generated
Diffie-Hellman value and combines it with its own Diffie-Hellman value to
obtain its copy of the Diffie-Hellman key.
.LI
The client uses the encryption algorithm specified by the PKSS, along
with its Diffie-Hellman key to obtain the hashed algorithm list and the
session key (still encrypted under the user's password H2 value).
.P
The login client computes a hash on its own algorithm list and
compares it with the hashed algorithm list returned from the PKSS.
The two lists must match. Otherwise, the client determines that the
PKSS is invalid and returns an error.
.LI
The login client decrypts the session key by using H2 derived
from the user's password.  The client uses the session key to decrypt
the PKSS-generated nonce (N\u\s-2s\s+2\d). The session key will be
used to authenticate the current session communications between the
client and PKSS.
.nS note
A PKSS imposter would not know the user's password H2 value. The
resulting session key would differ from the imposter's session key,
preventing further communications between the client and the imposter.
.nE
.LI
The client composes a message encrypted under the session key. The
message consists of
.ML
.LI
The PKSS-generated nonce (N\u\s-2s\s+2\d)
.LI
A client-generated nonce (N\u\s-2c\s+2\d)
.LI
An operation identifier that indicates private key acquisition
.LE
.LE
.bp
.FG "Client Initiation of Private Key Acquisition"
.pI ../security/figures/2_authn_12.ps 0 0 1
...\" XFIG SOURCE "pkss1.fig" EXPORT SETTINGS:
...\" 
...\"   Magnification:  65%
...\"   Orientation: 	Portrait
...\"   Justification:  Centered
...\"   Offset:	  	X=minus 1.25 inches, Y=minus 1.75 inches
...\"   Language:	PostScript
...\" .H 6 "Client Completion of Private Key Acquisition from PKSS"
.P
.SP
\*LClient Completion of Private Key Acquisition from PKSS\*O
.P
The client DCE login program completes the process of key acquisition
from the PKSS. Refer to Figure 24-3 as you read the following steps.
.AL
.LI
The client sends the PKSS the composed message encrypted under the
session key (see Step 9 in the preceding discussion).
.LI
Upon receipt of the client message, the PKSS uses the session key to
obtain the operation ID, the client-generated nonce (N\u\s-2c\s+2\d),
and the PKSS-generated nonce (N\u\s-2s\s+2\d).
.P
The PKSS compares the client's copy of N\u\s-2s\s+2\d with its
original nonce (N\u\s-2s\s+2\d).  A match proves the client had
knowledge of the user's secret password which was needed to obtain the
session key.  The client used the session key to obtain N\u\s-2s\s+2\d.
.LI
The PKSS composes a message consisting of
.ML
.LI
The user's private key encrypted under the user's password H1 value
.LI
The user's public key
.LI
The key version number
.LI
The client-generated nonce (N\u\s-2c\s+2\d)
.LE
.LI
The PKSS encrypts this message with the session key and sends it to
the client.
.LI
Upon receipt, the client uses the session key to obtain the user's
private key (encrypted under the user's password H1 value), the user's
public key, the key version number, and the client-generated nonce
(N\u\s-2c\s+2\d).
.P
The client compares the PKSS's copy of N\u\s-2c\s+2\d with
its own nonce. A match proves the authenticity of the PKSS because only
the true PKSS could have used the correct user password H2 value to
properly encrypt the session key passed to the client in the first
message.
.LI
The client uses its password H1 value to decrypt the private key.
The client's security runtime program returns the authenticated private
key to the calling routine.
.LE
.bp
.FG "Client Acquisition of Private Key from PKSS"
.pI ../security/figures/2_authn_13.ps 0 0 1
...\" XFIG SOURCE "pkss2.fig" EXPORT SETTINGS:
...\" 
...\"   Magnification:    65%
...\"   Orientation: 	  Portrait
...\"   Justification:    Centered
...\"   Offset:	  	  X=minus 1.50 inches, Y=minus 2.00 inches
...\"   Language:	  PostScript
...\" 
.zZ "enh,13609,R1.2.2,Add PKSS info to public key protocol"
.H 5 "The Third-Party Authentication Protocol"
.iX "authentication" "third-party"
.iX "third-party authentication"
.iX "protocols" "third-party authentication"
.P
The DCE Authentication Service can use the
third-party authentication protocol to provide a user with a
TGT.  Refer to Figure 24-2 as you read the following steps.
.AL
.LI
The user logs in, entering the correct user name.  The login program invokes
\*Lsec_login_setup_identity(\|)\*O, which takes the user's principal name as one
of its arguments, and 
\*Lsec_\%login_\%valid_\%and_\%cert_\%ident(\|)\*O, which has 
the user's password as one of its arguments.
The \*Lsec_login_valid_and_cert_ident(\|)\*O routine causes
the security runtime to request a TGT from the
authentication service of the KDS.
(The client principal will later present the TGT to the TGS, to acquire
service tickets to other servers.)
The client's security runtime performs the following steps to construct
the TGT request to the authentication service:
.AL
.LI
It requests, from the \*Lsecval\*O service, a random key, say
conversation key 1, which the client will later use to
encrypt its request to the authentication service.
Two copies of conversation key 1 are passed to the client: one
unencrypted and one encrypted in the machine session key (a copy of
which is sealed inside the machine ticket-granting ticket, or MTGT).
(In order to do this securely, the request to \*Lsecval\*O must be done
over a secure local communications channel on the host machine.)
It then concatenates the encrypted copy of conversation key 1
with the MTGT.
.P
.ne 7i
.FG "Client Acquires TGT Using Third-Party Protocol"
.pI ../security/figures/2_authn_15.ps 7i 3.5i
.sp 
.LI
It generates another random key, conversation key 2,
which the authentication service will later use to encrypt the TGT
it returns to the client.
It then concatenates it to a timestamp string.
.LI
It derives, from the password input by the user, the user's secret key,
a copy of which
also exists in the registry service database.  It then encrypts the 
timestamp/conversation
key 2 twice: first by using the user's secret key, and then by using
conversation key 1.
.LI
Finally, it completes constructing the authentication service request message by
concatenating the encrypted
conversation key 1 (obtained from \*Lsecval\*O in Step 1a) with the
doubly encrypted timestamp and conversation key 1.
.LE
.LI
The client's security runtime then forwards the constructed request to the
authentication service of the KDS.
(This corresponds to the first step of the DCE Version 1.0 protocol,
described in Section 24.2.1.1.3.)
.LI
The authentication service receives the request and performs the following
steps to verify the user and prepare the user's TGT:
.AL
.LI
It decrypts the MTGT (by using the KDS's secret key),
and obtains the machine session key from it.
(This decryption is not shown pictorially in Figure 24-2.)
.LI
Using the machine session key, it decrypts the package containing
conversation key 1.
.LI
It obtains the user's secret key from the registry service and then decrypts
the doubly encrypted package containing the timestamp and conversation key 2
by using the user's secret key and conversation key 1. 
.P
If this decryption fails, the user's secret key that was used by the
login program to encrypt the package differs from the one stored in
the registry service, and therefore the password supplied to the login
program by the user was incorrect.  In this case, the user is not
authenticated, and an error code is returned to the login program.
.P
If the decryption succeeds, and if the decrypted
timestamp is within an allowable clock skew (5 minutes) 
of the current time, the user has been authenticated
(that is, the user knows the correct principal password and this isn't a
replay attack), and the authentication service
proceeds with preparation of the user's TGT.
.LE
.LI
.ne 4
The authentication service then prepares the user's TGT,
encrypts it in the KDS's secret key, encrypts the conversation
key 3 contained in the TGT (to be used later by the client to acquire
service tickets) in conversation key 2, and returns this data to the client.
.LI
The client security runtime decrypts the reply from the authentication
service by using
conversation key 2, obtaining the conversation key 3 from the TGT,
and it becomes part of the client's login context.
.LE
.P
Note the following security safeguards inherent in the structure of this
protocol:
.ML
.LI
All network transmissions between the security client and the
authentication service are encrypted by using strong random keys 
(not weak keys derived from passwords),
placing even offline decryption attempts
at the outer limits of practical possibility.
.LI
.ne 7
The timestamp and conversation key 2 are encrypted by using the user's
secret key, which is derived from the user's password (and subsequently
reencrypted by using conversation key 1).  This enables the authentication
service
to verify that the requesting client knows the user's password.
(It does this by decrypting the package via
the registry service's copy of the
user's secret key; if the decryption succeeds, the keys are the same,
that is, they were derived from the same password.)
.LI
The authentication service actively verifies whether the requesting
client knows the user's password.
Contrast this with the DCE Version 1.0 protocol, 
where the authentication service blindly issues
TGTs without requiring any evidence that the requestor knows the user's
password.  It is therefore aware of, and can manage, persistent login failures
for a given user, eliminating active password-guessing attacks.
.LI
The authentication service's reply is encrypted by using conversation 
key 2, which was provided by the client.  This verifies to the client 
that the authentication service itself is
authentic since, if it were not, it would not have been able to obtain
the machine session key and user's secret key it needed to
decrypt conversation key 2.
.LE
.P
These safeguards provide assurance to both server and client that the
entity with which each is communicating is, in fact, what it claims to be.
.P
Having acquired the user's TGT, the login program proceeds
with the next step in the authentication procedure (described in 
Section 24.2.1.2).
.H 5 "The Timestamps Authentication Protocol"
.P
This section describes how the DCE Authentication Service 
uses the timestamps authentication protocol to provide a user with a TGT.
.P
Since the timestamps protocol is 
largely identical to the DCE Version 1.0 protocol,
which is fully explained in the next section, this section
describes only the differences between the two.
.P
The timestamps protocol proceeds 
exactly as the DCE Version 1.0 protocol described
in the \*Efollowing\*O section, with these additions:
.ML
.LI
In Step 1, the client security runtime sends to the authentication
service, in addition to the user's stringname, the current 
timestamp encrypted in
the user's secret key.
.LI
.ne 3
In Step 2, the authentication service, before preparing the user's TGT,
verifies the user's authenticity (albeit not as strongly as in the
third-party protocol) as follows:
.AL
.LI
It decrypts the timestamp by using the copy of the user's key it obtained from
the registry service.
.LI
If the decryption succeeds, and the timestamp is within an allowable
clock skew (5 minutes) of the
current time, the user is authenticated, and the authentication service proceeds
to prepare the TGT. If the decryption fails, or if the timestamp is not
within the allowable clock skew, 
the authentication service rejects the login request.
.LE
.LE
.P
With this protocol, the authentication service can verify the following:
.ML
.LI 
That the client login request is timely; that is, that the 
authentication service is communicating with the client ``now'' 
(within the allowable clock skew)
.LI
That the requesting client knows the user's password
.LE
.P
The authentication service is therefore aware of, 
and can manage, persistent login failures
for a given user, eliminating passive password-guessing attacks.
.P
From this point, the timestamps protocol continues as the DCE Version 
1.0 protocol described in the next section, and then proceeds
with the next step in the authentication procedure, described in 
Section 24.2.1.2.
.nS note
Encrypted timestamps (under the name ``authenticators'')
are passed in several places in the protocols, to
guarantee ``fresh'' communications (within the allowable clock skew) and
thereby guard against replay attacks.  This has been shown explicitly in
the preceding, but will be omitted in the remainder of this chapter.
.nE
.H 5 "The DCE Version 1.0 Authentication Protocol"
.P
This section explains how the DCE Authentication Service uses the DCE 
Version 1.0
protocol to authenticate a user.  This protocol exists in DCE Version 1.1 solely
to provide interoperability between DCE Version 1.1 servers and pre-DCE
Version 1.1
clients; \*Vonly\*O pre-DCE Version 1.1
clients transmit DCE Version 1.0 login requests, and the authentication service returns
DCE Version 1.0 responses \*Vonly\*O to pre-DCE Version 1.1 clients.
.P
The DCE Version 1.0 protocol lacks the security features 
previously described for
the third-party and timestamps protocols, hence this protocol
is more vulnerable to attacks.
You should keep this in mind when you are considering the inclusion of
pre-DCE Version 1.1 clients in your DCE Version 1.1 cell.
.P
The DCE Version 1.0 protocol proceeds as follows.  Refer to 
Figure 24-3 as you read these steps.
.AL
.LI
The user logs in, entering the correct user name.  The login tool invokes
\*Lsec_login_setup_identity(\|)\*O, which takes the user's principal name as one
of its arguments.  This call causes the client security runtime to
request a TGT and passes the user's name
(represented as a string, not a UUID) to the authentication service.
The TGT will later be used by the client to acquire service tickets to
other services; the first such usage will be to acquire a service ticket
to the privilege service (see Section 24.2.1.2).
.P
.ne 7i
.FG "Client Acquires TGT Using the DCE Version 1.0 Protocol"
.pI ../security/figures/2_authn_20.ps 7.1i 4.45i
.sp .5
.LI
.ne 9
Upon receiving the request for
a TGT, the authentication service obtains the user's secret key from
the registry service database (where the secret keys of all principals in
the cell are stored).  Using its own secret key (that is, that of the KDS),
the authentication service encrypts the user's identity, along 
with a conversation key 3
(this conversation key 3 is the same as conversation key 3 in
the discussion of the third-party protocol, earlier in this chapter),
in a TGT.  The authentication service separately encrypts a copy of
conversation key 3 with the user's secret key and returns this data to
the client.
...\" .nS "note"
...\" Figure 24-3 depicts the TGT as being doubly encrypted, once in the KDS's
...\" secret key and once in the client's secret key.  That's a convenient way
...\" to think of what's happening (and is what was actually done in an
...\" earlier version of the Kerberos protocol), however in actuality the TGT
...\" itself in only encrypted once (in the KDS's secret key), and only the
...\" conversation key 1 is encrypted in the client's secret key.  A similar
...\" remark holds in the other figures in this chapter (the only place double
...\" encryption really happens is where it was explicitly mentioned
...\" in the third-party authentication protocol described previously).
...\" .nE
.LI
When this data arrives at the client,
the login tool prompts the user for the password
and invokes \*Lsec_login_valid_and_cert_ident(\|)\*O.  This call passes the
password to the client's security
runtime library.  The security runtime derives the user's secret key
from the password (using a well-known algorithm), and uses it to decrypt
conversation key 3. (If the user
enters the wrong password, this decryption fails.)
The client's security runtime cannot decrypt
the TGT since it does not know the KDS's secret
key.  The TGT is the client principal's certificate of identity\(emit
is usable by the client precisely because the client knows the
conversation key 3 carried in it.
.LE
.nS note
One of the functions of \*Lsec_login_valid_and_cert_ident(\|)\*O is to
authenticate the authentication service itself to the host machine's
login program, by demonstrating that the (purported) authentication service really knows
the secret key of the host computer.
(The mere fact that the purported authentication service knew the user's
secret key is not convincing to the host's login program, because that
purported authentication service could have been a bogus server working in league with a
bogus user\(emthe host doesn't trust any of these things.)
The way in which this is accomplished is not
illustrated here but is explained in Chapter 30.
.nE
.P
Having acquired the user's TGT, the login program proceeds
with the next step in the authentication procedure,
described in Section 24.2.1.2.
.P
...\"Dividing the login sequence into two parts (\*Lsec_login_setup_identity(\|)\*O
...\"and \*Lsec_login_validand_cert_ident(\|)\*O) minimizes the time that the password
...\"remains in clear text in the client's address space.
.H 4 "How the Client Obtains a PTGT for the User"
.iX "-: privilege ticket-granting ticket" "PTGT"
.iX "commands" "authentication"
.iX "security" "commands used in authentication"
.P
This section describes the acquisition, by the client's security
runtime, of the user's PTGT.
Acquisition of the user's PTGT is
the second of the two parts of DCE user authentication.
.P
.ne 4
From this point on, the
client principal uses four different conversation keys
to talk with other principals.
...\"This design
...\"feature obviates the need for principals (other than the Authentication Service)
...\"to know the secret keys of other principals, which is itself a security risk.
Use of multiple short-lived keys makes an attacker's task far more difficult,
since there are more encryption keys to discover
and less encrypted material and time with which to ``crack'' them.
.P
Refer to Figure 24-4 as you read the following steps.
.AL
.LI
.iX "privilege ticket-granting ticket"
When the client's security runtime has succeeded in decrypting
conversation key 3, it next wants to acquire a
PTGT from the privilege service.  Before a request for a PTGT
can even be formulated, however, a service ticket to the privilege service
must be acquired.
The client's security runtime therefore begins by requesting such a
service ticket from the TGS.
The security runtime encrypts this request by using the conversation key 3
(which is also sealed in the client's TGT); it also sends along the
client's TGT.
.LI
.ne 15
The TGS decrypts the TGT (which was encrypted in the KDS's secret key),
learning conversation key 3, and verifies that the request was properly
encrypted by using conversation key 3.
This convinces the TGS that the identity of the requesting client
is authentic; that is, no other principal could have sent a message
so encrypted because no other principal knows conversation key 3.
(The reader should review the preceding steps if necessary to be
convinced that this is true.)
Since the user has demonstrated to the TGS knowledge
of the key, the TGS allows the user to talk to the privilege service,
and so prepares a service ticket to that service.  This
ticket contains the identity of the user (and a conversation
key 4), encrypted under the secret key of the privilege service (which
the TGS retrieves from the registry service).
The TGS separately encrypts conversation key 4 under conversation key 3,
and returns this data to the client.
.nS "note"
Beginning with Figure 24-4,
the illustrations do not emphasize all the TGS's encryption and
decryption activities (such emphasis would be redundant since the TGS
knows all of the keys).
.nE
.LI
Upon receipt of this data, the client's security runtime uses
conversation key 3 to decrypt conversation key 4.
The client then formulates a request for a PTGT, encrypting it with
conversation key 4, and sends this together with the service ticket it just
received from the TGS, to the privilege service.
.LI
The privilege service decrypts the service ticket sent to it (using its
secret key), thereby learning the
identity of the client and the conversation key 4 it will use to decrypt
the request and to encrypt its response.  The privilege service is convinced
of the authenticity of this request because the
information was encrypted under its own secret key, and no principal other
than the KDS (acting as the TGS) could have encrypted the information
by using this secret key.  Because the privilege service believes the
authenticity of the client's identity, it prepares an
extended privilege attribute certificate (EPAC) to issue to the client.
(Actually, in the pure DCE Version 1.0 protocol this would be a PAC, 
not an EPAC, but since this is a high-level description intended for 
both releases we'll just talk about EPACs without fear of confusion.  
So what we're really describing here is an extended privilege 
TGT, or EPTGT, though we'll continue to call it a PTGT.)
.P
.ne 18
The EPAC describes the user's privilege attributes (identity information
and group membership) and any extended attributes that are associated
with the user\(emall represented as UUIDs (not strings).
The EPAC (or EPAC chain, in case of a delegated operation) is sealed with 
an MD5 checksum.  (Delegation is described in Chapter 27.)  The privilege 
service constructs a PTGT, which is a ticket that contains
the EPAC, the EPAC seal, another copy of the EPAC seal encrypted in the
secret key of the privilege service (this is called a \*Edelegation
token\*O), and a conversation key 5 (which is actually generated by the
KDS, though the illustration doesn't show this detail).
All this information except for the EPAC itself is encrypted in the
secret key of the KDS (thus, the delegation token is doubly encrypted).
(The KDS and privilege service cooperate to prepare the PTGT, although
the illustration only shows the privilege service preparing it.)
The EPAC seal inside the PTGT binds the EPAC to the PTGT,
guaranteeing its integrity even though it isn't encrypted.
The conversation key 5 is encrypted in conversation key 4, and all this
data is returned to the client.
...\" .cS
...\" OLD SAVE ******************* -- OK, but this is an old buggy description!
...\" ...\" Privilege Attribute Certificate (PAC), which
...\" ...\" describes the user's privilege attributes (data that is used in making
...\" ...\" authorization decisions).
...\" The privilege service encrypts the user's PAC and
...\" a third conversation key into the PTGT using the
...\" Authentication Service's secret key. (The Authentication Service and Privilege
...\" Service cooperate to prepare the PTGT, although the illustration only shows the
...\" Privilege Service preparing it).  The PTGT envelope is encrypted by using the second
...\" conversation key and also includes the third conversation key. (The
...\" Authentication Service supplies the third conversation key, although the
...\" illustration does not show this detail.)
...\" OLD SAE************************
...\" .cE
.PP
.ne 7i
.FG "Client Acquires PTGT"
.pI ../security/figures/2_authn_30.ps 6.5i 2.8i
.sp 3.1
.LI
.ne 3
The client's security runtime uses conversation key 4 to decrypt
conversation key 5.  It cannot decrypt the PTGT itself, since
the PTGT is encrypted under the secret key of the KDS.
.LE
.H 4 "The Login Context"
.P
At this point, the security service has authenticated the user's
identity (that is, has verified that the user knows its password),
and the user has acquired (trusted) information about
its privilege attributes from the privilege service.
The client now calls \*Lsec_login_set_context(\|)\*O to set the
login context (a handle to this user's network identity and privilege
attributes that have been established).  Henceforth,
processes invoked by this user inherit the user's login context, and
among these processes is the client side of distributed applications
\(em those are the subject of the rest of the walkthrough.
.P
...\"
.H 4 "Identities in a Delegation Chain"
...\"
When a user who has initiated delegation (with
\*Lsec_\%login_\%become_\%initiator(\|)\*O)
makes an authenticated RPC to the next member in a delegation chain
(the first intermediary), the initiator passes its PTGT (including EPAC,
seal and delegation token) to the TGS, and receives an extended
privilege service ticket (again containing EPAC, seal and delegation
token) to the intermediary.  This is passed to the intermediary.
The intermediary then invokes either routine
\*Lsec_login_become_delegate(\|)\*O or \*Lsec_login_become_impersonator(\|)\*O,
passing to the privilege service the authorization information it
received from the initiator (EPAC and delegation token), together with
the intermediary's own PTGT (including the intermediary's EPAC, seal and
delegation token).
.P
The privilege service uses the two delegation tokens, which are
seals over the initiator's and intermediary's EPAC encrypted in the
privilege service's own secret key, to verify the authenticity of the EPACs.
If these are valid,
the privilege service creates an EPAC chain, consisting of the initiator's and
intermediary's EPACs, and
generates a new seal and delegation token for this EPAC chain, and
returns to the intermediary a new PTGT containing this information.
Thus, the intermediary's authorization information
now includes both EPACs in the delegation chain and a PTGT that contains
the EPAC chain's seal and delegation token.
The subsequent additions of identities to
the delegation chain are handled in the same manner, resulting in PTGTs
with each intermediary's identity being added to the EPAC chain.
Any such PTGT can be used to continue the delegation chain or to
acquire a service ticket to the ultimate target server.
.zA "enh,13609,R1.2.2,Changed heads for consistency with pub key"
.H 3 "Authenticating an Application"
.P
Applications that are run between client and server must also be authenticated.
For specific information about using the authenticated RPC routines 
see Chapters 13 and 14.  For information about the
GSSAPI, see Chapters 23 and 26.
.H 4 "Authentication Using Authenticated RPC"
.zZ "enh,13609,R1.2.2,Changed heads for consistency with pub key"
.P
This section explains how DCE security authenticates an application,
to which the application developer has added authenticated RPCs.
.nS note
The authenticated RPC facility may
also be referred to as the \*Eprotected\*O RPC facility, as it
involves services beyond authentication.
Authenticated RPC may also be referred to as the protected RPC facility, 
.nE
.P
Refer to Figure 24-5 as you read the following steps.
.PP
.ne 5.5i
.FG "Client Sets Authentication and Authorization Information"
.pI ../security/figures/2_authn_40.ps 5.2i 3.8i
.sp .5
.AL
.LI
Having been authenticated
and having acquired a PTGT, the user invokes an application.  The
client side of the application makes calls to routines \*Lrpc_binding_import_begin(\|)\*O,
\*Lrpc_\%binding_\%import_\%next(\|)\*O, and the like.  These calls specify
the remote interfaces required by the client for the application.
.LI
The CDS returns the client binding handles to the
specified interfaces. (For simplicity in this example, we consider
the simple binding model in which the client consults the CDS for the
server's RPC binding name.)
.LI
.ne 17
The client \*Eannotates the binding handle\*O\(emthat is, it sets
security information for the binding handle by calling
\*Lrpc_\%binding_\%set_\%auth_\%info(\|)\*O.  Among other parameters, 
this routine sets
the authentication protocol, the protection level, and authorization
protocol for the binding handle corresponding to the remote interface.
It also sets the server's principal name, which the client must know
securely (it may be the same or different than the server's RPC binding name).
In this example, assume that the authentication protocol
(\*Vauthn_svc\*O parameter) is DCE shared-secret authentication, the
protection level
(\*Vprotect_level\*O) is packet privacy (all RPC argument values
are encrypted), and the authorization protocol (\*Vauthz_svc\*O)
is DCE authorization.  (``DCE authorization'' means that an
EPAC chain, containing UUIDs representing the client's or delegation chain's
privilege attributes, will be sent to the server, which will compare this
information with the ACLs protecting the objects of interest in order
to determine whether the principal is to be granted or denied access.)
.P
Refer to Figure 24-6 as you read the following steps.
.LI
The client requests some operation (using the annotated binding handle)
to be performed by the server.  The client RPC runtime requests from the TGS
a service ticket to the server (identified by the server principal
name with which the binding handle has been annotated).
To acquire the ticket, the client security runtime formulates a request to the TGS.
The request includes the server's principal name, which the client security 
runtime encrypts under conversation key 3. Also sent along with the request is
the principal's PTGT, including EPAC and seal.
.P
.ne 6i
.FG "Client Principal Makes Application Request"
.pI ../security/figures/2_authn_50.ps 6i 4.3i
...\" 
...\" DCE 1.2 writers:
...\" Due to insufficient resources the above figure, while revised,
...\" was not revised completely as per Walt Tuvell instructions.  
...\" Remaining problems are as follows: in right side of "Client
...\" Principal" section, "request ticket to application server"
...\" should be repeated in box attached to top of PTGT/Seal block 
...\" in middle; box labelled "EPAC" should descend from that
...\" same block; and the Seal/EPAC block in the bottom of that
...\" section should be duplicated to the left of the "Application
...\" Server" block in lower right.
...\" 
.sp 2.5
.zA "enh,13562,R1.2.2,add user-to-user protocol" 
.LI
.ne 8
The TGS decrypts the PTGT (which was encrypted in the KDS's secret key),
thereby recovering conversation key 5, and uses conversation key 5 to
decrypt the rest of the TGS request message.
The TGS then constructs a service ticket,
including the EPAC chain information
and conversation key 6. By default, the key that is used to encrypt the service 
ticket is the application server's secret key.
.P
.iX "user-to-user authentication"
.iX "protocols" "user-to-user authentication"
.iX "authentication" "user-to-user protocol"
For server principals that must use the user-to-user authentication protocol,
the service ticket granted must be encrypted using the session key obtained
from the server's current TGT, which the client must pass in with the ticket
request. If the client had used the server-key-based request, and 
the server
requires user-to-user protocol, the TGS will respond with an error instructing
the client-side runtime to ask the server for its current TGT and to reissue
the request with this TGT.
.P
The service ticket is returned to the client, together with conversation
key 6 encrypted under conversation key 5.
.LI
The client's security runtime uses conversation key 5 to decrypt
conversation key 6, and then uses conversation key 6 to encrypt the
application-level RPC request to the server.
The client's RPC runtime sends the encrypted application request to the
application server, together with the service ticket.
.P
Refer to Figure 24-7 as you read the following steps.
.LI
The application server's security runtime receives the client's request and
decrypts the service ticket by using its secret key, or the TGT session key
if user-to-user based authentication is used. In this way, the server's
security runtime learns conversation key 6 and uses it to decrypt the RPC
request.  If the server determines from the client's
authorization information (EPAC chain)
that the request is granted, it performs the requested operation and
prepares a response.  The server's runtime encrypts the response
by using conversation key 6 and sends it back to the client.
.LI
The client runtime receives and decrypts the response, and returns data
to the application (by returning from the RPC).
.zZ "enh,13562,R1.2.2,add user-to-user protocol" 
.LE
.P
.ne 6i
.FG "Application Server Responds to Client's Request"
.pI ../security/figures/2_authn_70.ps 6.1i 4.3i
.P
The preceding walkthroughs have focused on the security aspect of
authenticated RPC in DCE, not on its communications aspect.  The
technical details of integrating security with RPC lie beyond the
scope of this chapter.  However, the following remarks apply:
.ML
.LI
.ne 13
In the CO (virtual circuit) RPC protocol, the client's
security credentials (ticket with conversation key 6
and EPAC) are \*Epushed\*O from client to server at connection
establishment time, that is, at the time of the first remote procedure call
 from client
to server (and the remote call is of course protected with conversation key
6).  In the CL (datagram) RPC protocol, on the other hand, while the
first remote call from client to server is protected as previously described 
(with conversation key 6), the credentials themselves are not sent with
the remote call.  Instead, the server itself \*Epulls\*O the credentials, by
performing a \*Ecallback\*O, that is, a reverse (system-level) RPC back to
the client, requesting the credentials.  Once it receives these
credentials, the server proceeds as if the credentials had been
transferred with the original application-level RPC (from client to
server) itself, as in the preceding walkthroughs. 
.LI
Once the application client and server have established
conversation key 6, they cache it and continue to use it for subsequent
RPCs, until it \*Eexpires\*O. All tickets and their conversation
keys are accompanied by an expiration time, beyond which a new
conversation key must be established (via a new service ticket, or
perhaps even a new TGT if that expires, as described in the preceding 
walkthroughs).  Thus, the security overhead of these subsequent RPCs is
minimal, namely, it is reduced merely to the overhead of
encryption/decryption processing itself, without the protocol
message-passing.
.LE
...\" .cS
...\" ***************************************************************************
...\" This is new material for the Authentication chapter in the
...\" Application Development Guide.  This section follows the existing
...\" section on " A Walkthrough of DCE Application Authentication Using RPC".
...\" ***************************************************************************
...\" .cE
.zA "enh,13609,R1.2.2,Changed heads for consistency with pub key"
.H 4 "Authentication Using GSSAPI"
.zZ "enh,13609,R1.2.2,Changed heads for consistency with pub key"
.iX "authentication" "of applications that use GSSAPI"
.iX "GSSAPI" "authentication process"
.PP
This section describes the process by which applications that
perform their network communications via a mechanism
other than DCE RPC can use GSSAPI and DCE
security to authenticate and otherwise protect their communications.
(These alternative communications mechanisms are called \*Epeer-to-peer\*O, to
distinguish them from RPC.)
.PP
In peer-to-peer communications, the application component that
establishes the secure connection is called the \*Econtext initiator\*O
or simply \*Einitiator\*O.  The context initiator is analogous to a DCE
RPC client.  The application component that accepts the secure
connection is called the \*Econtext acceptor\*O or simply
\*Eacceptor\*O.  The context acceptor is analogous to a DCE RPC server.
.PP
.ne 4
The peer application components establish a secure connection in 
the following way.  
(The reader will notice that the underlying security aspects are
identical to those of the preceding RPC case, the only differences being in
the explicit routine-invocation and communications aspects.)
.AL
.LI
.ne 3
The context initiator uses the \*Lgss_init_sec_context(\|)\*O routine to
request from the DCE security server a service ticket (as previously
described) that will allow the initiator to talk to the context acceptor.  
.PP
The initiator's security runtime creates an envelope that contains:
.ML
.LI
The initiator's PTGT
.nS note
.ne 3
It is assumed that the initiator's
security runtime already possesses a PTGT; that is, GSSAPI itself does not
handle login.
.nE
.LI
The acceptor's principal name, protected under conversation key 5
.LE
.PP
The initiator's security runtime sends the envelope to the TGS. 
(As in Section 24.2.2, step 4, this
communication happens via RPC, but this use of RPC is hidden from the
application because it's an implicit RPC being made by the security
runtime, not an explicit RPC by the application initiator itself.)  The
TGS issues a service ticket to the initiator, encrypted in the
acceptor's secret key, exactly as described in Section 24.2.2, step 5.
...\" .PP
...\" .ne 6i
...\" .FG "Peer Applications Establish a Security Context"
...\" .sp .5
...\" .pI ../security/figures/2_authn_80.ps 0 0 1
.LI
The initiator's security runtime recovers conversation key 6 as
described in Section 24.2.2, step 6, and then hands to the GSSAPI the
service ticket (including EPAC chain) and conversation key 4.
.LI
GSSAPI holds onto conversation key 6 and creates a
GSSAPI \*Vtoken\*O containing the service ticket.
.PP
This GSSAPI token is then returned to the initiator, which forwards it
to the acceptor (via the application's chosen communications mechanism).
(Compare this with Section 24.2.2, step 6.)
.LI
The acceptor calls the \*Lgss_accept_sec_context(\|)\*O routine, which
passes the token to the acceptor's security runtime.
.LI
The acceptor's security runtime processes the token, in particular
recovering conversation key 6, exactly as described in Section 24.2.2,
step 7.
.LI
.ne 4
The acceptor's GSSAPI holds onto conversation key 6 and the EPAC chain,
and creates a GSSAPI token containing the success message.  It passes the
token to the acceptor.  (Again, refer to Section 24.2.2, step 7.)
.LI
The acceptor forwards the GSSAPI token to the initiator.
.LI
The initiator passes the token to its GSSAPI, which sends it to the security
runtime by calling the \*Lgss_init_sec_context(\|)\*O routine again.
.LI
The initiator's security runtime tries to decrypt the message.  If this
succeeds, it returns a success status to the GSSAPI that the acceptor's
identity is authenticated.  If not, it returns a failure status to the
GSSAPI.  (Compare this to Section 24.2.2, step 8.)
.LE
.PP
The context acceptor and context initiator can then use
conversation key 6 in future communications by calling
the \*Lgss_sign(\|)\*O and \*Lgss_seal(\|)\*O routines.  
(Compare this scenario with the RPC remarks following Section 24.2.2,
step 8.)
The context acceptor can get the initiator's
EPAC chain in the form of an \*Lrpc_authz_cred_handle_t\*O object so it can
perform a DCE ACL check by calling the
\*Lgssdce_extract_creds_from_sec_context(\|)\*O routine.  If the
context initiator wants to talk to a different context acceptor, it must
acquire a ticket to that context acceptor.
.H 2 "Intercell Authentication"
.iX "authentication" "intercell"
.P
While the intercell authentication model is an extension of intracell
authentication, certain concepts are particular to
intercell authentication.  The following subsections discuss those concepts.
.nL
.ne 20
.H 3 "KDS Surrogates"
.P
A principal trusts the DCE Security Service 
(registry service/KDS/privilege service) to
authenticate other principals in its cell because it trusts the
cryptographic algorithms and protocols, and the security of the code and
data of the security service itself (which is trusted because it is
part of the DCE network trusted computing base).  
The DCE Security Service can authenticate all principals in
its cell because it shares a secret key with each of them.  
A client principal
that wants to talk to a \*Vforeign\*O
server principal (that is, a principal in
another cell) must acquire a ticket targeted to that server.  As always,
such a ticket must be encrypted in the secret key of the foreign server,
else the server will not trust the ticket.
The client cannot get such a ticket from its own local security service,
because only the foreign security service, not
local security service, knows the secret
key of the foreign server.  Therefore, some means must be devised
by which the two instances of the security service can
securely convey information about their respective principals to one
another (without actually divulging secret keys of principals to foreign
security services, which would be a security risk).
.P
Besides the fact that it is trusted \*Ea priori\*O, a cell's KDS
is an exceptional principal in this other respect: other kinds
of principals share their secret keys with the local security
service, whereas the KDS's key is private to the KDS; that is, it
is known to no other principal.  Thus, one problem that intercell
authentication must overcome
is the means by which the KDS in one cell may trust
that in another cell without either of them having to share
their private keys (which would again introduce an unacceptable
security risk).
.nS "note"
.ne 11
With respect to cryptographic keys, the term \*Esecret\*O refers to keys
that are (securely) shared between a bounded set of two (or more)
principals, while \*Eprivate\*O refers to keys that are known to only
a single principal, and \*Epublic\*O to keys that are known to an
unbounded set of principals (potentially to all principals).
The cryptographic algorithms and protocols that are currently supported
by DCE all depend on ``secret key technology'' (typified by DES), even
though a small number of private keys (those of KDSs) are used.
.nE
.P
.ne 13
The solution to this problem is a small extension of the shared-secret
authentication model previously discussed in this chapter.  Namely,
a new principal is invented specifically for cross-cell authentication,
and two entries for this principal are made, one each in the registry service
databases of the two mutually authenticating cells.  The two entries
have the \*Esame\*O secret key.  These two special registry service database entries
.iX "authentication" "mutual surrogates"
.iX "mutual authentication surrogates"
.iX "surrogates" "mutual authentication"
are known as \*Emutual authentication surrogates\*O, and the two cells that
maintain mutual authentication surrogates are called \*Etrust peers\*O.
It is through their surrogates that the two instances of the KDS
can convey information about their respective principals
to one another (though the two KDSs never communicate directly with one
another, nor do the surrogates), thus enabling a client principal from
one cell to acquire a ticket to a server principal in another cell.
.P
An authentication surrogate is a true principal in the sense that it is
represented by an entry in a registry service database, but it is not an autonomous
participant in authenticated communications in the same sense that,
for example, a client or a server is.  Rather, it is more like an \*Ealias\*O
that is assumed by a cell's KDS when it communicates with foreign clients.
The establishment, via surrogates, of a trust peer relationship
between two cells is an \*Eexplicit\*O expression of mutual trust in the
two KDSs on the part of the cell administrators
who establish the relationship.  Administrators use the \*Lrgy_edit\*O
tool to create surrogates and establish the trust relationship.
Administrators who do not trust one another's cells must not establish
such a relationship.
.H 3 "Intercell Authentication by Trust Peers"
.P
This section explains how a client principal in one cell is authenticated
by the KDS in a peer cell, so that the client principal
may communicate with a server principal that is a member of the foreign
cell.  The style of description is the same as in the walkthroughs
earlier in this chapter, though no figures are used here.
.AL
.LI
A client principal, having already been authenticated in the normal way
by the KDS and privilege service in its home cell and acquired its 
PTGT, requests its local TGS for a service ticket targeted
to a server in a foreign cell.  The client
specifies the server principal by its fully
qualified principal name, which includes the name of the
foreign cell.
.LI
.ne 10
The client's security runtime makes a request to the client's local TGS
for a service ticket to the foreign server.  The TGS recognizes by the
server's principal name that it is foreign, so this TGS cannot directly issue
the desired service ticket.  Instead, it issues a so-called
cross-cell TGT (XTGT), which is targeted to the \*Esurrogate\*O shared
between the two cells (that is, it is encrypted in the surrogate's secret
key).  The EPAC
data in the client's PTGT is copied into the XTGT, and
the local TGS returns the XTGT to the client. (For simplicity, we deal
here only with simple case of EPAC data, not a delegation EPAC chain.)
.LI
The client receives the XTGT, recognizes that it is not targeted to the
application server it had requested, and proceeds to send a request
to the foreign TGS for a service ticket to the foreign privilege service, this time
presenting the XTGT (instead of its original TGT) as proof of
authentication.  Upon receiving this request,
the foreign TGS decrypts it by using the surrogate's secret key, and
returns to the client a service ticket to the foreign privilege service.
(Note how knowledge of the surrogate's shared key makes it
possible for the two TGSs to cooperate in this way.)
.LI
The client's security runtime sends this service ticket to the
foreign privilege service, to obtain a cross-cell privilege TGT (XPTGT). 
This XPTGT contains the client's original EPAC, and is encrypted with 
the secret key of the foreign privilege service.
.LI
.ne 7
After the client principal receives
the XPTGT, it sends it to the foreign TGS,
requesting a service ticket to the foreign server principal it was
originally interested in.
From this point on, the protocol goes exactly as it would
in the case of a client principal in the server's cell requesting a service
ticket to that server (as previously described).
Similarly, the client principal may reuse the XPTGT
to acquire service tickets to any other servers in the foreign cell.
.LE
.iX "-]" "authentication"
