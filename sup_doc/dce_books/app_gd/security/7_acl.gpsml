...\"
...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE in the
...\" src directory for the full copyright text.
...\"  
...\" 
...\" HISTORY 
...\" $Log: 7_acl.gpsml,v $
...\" Revision 1.1.10.1  1996/03/27  14:13:23  wardr
...\" 	{edit R1.2.1}
...\" 	More Release Edits
...\" 	[1996/03/27  14:12:59  wardr]
...\"
...\" Revision 1.1.8.12  1995/06/07  14:40:16  rcb
...\" 	PRENTICE HALL reformat; final edits and changes
...\" 	[1995/06/05  19:59:36  rcb]
...\" 
...\" 	fixed typo
...\" 	[1995/05/15  15:04:09  rcb]
...\" 
...\" 	PRENTICE HALL reformat
...\" 	[1995/05/15  14:08:51  rcb]
...\" 
...\" 	incorporated 1.1 edits
...\" 	[1995/05/15  13:26:05  rcb]
...\" 
...\" Revision 1.1.8.11  1994/11/03  23:35:31  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:39:12  neilson]
...\" 
...\" 	Substituted macros for book names in cross refs.
...\" 
...\" Revision 1.1.8.10  1994/10/21  16:22:24  jshirley
...\" 	Fixed cross-refs.
...\" 	[1994/10/21  16:22:12  jshirley]
...\" 
...\" Revision 1.1.8.9  1994/10/12  21:41:08  neilson
...\" 	CR 10357, 11319, 10001 - Fix leftover items.
...\" 	[1994/10/12  21:40:06  neilson]
...\" 
...\" Revision 1.1.8.8  1994/09/07  14:43:30  neilson
...\" 	CR 11319 - Moved text for this change out of the commented-out area
...\" 	where I had mistakenly placed it!  While I was at it, I marked
...\" 	everything inside ".cS-.cE " pairs with leading ...\" comment indicators.
...\" 	[1994/09/07  14:23:48  neilson]
...\" 
...\" Revision 1.1.8.7  1994/08/26  15:24:24  neilson
...\" 	CR 11319 - Improve wording.
...\" 	[1994/08/26  15:23:46  neilson]
...\" 
...\" Revision 1.1.8.6  1994/08/17  20:35:53  neilson
...\" 	CR 11319 - Add ACL Manager name guidelines.
...\" 	[1994/08/17  20:35:19  neilson]
...\" 
...\" Revision 1.1.8.5  1994/05/22  03:38:39  neilson
...\" 	Add engineering changes.
...\" 	[1994/05/22  02:15:51  neilson]
...\" 
...\" Revision 1.1.8.4  1994/05/04  14:43:49  neilson
...\" 	(def, 8399, R1.1)
...\" 	Remove sec_acl_mgr docs, use ACL Library instead.
...\" 	[1994/05/04  14:43:11  neilson]
...\" 
...\" Revision 1.1.8.3  1994/03/14  22:00:56  rom
...\" 	{enh, 10129, R1.1}
...\" 	Fix pathnames of included files for new three-book organization.
...\" 	[1994/03/14  21:20:33  rom]
...\" 
...\" Revision 1.1.8.2  1993/09/08  15:24:43  millette
...\" 	(defect, 8326, R1.0.3)
...\" 	Change sec_acl_type_object in example
...\" 	[1993/09/08  15:23:21  millette]
...\" 
...\" Revision 1.1.6.6  1993/02/22  21:43:33  buckler
...\" 	Changed .P! to .pI and added Postscript boundary boxes
...\" 	[1993/02/22  21:42:43  buckler]
...\" 
...\" Revision 1.1.6.5  1993/01/28  18:46:23  cjd
...\" 	Embedded copyright notice
...\" 	[1993/01/28  18:07:20  cjd]
...\" 
...\" Revision 1.1.6.4  1992/12/11  22:37:35  millette
...\" 	Bug 6401: Document missing APIs
...\" 	[1992/12/11  22:35:02  millette]
...\" 
...\" Revision 1.1.6.3  1992/12/07  21:12:16  millette
...\" 	Bug 5054: Errors in app_gd (rpc_inq_object to rpc_binding_inq_object
...\" 	in Section 45.2.1.1 example)
...\" 	[1992/12/07  21:10:39  millette]
...\" 
...\" Revision 1.1.6.2  1992/11/20  20:00:51  weir
...\" 	Moved into 1.0.2doc tree
...\" 	[1992/11/20  19:50:39  weir]
...\" 
...\" Revision 1.1.4.6  1992/11/11  23:53:38  buckler
...\" 	Corrected index entries
...\" 	[1992/11/11  22:58:34  buckler]
...\" 
...\" Revision 1.1.4.5  1992/11/06  16:31:00  lmk
...\" 	Prentice-Hall index edits only
...\" 	[1992/11/06  16:27:28  lmk]
...\" 
...\" Revision 1.1.4.4  1992/10/10  15:50:29  casey
...\" 	Index changes for PH
...\" 	[1992/10/10  15:37:07  casey]
...\" 
...\" Revision 1.1.4.3  1992/10/09  15:17:56  lmk
...\" 	Prentice-Hall edits only
...\" 	[1992/10/09  15:14:47  lmk]
...\" 
...\" Revision 1.1.4.2  1992/09/14  15:37:17  lmk
...\" 	Prentice-Hall edits only
...\" 	[1992/09/14  15:36:29  lmk]
...\" 
...\" Revision 1.1.2.2  1992/05/07  15:12:39  millette
...\" 	Bug 2769:  Miscellaneaous format and editorial errors.
...\" 	no change bars used.
...\" 	[1992/05/07  14:29:13  millette]
...\" 
...\" Revision 1.1  1992/01/29  16:08:38  damon
...\" 	Initial revision
...\" 
...\" $EndLog$
...\"
...\" (c) Copyright 1991, Open Software Foundation, Inc.  ALL RIGHTS RESERVED
.H 1 "The Access Control List APIs"
.P
.iX "API" "access control list"
As a rule, DCE Security Service interfaces are local client-side
APIs only.  The access control list (ACL)
facility includes this kind of interface, and some
others as well, as follows:
.ML
.LI
The DCE client ACL interface, \*Lsec_acl_\*V*\*L(\|)\*O, is a local
interface that calls a client-side implementation of the ACL network
interface.  It enables clients to browse or edit DCE ACLs.
.LI
The DCE server ACL manager library, \*Ldce_acl_\*V*\*L(\|)\*O,
enables servers to perform DCE-conformant authorization
checks at runtime.  This ACL library provides an implementation of the
ACL manager interface and the ACL network interface.  It supports the
development of ACL managers for DCE servers.
.LI
The DCE ACL network interface, \*Lrdacl_\*V*\*L(\|)\*O,
enables servers that manage access control to communicate with
\*Lsec_acl\*O-based clients.
.LE
.P
Figure 32-1 provides a schematic view
of the relationships and usage of these interfaces, as well as some
relevant RPC interfaces.  This chapter first discusses the client API,
and then the two server program interfaces.
.P
.ne 5i
.FG "ACL Program Interfaces"
.pI ../security/figures/7_acl_10.eps 0 0 1
.H 2 "The Client-Side API"
.P
The client-side API is a local interface consisting of a set of
routines that are prefixed \*Lsec_acl\*O.  This is the interface
.iX "ACL" "editor"
.iX "editor, ACL"
on which the default DCE ACL editor (the DCE control program, or \*Ldcecp\*O) 
is built.  An application that needs to replace \*Ldcecp\*O with a DCE ACL
editor or browser of its own calls this interface.
The following subsections provide specific information on the functionality
that this API supports.
.H 3 "Binding to an ACL"
.P
.iX "ACL" "handle"
.iX "handle" "ACL"
Any operation performed on an ACL uses an ACL handle of type
\*Lhandle_t\*O to identify the target of the operation.  The handle is
bound to the server that manages the object protected by the ACL, not
to the ACL itself.  Since an object may be protected by more than one
ACL manager type (see Chapter 25), 
the ACL itself can only be uniquely identified by
the ACL handle in combination with the manager type that manages it.
ACL editing calls must also specify the ACL type to be read or
otherwise manipulated (the object, default container, or default
Object ACL types).
.P
An application calls \*Lsec_acl_bind(\|)\*O to get an ACL handle.
The handle itself is opaque to the calling program, which needs none
of the information encoded in it to use the ACL interface. 
A program can obtain the list of ACL manager types protecting an object 
and pass this data, along with the ACL type identifier, to another 
client-side routine.  The following two calls perform this function:
.ML
.LI
\*Lsec_acl_get_manager_types(\|)\*O returns a list of UUIDs 
of the manager types.
.LI
\*Lsec_acl_get_manager_types_semantics(\|)\*O returns UUIDs of the
manager types, and also the POSIX semantics supported by each manager type.  
The output of this call is used by the \*Lsec_acl_calc_mask(\|)\*O routine 
when it calculates a new \*Lmask_obj\*O mask.
.LE
.P
In the absence of CDS, an application may call 
\*Lsec_acl_bind_to_addr(\|)\*O;
this call binds to a network address rather than a cell namespace
entry. 
...\" .cS
...\" *****
...\" A program
...\" can obtain a list of ACL manager types protecting an object with the
...\" \*Lsec_acl_get_manager_types(\|)\*O call, which returns a list of
...\" UUIDs corresponding
...\" to these manager types; and pass this data, along with the ACL type
...\" identifier, to another client-side routine. (In the absence of
...\" a Cell Directory Service, an application may call \*Lsec_acl_bind_to_addr(\|)\*O;
...\" this call binds to a network address rather than a cell namespace
...\" entry.)
...\" ****
...\" .cE
.P
Once an application is finished using an ACL handle, it should call
\*Lsec_acl_release_handle(\|)\*O to dispose of it.
.H 3 "ACL Editors and Browsers"
.P
.ne 5
After obtaining a handle to the object in question (and using\*L
sec_acl_get_manager_types(\|)\*O or 
\*Lsec_\%acl_\%get_\%manager_\%types_\%semantics(\|)\*O 
to determine the ACL manager types
protecting the object), 
editors and browsers use the \*Lsec_acl_lookup(\|)\*O function to
return a copy of an object's ACL. 
.P
Once an object's ACL is retrieved,
the editor can call \*Lsec_acl_get_printstring(\|)\*O to receive
instructions about how to display the permissions of the ACL in a
human-readable form.
This call returns a symbol or word for each
permission (a character string), and also a bitmask, with a bit (or
bits) set to encode the permission.  In
addition, the print string structure includes a short explanation of
each permission.
.P
An ACL cannot be modified in part. To change an ACL, an editor must
read the entire ACL (the \*Lsec_acl_t\*O structure), modify it,
and replace it entirely by calling \*Lsec_acl_replace(\|)\*O.
If the ACL manager supports the \*Lmask_obj\*O mask type, you can use
\*Lsec_acl_calc_mask(\|)\*O to calculate a new
\*Lsec_acl_e_type_mask_obj\*O entry type.  This function is supported
for POSIX compatibility only, for those applications that use
\*Lmask_obj\*O with its POSIX semantics.  Accordingly,
\*Lsec_acl_calc_mask(\|)\*O returns the union of the permissions of all
ACL entries \*Eother than\*O \*Luser_obj\*O, \*Lother_obj\*O,
\*Lunauthenticated\*O (and the pre-existing \*Lmask_obj\*O).  These
correspond approximately to what POSIX calls the ``File Group Class'' of
ACL entries, although that designation is not appropriate in the DCE
context.  In particular, \*Lsec_acl_calc_mask(\|)\*O works
independently of DCE DFS.
.P
Use the \*Lsec_acl_get_manager_types_semantics(\|)\*O routine to obtain
the required POSIX semantics and determine if the manager to which the
ACL list will be submitted supports the \*Lsec_acl_e_type_mask_obj\*O
entry type.
...\" .cS
...\" .zA "def,6401,R1.0.2,add APIs"   
...\" If the ACL manager supports the \*Lmask_obj\*O mask type, you can use \*Lsec_acl_calc_mask(\|)\*O to 
...\" calculate a new \*Lsec_acl_e_type_mask_obj\*O entry type.  This entry is the union of 
...\" the permissions of all ACL entries that refer to members of the File Group Class.  
...\" Use the \*Lsec_acl_get_manager_types_semantics(\|)\*O routine to obtain the  
...\" required POSIX semantics and determine if the manager to which the ACL list 
...\" will be submitted supports the \*Lsec_acl_e_type_mask_obj\*O entry type. 
...\" .zZ "def,6401,R1.0.2,add APIs" 
...\" .cE
.P
An ACL can occupy a substantial amount of memory. The memory management
routine, \*Lsec_acl_release(\|)\*O, frees the memory occupied by
an ACL, and returns it to the pool.  This is implemented strictly as
a local operation.
...\" .cS
...\" .H 3 "Testing Access"
...\" .P
...\" .iX "ACL" "access testing"
...\" .iX "access testing" "ACL"
...\" Access testing by clients is not definitive because the state of an
...\" ACL can change between the access test and the request to the server
...\" to perform an application operation.  More typically, a client simply
...\" requests an operation; then, upon receiving the request, the server
...\" performs the access test, and depending on the result, either executes
...\" the client's request or returns an error to the client.  However, if
...\" an application server acts as a client of another server that manages
...\" ACLs for the application objects, the application server needs the
...\" results of access tests from the ACL manager server in order to process
...\" requests from application clients.
...\" .P
...\" After calling \*Lsec_acl_bind(\|)\*O to acquire an ACL handle to
...\" the target object, such an application server would call \*Lsec_acl_test_access(\|)\*O with the returned handle, the UUID of the ACL manager, and
...\" the permission(s) requested in order to perform the requested operation.
...\" The access-test function returns TRUE if the object's ACL allows
...\" the client to perform the operation; otherwise, it returns FALSE.
...\" An alternative
...\" to \*Lsec_acl_test_access(\|)\*O, \*Lsec_acl_get_access(\|)\*O is
...\" useful for implementing operations like the conventional UNIX system
...\" access function.
...\" .P
...\" Some applications need to check an ACL on behalf of a principal other
...\" than the one represented by the calling process.  For example, a replicated
...\" database server would presumably need to check the privilege attributes
...\" of its clients against the database ACL entries.  In this case, the
...\" server would use the \*Lsec_acl_test_access_on_behalf(\|)\*O function,
...\" which is identical to the \*Lsec_acl_test_access(\|)\*O function,
...\" except that it also requires the PAC of the principal for which the
...\" server principal is acting as an agent.  This function checks both
...\" the privilege attributes of the principal represented by the calling
...\" process and those encoded in the PAC. It returns TRUE if the most
...\" restrictive combination of the two permission sets grants the requested
...\" permission(s).
...\" .cE
.H 3 "Errors"
.P
.iX "ACL" "errors"
.iX "errors" "ACL"
Although the ACL API saves errors received from the DCE RPC runtime
(or other APIs) in ACL handle data, it returns an error describing
the ACL operation that failed as a result of the RPC error.  However,
if an error occurs and the client needs to know the cause of the ACL
operation failure, it may call \*Lsec_acl_get_error_info(\|)\*O.
This routine returns the error code last stored in the handle.
...\" .cS
...\" .H 2 "The Server-Side API"
...\" .P
...\" .iX "API" "server-side"
...\" .iX "server-side APIs"
...\" The server-side API consists of a set of routines that are prefixed \*Lsec_acl_mgr\*O.  This is the interface from which the default DCE ACL
...\" managers are built.  It would be used by any application that accesses
...\" persistent storage of access control information in order to make
...\" runtime authorization decisions that are DCE-conformant (in terms
...\" of the representation of identities,
...\" the access-check algorithm, and so on).  This is a local
...\" interface that is supplied in source code form (interfaces to these
...\" routines are described in the \*EOSF DCE Application Development Reference\*O).
...\" This interface can be tailored as necessary for integration into application
...\" code.
...\" .P
...\" A second program interface is the ACL network interface (or ``wire''
...\" protocol).  This interface consists of a set of routines that are prefixed
...\" \*Lrdacl\*O.  This is a remote interface that enables any server
...\" program that manages access control information (preferably, though
...\" not necessarily, DCE ACL managers) to communicate with \*Lsec_acl-\*Obased clients.
...\" .H 3 "The ACL Manager Interface"
...\" .P
...\" Following is a summary of ACL manager routines:
...\" .ML
...\" .LI
...\" \*Lsec_acl_mgr_configure(\|)\*O
...\" .P
...\" Creates an ACL database
...\" and returns a handle to it
...\" .LI
...\" \*Lsec_acl_mgr_is_authorized(\|)\*O
...\" .P
...\" Takes a principal's
...\" PAC and the requested permission set and returns TRUE if the permission
...\" set is granted
...\" .LI
...\" \*Lsec_acl_mgr_get_access(\|)\*O
...\" .P
...\" Returns a principal's
...\" permissions to an object (useful for implementing operations like
...\" the conventional UNIX system access function)
...\" .LI
...\" \*Lsec_acl_mgr_replace(\|)\*O
...\" .P
...\" Replaces the specified
...\" ACL
...\" .LI
...\" \*Lsec_acl_mgr_lookup(\|)\*O
...\" .P
...\" Returns a copy of the
...\" object's ACL
...\" .LI
...\" \*Lsec_acl_mgr_get_manager_types(\|)\*O
...\" .P
...\" Returns a
...\" list of manager types protecting the object
...\" .zA "def,6401,R1.0.2,add APIs" 
...\" .LI
...\" \*Lsec_acl_mgr_get_types_semantics(\|)\*O 
...\" .P
...\" Returns the types of
...\" ACLs and the POSIX semantics that are protecting an object  
...\" .zZ "def,6401,R1.0.2,add APIs"
...\" .LI
...\" \*Lsec_acl_mgr_get_printstring(\|)\*O
...\" .P  
...\" Returns human-readable representations of permissions                                                   
...\" ...\" .LI
...\" ...\" \*Lsec_acl_get_manager_types_semantics(\|)\*O
...\" ...\" .P
...\" ...\" Lists the manager types of the ACLs protecting an object 
...\" ...\" .LI
...\" ...\" \*Lsec_acl_calc_mask(\|)\*O 
...\" ...\" .P
...\" ...\" Returns the \*Lsec_acl_type_mask_obj\*O entry for the specified ACL
...\" ...\"
...\" .LE
...\" .H 4 "A Sample ACL Manager"
...\" .P
...\" Following is sample application server code that tests a client's
...\" access to an object that the application protects:  
...\" .zA "def,5054,R1.0.2,rpc_inq_object to rpc_binding_inq_object"
...\" .oS
...\" application_op(handle_th, ...)
...\" {
...\"    ...
...\"    rpc_binding_inq_auth_client(h,&PAC, &server_name,
...\"                                &protect_level, &authn_svc,
...\"                                &authz_svc, &st);
...\" 
...\"    rpc_binding_inq_object(h, &object, &st);
...\" 
...\"    if (authentication_levels_are_appropriate(server_name,
...\"                                              protect_level,
...\"                                              authn_svc,
...\"                                              authz_svc)
...\"       && sec_acl_mgr_is_authorized(sec_acl_mgr_handle_t,
...\"                                    sec_acl_permset_t, &PAC,
...\"                                    (sec_acl_key_t)&object,
...\" .zA "def,8326,R1.0.3,sec_acl_type_object to manager_type"                               
...\"                                    &manager_type, NULL,
...\"                                    NULL, &st))
...\" .zZ "def,8326,R1.0.3,sec_acl_type_object to manager_type"                                   
...\"    {
...\"       ...Application code to perform operation
...\"    }
...\"    else
...\"    {
...\"       ...Perform appropriate application logging etc.
...\"    }
...\" }
...\" 
...\" .oE 
...\" .zZ "def,5054,R1.0.2,rpc_inq_object to rpc_binding_inq_object"
...\" .P
...\" For more information about writing ACL managers, refer to Part 1 of
...\" this guide.
...\" .cE
.H 2 "Guidelines for Constructing ACL Managers"
.P
ACL manager names for all of DCE should follow the convention for
naming \*Ldcecp\*O attributes.  There is no architectural
restriction involved in the guidelines shown here, merely an attempt at
consistency.  The DCE control program will accept names
outside of this convention, but adherence to it will make usage of ACL
managers easier. 
.P
The guidelines are as follows:
.ML
.LI
Alphabetic characters in names must be lowercase only.
.LI
Names should not contain underscores.
.LI
Names should not contain spaces.
.LI
Names should be no longer than 16 bytes, the defined value of
\*Lsec_acl_printstring_len\*O.
.LI
Names should be similar to object command names supported in
\*Ldcecp\*O whenever possible.  For example, the ACL manager name
\*Lprincipal\*O refers to the object, \*L/.:/sec/principal\*O, that
contains registry information about principals.  Note that \*Ldcecp\*O
allows abbreviations.  For example, a user can specify \*Lorg\*O for the
ACL manager name \*Lorganization\*O.
.LI
Names must be unique within a component's ACL manager but not
necessarily within DCE.  For example, the name \*Lxattrschema\*O can be
used for a DCE extended attribute configuration schema ACL object and
for a security ERA schema ACL object.
.LI
The help string for an ACL manager must specify the component
that owns or manages the objects in question because this
information cannot always be derived from the ACL manager name.
.LE
.H 2 "Extended Naming of Protected Objects"
.P
.iX "ACL" "extended naming"
.iX "ACL" "manager interface"
.iX "extended naming, ACL"
.iX "manager interface, ACL"
The DCE ACL model supports extended naming so that ACL managers can
separately protect objects that are not registered in the cell
namespace.  This provides an alternative to registering all the
server's objects with CDS.  The server alone is
registered, and it contains code to identify its own objects by name.
To achieve ACL protection for these objects, the ACL manager must be
able to identify the ACLs in the same way the server identifies the
objects.  A resolution routine provides this ability.
.P
Figure 32-2 shows the example of a printer server
that is registered with CDS, with printers that are not.  The ACL manager
for the printer server uses the \*Ldce_acl_resolve_by_name(\|)\*O resolution
routine to obtain the UUIDs of the several printers that are supported.
The administrator in charge of the printers can change the printers,
their names, and their ACLs without concern for registering them with CDS.
.P
.FG "Protection with Extended Naming"
.pI ../security/figures/7_acl_11.eps 3.6i 4.3i
.sp .5
.P
.ne 5
When the \*Ldce_acl_register_object_type(\|)\*O routine registers an
object type, it associates a resolution routine with the object type.
The ACL library provides two resolution routines:
\*Ldce_acl_resolve_by_name(\|)\*O and \*Ldce_acl_resolve_by_uuid(\|)\*O.
Other resolution routines can be easily written, as required.
...\" .cS
...\" For example, suppose an application manages different
...\" kinds of printers.  The application may register only printer types,
...\" such as \*Llaser\*O and \*Lline\*O, with the Cell Directory Service.
...\" Among the laser printers is a high-resolution printer that is
...\" available only to members of the group \*Lwriters\*O, and low-resolution
...\" laser printers that anyone may use.  When the Cell Directory Service receives
...\" a name such as \*L/laser/high-resolution\*O, it passes the
...\" residual part of the name (\*Lhigh-resolution\*O) to the appropriate
...\" ACL manager, which resolves the residual and makes a determination
...\" as to whether the principal requesting to print on the high-resolution
...\" laser printer may do so.
...\" .cE
.P
To take advantage of extended naming, an ACL manager must register
the server name, object UUID, and \*Lrdaclif.idl\*O interface with
the CDS.  (Refer to the \*(Dd for more information). 
In addition, the ACL manager must register the object
UUID and \*Lrdaclif.idl\*O interface with the RPC endpoint mapper
(refer to the chapters concerning RPC in Part 3 of this guide).
.H 3 "The ACL Network Interface"
.iX "ACL" "network interface"
.iX "network" "ACL interface"
.P
The ACL network interface, \*Lrdacl_\*V*\*L(\|)\*O, provides a DCE-common
interface to ACL managers.  It is the interface exported by the default
DCE ACL managers to the default DCE ACL client (that is, the
\*Ldcecp\*O tool), and any other client based on the client API.
.P
The client API, \*Lsec_acl_\*V*\*L(\|)\*O, is a local interface that calls
a client-side implementation of the ACL network interface.  The server
side implementation of this interface must conform to the
\*Lrdacl_\*V*\*L(3sec)\*O reference pages.  The DCE ACL library
provides such an implementation.  Following is a summary of the
\*Lrdacl_\*V*\*L(\|)\*O routines:
.ML
.LI
\*Lrdacl_lookup(\|)\*O
.P
Retrieves a copy of the object's
ACL.
.LI
\*Lrdacl_replace(\|)\*O
.P
Replaces the specified ACL.
.LI
\*Lrdacl_get_access(\|)\*O
.P
Returns a principal's
permissions to an object (useful for implementing operations like
the conventional UNIX system access function).
.LI
\*Lrdacl_test_access(\|)\*O
.P
Determines whether the
calling principal has the requested permission(s).
.LI
\*Lrdacl_test_access_on_behalf(\|)\*O
.P
Determines
whether the principal represented by the calling principal has the
requested permission(s).  This function returns TRUE if both the principal
and the calling principal acting as its agent have the requested permission(s).
.nS note
The \*Lrdacl_test_access_on_behalf(\|)\*O routine is deprecated and
should not be used in new code.  Delegation has removed the need for
this routine.
.nE note
.LI
\*Lrdacl_get_manager_types(\|)\*O
.P
Returns a list
of manager types protecting the object.
.LI
\*Lrdacl_get_printstring(\|)\*O
.P
Obtains human-readable
representations of permissions.
.LI
\*Lrdacl_get_referral(\|)\*O
.P
Returns a referral to
an ACL update site.  This function enables a client that attempts to
modify an ACL at a read-only site to recover from the error and
rebind to an update site.
.LE
...\" ****************************************
.H 3 "The ACL Library"
.P
The ACL library provides an implementation of the ACL manager
interface and the ACL network interface for
the convenience of programmers who are writing ACL managers for DCE
servers.
.P
The ACL library meets the following needs:
.ML
.LI
It provides stable storage for ACLs.
.LI
It implements the \*Lrdacl_\*V*\*L(\|)\*O interface, including support for
multiple object types, initial default Object ACLs, and initial
default Container ACLs.
.LI
It implements the full access algorithm, including masks and
delegation.
.LI
It provides DCE developers with a set of convenience functions so that servers
can easily perform common styles of access control with minimal effort.
...\" .cS
...\" .LI
...\" It supports copy-on-write ACLs by indicating to application code that an
...\" operation is modifying an ACL object.  This gives the application code
...\" the opportunity to create a new ACL object if the original object has
...\" a reference count greater than one.  \*L *** WE DON'T DO THIS.  Ask rsalz
...\" if we should. *** \*O
...\" .cE
.LE
.H 4 "ACL Library Capabilities"
.P
The ACL library provides simple and practical access to the DCE security
model.
...\" .cS
...\" .P
...\" ACL objects, stored in a Backing Store database, are indexed by a
...\" DCE UUID.
...\" The standard data prolog defined in the Backing Store Library includes
...\" a reference count field.  If a server uses this field, it can share
...\" ACL objects, creating new ones only when the ACL library indicates to
...\" the server that an \*Lrdacl\*O \*Lreplace\*O operation is being done. 
...\" .cE
.P
The library provides a routine that indicates in a single call whether
or not a client has the appropriate permissions to perform a
particular operation.  A server can also easily retrieve the full set
of permissions granted to a client by an object's ACL.
.P
The library provides the complete \*Lrdacl_\*V*\*L(\|)\*O remote interface.
Standard routines are provided to map either a
UUID attached to a handle or a residual name specified as one of the
parameters.
.P
The combination of these capabilities means that most servers will not
have any need to use DCE ACL data types directly.
.H 4 "The ACL API"
.P
The ACL library API, \*Ldce_acl_\*V*\*L(\|)\*O, is a local interface that
provides the server-side implementation of the ACL network interface.
The reference pages in \*(Dr
describe the library routines.
.P
The ACL library consists of the following parts:
.ML
.LI
Initialization routines, where the server registers each ACL manager
type.
.LI
Server queries, where a server can perform various types of access
checks.
.LI
ACL object creation, where servers can create ACLs without concern
for most low-level data type details.
.LI
The \*Lrdacl_\*V*\*L(\|)\*O implementation and server callback, where the
server maps \*Lrdacl_\*V*\*L(\|)\*O parameters into a specific ACL object.
Two sample resolver routines are associated with this part:
.ML
.ne 7
.LI
\*Ldce_acl_resolve_by_name(\|)\*O
.P
Finds an ACL's UUID, given an object's name.
.LI
\*Ldce_acl_resolve_by_uuid(\|)\*O
.P
Finds an ACL's UUID, given an object's UUID.
.LE
.LE
.H 5 "Initialization Routines"
.P
An ACL manager must first define the types of the objects it manages.
For example, a simple directory service would have directories and entries,
and each type of object would have a different ACL manager.  On a
practical level, if a server has different types of objects, then the most
common difference between the ACL managers is the printed representation
of its permission bits.  In other words, although the
\*Lsec_acl_printstring_t\*O values differ, the algorithm
for evaluating permissions remains the same.
.P
The ACL library provides a global print string that specifies the
\*Lread\*O, \*Lwrite\*O, and \*Lcontrol\*O bits.
Application developers are encouraged to use this print string
whenever appropriate.
.P
An ACL manager calls the \*Ldce_acl_register_object_type(\|)\*O routine
to register an object type, once for each type of object that the
server manages.  The manager print string does not define any permission bits;
they are set by the library to be the union of all permissions
in the ACL print string.
.P
The server must register the \*Lrdacl_\*V*\*L(\|)\*O interface with the RPC
runtime and with the endpoint mapper.  See the
\*Ldce_server_register(3dce)\*O reference page.
.H 5 "Server Queries"
.P
The ACL library provides several routines to automate the most common
use of DCE ACLs:
.ML
.LI
\*Ldce_acl_is_client_authorized(\|)\*O
.P
Checks whether a client's credentials are authenticated and, if so,
that they grant the desired access.
.LI
.ne 3
\*Ldce_acl_inq_client_permset(\|)\*O
.P
Returns the client's permissions, corresponding to an ACL.
.LI
\*Ldce_acl_inq_client_creds(\|)\*O
.P
Returns the client's credentials.
.LI
\*Ldce_acl_inq_permset_for_creds(\|)\*O
.P
Determines a client's complete extent of access to an object.
.LI
\*Ldce_acl_inq_acl_from_header(\|)\*O
.P
Retrieves the UUID of an ACL from the header of an object in the
backing store.
.LI
\*Ldce_acl_inq_prin_and_group(\|)\*O
.P
Inquires the principal and the group of an RPC caller.
.LE
.H 5 "Creating ACL Objects"
.P
The following convenience functions may be used by an application
programmer to create ACL objects in other servers or clients.
.ML
.LI
\*Ldce_acl_copy_acl(\|)\*O
.P
Copies an ACL.
.LI
\*Ldce_acl_obj_init(\|)\*O
.P
Initializes an ACL for an object.
.LI
\*Ldce_acl_obj_free_entries(\|)\*O
.P
Frees space used by an ACL's entries.
.LI
\*Ldce_acl_obj_add_user_entry(\|)\*O
.P
Adds permissions for a user ACL entry to the given ACL.
.LI
\*Ldce_acl_obj_add_group_entry(\|)\*O
.P
Adds permissions for a group ACL entry to the given ACL.
.LI
\*Ldce_acl_obj_add_id_entry(\|)\*O
.P
Adds permissions for an ACL entry to the given ACL.
.LI
\*Ldce_acl_obj_add_unauth_entry(\|)\*O
.P
Adds permissions for an \*Lunauthenticated\*O ACL entry to the given ACL.
.LI
\*Ldce_acl_obj_add_obj_entry(\|)\*O
.P
Adds permissions for an \*Lobj\*O ACL entry to the given ACL.
.LI
\*Ldce_acl_obj_add_foreign_entry(\|)\*O
.P
Adds permissions for the ACL entry for a foreign user or group to the given ACL.
.LI
\*Ldce_acl_obj_add_any_other_entry(\|)\*O
.P
Adds permissions for the \*Lany_other\*O ACL entry to a given ACL.
.LE
.H 5 "RDACL Implementation and Server Callback"
.P
The ACL library makes a complete implementation of the
\*Lrdacl_\*V*\*L(\|)\*O interface available to programmers writing servers,
in a manner that is mostly transparent to the rest of the server code.
.P
The operations in the \*Lrdacl_\*V*\*L(\|)\*O interface share an initial set of
parameters that specify the ACL object being operated upon:
.oS
handle_t                        h
sec_acl_component_name_t        component_name
uuid_t                          *manager_type
sec_acl_type_t                  sec_acl_type
.oE
.P
The \*Vsec_acl_type\*O parameter indicates whether a protection ACL,
an initial default Object ACL, or an initial default Container ACL
is desired.
It does not appear in the \*Laccess\*O operations as it must have the
value \*Lsec_acl_type_object\*O.
.P
In order to implement the \*Lrdacl_\*V*\*L(\|)\*O interface, 
the server must provide
a \*Lresolution\*O routine that maps these parameters into the UUID
of the desired ACL object; the library includes two such routines:
\*Ldce_\%acl_\%resolve_\%by_\%uuid(\|)\*O 
and \*Ldce_acl_resolve_by_name(\|)\*O.
.P
.ne 6
The resolution routine is required because servers use the namespace
in different ways.  Here are three examples:
.ML
.LI
Servers that export only their binding information and manage a single
object, and hence use a single ACL, do not need the resolution
parameters.  DTS is an example of this case.
.LI
Servers with many objects in the namespace, with a UUID in
each entry, will call \*Lrpc_binding_inq_object\*O on the handle to
obtain the object UUID.  They then use this same UUID as the index of
the ACL object.  Many application servers will be of this type.  One
ACL library resolver function, \*Ldce_acl_resolve_by_uuid(\|)\*O, matches
this paradigm.  This paradigm is not appropriate if the number of
objects is immense.
.LI
Servers with many objects will use a junction or similar architecture so
that the component name (also called the \*Lresidual\*O) specifies
the ACL object by name.  The DCE security server is essentially of this type.  Another
ACL library resolver function, \*Ldce_acl_resolve_by_name(\|)\*O, matches
this paradigm.
.LE
.P
The following \*Ltypedef\*O specifies the signature for a resolution
routine.
The first four parameters are the common \*Lrdacl_\*V*\*L(\|)\*O parameters 
mentioned previously.
.oS
typedef void (*dce_acl_resolve_func_t)(
/* [in] parameters */
    handle_t                    h,
    sec_acl_component_name_t    component_name,
    sec_acl_type_t              sec_acl_type,
    uuid_t                      *manager_type,
    boolean32                   writing,
    void                        *resolver_arg
/* [out] parameters */
    uuid_t                      *acl_uuid,
    error_status_t              *st
);
.oE
.P
For situations in which neither of the ACL library resolver functions,
\*Ldce_acl_resolve_by_uuid(\|)\*O or
\*Ldce_acl_resolve_by_name(\|)\*O, is 
appro\%priate, application
developers must provide their own.
.P
.ne 4
The following two examples illustrate the general structure of the
\*Ldce_acl_resolve_by_uuid(\|)\*O API and
\*Ldce_acl_resolve_by_name(\|)\*O API that are supplied in the ACL
library.  They may be used as paradigms for creating additional
resolver routines.
.P
The first example shows \*Ldce_acl_resolve_by_name(\|)\*O.
.P
A server has several objects and stores each in a backing store database.
Part of the standard header for each object is a structure that contains
the UUID of the ACL for that object.
(The standard header is not intended to be an abstract type, but rather
a common prolog provided to ease server development.)  The
resolution routine for this server retrieves the object UUID
from the handle, uses that as an index into its own backing store,
and uses the \*Vsec_acl_type\*O parameter to retrieve the appropriate
ACL UUID from the standard data header.
.P
This routine needs the database handle for the server's object storage,
which is specified as the \*Vresolver_arg\*O parameter in
the \*Ldce_\%acl_\%register_\%object_\%type(\|)\*O call.
.nL
.ps 11
.vs 13
.oS
.ne 36
#define STAT_CHECK_RET(st) { if (st != error_status_ok) return; }
dce_acl_resolve_func_t
dce_acl_resolve_by_uuid(
  /* in */
    handle_t			h,
    sec_acl_component_name_t	component_name,
    sec_acl_type_t		sec_acl_type,
    uuid_t			*manager_type,
    boolean32			writing,
    void			*resolver_arg,
  /* out */
    uuid_t			*acl_uuid,
    error_status_t		*st
)
{
    dce_db_handle_t             db_h;
    dce_db_header_t             dbh;
    uuid_t                      obj;

    /* Get the object. */
    rpc_binding_inq_object(h, &obj, st);
    STAT_CHECK_RET(*st);

.ne 7
    /* Get object header using the object backing store.  
     * The handle was passed in as the resolver_arg in the 
     * dce_acl_register_object_type call.
     */
    db_h = (dce_db_handle_t)resolver_arg;
    dce_db_std_header_fetch(db_h, &obj, &dbh, st);
    STAT_CHECK_RET(*st);

    /* Get the appropriate ACL based on the ACL type. */
    dce_acl_inq_acl_from_header(dbh, sec_acl_type, acl_uuid, st);
    STAT_CHECK_RET(*st);
}
.oE
.ps 12
.vs 14
.P
.ne 20
The next example shows \*Ldce_acl_resolve_by_name(\|)\*O.
.P
A server uses the residual name to resolve an ACL object by using
\*Ldce_acl_resolve_by_name(\|)\*O.
This routine requires a DCE database that maps names into ACL UUIDs.
This backing store database must be maintained by the server
application so that created objects always get a name, and
that name must be a key into a database that stores the UUID
identifying the object.  The \*Vresolver_arg\*O parameter given in the
\*Ldce_acl_register_object_type(\|)\*O call must be a handle for that
database.
.nL
.ps 11
.vs 13
.oS
.ne 30
#define STAT_CHECK_RET(st) { if (st != error_status_ok) return; }
dce_acl_resolve_func_t
dce_acl_resolve_by_name(
  /* in */
    handle_t			h,
    sec_acl_component_name_t	component_name,
    sec_acl_type_t		sec_acl_type,
    uuid_t			*manager_type,
    boolean32			writing,
    void			*resolver_arg,
  /* out */
    uuid_t			*acl_uuid,
    error_status_t		*st
)
{
    dce_db_handle_t             db_h;
    dce_db_header_t             dbh;

    /* Get object header using the object backing store.  
     * The handle was passed in as the resolver_arg in the 
     * dce_acl_register_object_type call.
     */
    db_h = (dce_db_handle_t)resolver_arg;
    dce_db_std_header_fetch(db_h, component_name, &dbh, st);
    STAT_CHECK_RET(*st);

    /* Get the appropriate ACL based on the ACL type. */
    dce_acl_inq_acl_from_header(dbh, sec_acl_type, acl_uuid, st);
    STAT_CHECK_RET(*st);

}
.oE
.ps 12
.vs 14
