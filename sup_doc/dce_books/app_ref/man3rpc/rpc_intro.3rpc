...\" @OSF_COPYRIGHT@
...\" COPYRIGHT NOTICE
...\" Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
...\" ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
...\" the full copyright text.
...\" 
...\" 
...\" HISTORY
...\" $Log: rpc_intro.3rpc,v $
...\" Revision 1.1.4.1  1996/11/18  19:57:12  wardr
...\" 	{edit,R1.2.2}
...\" 	Init capped heads and added PDG pointer
...\" 	[1996/11/18  19:34:17  wardr]
...\"
...\" Revision 1.1.2.12  1995/06/21  13:20:25  buckler
...\" 	More 1.1 edits.
...\" 	[1995/06/20  18:58:05  buckler]
...\" 
...\" 	More 1.1 edits.
...\" 	[1995/06/19  16:54:21  buckler]
...\" 
...\" 	More 1.1 edits.
...\" 	[1995/06/19  16:19:18  buckler]
...\" 
...\" Revision 1.1.2.11  1995/06/07  20:11:04  buckler
...\" 	1.1 edits  Prentice Hall reformat
...\" 	[1995/06/07  20:06:08  buckler]
...\" 
...\" Revision 1.1.2.9  1995/05/18  16:31:26  rcb
...\" 	PRENTICE HALL reformat: preliminary fiddling
...\" 	[1995/05/18  16:30:56  rcb]
...\" 
...\" Revision 1.1.2.8  1994/11/03  23:45:57  neilson
...\" 	Substituted macros for book names in cross refs.
...\" 	[1994/11/03  01:39:32  neilson]
...\" 
...\" Revision 1.1.2.7  1994/10/18  18:22:43  zahn
...\" 	{enh,5284,R1.1}
...\" 
...\" 	Added M. Romagna's technical review comments.
...\" 	[1994/10/18  18:22:28  zahn]
...\" 
...\" Revision 1.1.2.6  1994/07/14  19:04:24  jshirley
...\" 	(def,10220,R1.1}
...\" 	Remove references to rpcd and sec_clientd.
...\" 	[1994/07/14  18:44:13  jshirley]
...\" 
...\" Revision 1.1.2.5  1994/06/13  17:03:47  devobj
...\" 	cr10872 - fix copyright
...\" 	[1994/06/13  16:47:34  devobj]
...\" 
...\" Revision 1.1.2.4  1994/05/05  19:29:41  zahn
...\" 	Added a note about including an application that
...\" 	has used the ACF encode and decode attributes as
...\" 	a prerequisite for using the IDL encoding services.
...\" 	[1994/05/05  19:29:18  zahn]
...\" 
...\" Revision 1.1.2.3  1994/05/03  18:12:45  zahn
...\" 	Removed use of bookdef macro for Appication Development
...\" 	Guide-Core Components.  Looks like it was the build breaking
...\" 	culprit.
...\" 	[1994/05/03  18:12:29  zahn]
...\" 
...\" Revision 1.1.2.2  1994/04/13  19:15:48  zahn
...\" 	{enh,5284,R1.1}
...\" 
...\" 	Added documentation for character and code set i14y.
...\" 
...\" 	(enh,9601,R1.1}
...\" 
...\" 	Added documentation for IDL encoding services.
...\" 
...\" 	{enh,9773,R1.1}
...\" 
...\" 	Added documentation for character/code set registry.
...\" 
...\" 	{def,9262,R1.1}
...\" 
...\" 	Deleted "stub support routine" list and list of rpc_ss
...\" 	calls.  Merged rpc_sm call list into "DCE RPC routines"
...\" 	list.  This work is part of de-emphasizing use of rpc_ss
...\" 	routines and emphasizing use of rpc_sm routines.
...\" 
...\" 	(def,9908,R1,1}
...\" 
...\" 	Deleted note about connectionful RPC being unsupported
...\" 	because it's no longer true.
...\" 
...\" 	(def,8443,R1.1}
...\" 
...\" 	Removed listing of dce_error_inq_text() from list of
...\" 	DCE RPC routines because it's moving to man3dce.
...\" 
...\" 	Fixed all documentation references to use macros defined in bookdefs.mac.
...\" 	[1994/04/13  19:15:32  zahn]
...\" 
...\" Revision 1.1.2.1  1994/04/11  20:37:03  rom
...\" 	{def, 10326, R1.1}
...\" 	Incorporate a later version of intro.3rpc.
...\" 	[1994/04/11  20:00:20  rom]
...\" 
...\" 	{def, 10326, R1.1}
...\" 	Rename intro.3rpc to rpc_intro.3rpc.
...\" 	[1994/04/11  19:49:52  rom]
...\" 
...\" $EndLog$
...\"
...\" (c) Copyright 1991, Open Software Foundation, Inc.  ALL RIGHTS RESERVED
...\"   HISTORY COMMENTS:
...\"
...\"   DATE:                            COMMENT:
...\"
...\"	Mon Nov 11, 1991                 Initial file submission to HP
...\"                                    for final integration at IBM.
...\"                                   
...\"
...\" ********************************************************************
...\" Copyright (c) 1991 Hewlett-Packard Co. and Digital Equipment Corp. *
...\" All rights reserved.                                               *
...\" ********************************************************************
...\" .cS
...\" .nr H1 1  -- Commented out because it undesirably reset a chapter counter.
...\" .cE
.TH rpc_intro 3rpc
.SH "Name"
\*Lrpc_intro\*O - Introduction to the DCE RPC API runtime
.SH "Description"
This introduction gives general information about the DCE RPC application
programming interface (API) and
an overview of the following parts of the DCE RPC API runtime:
.iX "API overview"
.iX "Application Programming Interface"
.iX "DCE RPC Application Programming Interface"
.iX "RPC" "Application Programming Interface"
.ad l
.ML
.LI
Runtime services
.LI
Environment variables
.LI
Data types and structures
.LI
Permissions required
.LI
Frequently used routine arguments
.LE
.ad b
.SS "General Information"
.PP
The following subsections contain
topics, beyond those directly related to the RPC API,
that application programmers need to know.
.VL
.LI "IDL-to-C Mappings"
The Interface Definition Language (IDL) compiler converts an
interface definition into output files.  The \*Lrpc_intro(1rpc)\*O
reference page in the
...\"\*EOSF DCE Command Reference\*O
\*(Ar
contains a summary of the \*Lidl\*O command, which
invokes the IDL compiler.
.iX "\*Lidl\*O command"
.iX "commands" "\*Lidl\*O"
.iX "IDL compiler"
.iX "Interface Definition Language compiler"
.PP
Additional information about the IDL compiler appears in the following table,
which shows the IDL base types and the IDL-to-C mappings.
.iX "IDL base types"
.iX "IDL-to-C mappings"
...\"  *****************
...\" WRITER'S NOTE: The remainder of this section, beginning with
...\" The following table lists the IDL base data type specifiers.
...\" is shared with the rpc_intro(1rpc) reference page.
...\" Changes to either copy of the text apply to both copies.
...\"  *****************
.PP
The following table lists the IDL base data type specifiers.
Where applicable, the table shows the size of the corresponding
transmittable type and the type macro emitted by the IDL compiler for
resulting declarations.
.iX "\*Lidl_\*O macros"
.iX "macros" "\*Lidl_\*O"
.PP
...\" .TB "Base Data Type Specifiers\(emrpc_intro(3rpc)"
.TS
center allbox tab(@);
cb s s s s
cb cb lb | lb | lb
cb cb lb | lb | lb
cb | cb | lb | l | lb.
Base Data Type Specifiers\(emrpc_intro(3rpc)
=
@Specifier@@@Type Macro
(sign)@(size)@(type)@Size@Emitted by idl
=
@small@int@8 bits@idl_small_int
@short@int@16 bits@idl_short_int
@long@int@32 bits@idl_long_int
@hyper@int@64 bits@idl_hyper_int
unsigned@small@int@8 bits@idl_usmall_int
unsigned@short@int@16 bits@idl_ushort_int
unsigned@long@int@32 bits@idl_ulong_int
unsigned@hyper@int@64 bits@idl_uhyper_int
@@float@32 bits@idl_short_float
@@double@64 bits@idl_long_float
@@char@8 bits@idl_char
@@boolean@8 bits@idl_boolean
@@byte@8 bits@idl_byte
@@void@\(em@idl_void_p_t
@@handle_t@\(em@\(em
.TE
.PP
Note that you can use the \*Lidl_\*O macros in the code you write for
an application to ensure that your type declarations are consistent
with those in the stubs, even when the application is ported to
another platform.  The \*Lidl_\*O macros are especially useful when
passing constant values to RPC calls.  For maximum portability, all
constants passed to RPC calls declared in your network interfaces
should be cast to the appropriate type because the size of integer
constants (like the size of the \*Lint\*O data type) is unspecified in
the C language.
.PP
The \*Lidl_\*O macros are defined in \*Ldce/idlbase.h\*O, which
is included by header files that the IDL compiler generates.
.iX "\*Lidlbase.h\*O"
.LI "Management Commands for Programmers"
.iX "programmer commands"
.iX "RPC" "management commands"
.iX "DCE RPC management commands"
.iX "commands" "programmer"
In addition to the \*Lidl\*O command for programmers, DCE RPC provides
two management commands
for the RPC control program and the DCE host daemon, as follows:
.ML
.LI
The \*Lrpccp\*O control program
accesses the RPC control program (RPCCP).  This
program provides a set of commands for accessing the
operations of the RPC Name Service Interface (NSI).
RPCCP also supports showing the elements of the local endpoint map and
removing elements from it.
.iX "\*Lrpccp\*O command"
.iX "commands" "\*Lrpccp\*O"
.iX "commands" "management"
.iX "management commands"
.iX "RPC" "control program"
.iX "control program" "RPC"
.iX "RPC" "name service interface operations"
.iX "NSI operations"
.iX "name service interface operations"
.PP
.ne 7
You can manage the name service with RPCCP commands
or with DCE RPC runtime routines.  For example, suppose you want to obtain
the members of a group.  You can give the \*Lshow group\*O command
to RPCCP or you can write an application program that calls
the following DCE RPC runtime routines:
.ad l
.ML
.LI
\*Lrpc_ns_group_mbr_inq_begin(\|)\*O
.LI
\*Lrpc_ns_group_mbr_inq_next(\|)\*O
.LI
\*Lrpc_ns_group_mbr_inq_done(\|)\*O
.LE
.ad b
.LI
The \*Ldced\*O command starts the DCE host daemon.
The daemon maintains the local endpoint map for RPC servers and looks
up endpoints for RPC clients.
.iX "\*Ldced\*O command"
.iX "commands" "\*Ldced\*O"
.iX "DCE host" "daemon"
.iX "daemon" "DCE host"
.LE
See the \*(Ar for more information about
these two management commands.
.LE
.SS "Overview of DCE RPC Runtime Services"
.iX "DCE RPC runtime services"
.iX "RPC" "runtime services"
.iX "runtime services, DCE RPC"
.iX "services, DCE RPC runtime"
.iX "DCE RPC runtime routines"
.iX "RPC" "runtime routines"
.iX "runtime routines, DCE RPC"
.iX "routines" "DCE RPC runtime"
.PP
The RPC runtime services consist of RPC routines that perform a variety
of operations.
.PP
Note that the RPC API is thread safe and synchronous cancel safe (in
the context of POSIX threads).  However, the RPC API is not
asynchronous cancel safe.  For more information about threads and
their cancellation, see the \*(Dk.
.iX "threads"
.iX "POSIX threads"
.PP
.ad l
The rest of this overview consists of the following items:
.ML
.LI
An explanation of abbreviations in the names of the
RPC runtime routines
.LI
An alphabetical list of DCE RPC runtime routines.  With each routine
name is its description and the type of application program that most
likely calls the routine. 
.LE
.ad b
.iX "abbreviations in routine names"
.PP
.ne 6
An alphabetical list of abbreviations in the names of
the DCE RPC routines follows.
The list can help you remember the names more easily.
For example, consider the routine name \*Lrpc_mgmt_ep_elt_inq_begin(\|)\*O.
Use the next list to expand the name to ``RPC management endpoint
element inquiry begin,'' which summarizes the description
``Creates an inquiry context for viewing the elements in a local
or remote endpoint map.  (Management).''
.VL
.LI "\*Lauth\*O"
authentication, authorization
.LI "\*Lcom\*O"
communications
.LI "\*Lcs\*O"
character/code set interoperability
.LI "\*Ldce\*O"
distributed computing environment
.LI "\*Ldflt\*O"
default
.LI "\*Lelt\*O"
element
.LI "\*Lep\*O"
endpoint
.LI "\*Lexp\*O"
expiration
.LI "\*Lfn\*O"
function
.LI "\*Lid\*O"
identifier
.LI "\*Lidl_es\*O"
IDL encoding services
.LI "\*Lif\*O"
interface
.LI "\*Linq\*O"
inquiry
.LI "\*Lmbr\*O"
member
.LI "\*Lmgmt\*O"
management
.LI "\*Lns\*O"
name service
.LI "\*Lprotseq\*O"
protocol sequence
.LI "\*Lrgy\*O"
DCE character and code set registry
.LI "\*Lrpc\*O"
remote procedure call
.LI "\*Lstats\*O"
statistics
.LE
.PP
An alphabetical list of the RPC runtime routines follows.
.iX "routines" "RPC runtime"
With each routine name is its description and the type of application
program that most likely calls the routine.
.VL
.LI "\*Lcs_byte_from_netcs(\|)\*O"
Converts international character data from a network code set
to a local code set. (Client, server).
.LI "\*Lcs_byte_local_size(\|)\*O"
Calculates the necessary buffer size for a code set conversion
from a network code set to a local code set. (Client, server).
.LI "\*Lcs_byte_net_size(\|)\*O"
Calculates the necessary buffer size for a code set conversion
from a local code set to a network code set. (Client, server).
.LI "\*Lcs_byte_to_netcs(\|)\*O"
Converts international character data from a local code set
to a network code set. (Client, server).
.LI "\*Ldce_cs_loc_to_rgy(\|)\*O"
Maps a local name for a code set to a code set value
in the code set registry. (Client, server).
.LI "\*Ldce_cs_rgy_to_loc(\|)\*O"
Maps a code set value in the code set registry to a
the local name for a code set. (Client, server).
.LI "\*Lidl_es_decode_buffer(\|)\*O"
Returns a buffer decoding handle. (Client, server).
.LI "\*Lidl_es_decode_incremental(\|)\*O"
Returns an incremental decoding handle. (Client, server).
.LI "\*Lidl_es_encode_dyn_buffer(\|)\*O"
Returns a dynamic buffer encoding handle. (Client, server).
.LI "\*Lidl_es_encode_fixed_buffer(\|)\*O"
Returns a fixed buffer encoding handle. (Client, server).
.LI "\*Lidl_es_encode_incremental(\|)\*O"
Returns an incremental encoding handle. (Client, server).
.LI "\*Lidl_es_handle_free(\|)\*O"
Frees an IDL encoding services handle. (Client, server).
.LI "\*Lidl_es_inq_encoding_id(\|)\*O"
Identifies an application encoding operation. (Client, server).
.LI "\*Lrpc_binding_copy(\|)\*O"
Returns a copy of a binding handle.  (Client or server).
.LI "\*Lrpc_binding_free(\|)\*O"
Releases binding handle resources.  (Client or server).
.LI "\*Lrpc_binding_from_string_binding(\|)\*O"
Returns a binding handle from a string representation of a
binding handle.  (Client or management).
.LI "\*Lrpc_binding_inq_auth_client(\|)\*O"
Returns authentication and authorization information from the
binding handle for an authenticated client.  (Server).
.nL
.ne 8
.LI "\*Lrpc_binding_inq_auth_info(\|)\*O"
Returns authentication and authorization information from a
server binding handle.  (Client).
.LI "\*Lrpc_binding_inq_object(\|)\*O"
Returns the object UUID from a binding handle.  (Client or server).
.LI "\*Lrpc_binding_reset(\|)\*O"
Resets a server binding handle so the host remains specified, but the
server instance on that host is unspecified.  (Client or management).
.LI "\*Lrpc_binding_server_from_client(\|)\*O"
Converts a client binding handle to a server binding handle.  (Server).
.LI "\*Lrpc_binding_set_auth_info(\|)\*O"
Sets authentication and authorization information into a server
binding handle.  (Client).
.LI "\*Lrpc_binding_set_object(\|)\*O"
Sets the object UUID value into a server binding handle.  (Client).
.LI "\*Lrpc_binding_to_string_binding(\|)\*O"
Returns a string representation of a binding handle.  (Client, server,
or management).
.LI "\*Lrpc_binding_vector_free(\|)\*O"
Frees the memory used
to store a vector and binding handles.  (Client or server).
.LI "\*Lrpc_cs_binding_set_tags(\|)\*O"
Places code set tags into a server binding handle.
(Client).
.LI "\*Lrpc_cs_char_set_compat_check(\|)\*O"
Evaluates character set compatibility between a client and a server.
(Client).
.LI "\*Lrpc_cs_eval_with_universal(\|)\*O"
Evaluates a server's supported character sets and code sets during
the server binding selection process. (Client).
.LI "\*Lrpc_cs_eval_without_universal(\|)\*O"
Evaluates a server's supported character sets and code sets during
the server binding selection process. (Client).
.LI "\*Lrpc_cs_get_tags(\|)\*O"
Retrieves code set tags from a binding handle.
(Client, server).
.LI "\*Lrpc_ep_register(\|)\*O"
Adds to, or replaces, server address information in
the local endpoint map.  (Server).
.LI "\*Lrpc_ep_register_no_replace(\|)\*O"
Adds to server address information in the
local endpoint map.  (Server).
.LI "\*Lrpc_ep_resolve_binding(\|)\*O"
Resolves a partially bound server binding handle into a
fully bound server binding handle.  (Client or management).
.LI "\*Lrpc_ep_unregister(\|)\*O"
Removes server address information from the
local endpoint map.  (Server).
.LI "\*Lrpc_if_id_vector_free(\|)\*O"
Frees a vector and the interface identifier structures it
contains.  (Client, server, or management).
.LI "\*Lrpc_if_inq_id(\|)\*O"
Returns the interface identifier for
an interface specification.  (Client or server).
.LI "\*Lrpc_mgmt_ep_elt_inq_begin(\|)\*O"
Creates an inquiry context for viewing the elements in a local or
remote endpoint map.  (Management).
.LI "\*Lrpc_mgmt_ep_elt_inq_done(\|)\*O"
Deletes the inquiry context for viewing the elements in a local or
remote endpoint map.  (Management).
.LI "\*Lrpc_mgmt_ep_elt_inq_next(\|)\*O"
Returns one element at a time from a local or
remote endpoint map.  (Management).
.LI "\*Lrpc_mgmt_ep_unregister(\|)\*O"
Removes server address information from a local or
remote endpoint map.  (Management).
.LI "\*Lrpc_mgmt_inq_com_timeout(\|)\*O"
Returns the communications timeout value in
a binding handle.  (Client).
.LI "\*Lrpc_mgmt_inq_dflt_protect_level(\|)\*O"
.nL
Returns the default protection level for
an authentication service.  (Client or server).
.LI "\*Lrpc_mgmt_inq_if_ids(\|)\*O"
Returns a vector of interface identifiers of interfaces
a server offers.  (Client, server, or management).
.LI "\*Lrpc_mgmt_inq_server_princ_name(\|)\*O"
.nL
Returns a server's principal name.  (Client, server, or management).
.LI "\*Lrpc_mgmt_inq_stats(\|)\*O"
Returns RPC runtime statistics.  (Client, server, or management).
.LI "\*Lrpc_mgmt_is_server_listening(\|)\*O"
Tells whether a server is listening for remote procedure
calls.  (Client, server, or management).
.LI "\*Lrpc_mgmt_set_authorization_fn(\|)\*O"
Establishes an authorization function for processing remote calls to
a server's management routines.  (Server).
.LI "\*Lrpc_mgmt_set_cancel_timeout(\|)\*O"
Sets the lower bound on the time to wait before timing out after
forwarding a cancel.  (Client).
.LI "\*Lrpc_mgmt_set_com_timeout(\|)\*O"
Sets the communications timeout value in a binding handle.  (Client).
.LI "\*Lrpc_mgmt_set_server_stack_size(\|)\*O"
Specifies the stack size for each server thread.  (Server).
.LI "\*Lrpc_mgmt_stats_vector_free(\|)\*O"
Frees a statistics vector.  (Client, server, or management).
.LI "\*Lrpc_mgmt_stop_server_listening(\|)\*O"
Tells a server to stop listening for remote procedure
calls.  (Client, server, or management).
.LI "\*Lrpc_network_inq_protseqs(\|)\*O"
Returns all protocol sequences supported by both the RPC runtime and
the operating system.  (Client or server).
.LI "\*Lrpc_network_is_protseq_valid(\|)\*O"
Tells whether the specified protocol sequence is supported by both the
RPC runtime and the operating system.  (Client or server).
.LI "\*Lrpc_ns_binding_export(\|)\*O"
Establishes a name service database entry with binding handles or
object UUIDs for a server.  (Server).
.LI "\*Lrpc_ns_binding_import_begin(\|)\*O"
Creates an import context for an
interface and an object in the name service database.  (Client).
.LI "\*Lrpc_ns_binding_import_done(\|)\*O"
Deletes the import context for searching the name service database.  (Client).
.LI "\*Lrpc_ns_binding_import_next(\|)\*O"
Returns a binding handle of a compatible server (if found) from the
name service database.  (Client).
.LI "\*Lrpc_ns_binding_inq_entry_name(\|)\*O"
Returns the name of an entry in the name service database from which
the server binding handle came.  (Client).
.LI "\*Lrpc_ns_binding_lookup_begin(\|)\*O"
Creates a lookup context for an
interface and an object in the name service database.  (Client).
.LI "\*Lrpc_ns_binding_lookup_done(\|)\*O"
Deletes the lookup context for searching the name service database.  (Client).
.LI "\*Lrpc_ns_binding_lookup_next(\|)\*O"
Returns a list of binding handles of one or more compatible servers
(if found) from the name service database.  (Client).
.LI "\*Lrpc_ns_binding_select(\|)\*O"
Returns a binding handle from a list
of compatible server binding handles.  (Client).
.LI "\*Lrpc_ns_binding_unexport(\|)\*O"
Removes the binding handles for an interface,
or object UUIDs, from an entry in the name service database.  (Server).
.LI "\*Lrpc_ns_entry_expand_name(\|)\*O"
Expands the name of a name service entry.  (Client, server, or management).
.LI "\*Lrpc_ns_entry_object_inq_begin(\|)\*O"
Creates an inquiry context for viewing
the objects of an entry in the name service database.
(Client, server, or management).
.LI "\*Lrpc_ns_entry_object_inq_done(\|)\*O"
Deletes the inquiry context for viewing
the objects of an entry in the name service database.
(Client, server, or management).
.LI "\*Lrpc_ns_entry_object_inq_next(\|)\*O"
Returns one object at a time from an
entry in the name service database.  (Client, server, or management).
.LI "\*Lrpc_ns_group_delete(\|)\*O"
Deletes a group attribute.  (Client, server, or management).
.LI "\*Lrpc_ns_group_mbr_add(\|)\*O"
Adds an entry name to a group; if
necessary, creates the entry.  (Client, server, or management).
.LI "\*Lrpc_ns_group_mbr_inq_begin(\|)\*O"
Creates an inquiry context for viewing group members.  (Client, server,
or management).
.LI "\*Lrpc_ns_group_mbr_inq_done(\|)\*O"
Deletes the inquiry context for a group.  (Client, server, or management).
.LI "\*Lrpc_ns_group_mbr_inq_next(\|)\*O"
Returns one member name at a time
from a group.  (Client, server, or management).
.LI "\*Lrpc_ns_group_mbr_remove(\|)\*O"
Removes an entry name from a group.  (Client, server, or management).
.LI "\*Lrpc_ns_import_ctx_add_eval(\|)\*O"
Adds an evaluation routine to an import context.
(Client).
.LI "\*Lrpc_ns_mgmt_binding_unexport(\|)\*O"
Removes multiple binding handles, or object UUIDs, from an entry in the
name service database.  (Management).
.LI "\*Lrpc_ns_mgmt_entry_create(\|)\*O"
Creates an entry in the name service database.  (Management).
.LI "\*Lrpc_ns_mgmt_entry_delete(\|)\*O"
Deletes an entry from the name service database.  (Management).
.LI "\*Lrpc_ns_mgmt_entry_inq_if_ids(\|)\*O"
Returns the list of interfaces exported to an entry in
the name service database.
(Client, server, or management).
.LI "\*Lrpc_ns_mgmt_free_codesets(\|)\*O"
Frees a code sets array that has been allocated in memory. (Client).
.LI "\*Lrpc_ns_mgmt_handle_set_exp_age(\|)\*O"
Sets a handle's expiration age for local copies of name service data.
(Client, server, or management).
.LI "\*Lrpc_ns_mgmt_inq_exp_age(\|)\*O"
Returns the application's global expiration age for local copies of
name service data. (Client, server, or management).
.LI "\*Lrpc_ns_mgmt_read_codesets(\|)\*O"
Reads the code sets attribute associated with an RPC server entry
in the name service database. (Client).
.LI "\*Lrpc_ns_mgmt_remove_attribute(\|)\*O"
Removes an attribute from an RPC server entry in the name service database.
(Server, management).
.LI "\*Lrpc_ns_mgmt_set_attribute(\|)\*O"
Adds an attribute to an RPC server entry in the name service database.
(Server, management).
.LI "\*Lrpc_ns_mgmt_set_exp_age(\|)\*O"
Modifies the application's global expiration age for local
copies of name service data.  (Client, server, or management).
.LI "\*Lrpc_ns_profile_delete(\|)\*O"
Deletes a profile attribute.  (Client, server, or management).
.LI "\*Lrpc_ns_profile_elt_add(\|)\*O"
Adds an element to a profile.  If necessary, creates the
entry.  (Client, server, or management).
.LI "\*Lrpc_ns_profile_elt_inq_begin(\|)\*O"
Creates an inquiry context for viewing the elements in a profile.
(Client, server, or management).
.LI "\*Lrpc_ns_profile_elt_inq_done(\|)\*O"
Deletes the inquiry context for a profile.  (Client, server, or management).
.LI "\*Lrpc_ns_profile_elt_inq_next(\|)\*O"
Returns one element at a time from a profile.  (Client, server, or management).
.LI "\*Lrpc_ns_profile_elt_remove(\|)\*O"
Removes an element from a profile.  (Client, server, or management).
.LI "\*Lrpc_object_inq_type(\|)\*O"
Returns the type of an object.  (Server).
.LI "\*Lrpc_object_set_inq_fn(\|)\*O"
Registers an object inquiry function.  (Server).
.LI "\*Lrpc_object_set_type(\|)\*O"
Assigns the type of an object.  (Server).
.LI "\*Lrpc_protseq_vector_free(\|)\*O"
Frees the memory used by a vector and its
protocol sequences.  (Client or server).
.LI "\*Lrpc_rgy_get_codesets(\|)\*O"
Gets supported code sets information from the local host.
(Client, server).
.LI "\*Lrpc_rgy_get_max_bytes(\|)\*O"
Gets the maximum number of bytes that a code set uses to encode one character.
(Client, server).
.LI "\*Lrpc_server_inq_bindings(\|)\*O"
Returns binding handles for communication
with a server.  (Server).
.LI "\*Lrpc_server_inq_if(\|)\*O"
Returns the manager entry point vector registered for an interface.  (Server).
.LI "\*Lrpc_server_listen(\|)\*O"
Tells the RPC runtime to listen for remote procedure calls.  (Server).
.LI "\*Lrpc_server_register_auth_info(\|)\*O"
Registers authentication information with the RPC runtime.  (Server).
.LI "\*Lrpc_server_register_if(\|)\*O"
Registers an interface with the RPC runtime.  (Server).
.LI "\*Lrpc_server_unregister_if(\|)\*O"
Unregisters an interface from the RPC runtime.  (Server).
.LI "\*Lrpc_server_use_all_protseqs(\|)\*O"
Tells the RPC runtime to use all supported protocol sequences for
receiving remote procedure calls.  (Server).
.nL
.ne 8
.LI "\*Lrpc_server_use_all_protseqs_if(\|)\*O"
Tells the RPC runtime to use all the
protocol sequences and endpoints specified in the
interface specification for receiving remote procedure calls.  (Server).
.LI "\*Lrpc_server_use_protseq(\|)\*O"
Tells the RPC runtime to use the
specified protocol sequence for receiving remote procedure calls.  (Server).
.LI "\*Lrpc_server_use_protseq_ep(\|)\*O"
Tells the RPC runtime to use the
specified protocol sequence combined with the
specified endpoint for receiving remote procedure calls.  (Server).
.LI "\*Lrpc_server_use_protseq_if(\|)\*O"
Tells the RPC runtime to use the
specified protocol sequence combined with the
endpoints in the interface specification
for receiving remote procedure calls.  (Server).
.LI "\*Lrpc_sm_allocate(\|)\*O"
Allocates memory within the RPC stub memory management scheme. 
(Usually server, possibly client).
.LI "\*Lrpc_sm_client_free(\|)\*O"
Frees memory allocated by the current memory allocation
and freeing mechanism used by the client stubs. (Client).
.LI "\*Lrpc_sm_destroy_client_context(\|)\*O"
Reclaims the client memory resources for a context handle, and sets the
context handle to NULL. (Client).
.LI "\*Lrpc_sm_disable_allocate(\|)\*O"
Releases resources and allocated memory within the RPC stub memory
management scheme. (Client).
.LI "\*Lrpc_sm_enable_allocate(\|)\*O"
Enables the stub memory management environment. (Client).
.LI "\*Lrpc_sm_free(\|)\*O"
Frees memory allocated by the \*Lrpc_sm_allocate(\|)\*O routine.
(Usually server, possibly client).
.LI "\*Lrpc_sm_get_thread_handle(\|)\*O" 
Gets a thread handle for the stub memory management environment. 
(Usually server, possibly client).
.nL
.ne 4
.LI "\*Lrpc_sm_set_client_alloc_free(\|)\*O"
Sets the memory allocation and freeing mechanism used by the client
stubs. (Client).
.LI "\*Lrpc_sm_set_thread_handle(\|)\*O"
Sets a thread handle for the stub memory management environment. 
(Usually server, possibly client).
.LI "\*Lrpc_sm_swap_client_alloc_free(\|)\*O"
Exchanges the current memory allocation and freeing mechanism
used by the client stubs with one supplied by the client. (Client).
.LI "\*Lrpc_string_binding_compose(\|)\*O"
Combines the components of a string binding into
a string binding.  (Client or server).
.LI "\*Lrpc_string_binding_parse(\|)\*O"
Returns, as separate strings, the components of a
string binding.  (Client or server).
.LI "\*Lrpc_string_free(\|)\*O"
Frees a character string allocated by
the runtime.  (Client, server, or management).
.LI "\*Luuid_compare(\|)\*O"
Compares two UUIDs and determines their
order.  (Client, server, or management).
.LI "\*Luuid_create(\|)\*O"
Creates a new UUID.  (Client, server, or management).
.LI "\*Luuid_create_nil(\|)\*O"
Creates a nil UUID.  (Client, server, or management).
.LI "\*Luuid_equal(\|)\*O"
Determines if two UUIDs are equal.  (Client, server, or management).
.LI "\*Luuid_from_string(\|)\*O"
Converts a string UUID to its
binary representation.  (Client, server, or management).
.LI "\*Luuid_hash(\|)\*O"
Creates a hash value for a UUID.  (Client, server, or management).
.LI "\*Luuid_is_nil(\|)\*O"
Determines if a UUID is nil.  (Client, server, or management).
.LI "\*Luuid_to_string(\|)\*O"
Converts a UUID from a binary representation to
a string representation.  (Client, server, or management).
.LI "\*Lwchar_t_from_netcs(\|)\*O"
Converts international character data from a network code set
to a local code set. (Client, server).
.LI "\*Lwchar_t_local_size(\|)\*O"
Calculates the necessary buffer size for a code set conversion
from a network code set to a local code set. (Client, server).
.LI "\*Lwchar_t_net_size(\|)\*O"
Calculates the necessary buffer size for a code set conversion
from a local code set to a network code set. (Client, server).
.LI "\*Lwchar_t_to_netcs(\|)\*O"
Converts international character data from a local code set
to a network code set. (Client, server).
.LE
.SS "Environment Variables"
.PP
The RPC NSI
routines use the following environment variables:
.ML
.LI
\*LRPC_DEFAULT_ENTRY\*O
.iX "environment variables" "\*LRPC_DEFAULT_ENTRY\*O"
.iX "\*LRPC_DEFAULT_ENTRY\*O"
.PP
Designates the default entry in
the name service database
that the import and lookup routines use
as the starting point to search for
binding information for a compatible server.
Normally, the starting entry is a profile.
.PP
An application that uses a default entry name must
define this environment variable.  The RPC runtime does not provide
a default.
.PP
For example, suppose that a client application needs to search
the name service database for a server binding handle.  The application
can use the \*Lrpc_ns_binding_import_begin(\|)\*O routine as part
of the search.  If so, the application must specify, to the
routine's \*Ventry_name\*O parameter, the name of the entry in the
name service database at which to begin the search.
If the search is to begin at the entry that the
\*LRPC_DEFAULT_ENTRY\*O environment variable specifies, then the
application must specify the value NULL to
parameter \*Ventry_name\*O in \*Lrpc_ns_binding_import_begin(\)\*O.
.LI
\*LRPC_DEFAULT_ENTRY_SYNTAX\*O
.iX "environment variables" "\*LRPC_DEFAULT_ENTRY_SYNTAX\*O"
.iX "\*LRPC_DEFAULT_ENTRY_SYNTAX\*O"
.PP
Specifies the syntax of the name
provided in the \*LRPC_\%DEFAULT_\%ENTRY\*O environment variable.
In addition, provides the syntax for those
RPC NSI routines that allow a default value for the name syntax argument.
.PP
If the \*LRPC_DEFAULT_ENTRY_SYNTAX\*O environment variable is not defined,
the RPC runtime uses the \*Lrpc_c_ns_syntax_dce\*O name syntax.
.PP
.ne 8
(For the valid name syntaxes in this reference page and for
the valid syntax values, see the table in the
description of the frequently used routine argument \*Vname_syntax\*O,
which appears later in this reference page.)
...\" 
...\" 
...\" .LI
...\" \*LRPC_DEBUG\*O
...\" .iX "environment variables" "\*LRPC_DEBUG\*O"
...\" .iX "\*LRPC_DEBUG\*O"
...\" .PP
...\" Appears for the sole purpose of telling you not to set it and not to use it.
...\" 
...\" 
.LE
.PP
Optionally, each application defines either or both of the first
two environment variables.
The application can change the value of either one, or both,
at any time during runtime.
.SS "RPC Data Types and Structures"
.iX "RPC" "data types and structures"
.iX "RPC" "structures and data types"
.iX "data types and structures"
.iX "structures and data types"
.PP
The following subsections contain
the data types and structures used by client, server,
and management application programs.
.PP
Much of the information in this section is derived from
the \*(Dg.  You may want to refer
to the appropriate volume of this
book as you read this section.  For example, this section
contains a brief description of a binding handle.  The \*(Dk 
explains binding handles in detail.
It also explains concepts related to binding handles, such as
binding information and string bindings.
.VL
.LI "Binding Handle"
A binding handle is
a pointer-size opaque variable containing information the RPC runtime
uses to manage binding information.  The RPC runtime uses
binding information
to establish a client/server relationship that allows the execution of
remote procedure calls.
.iX "binding handle"
.iX "handle" "binding"
.iX "binding information"
.PP
Based on the context where it is created, a binding handle is
considered a server binding handle or a
client binding handle.
.iX "binding handle" "client"
.iX "binding handle" "server"
.iX "client binding handle"
.iX "server binding handle"
.PP
A server binding handle is a reference to the binding information necessary
for a client to establish a relationship with a specific server.  Many
RPC API runtime routines return a server binding handle that you can
use to make a remote procedure call.
.PP
A server binding handle refers to several components
of binding information.
One is the network address of a server's host system.
Each server instance has one or more transport addresses (endpoints).
A well-known endpoint is
a stable address on the host, while a dynamic endpoint is an
address that the RPC runtime requests for the server.
Some transport protocols provide fewer well-known endpoints than
dynamic endpoints.
.iX "endpoint"
.iX "endpoint" "well-known"
.iX "endpoint" "dynamic"
.iX "dynamic endpoint"
.iX "well-known endpoint"
.PP
If binding information contains an endpoint,
the corresponding binding handle is a fully bound binding handle.  If the
information lacks an endpoint, the binding handle is
a partially bound binding handle.
.iX "binding handle" "fully bound"
.iX "binding handle" "partially bound"
.iX "fully bound binding handle"
.iX "partially bound binding handle"
.PP
.ne 8
The RPC runtime creates and provides a client binding handle to a called
remote procedure as the
\*Lhandle_t\*O parameter.  The client binding handle contains information
about the calling client.
A client binding handle cannot be used to make a remote procedure call.
A server uses the client binding handle.
The \*Lrpc_binding_server_from_client(\|)\*O routine
converts a client binding handle to a server binding handle.  You can use the
resulting server binding handle to make a remote procedure call.
.PP
For an explanation of making a remote procedure call with
a partially bound binding handle, see the \*(Dk.
For an explanation of failures associated with
such a call, see the explanation of status code
\*Lrpc_s_wrong_boot_time\*O in the \*(Tg.
.PP
Binding information can contain an object UUID.
The default object UUID associated with a binding handle is a nil UUID.
Clients can obtain a nonnil UUID in various ways, such as from a string
representation of binding information (a string binding), or by
importing it.
.PP
The following table contains the RPC runtime routines that operate
on binding handles.  The table also specifies the type of binding
handle, client or server, allowed.
.PP
.ne 3.5i
...\".TB "Client and Server Binding Handles"
.PP
.in -1.1i
.TS
center, allbox, tab(@);
cb s s
lb | lb | lb
lb | l | l.
Client and Server Binding Handles
_
Routine@Input Argument@Output Argument
_
rpc_binding_copy(\|)@T{
Server
T}@T{
Server
T}
rpc_binding_free(\|)@T{
Server
T}@T{
None
T}
rpc_binding_from_string_binding(\|)@T{
None
T}@T{
Server
T}
rpc_binding_inq_auth_client(\|)@T{
Client
T}@T{
None
T}
rpc_binding_inq_auth_info(\|)@T{
Server
T}@T{
None
T}
rpc_binding_inq_object(\|)@T{
Server or client
T}@T{
None
T}
rpc_binding_reset(\|)@T{
Server
T}@T{
None
T}
rpc_binding_server_from_client(\|)@T{
Client
T}@T{
Server
T}
rpc_binding_set_auth_info(\|)@T{
Server
T}@T{
None
T}
rpc_binding_set_object(\|)@T{
Server
T}@T{
None
T}
rpc_binding_to_string_binding(\|)@T{
Server or client
T}@T{
None
T}
rpc_binding_vector_free(\|)@T{
Server
T}@T{
None
T}
rpc_ns_binding_export(\|)@T{
Server
T}@T{
None
T}
rpc_ns_binding_import_next(\|)@T{
None
T}@T{
Server
T}
rpc_ns_binding_inq_entry_name(\|)@T{
Server
T}@T{
None
T}
rpc_ns_binding_lookup_next(\|)@T{
None
T}@T{
Server
T}
rpc_ns_binding_select(\|)@T{
Server
T}@T{
Server
T}
rpc_server_inq_bindings(\|)@T{
None
T}@T{
Server
T}
.TE
.in +1.1i
.PP
If the input argument type is
only a client or only a server, the routines return the status code
\*Lrpc_s_wrong_kind_of_binding\*O when an application provides the incorrect
binding handle type.
.PP
An application can share a single binding handle across multiple
threads of execution.  The RPC runtime, instead of the application,
manages binding handle concurrency control across concurrent remote
procedure calls that use a single binding handle.  However, the
client application has responsibility for binding handle concurrency
control for operations that read or modify a binding handle.  
.PP
.ne 8
The related
routines are as follows:
.iX "threads"
.iX "binding handle" "concurrency control"
.iX "concurrency control"
.ad l
.ML
.LI
\*Lrpc_binding_free(\|)\*O
.LI
\*Lrpc_binding_reset(\|)\*O
.LI
\*Lrpc_binding_set_auth_info(\|)\*O
.LI
\*Lrpc_binding_set_object(\|)\*O
.LI
\*Lrpc_ep_resolve_binding(\|)\*O
.LI
\*Lrpc_mgmt_set_com_timeout(\|)\*O
.LE
.ad b
.PP
For example, suppose an application shares a binding handle across two
threads of execution and it resets the binding handle endpoint in one of
the threads (by calling \*Lrpc_binding_reset(\|)\*O).
The binding handle in the other thread is then
also reset.  Similarly, freeing the binding handle in one thread
(by calling \*Lrpc_binding_free(\|)\*O) frees the
binding handle in the other thread.
.PP
If you do not want this effect, your application can create a
copy of a binding handle by calling \*Lrpc_binding_copy(\|)\*O.
An operation on one binding handle then has no effect on
the second binding handle.
.PP
Clients and servers can access and set object UUIDs by using
\*Lrpc_binding_inq_object(\|)\*O and
\*Lrpc_binding_set_object(\|)\*O.
.PP
Routines requiring a binding handle as an argument show a data type of
\*Lrpc_binding_handle_t\*O.  Binding handle arguments are passed
by value.
.iX "data types" "\*Lrpc_binding_handle_t\*O"
.iX "\*Lrpc_binding_handle_t\*O data type"
.LI "Binding Vector"
The binding vector data structure contains a list of binding handles
over which a server application can receive remote procedure calls.
.iX "binding vector"
.PP
The binding vector contains a count member (\*Vcount\*O), followed by
an array of binding handle (\*Vbinding_h\*O) elements.
.PP
The C language representation of a binding vector is as follows:
.iS
typedef struct {
               unsigned32    count;
               rpc_binding_handle_t  binding_h[1];
               } rpc_binding_vector_t;
.iE
.PP
The RPC runtime creates binding handles when a server application registers
protocol sequences.  To obtain a binding vector, a server application calls the
\*Lrpc_server_inq_bindings(\|)\*O routine.
.PP
.ne 8
A client application obtains a binding vector of compatible servers from the
name service database by calling the routine
\*Lrpc_\%ns_\%binding_\%lookup_\%next(\|)\*O.
.PP
In both routines, the RPC runtime allocates memory
for the binding vector.  An application calls the
\*Lrpc_binding_vector_free(\|)\*O routine to free the binding vector.
.PP
An application, when it is finished with an individual binding handle
in a binding vector, frees the binding handle by calling
\*Lrpc_binding_free(\|)\*O.  This routine also sets the
corresponding pointer in the binding vector to NULL.
.PP
Note that you should not decrement the \*Vcount\*O field in a
binding vector structure when you call the \*Lrpc_binding_free(\|)\*O routine to
free an individual binding handle.
.PP
The following routines require a binding vector and show an
argument data type of \*Lrpc_binding_vector_t\*O:
.iX "data types" "\*Lrpc_binding_vector_t\*O"
.iX "\*Lrpc_binding_vector_t\*O data type"
.ad l
.ML
.LI
\*Lrpc_binding_vector_free(\|)\*O
.LI
\*Lrpc_ep_register(\|)\*O
.LI
\*Lrpc_ep_register_no_replace(\|)\*O
.LI
\*Lrpc_ep_unregister(\|)\*O
.LI
\*Lrpc_ns_binding_export(\|)\*O
.LI
\*Lrpc_ns_binding_lookup_next(\|)\*O
.LI
\*Lrpc_ns_binding_select(\|)\*O
.LI
\*Lrpc_server_inq_bindings(\|)\*O
.LE
.ad b
.LI "Boolean"
Routines that require a Boolean-valued argument or return a Boolean value
show a data type of \*Lboolean32\*O.  DCE RPC provides the
integer constants TRUE (1) and FALSE (0)
for use as Boolean values.
.iX "data types" "\*Lboolean32\*O"
.iX "\*Lboolean32\*O data type"
...\" place after boolean32 definition
.iX "data types" "\*Lrpc_cs_c_set_t*\O"
.iX "\*Lrpc_cs_c_set_t\*O data type"
.LI "Code Set"
A code set is a mapping of the members of a character
set to specific numeric code values.  Different code
sets use different numeric code values to represent
the same character.  In general, operating systems
use string names to refer to the code sets that the
system supports.  It is common for different operating
systems to use different string names to refer to
the same code set. 
.PP
.ne 8
Distributed applications that run in a network of heterogeneous
operating systems need to be able to identify the character sets and
code sets that client and server machines are using
to avoid losing data during communications between each other.
.PP
DCE RPC supports transparent automatic conversion for
characters that are members of the DCE Portable Character Set (DCE PCS)
and which are encoded in the ASCII and U.S. EBCDIC code sets.
The RPC runtime automatically converts DCE PCS characters encoded
in ASCII or U.S. EBCDIC, if necessary, when they are passed over the 
network between client and server.
.PP
DCE RPC applications that need to transfer character data
that is outside the DCE PCS character set and ASCII and U.S.
EBCDIC encodings (international characters) can use special
IDL constructs and a set of DCE RPC routines to set up their
applications so that they can pass this international character
data with minimal or no loss between client and server applications.
An example of such an application would be one that used European,
Chinese, or Japanese characters mapped to EUC, Big5, or SJIS encodings.
Together, the IDL constructs and the DCE RPC routines provide
a method of automatic code set conversion for applications
that transfer international character data in heterogeneous code
set environments. 
.PP
DCE provides a mechanism to uniquely identify a code set;
this mechanism is the code set registry.  The code set
registry assigns a unique identifier to each character
set and code set.  Because the registry provides code set
identifiers that are consistent across a network of heterogeneous
operating systems, it provides a method for clients
and servers in a heterogeneous environment to use to 
identify code sets without having to rely on operating
system-specific string names.
.PP
The code set data structure contains a 32-bit hexadecimal
value (\*Vc_set\*O) that uniquely identifies
the code set followed by a 16-bit decimal value
(\*Vc_max_bytes\*O) that indicates the maximum number of
bytes this code set uses to encode one character in this
code set.
.PP
The value for \*Vc_set\*O is one of the registered values
in the code set registry.
.PP
The following routines require a code set value:
.ad l
.ML
.LI
\*Lcs_byte_from_netcs(\|)\*O
.LI
\*Lcs_byte_local_size(\|)\*O
.LI
\*Lcs_byte_net_size(\|)\*O
.LI
\*Lcs_byte_to_netcs(\|)\*O
.LI
\*Ldce_cs_loc_to_rgy(\|)\*O
.LI
\*Ldce_cs_rgy_to_loc(\|)\*O
.LI
\*Lrpc_cs_get_tags(\|)\*O
.LI
\*Lrpc_cs_binding_set_tags(\|)\*O
.LI
\*Lrpc_rgy_get_max_bytes(\|)\*O
.LI
\*Lwchar_t_from_netcs(\|)\*O
.LI
\*Lwchar_t_local_size(\|)\*O
.LI
\*Lwchar_t_net_size(\|)\*O
.LI
\*Lwchar_t_to_netcs(\|)\*O
.LE
.ad b
.PP
In these routines, the code set value shows a data type of \*Lunsigned32\*O.
.PP
The RPC stub buffer sizing routines \*V*\*L_net_size(\|)\*O and
\*V*\*L_local_size\(|)\*O use the value of \*Vc_max_bytes\*O to calculate
the size of a buffer for code set conversion.
.PP
The C language representation of a code set structure is as follows:
.iS 
typedef struct {
        long            c_set;
        short           c_max_bytes;
} rpc_cs_c_set_t;
.iE
.PP
The code set data structure is a member of the code sets array.
.LI "Code Sets Array"
.iX "data types" "\*Lrpc_codeset_mgmt_t*\O"
.iX "\*Lrpc_codeset_mgmt_t\*O data type"
The code sets array contains the list of the code sets that
a client or server supports.  The structure consists of a version number
member (\*Vversion\*O), followed by a count member (\*Vcount\*O), followed
by an array of code set data structures (\*Vrpc_cs_c_set_t\*O).
This array is declared to be a conformant array so that
its size will be determined at runtime.  The \*Vcount\*O member
indicates the number of code sets contained in the array.
.PP
The first element in the code sets array represents
the client or server process's local code set.
.PP
.ne 6
The second element through the \*Vn\*Oth element
represents one or more intermediate code sets that
the process can use to transmit character data over
the network.  Client or server processes can convert
into an intermediate code set when their host system does
not provide a converter for the other's local code set but
does provide a converter for the intermediate code set.
.PP
DCE RPC routines for character/code sets compatibility
evaluation and code set conversion support one intermediate
code set, which is the ISO 10646 Universal character/code set.
Consequently, DCE requires host systems running applications
that transfer international characters to provide converters
for this code set.
.PP
System administrators for machines in internationalized
DCE cells (that is, cells of machines that run applications that
use the DCE character/code sets compatibility evaluation
and conversion functionality) and who want to use
other intermediate code sets can run the \*Lcsrc\*O utility
and specify that their intermediate code set(s) be used in preference
to ISO 10646.
.PP
The remaining elements in the array represent other
code sets that the process's host supports (that is,
code sets for which the system provides converters).
.PP
The C language representation of a code set structure is
as follows:
.iS
typedef struct rpc_codeset_mgmt_t {
        unsigned32      version;
        long            count;
        [size_is(count)] rpc_cs_c_set_t codesets[];
} rpc_codeset_mgmt_t, *rpc_codeset_mgmt_p_t;
.iE
.PP
Client and server applications and DCE RPC routines for automatic
code set conversion obtain a code sets array by calling the
routine \*Lrpc_rgy_get_codesets(\|)\*O.  Server applications
user the code sets array as input to the
\*Lrpc_ns_mgmt_set_attribute(\|)\*O routine, which registers
their supported code sets in the name service database.
Client applications look up a server's supported code sets in
the name service database by calling the routine
\*Lrpc_ns_mgmt_read_codesets(\|)\*O and then use their
code sets array to evaluate their supported code
sets against the code sets that the server supports.
.PP
.ne 6
The following DCE RPC routines require a code sets array
and show an argument data type of \*Lrpc_codeset_mgmt_t\*O:
.ad l
.ML
.LI
\*Lrpc_ns_mgmt_read_codesets(\|)\*O
.LI
\*Lrpc_rgy_get_codesets(\|)\*O
.LE
.ad b
.PP
Server applications that use \*Lrpc_ns_mgmt_set_attribute(\|)\*O
to register their supported code sets in the name service database
also specify the code sets array, but show an argument data type
of \*Lvoid\*O.
.LI "Conversion Type"
The conversion type data structure is an enumerated type that RPC
stub buffer sizing routines return to indicate whether
character data conversion is necessary and whether or not existing
storage is sufficient for the stub to store the results of the
conversion.  The conversion type can be one of the following values:
.VL
.LI "\*Lidl_cs_no_convert\*O"
No code set conversion is required.
.LI "\*Lidl_cs_in_place_convert\*O"
Code set conversion can be performed in a single storage area.
.LI "\*Lidl_cs_new_buffer_convert\*O"
The converted data must be written to a new storage area.
.LE
.PP
The C language representation of a conversion type structure is
as follows:
.iS
typedef enum {
        idl_cs_no_convert,
        idl_cs_in_place_convert,
        idl_cs_new_buffer_convert,
} idl_cs_convert_t;
.iE
.PP
.LI "Endpoint Map Inquiry Handle"
.iX "endpoint map inquiry handle"
.iX "handle" "endpoint map inquiry"
An endpoint map inquiry handle is a pointer-size opaque variable
containing information the RPC runtime uses to access the elements in
a local or remote endpoint map.  The description of the
\*Lrpc_ep_register(\|)\*O routine lists the contents of an element.
.PP
.ne 6
The following routines require an endpoint map inquiry handle and
show an argument data type of \*Lrpc_ep_inq_handle_t\*O:
.iX "data types" "\*Lrpc_ep_inq_handle_t\*O"
.iX "\*Lrpc_ep_inq_handle_t\*O data type"
.ad l
.ML
.LI
\*Lrpc_mgmt_ep_elt_inq_begin(\|)\*O
.LI
\*Lrpc_mgmt_ep_elt_inq_done(\|)\*O
.LI
\*Lrpc_mgmt_ep_elt_inq_next(\|)\*O
.LE
.ad b
.LI "Global Name"
.iX "global name"
.iX "name" "global"
.iX "cell name"
.iX "name" "cell"
.iX "cell-relative name"
.iX "name" "cell-relative"
The NSI uses global names for the names of
name service entries.  A global name includes both a cell name and
a cell-relative name composed of a directory pathname and a leaf name.
For a description of global names, see the \*(Ai.
The cell name is assigned to a cell root at its creation.  When you specify
only a cell-relative name to an NSI operation, the NSI automatically
expands the name into a global name by inserting the local cell name.
Thus, the name of a member in a group or in a profile element is always
stored as a global name.  When returning the name of a name service entry
or a member, NSI operations return global names.
.PP
For example, even when you specify a cell-relative name as
the \*Vmember_name\*O parameter to routine \*Lrpc_ns_group_mbr_add(\|)\*O,
when you read that group member (by calling
\*Lrpc_\%ns_\%group_\%mbr_\%inq_\%next(\|)\*O), you will receive the corresponding
global name.
.iX "IDL encoding service handle"
.iX "handle" "IDL encoding service"
.LI "IDL Encoding Service Handle"
An IDL encoding service handle is a pointer-size opaque variable
that points to functions that control how data encoding or decoding
is performed.  The following routines return an IDL encoding service
handle and show an argument data type of \*Lidl_es_handle_t\*O:
.ad l
.ML
.LI
\*Lidl_es_encode_incremental(\|)\*O
.LI
\*Lidl_es_decode_buffer(\|)\*O
.LI
\*Lidl_es_decode_incremental(\|)\*O
.LI
\*Lidl_es_encode_dyn_buffer(\|)\*O
.LI
\*Lidl_es_encode_fixed_buffer(\|)\*O
.LE
.ad b
.PP
The \*Lidl_es_handle_free(\|)\*O and \*Lidl_es_inq_encoding_id(\|)\*O
routines require an IDL encoding service handle.
.PP
.ne 5
Note that in order to use the IDL encoding services, you must include
a header file that has been generated for an application that has used
the \*Lencode\*O and \*Ldecode\*O ACF attributes on one or more of its
operations.
.LI "Interface Handle and Specification"
.iX "interface handle"
.iX "interface specification"
.iX "handle" "interface"
.iX "specification" "interface"
An interface handle is a pointer-size opaque variable containing
information the RPC runtime uses to access the interface specification data
structure.
.PP
The DCE IDL compiler automatically creates an interface specification data
structure from each IDL file and creates a global variable of type
\*Lrpc_if_handle_t\*O for the interface specification.
.PP
The DCE IDL compiler places an interface handle declaration
in the generated \*Vinterface-name\*L.h\*O file.  The compiler generates
this header file for each interface.
.PP
Routines requiring the interface handle as an argument show a data type
of \*Lrpc_if_handle_t\*O.
.PP
The form of each interface handle name is as follows:
.ad l
.ML
.LI
For the client:
.PP
\*Vif-name\*L_v\*Vmajor-version\*L_\*Vminor-version\*L_c_ifspec\*O
.LI
For the server:
.PP
\*Vif-name\*L_v\*Vmajor-version\*L_\*Vminor-version\*L_s_ifspec\*O
.LE
.ad b
.PP
where
.ad l
.ML
.LI
The \*Vif-name\*O variable is the interface identifier
specified in the IDL file.
.LI
The \*Vmajor-version\*O variable is the interface's major-version
number specified in the IDL file.
.LI
The \*Vminor-version\*O variable is the interface's minor-version
number specified in the IDL file.
.LE
.ad b
.PP
An example is \*Lnotes_v1_2_c_ifspec\*O
.PP
The maximum combined length of the interface identifier
and interface version number is 19 characters.
.PP
Since the major-version and minor-version numbers must each be at
least 1 character, the interface name can be no more than 17
characters.  This limits the interface handle name to 31 or
fewer characters.
.PP
No concurrency control is required for interface handles.
.PP
The following routines require an interface handle and show an
argument data type of \*Lrpc_if_handle_t\*O:
.iX "data types" "\*Lrpc_if_handle_t\*O"
.iX "\*Lrpc_if_handle_t\*O data type"
.ad l
.ML
.LI
\*Lrpc_ep_register(\|)\*O
.LI
\*Lrpc_ep_register_no_replace(\|)\*O
.LI
\*Lrpc_ep_resolve_binding(\|)\*O
.LI
\*Lrpc_ep_unregister(\|)\*O
.LI
\*Lrpc_if_inq_id(\|)\*O  
...\" .LI
...\" \*Lrpc_if_register_auth_info(\|)\*O
.LI
\*Lrpc_ns_binding_export(\|)\*O
.LI
\*Lrpc_ns_binding_import_begin(\|)\*O
.LI
\*Lrpc_ns_binding_lookup_begin(\|)\*O
.LI
\*Lrpc_ns_binding_unexport(\|)\*O
.LI
\*Lrpc_server_inq_if(\|)\*O
.LI
\*Lrpc_server_register_if(\|)\*O
.LI
\*Lrpc_server_unregister_if(\|)\*O
.LI
\*Lrpc_server_use_all_protseqs_if(\|)\*O
.LI
\*Lrpc_server_use_protseq_if(\|)\*O
.LE
.ad b
.LI "Interface Identifier"
.iX "interface identifier"
.iX "identifier" "interface"
.PP
The interface identifier (id) data structure contains
the interface UUID and major-version and
minor-version numbers of an interface.
The interface identifier is a subset of the data contained in the
interface specification structure.
.iX "data structures" "interface identifier"
.iX "interface identifier data structure"
.PP
The C language representation of an interface identifier structure is
as follows:
.iS
typedef struct {
               uuid_t      uuid;
               unsigned16  vers_major;
               unsigned16  vers_minor;
               } rpc_if_id_t;
.iE
.PP
.ne 5
Routines that require an interface identifier structure show a data type
of \*Lrpc_if_id_t\*O.  In those routines, the application is
responsible for providing memory for the structure.
.iX "data types" "\*Lrpc_if_id_t\*O"
.iX "\*Lrpc_if_id_t\*O data type"
.PP
The \*Lrpc_if_inq_id(\|)\*O
routine returns the interface identifier from an
interface specification.
The following routines require an interface identifier:
.ad l
.ML
.LI
\*Lrpc_mgmt_ep_elt_inq_begin(\|)\*O
.LI
\*Lrpc_mgmt_ep_elt_inq_next(\|)\*O
.LI
\*Lrpc_mgmt_ep_unregister(\|)\*O
.LI
\*Lrpc_ns_mgmt_binding_unexport(\|)\*O
.LI
\*Lrpc_ns_profile_elt_add(\|)\*O
.LI
\*Lrpc_ns_profile_elt_inq_begin(\|)\*O
.LI
\*Lrpc_ns_profile_elt_inq_next(\|)\*O
.LI
\*Lrpc_ns_profile_elt_remove(\|)\*O
.LE
.ad b
.LI "Interface Identifier Vector"
The interface identifier vector data structure contains
a list of interfaces offered by a server.
.iX "data structures" "interface identifier vector"
.iX "interface identifier vector data structure"
The interface identifier vector contains a count member (\*Vcount\*O),
followed by an array of pointers to interface identifiers (\*Vrpc_if_id_t\*O).
.PP
The C language representation of an interface identifier vector is
as follows:
.iS
typedef struct {
               unsigned32     count;
               rpc_if_id_t    *if_id[1];
               } rpc_if_id_vector_t;
.iE
.iX "data types" "\*Lrpc_if_id_vector_t\*O"
.iX "\*Lrpc_if_id_vector_t\*O data type"
.PP
The interface identifier vector is a read-only vector.  To obtain a vector of
the interface identifiers registered by a server with the RPC runtime, an
application calls the \*Lrpc_mgmt_inq_if_ids(\|)\*O routine.  To obtain a
vector of the interface identifiers exported by a server to a
name service database,
an application calls the \*Lrpc_ns_mgmt_entry_inq_if_ids(\|)\*O routine.
.PP
The RPC runtime allocates memory for the
interface identifier vector.  The application
calls the \*Lrpc_if_id_vector_free(\|)\*O routine to free the interface
identifier vector.
.LI "Manager Entry Point Vector"
The manager entry point vector (EPV) is an array of pointers to
remote procedures.
.iX "manager entry point vector"
.iX "vector" "manager entry point"
.iX "entry point vector" "manager"
.iX "data structures" "manager entry point vector"
.PP
The DCE IDL compiler automatically generates a manager EPV data type,
into the header file generated by the IDL compiler, for
use in constructing manager EPVs.  The data type is named as follows:
.PP
\*Vif-name\*L_v\*Vmajor-version\*L_\*Vminor-version\*L_epv_t\*O
.iX "manager entry point vector data type"
.iX "data structures" "manager entry point vector"
.PP
where
.ad l
.ML
.LI
The \*Vif-name\*O variable is the interface identifier specified
in the IDL file.
.LI
The \*Vmajor-version\*O variable is the interface's major-version
number specified in the IDL file.
.LI
The \*Vminor-version\*O variable is the interface's minor-version
number specified in the IDL file.
.LE
.ad b
.PP
By default, the DCE IDL compiler automatically creates and initializes
a manager EPV.
DCE IDL creates this EPV assuming that a manager routine of the same
name exists for each procedure in
the interface (as specified in the IDL file).
.PP
The DCE IDL compiler can define a client entry point vector
.iX "client entry point vector"
.iX "vector" "client entry point"
.iX "entry point vector" "client"
.iX "data structures" "client entry point vector"
with addresses of local routines.  Client applications can call
these routines.  For more information about
client entry point vectors, see the
explanation of the \*L\-cepv\*O argument in the
\*Lidl(1rpc)\*O reference page.
.PP
If the server offers multiple implementations of the same interface, the server
must create additional manager EPVs, one for each implementation.  Each EPV
must contain exactly one entry point (address of a function) for each procedure
defined in the IDL file.  The server application declares and initializes one
manager EPV variable of type
\*Vif-name\*L_v\*Vmajor-version\*L_\*Vminor-version\*L_epv_t\*O
for each implementation of the interface.
.PP
The \*Lrpc_server_register_if(\|)\*O and \*Lrpc_server_inq_if(\|)\*O routines
use the manager EPV data type and show the manager EPV argument as having an
\*Lrpc_mgr_epv_t\*O data type.
.iX "data types" "\*Lrpc_mgr_epv_t\*O"
.iX "\*Lrpc_mgr_epv_t\*O data type"
.LI "Name Service Handle"
.iX "name service handle"
.iX "handle" "name service"
A name service handle is a pointer-size opaque variable
containing information the
RPC runtime uses to return the following RPC data from the
name service database:
.ad l
.ML
.LI
Server binding handles
.LI
UUIDs of resources offered by a server
.LI
Profile members
.LI
Group members
.LE
.ad b
.PP
The following routines require a name service handle and
show an argument data type of \*Lrpc_ns_handle_t\*O:
.iX "data types" "\*Lrpc_ns_handle_t\*O"
.iX "\*Lrpc_ns_handle_t\*O data type"
.ad l
.ML
.LI
\*Lrpc_ns_binding_import_begin(\|)\*O
.LI
\*Lrpc_ns_binding_import_next(\|)\*O
.LI
\*Lrpc_ns_binding_import_done(\|)\*O
.LI
\*Lrpc_ns_binding_lookup_begin(\|)\*O
.LI
\*Lrpc_ns_binding_lookup_next(\|)\*O
.LI
\*Lrpc_ns_binding_lookup_done(\|)\*O
.LI
\*Lrpc_ns_entry_object_inq_begin(\|)\*O
.LI
\*Lrpc_ns_entry_object_inq_next(\|)\*O
.LI
\*Lrpc_ns_entry_object_inq_done(\|)\*O
.LI
\*Lrpc_ns_group_mbr_inq_begin(\|)\*O
.LI
\*Lrpc_ns_group_mbr_inq_next(\|)\*O
.LI
\*Lrpc_ns_group_mbr_inq_done(\|)\*O
.LI
\*Lrpc_ns_profile_elt_inq_begin(\|)\*O
.LI
\*Lrpc_ns_profile_elt_inq_next(\|)\*O
.LI
\*Lrpc_ns_profile_elt_inq_done(\|)\*O
.LI
\*Lrpc_ns_mgmt_handle_set_exp_age(\|)\*O
.LE
.ad b
.PP
The scope of a name service handle is from a \*V*\*L_begin(\|)\*O routine through
the corresponding \*V*\*L_done(\|)\*O routine.
.PP
Applications have responsibility for concurrency control
of name service handles across threads.
...\" .iX "threads"
.iX "name service handle" "concurrency control"
.iX "concurrency control"
.nL
.ne 7
.LI "Protocol Sequence"
.iX "protocol sequence"
.PP
A protocol sequence is a character string identifying the network
protocols used to establish a relationship between a client and server.
The protocol sequence contains a set of options that the RPC runtime
must know about.  The following options are in this set:
.ad l
.ML
.LI
The RPC protocol used for communications
(choices are \*Lncacn\*O and \*Lncadg\*O).
.LI
The format used in the network address supplied in the binding
(choice is \*Lip\*O).
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo formats,
...\" ** replace the 1 line just before the ".cS" symbol with the following 1 line.
...\" (choices are \*Lip\*O, \*Ldnet\*O, and \*Losi\*O).
...\" DIGITAL_END
...\" .cE
.LI
The transport protocol used for communications
(choices are \*Ltcp\*O and \*Ludp\*O).
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo transport protocols,
...\" ** replace the 1 line just before the ".cS" symbol with the following 1 line.
...\" (choices are \*Ltcp\*O, \*Ludp\*O, \*Lnsp\*O, and \*Ldna\*O).
...\" DIGITAL_END
...\" .cE
.LE
.ad b
.PP
Because only certain combinations of these options are valid (are
useful for interoperation), RPC provides predefined strings
that represent the valid combinations.  RPC applications use only
these strings.
.PP
The following table contains predefined strings representing valid
protocol sequences.  In the descriptions NCA is an abbreviation of
Network Computing Architecture.
.iX "Network Computing Architecture"
.iX "protocol sequences" "valid"
...\" .TB "Valid Protocol Sequences"
.PP
.TS
center, allbox, tab(@);
cb s
lb | lb
lb |  l.
Valid Protocol Sequences
_
Protocol Sequence@Description
_
ncacn_ip_tcp@T{
NCA Connection over Internet Protocol:
Transmission Control Protocol
T}
\*Lip\*O or \*Lncadg_ip_udp\*O@T{
NCA Datagram over Internet Protocol:
User Datagram Protocol
T}
.TE
.iX "\*Lncacn_ip_tcp\*O protocol sequence"
.iX "\*Lip\*O protocol sequence"
.iX "\*Lncadg_ip_udp\*O protocol sequence"
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,
...\" ** add here the following 4 lines.
...\" ncacn_dnet_nsp@NCA Connection over DECnet:
...\" @Network Services Protocol (DECnet Phase IV)
...\" ncacn_osi_dna@NCA Connection over Open Systems
...\" @Interconnection: DNA Session Control
...\" @(DECnet Phase V)
...\" DIGITAL_END
...\" .cE
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,
...\" ** add here the following 2 lines.
...\" \*Ldds\*O or \*Lncadg_dds\*O@NCA Datagram over Domain Datagram
...\" @Service
...\" DIGITAL_END
...\" .cE
.PP
A server application can use a particular protocol sequence only if
the operating system software supports that protocol.
A server chooses to accept remote procedure
calls over some or all of the supported protocol sequences.
.PP
Client and server applications can determine if a protocol sequence
is supported by both the RPC runtime and the operating system.  The
applications make this determination by calling
the following routines:
.ad l
.ML
.LI
\*Lrpc_network_inq_protseqs(\|)\*O
.LI
\*Lrpc_network_is_protseq_valid(\|)\*O
.LE
.ad b
.PP
.ne 5
The following routines allow server applications to register
protocol sequences with the runtime:
.ad l
.ML
.LI
\*Lrpc_server_use_all_protseqs(\|)\*O
.LI
\*Lrpc_server_use_all_protseqs_if(\|)\*O
.LI
\*Lrpc_server_use_protseq(\|)\*O
.LI
\*Lrpc_server_use_protseq_ep(\|)\*O
.LI
\*Lrpc_server_use_protseq_if(\|)\*O
.LE
.ad b
.PP
Those routines requiring a protocol sequence argument show a data type of
\*Lunsigned_char_t *\*O.
.iX "data types" "\*Lunsigned_char_t *\*O"
.iX "\*Lunsigned_char_t *\*O data type"
.PP
A client can use the protocol sequence strings to construct a string binding
using the \*Lrpc_string_binding_compose(\|)\*O routine.
.LI "Protocol Sequence Vector"
The protocol sequence vector data structure contains a list of
protocol sequences over which the RPC runtime can send or receive
remote procedure calls.
.iX "data structures" "protocol sequence vector"
.iX "protocol sequence vector data structure"
The protocol sequence vector contains a count member (\*Vcount\*O),
followed by an array of pointers to protocol sequence strings
(\*Vprotseq\*O).
.PP
The C language representation of a protocol sequence vector is as follows:
.iS
typedef struct {
               unsigned32       count;
               unsigned_char_t  *protseq[1];
               } rpc_protseq_vector_t;
.iE
.iX "data types" "\*Lrpc_protseq_vector_t\*O"
.iX "\*Lrpc_protseq_vector_t\*O data type"
.PP
The protocol sequence vector is a read-only vector.
To obtain a protocol sequence vector, a server application calls the
\*Lrpc_network_inq_protseqs(\|)\*O routine.  The RPC runtime allocates memory
for the protocol sequence vector.  The server application calls the
\*Lrpc_protseq_vector_free(\|)\*O routine to free the protocol
sequence vector.
.nL
.ne 8
.LI "Statistics Vector"
The statistics vector data structure contains
statistics from the RPC runtime on a per address space basis.
.iX "data structures" "statistics vector"
.iX "statistics vector data structure"
The statistics vector contains a count member (\*Vcount\*O),
followed by an array of statistics.
Each array element contains an \*Lunsigned32\*O value.  The following
list describes the statistics indexed by the specified constant:
.VL
.LI "\*Lrpc_c_stats_calls_in\*O"
The number of remote procedure calls received by the runtime.
.LI "\*Lrpc_c_stats_calls_out\*O"
The number of remote procedure calls initiated by the runtime.
.LI "\*Lrpc_c_stats_pkts_in\*O"
The number of network packets received by the runtime.
.LI "\*Lrpc_c_stats_pkts_out\*O"
The number of network packets sent by the runtime.
.LE
.PP
The C language representation of a statistics vector is as follows:
.iS
typedef struct {
               unsigned32       count;
               unsigned32       stats[1];
               } rpc_stats_vector_t;
.iE
.iX "data types" "\*Lrpc_stats_vector_t\*O"
.iX "\*Lrpc_stats_vector_t\*O data type"
.PP
To obtain runtime statistics, an application calls the
\*Lrpc_mgmt_inq_stats(\|)\*O routine.  The RPC runtime allocates memory
for the statistics vector.  The application calls the
\*Lrpc_mgmt_stats_vector_free(\|)\*O routine to free the statistics vector.
.LI "String Binding"
.iX "string binding"
.iX "binding" "string"
.iX "binding handle"
A string binding contains the character representation of a binding handle.
.PP
String bindings are a convenient way of representing portions of a
binding handle.  However, you cannot use string bindings directly to
make remote procedure calls.  You must first call the routine
\*Lrpc_binding_from_string_binding(\|)\*O, which
converts a string binding to a binding handle.
.PP
A string binding does not contain all the information from a
binding handle.  For example, a call to 
\*Lrpc_binding_to_string_binding(\|)\*O does not translate the
authentication information sometimes associated with a binding handle into
the resulting string binding.
.PP
You can begin the development of a distributed application by having its
servers communicate their binding information to clients by using
string bindings.  This communication allows a
server to establish a client/server relationship without using the
local endpoint map or the name service database.
.PP
.ne 10
In this case, the server calls none of the \*Lrpc_ep_register(\|)\*O,
\*Lrpc_ep_register_no_replace(\|)\*O, and \*Lrpc_ns_binding_export(\|)\*O
routines.  Instead, the server
calls only routine \*Lrpc_\%server_\%inq_\%bindings(\|)\*O to obtain
a vector of binding handles.  The server obtains binding handles one
at a time from the vector and calls
routine \*Lrpc_binding_to_string_binding(\|)\*O to convert each binding handle
into a string binding.
The resulting string binding is always fully bound and may
contain a nonnil object UUID. The server then makes some or all of
its string bindings available to clients.  One way is placing
the string bindings in a file to be read by clients or users or both.
Another way is delivering the string bindings to clients or users
by means of a file, mail, or paper.
.PP
You can continue the distributed application's development by changing
the application so that servers use the local endpoint map and the
name service database to communicate their binding information.
.PP
To find the server, a client obtains a string binding
containing a protocol sequence that the client runtime
supports and, optionally, an object UUID that the client requires.
The client then calls routine \*Lrpc_binding_from_string_binding(\|)\*O to
convert the string binding into a server binding handle.
.PP
Other useful routines for working with string bindings are
\*Lrpc_string_binding_compose(\|)\*O, which creates a string binding
from its component parts, and \*Lrpc_string_binding_parse(\|)\*O,
which separates a string binding into its component parts.
.PP
The two formats of a string binding follow.  The four fields
represent
the object UUID, RPC protocol sequence, network address, and
endpoint and network
options of the binding.
A delimiter character such as \*L@\*O (at sign) or \*L:\*O (colon)
separates each field.  A string binding does not contain any whitespace.
.iS
\*Vobject-uuid\*O \*L@\*O \*Vrpc-prot-seq\*O \*L:\*O \*Vnw-addr\*O [\*Vendpoint\*L, \*Vopt\*O \&...]
.iE
or
.iS
\*Vobject-uuid\*O \*L@\*O \*Vrpc-prot-seq\*O \*L:\*O \*Vnw-addr\*O [\*Vendpoint \*L= \*Vendpoint\*L, \*Vopt\*O \&...]
.iE
.nL
.ne 8
.VL
.LI \*Vobject-uuid\*O
.iX "string binding" "object UUID portion"
.iX "object UUID portion of a string binding"
This field specifies the UUID of the object operated on by the remote
procedure that is called with this string binding.  The RPC runtime,
at the server, maps the object's type to a manager entry point
vector (EPV) to invoke the
correct manager routine.  The explanation of the
routine \*Lrpc_server_register_if(\|)\*O discusses mapping object UUIDs
to manager EPVs.
.PP
This field is optional.  If you do not provide it the RPC runtime assumes
a nil UUID.
.LI \*L@\*O
This symbol is the delimiter character for the object UUID
field.  If you specify an
object UUID you must follow it with this symbol.
.LI \*Vrpc-protocol-sequence\*O
.iX "string binding" "protocol sequence portion"
.iX "protocol sequence portion of a string binding"
This field specifies the protocol sequence used for making
remote procedure calls.  The valid protocol sequences are as follows:
.iS
\*Lncacn_ip_tcp\*O
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,
...\" ** add here the following 4 lines.
...\" .PP
\*Lncacn_dnet_nsp\*O
...\" .PP
\*Lncacn_osi_dna\*O
...\" DIGITAL_END
...\" .cE
\*Lncadg_ip_udp\*O
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,
...\" ** add here the following 2 lines.
...\" .PP
\*Lncadg_dds\*O
...\" DIGITAL_END
...\" .cE
.iE
.PP
More information about these valid protocol sequences appears in the
preceding table.
.PP
This field is required.
.LI \*L:\*O
This symbol is the delimiter character for the RPC protocol sequence
field.
.LI \*Vnw-addr\*O
.iX "string binding" "network address portion"
.iX "network address portion of a string binding"
This field specifies the address (\*Vaddr\*O) of a host on a
network (\*Vnw\*O) that
receives remote procedure calls made with this string binding.  The
format and content of the network address depends on the value of
\*Vrpc-protocol-sequence\*O as follows:
.PP
\*Lncacn_ip_tcp\*O and \*Lncadg_ip_udp\*O
.PP
Specify an Internet address using the common Internet address
notation or host name.
.PP
Two examples with common Internet address notation are \*L128.10.2.30\*O
and \*L#126.15.1.28\*O.  The second example shows the use of the
optional \*L#\*O (number sign) character.
.PP
An example with a host name is \*Lko\*O.
.PP
.ne 9
If the specified host name is multihomed, the binding handle that is returned
from the routine \*Lrpc_binding_from_string_binding(\|)\*O contains
a host address.  It is the first host address returned from
the system library call that
translates a host name to a host address for the network address format
in the protocol sequence.
To control the host address used, specify the
network address using the common Internet address notation instead of
a host name.
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,
...\" ** add the following three values and descriptions for \*Vnw-addr\*O:
...\" ** \*Lncacn_dnet_nsp\*O, \*Lncacn_osi_dna\*O, and \*Lncadg_dds\*O.
...\" .LI "\*Lncacn_dnet_nsp\*O"
...\" .PP
...\" Specify a DECnet Phase IV host address using the host name or area
...\" and node syntax.  When you use the host name, do not include a
...\" trailing pair of colons (::).
...\" .PP
...\" An example of a host name is \*Lsage\*O
...\" .PP
...\" An example of an area node is \*L4.120\*O
...\" .LI "\*Lncacn_osi_dna\*O"
...\" .PP
...\" Specify a DECnet Phase V host address using a Cell Directory Service
...\" (CDS) full name, a node synonym, area and node syntax, or an NSAP.
...\" .PP
...\" An example of a CDS full name is \*L.dec.eng.nac.dss.node\*O
...\" .PP
...\" An example of a node synonym is \*Lsage\*O
...\" .PP
...\" If the specified node synonym is multihomed, the binding handle returned
...\" from routine \*Lrpc_binding_from_string_binding\*O contains
...\" a host address.  It is the first
...\" host address returned from the system library call
...\" that translates a node synonym to a host address for the
...\" network address format in the protocol sequence.  To control the
...\" host address used, specify the
...\" network address using a CDS full name, area node syntax, or an NSAP
...\" instead of a node synonym.
...\" .PP
...\" An example of an area node is \*L4.120\*O
...\" .PP
...\" (If you choose this form of address the RPC runtime assumes that
...\" the transport is NSP; consequently, the RPC runtime ignores any
...\" options flags that indicate transport.)
...\" .PP
...\" An example of an NSAP is \*L%x49003FAA000400E4FD20\*O
...\" .PP
...\" The string representing the NSAP is a percent sign followed by the
...\" letter \*Cx\*O followed by hexadecimal digits.  No separators are
...\" allowed in the string.  Finally, any transport options in the
...\" string binding are ignored since the NSAP specified the transport
...\" to be used as part of its value.
...\" .LI "\*Lncadg_dds\*O"
...\" .PP
...\" Specify the Hewlett-Packard/Apollo Domain host address using the syntax
...\" for a host name or a network and node ID.
...\" .PP
...\" An example of a host name is \*C//saab\*O
...\" .PP
...\" An example of a network and node ID is \*C29C05.21B34
...\" DIGITAL_END
...\" .cE
.P
The network address field is optional.  If you do not supply this
field, the string binding refers to your local host.
.LI \*L[\*O
This symbol is the delimiter character specifying that
one endpoint and zero or more options follow.  If the string binding contains
at least one endpoint, this symbol is required.
.LI \*Vendpoint\*O
.iX "string binding" "endpoint portion"
.iX "endpoint portion of a string binding"
This field specifies the endpoint,
or address of a specific server instance on a host, to
receive remote procedure calls made with this string binding.  Optionally
the keyword \*Lendpoint=\*O can precede the endpoint specifier.
.PP
The format and content of the endpoint depends on the specified protocol
sequence as follows:
.PP
\*Lncacn_ip_tcp\*O and \*Lncadg_ip_udp\*O
...\" .PP
...\" Specify an Internet port number.
...\" .PP
...\" An example of an Internet port number is \*L1025\*O.
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,
...\" ** add the following three values and descriptions for \*Vnw-addr\*O:
...\" ** \*Lncacn_dnet_nsp\*O, \*Lncacn_osi_dna\*O, and \*Lncadg_dds\*O.
...\" .PP
...\" \*Lncacn_dnet_nsp\*O
...\" .PP
...\" Specify a DECnet Phase IV object name or object number.
...\" .PP
...\" An example of an object name is \*Ctestname\*O
...\" .PP
...\" An example of an object number is \*C#17\*O
...\" .PP
...\" The \*C#\*O (number sign) character must precede an object number.
...\" .PP
...\" \*Lncacn_osi_dna\*O
...\" .PP
...\" Specify a DECnet Phase V object name or object number.
...\" .PP
...\" An example of an object name is \*Cfal\*O
...\" .PP
...\" An example of an object number is \*C#17\*O
...\" .PP
...\" The \*C#\*O (number sign) character must precede an object number.
...\" .LI "\*Lncadg_dds\*O"
...\" .PP
...\" \*LTBS\*O
...\" DIGITAL_END
...\" .cE
.PP
The endpoint field is optional.  For more information about endpoints,
see the information on binding handles in this reference page.
.LI "\*L,\*O"
This symbol is the delimiter character specifying that option data
follows.  If an option follows, this delimiter is required.
.LI "\*Voption\*O"
.iX "string binding" "option portion"
This field specifies any options.  Each option is specified as
\*Voption name\*L=\*Voption value\*O.
.PP
The format and content of the option depends on the specified protocol
sequence as follows:
.PP
\*Lncacn_ip_tcp\*O and \*Lncadg_ip_udp\*O
.PP
There are no Internet options.
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo protocol sequences,
...\" ** add the following three values and descriptions for \*Vnw-addr\*O:
...\" ** \*Lncacn_dnet_nsp\*O, \*Lncacn_osi_dna\*O, and \*Lncadg_dds\*O.
...\" .PP
...\" .LI "\*Lncacn_dnet_nsp\*O"
...\" .PP
...\" There are no DECnet Phase IV options.
...\" .PP
...\" \*Lncacn_osi_dna\*O
...\" .PP
...\" Specify a DECnet Phase V option.  Presently one option exists for
...\" selecting a transport.  The option name is \*Ltpid\*O (for transport
...\" protocol identifier).  The option value is either \*Lcots\*O (for
...\" connection-oriented transport service) or \*Lnsp\*O (for network
...\" services protocol).
...\" .PP
...\" An example of a transport option is \*Ctpid=cots\*O.  Another
...\" example of a transport option is \*Ctpid=nsp\*O.
...\" .LI "\*Lncadg_dds\*O"
...\" .PP
...\" \*LTBS\*O
...\" DIGITAL_END
...\" .cE
.PP
The \*Voption\*O field is optional.
.LI "\*L]\*O"
This symbol is the delimiter character specifying that one endpoint
and zero or more options precede.
If the string binding contains at least one endpoint, this symbol is
required.
.LE
.PP
The \*L\e\*O (backslash) character is
treated as an escape character for all string binding fields.
.PP
Examples of valid string bindings follow.  In each example \*Vobj-uuid\*O
represents a UUID in string form.  In other words, the symbol \*Vobj-uuid\*O
can represent the UUID 308fb580-1eb2-11ca-923b-08002b1075a7.
.oS
\*Vobj-uuid\*C@ncacn_ip_tcp:16.20.16.27[2001]
\*Vobj-uuid\*C@ncacn_ip_tcp:16.20.16.27[endpoint=2001]
.oE
...\" .cS
...\" DIGITAL_BEGIN
...\" ** Next are 15 more examples of Digital Equipment Corporation and HP/Apollo
...\" ** string bindings (a paragraph of explanation precedes the 15th example).
...\" \*Vobj-uuid\*C@ncacn_dnet_nsp:took[elf_server]
...\" \*Vobj-uuid\*C@ncacn_dnet_nsp:took[endpoint=elf_server]
...\" ncacn_osi_dna:took[fal]
...\" \*Vobj-uuid\*C@ncacn_osi_dna:took[#17]
...\" \*Vobj-uuid\*C@ncacn_osi_dna:4.32[dlogin]
...\" \*Vobj-uuid\*C@ncacn_osi_dna:4.32[#17]
...\" ncacn_osi_dna:took[fal,tpid=nsp]
...\" ncacn_osi_dna:took[#17,tpid=cots]
...\" \*Vobj-uuid\*C@ncacn_osi_dna:4.32[dlogin,tpid=nsp]
...\" \*Vobj-uuid\*C@ncacn_osi_dna:4.32[dlogin]
...\" \*Vobj-uuid\*C@ncacn_osi_dna:.lkg.took[my_server_with_long_name,tpid=nsp]
...\" \*Vobj-uuid\*C@ncacn_osi_dna:.lkg.took[my_server_with_long_name,tpid=cots]
...\" \*Vobj-uuid\*C@ncacn_osi_dna:%x49003FAA000400E4FD20[dtr,tpid=nsp]
...\" \*Vobj-uuid\*C@ncacn_osi_dna:%x49003FAA000400E4FD21[#63,tpid=cots]\*O
...\" .PP
...\" The following example is a valid string binding, but the \*Ltpid\*O option
...\" is ignored because using the DECnet Phase IV network address
...\" implies \*Lnsp\*O, not \*Lcots\*O:
...\" .oS
...\" \*Vobj-uuid\*C@ncacn_osi_dna:4.32[#42,tpid=cots]\*O
...\" .oE
...\" DIGITAL_END
...\" .cE
.LI "String UUID"
.iX "string UUID"
.iX "UUID" "string"
.PP
A string UUID contains the character representation of a UUID.
A string UUID consists of multiple fields of hexadecimal characters.
Each field has a fixed length, and dashes separate the fields.
An example of a string UUID follows:
.oS
989c6e5c-2cc1-11ca-a044-08002b1bb4f5
.oE
.PP
When you supply a string UUID as an input argument to an RPC runtime
routine, you can enter the alphabetic hexadecimal characters in
either uppercase or lowercase letters.  The RPC runtime routines
that return a string UUID always return the hexadecimal characters in
lowercase letters.
.PP
The following routines require a string UUID:
.ad l
.ML
.LI
\*Lrpc_string_binding_compose(\|)\*O
.LI
\*Luuid_from_string(\|)\*O
.LE
.ad b
.PP
The following routines return a string UUID:
.ad l
.ML
.LI
\*Lrpc_string_binding_parse(\|)\*O
.LI
\*Luuid_to_string(\|)\*O
.LE
.ad b
.LI "Unsigned Character String"
.iX "unsigned character string"
.iX "character string" "unsigned"
.iX "string" "unsigned character"
.PP
DCE RPC treats all characters in strings as unsigned characters.  Those
routines with character string arguments show a data type of
\*Lunsigned_char_t *\*O.
.iX "\*Lunsigned_char_t\*O data type"
.iX "data types" "\*Lunsigned_char_t\*O"
.LI "UUID Vector"
.iX "UUID vector data structure"
.iX "data structures" "UUID vector"
.PP
The UUID vector data structure contains a list of UUIDs.
The UUID vector contains a count member (\*Vcount\*O),
followed by an array of pointers to UUIDs.
.PP
The C language representation of a UUID vector is as follows:
.iS
typedef struct
{
    unsigned32    count;
    uuid_t        *uuid[1];
} uuid_vector_t;
.iE
.iX "data types" "\*Luuid_vector_t\*O"
.iX "\*Luuid_vector_t\*O data type"
.PP
An application constructs a UUID vector to contain object UUIDs to be
exported or unexported from the name service database.  The following routines
require a UUID vector and show an argument data type of
\*Luuid_vector_t\*O:
.ad l
.ML
.LI
\*Lrpc_ep_register(\|)\*O
.LI
\*Lrpc_ep_register_no_replace(\|)\*O
.LI
\*Lrpc_ep_unregister(\|)\*O
.LI
\*Lrpc_ns_binding_export(\|)\*O
.LI
\*Lrpc_ns_binding_unexport(\|)\*O
.LI
\*Lrpc_ns_mgmt_binding_unexport(\|)\*O
.LE
.ad b
.LE
.SS "Permissions Required"
To use the NSI routines to access
entries in a Cell Directory Service (CDS) database, you need
.iX "RPC" "ACL permissions for NSI routines"
.iX "NSI" "ACL permissions for routines"
.iX "ACL" "permissions for RPC NSI routines"
.iX "access control list" "permissions for RPC NSI routines"
.iX "CDS" "ACL permissions for NSI routines"
.iX "permissions (ACL) for NSI routines"
access control list (ACL) permissions.
Depending on the NSI operation, you need ACL permissions to the parent
directory or the CDS object entry (the name service entry) or both.
.PP
The ACL permissions are as follows:
.ad l
.ML
.LI
To create an entry, you need insert permission to the parent directory.
.iX "insert permission"
.LI
To read an entry, you need read permission to the CDS object entry.
.iX "read permission"
.LI
To write to an entry, you need write permission to the CDS object entry.
.iX "write permission"
.LI
To delete an entry, you need delete permission either to the CDS object entry
or to the parent directory.
.iX "delete permission"
.LI
To test an entry, you need either test permission or read permission
to the CDS object entry.
.iX "test permission"
.LE
.ad b
.PP
Note that write permission does not imply read permission.
.PP
To find the ACL permissions for the NSI routines whose names
begin with \*Lrpc_ns\*O, see these routines' reference pages.
.PP
The non-NSI routines whose names do not begin with \*Lrpc_ns\*O do
not need ACL permissions, so their reference pages do not specify any.
.SS "Frequently Used Routine Parameters"
.iX "frequently used routine parameters"
.iX "parameters" "frequently used routine"
.PP
A few parameters are common to many of the DCE RPC routines.
These parameters are described fully here and again
briefly on the specific routine reference pages.
.VL
.LI "\*Vbinding\*O"
.iX "\*Vbinding\*O parameter"
Used as an input or output parameter.
.PP
Returns a binding handle for making remote procedure calls to a server.
.PP
A client obtains a binding handle by calling one of the following routines:
.ad l
.ML
.LI
\*Lrpc_binding_copy(\|)\*O
.LI
\*Lrpc_binding_from_string_binding(\|)\*O
.LI
\*Lrpc_ns_binding_import_next(\|)\*O
.LI
\*Lrpc_ns_binding_select(\|)\*O
.LE
.ad b
.PP
Creating a binding handle establishes a relationship
between a client and a server.  However, the relationship
does not involve any communications between the client and server.
The communications occur when a client makes a remote
procedure call.
.PP
As an input parameter to a remote procedure call, \*Vbinding\*O specifies
a binding handle that refers to binding information.  The client's
RPC runtime uses this binding information to make a remote procedure call
to a server.
.PP
Server manager routines can extract client information
from a client binding handle by using the following routines:
.ad l
.ML
.LI
\*Lrpc_binding_inq_auth_client(\|)\*O
.LI
\*Lrpc_binding_inq_object(\|)\*O
.LI
\*Lrpc_binding_to_string_binding(\|)\*O
.LI
\*Lrpc_string_binding_parse(\|)\*O
.LE
.ad b
.LI "\*Vname\*O"
.iX "\*Vname\*O parameter"
Used as an input/output parameter.
.PP
When used as an input parameter, the value of this parameter depends
on the syntax selected in the
\*Vname_syntax\*O parameter.  If it is allowed by the called routine,
the value NULL
specifies that the routine uses
the name specified in the \*LRPC_DEFAULT_ENTRY\*O environment variable.
Specifying NULL also has the called routine use the name syntax
that the environment variable \*LRPC_DEFAULT_ENTRY_SYNTAX\*O specifies.
.iX "\*LRPC_DEFAULT_ENTRY\*O environment variable"
.PP
For a \*Vname_syntax\*O value of \*Lrpc_c_ns_syntax_dce\*O,
use the DCE naming rules to specify parameter \*Vname\*O.
.PP
As an output parameter, returns an entry in the name service database
in the form of a character string that includes a terminating null
character.
The value of this parameter depends on the syntax selected in
\*Vname_syntax\*O.
.PP
For a \*Vname_syntax\*O value of \*Lrpc_c_ns_syntax_dce\*O,
\*Vname\*O is returned using the DCE naming syntax.
.PP
The DCE RPC runtime allocates memory for the returned string.  The application
is responsible for calling the \*Lrpc_string_free(\|)\*O routine to deallocate
the string.
.PP
If an application does not want a returned name string, the application
usually specifies NULL for this parameter.
The one exception is routine \*Lrpc_ns_entry_expand_name(\|)\*O;
it always returns a name string.
.LI "\*Vname_syntax\*O"
.iX "\*Vname_syntax\*O parameter"
Used as an input parameter, an integer value that specifies the syntax
of an entry name.  When allowed by
the called routine, a value of \*Lrpc_c_ns_syntax_default\*O
specifies that the routine uses the syntax
specified in the \*LRPC_DEFAULT_ENTRY_SYNTAX\*O
environment variable.
The following table lists the valid syntaxes that applications can use
in DCE RPC for entries in the name service database.
.PP
...\".TB "Valid Name Syntaxes"
.iX "name syntaxes" "valid"
.iX "syntaxes" "valid name"
.TS
center, allbox, tab(%);
cb s s
lb | lb | lb
lb | c | l.
Valid Name Syntaxes
_
Constant%Value%Description
_
rpc_c_ns_syntax_default%0%Default syntax
rpc_c_ns_syntax_dce%3%DCE
.TE
...\" .cS
...\" DIGITAL_BEGIN
...\" ** To include Digital Equipment Corporation and HP/Apollo formats,
...\" ** insert the following line in the table:
...\" rpc_c_ns_syntax_dec_dns%1%DECdns
...\" DIGITAL_END
...\" .cE
.PP
The \*Vname_syntax\*O parameter tells routines how to parse the
entry name specified in an input \*Vname\*O parameter or specifies the
syntax to use when returning an entry name as an output \*Vname\*O
parameter.
.PP
.ne 5
If the \*LRPC_DEFAULT_ENTRY_SYNTAX\*O environment variable is not
defined, the RPC runtime uses the \*Lrpc_c_ns_syntax_dce\*O name syntax.
.iX "\*LRPC_DEFAULT_ENTRY_SYNTAX\*O environment variable"
.LI "\*Vstring\*O"
.iX "\*Vstring\*O parameter"
Used as an input or output parameter.
.PP
Returns a character string, which always includes the
terminating null character \*L\\0\*O.
The DCE RPC runtime allocates memory for the returned string.  The application
calls the \*Lrpc_string_free(\|)\*O routine to deallocate the memory occupied by
the string.
.PP
If there is no data for the requested string, the routine returns the string
\*L\\0\*O.  For example, if the string binding passed to routine
\*Lrpc_string_binding_parse(\|)\*O does not contain an object UUID,
the routine returns
\*L\\0\*O as the value of the object UUID string.  The application must
call the \*Lrpc_string_free(\|)\*O routine to deallocate the memory occupied by
this string.
.PP
If an application does not require a returned output string, the application
specifies NULL for this parameter.
.LI "\*Vstatus\*O"
.iX "\*Vstatus\*O parameter"
Each routine in the RPC API returns a DCE status code indicating whether the
routine completed successfully or, if not, why not.  A return value
of \*Lrpc_s_ok\*O indicates success.  All other return values signify
routine failure.  The status codes listed for each RPC runtime routine
are the most likely, but not necessarily all, the status codes
that the routine can return.
.iX "DCE status codes"
.iX "status codes"
.iX "error codes"
.PP
The status code argument has a data type of \*Lunsigned32\*O.
.PP
To translate a DCE status code to a text message, call the
routine \*Ldce_error_inq_text(\|)\*O.
.iX "exceptions" "for RPC applications"
.iX "exception codes"
.iX "RPC"  "exceptions"
.iX "-;RPC status codes" "exceptions"
.PP
Note that RPC exceptions are equivalent to RPC status codes.  To
identify the status code that corresponds to a given exception, replace
the \*L_x_\*O string
of the exception with the string \*L_s_\*O; for example, the exception
\*Lrpc_x_already_listening\*O is equivalent to the status code
\*Lrpc_s_already_listening\*O.
.PP
For more information about the RPC status codes,
see the \*(Tg.
.LI "\*Vuuid\*O"
.iX "\*Vuuid\*O parameter"
Used as an input or output parameter.
.PP
When you need to specify a nil UUID to a \*Vuuid\*O input parameter
in any of the DCE RPC routines, you can supply the value NULL.
.LE
.nL
.ne .75i
.SH "Related Information"
.PP
.ad l
Books:  \*(Di, \*(Dk, \*(Dd, \*(Ar, \*(Tg.
.ad b
